// @ts-nocheck
import { ELEMENT_EMOJI_MAP, LOCATION_EMOJI_MAP, RELATION_ICON_MAP } from './emoji-maps';
import { MAIN_STYLES } from './styles';
import { injectDatabaseStyles, setDatabaseToastMute } from './database-ui-override';
import { RollResult, CustomFieldConfig, DerivedVarSpec, DiceExprPatch } from './types';

(function () {
  'use strict';

  const SCRIPT_ID = 'acu_visualizer_ui_v19_6_ai_overlay';

  // ========================================
  // 表主键配置 (用于行标识转换)
  const PRIMARY_KEYS = {
    全局数据表: null,
    世界地图点: '详细地点',
    地图元素表: '元素名称',
    主角信息: '姓名',
    重要人物表: '姓名',
    重要角色表: '姓名',
    技能表: '技能名称',
    物品表: '物品名称',
    装备表: '装备名称',
    任务表: '名称',
    总结表: '编码索引',
    总体大纲: '编码索引',
    重要情报: '情报名称',
    势力: '名称',
  };

  // 兼容新旧模板表名（重要人物表 = 旧名, 重要角色表 = 新名）
  const isNpcTableName = (name: string): boolean => name === '重要人物表' || name === '重要角色表';

  /**
   * 获取行的主键值
   * @param tableName 表名
   * @param row 行数据
   * @param headers 表头
   */
  function getRowKey(tableName, row, headers) {
    const pkField = PRIMARY_KEYS[tableName];
    if (pkField === null) return '_row_0';

    let fieldIndex = 1;
    if (pkField) {
      const idx = headers.indexOf(pkField);
      if (idx !== -1) fieldIndex = idx;
    }

    if (!row[fieldIndex]) return null;
    return `${pkField || headers[fieldIndex]}=${row[fieldIndex]}`;
  }

  // ========================================
  // 神-数据库适配层 (LockManager -> GodDB API)
  // ========================================

  /**
   * 获取神-数据库锁定API
   * @returns API对象，如果不可用返回null
   */
  function getDbLockAPI(): any {
    // 递归找到真正的顶层窗口（处理多层iframe嵌套）
    let topWindow: Window = window;
    try {
      while (topWindow.parent && topWindow.parent !== topWindow) {
        topWindow = topWindow.parent;
      }
    } catch (e) {
      // 跨域情况下无法访问parent，使用当前window
    }

    // 优先从顶层窗口获取，然后尝试当前窗口
    const api = (topWindow as any).AutoCardUpdaterAPI || (window as any).AutoCardUpdaterAPI;
    return api || null;
  }

  /**
   * 根据表名获取sheetKey
   * @param tableName - 表名（如"主角信息"）
   * @returns sheetKey（如"sheet_0"），找不到返回null
   */
  function getSheetKeyByTableName(tableName: string): string | null {
    const api = getDbLockAPI();
    if (!api || typeof api.exportTableAsJson !== 'function') return null;

    try {
      const data = api.exportTableAsJson() as Record<string, { name: string; content: (string | number | null)[][] }>;
      if (!data) return null;

      for (const key in data) {
        if (key.startsWith('sheet_') && data[key]?.name === tableName) {
          return key;
        }
      }
    } catch (e) {
      console.warn('[DICE]getSheetKeyByTableName 失败:', e);
    }
    return null;
  }

  /**
   * 通过主键值查找行索引
   * @param sheetKey - 表格标识
   * @param tableName - 表名
   * @param primaryKeyValue - 主键值（格式可能是 "字段名=值" 或纯值）
   * @returns 行索引（从0开始），找不到返回null
   */
  function findRowIndexByPrimaryKey(sheetKey: string, tableName: string, primaryKeyValue: string): number | null {
    const api = getDbLockAPI();
    if (!api || typeof api.exportTableAsJson !== 'function') return null;

    try {
      const data = api.exportTableAsJson() as Record<string, { name: string; content: (string | number | null)[][] }>;
      const sheet = data?.[sheetKey];
      if (!sheet || !sheet.content || !Array.isArray(sheet.content) || sheet.content.length < 2) {
        return null;
      }

      const headers = sheet.content[0] as string[];
      const pkField = PRIMARY_KEYS[tableName as keyof typeof PRIMARY_KEYS];

      // 处理特殊情况：全局数据表等没有主键的情况
      if (pkField === null) {
        return primaryKeyValue === '_row_0' ? 0 : null;
      }

      if (!pkField) return null;

      const pkIndex = headers.indexOf(pkField);
      if (pkIndex === -1) {
        console.warn(`[DICE]findRowIndexByPrimaryKey: 在表 ${tableName} 中找不到主键字段 ${pkField}`);
        return null;
      }

      // 【修复】解析 primaryKeyValue，提取实际值
      // getRowKey() 返回格式: "姓名=张三" -> 需要提取 "张三"
      let actualValue = primaryKeyValue;
      const eqIdx = primaryKeyValue.indexOf('=');
      if (eqIdx !== -1) {
        actualValue = primaryKeyValue.substring(eqIdx + 1);
      }

      // 遍历数据行（从索引1开始）
      for (let i = 1; i < sheet.content.length; i++) {
        const row = sheet.content[i];
        if (row && String(row[pkIndex]) === String(actualValue)) {
          // 神-数据库的 rowIndex 是从 0 开始的数据行索引（对应 content[1]）
          return i - 1;
        }
      }
    } catch (e) {
      console.warn('[DICE]findRowIndexByPrimaryKey 失败:', e);
    }
    return null;
  }

  /**
   * 安全地修改角色卡属性值
   * @param characterName - 角色名称
   * @param attrName - 属性名称
   * @param operation - 操作类型: 'add' | 'subtract' | 'set'
   * @param value - 操作数值
   * @param options - 可选配置 { initValue?: number, min?: number, max?: number }
   * @returns Promise<{ success: boolean, oldValue: number, newValue: number, error?: string }>
   */
  async function safeUpdateAttribute(
    characterName: string,
    attrName: string,
    operation: 'add' | 'subtract' | 'set',
    value: number,
    options?: { initValue?: number; min?: number; max?: number },
  ): Promise<{ success: boolean; oldValue: number; newValue: number; error?: string }> {
    console.info(`[DICE]safeUpdateAttribute: ${characterName}.${attrName} ${operation} ${value}`);

    try {
      // 1. 获取 DbLockAPI
      const api = getDbLockAPI();
      if (!api || typeof api.exportTableAsJson !== 'function') {
        const error = '神-数据库 API 不可用';
        console.error(`[DICE]safeUpdateAttribute: ${error}`);
        return { success: false, oldValue: 0, newValue: 0, error };
      }

      // 2. 导出表格数据
      const data = api.exportTableAsJson() as Record<string, { name: string; content: (string | number | null)[][] }>;
      if (!data) {
        const error = '无法导出表格数据';
        console.error(`[DICE]safeUpdateAttribute: ${error}`);
        return { success: false, oldValue: 0, newValue: 0, error };
      }

      // 3. 查找角色所在表格和行索引
      let targetSheetKey: string | null = null;
      let targetRowIndex: number | null = null;
      let targetColIndex: number = -1;

      // 遍历所有表格查找角色
      for (const sheetKey in data) {
        if (!sheetKey.startsWith('sheet_')) continue;
        const sheet = data[sheetKey];
        if (!sheet || !sheet.content || !Array.isArray(sheet.content) || sheet.content.length < 2) continue;

        const headers = sheet.content[0] as string[];
        const pkField = PRIMARY_KEYS[sheet.name as keyof typeof PRIMARY_KEYS];

        // 跳过无主键的表格
        if (pkField === undefined) continue;

        // 处理特殊情况：全局数据表等没有主键的情况
        if (pkField === null) {
          if (characterName === '_row_0') {
            targetSheetKey = sheetKey;
            targetRowIndex = 0;
            targetColIndex = headers.indexOf(attrName);
            break;
          }
          continue;
        }

        // 查找主键列索引
        const pkIndex = headers.indexOf(pkField);
        if (pkIndex === -1) continue;

        // 遍历数据行查找角色
        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && String(row[pkIndex]) === String(characterName)) {
            targetSheetKey = sheetKey;
            targetRowIndex = i - 1; // 神-数据库的 rowIndex 是从 0 开始的数据行索引
            targetColIndex = headers.indexOf(attrName);
            break;
          }
        }

        if (targetSheetKey) break;
      }

      if (!targetSheetKey || targetRowIndex === null) {
        const error = `找不到角色: ${characterName}`;
        console.warn(`[DICE]safeUpdateAttribute: ${error}`);
        return { success: false, oldValue: 0, newValue: 0, error };
      }

      if (targetColIndex === -1) {
        const error = `角色 ${characterName} 中找不到属性: ${attrName}`;
        console.warn(`[DICE]safeUpdateAttribute: ${error}`);
        return { success: false, oldValue: 0, newValue: 0, error };
      }

      // 4. 检查锁定状态
      const lockState = api.getTableLockState?.(targetSheetKey);
      if (lockState) {
        // 检查行锁定
        const isRowLocked = lockState.rows?.includes(targetRowIndex) ?? false;
        if (isRowLocked) {
          const error = `角色 ${characterName} 的整行已被锁定`;
          console.warn(`[DICE]safeUpdateAttribute: ${error}`);
          return { success: false, oldValue: 0, newValue: 0, error };
        }

        // 检查单元格锁定
        // 注意: targetColIndex 包含行号列，神-数据库的 colIndex 不包含行号列，需要 -1
        const cellKey = `${targetRowIndex}:${targetColIndex - 1}`;
        const isCellLocked = lockState.cells?.includes(cellKey) ?? false;
        if (isCellLocked) {
          const error = `属性 ${characterName}.${attrName} 已被锁定`;
          console.warn(`[DICE]safeUpdateAttribute: ${error}`);
          return { success: false, oldValue: 0, newValue: 0, error };
        }
      }

      // 5. 获取旧值或初始化
      const sheet = data[targetSheetKey];
      const currentValue = sheet.content[targetRowIndex + 1][targetColIndex]; // +1 因为 content[0] 是表头
      let oldValue: number;

      if (currentValue === null || currentValue === undefined || currentValue === '') {
        if (options?.initValue !== undefined) {
          oldValue = options.initValue;
          console.info(`[DICE]safeUpdateAttribute: 属性 ${attrName} 不存在，初始化为 ${oldValue}`);
        } else {
          const error = `属性 ${attrName} 不存在且未提供 initValue`;
          console.warn(`[DICE]safeUpdateAttribute: ${error}`);
          return { success: false, oldValue: 0, newValue: 0, error };
        }
      } else {
        oldValue = typeof currentValue === 'number' ? currentValue : parseFloat(String(currentValue));
        if (isNaN(oldValue)) {
          const error = `属性 ${attrName} 的值 "${currentValue}" 无法转换为数字`;
          console.warn(`[DICE]safeUpdateAttribute: ${error}`);
          return { success: false, oldValue: 0, newValue: 0, error };
        }
      }

      // 6. 执行操作
      let newValue: number;
      switch (operation) {
        case 'add':
          newValue = oldValue + value;
          break;
        case 'subtract':
          newValue = oldValue - value;
          break;
        case 'set':
          newValue = value;
          break;
        default:
          const error = `不支持的操作类型: ${operation}`;
          console.error(`[DICE]safeUpdateAttribute: ${error}`);
          return { success: false, oldValue, newValue: oldValue, error };
      }

      // 7. 应用 min/max 约束
      const min = options?.min ?? -Infinity;
      const max = options?.max ?? Infinity;
      newValue = Math.max(min, Math.min(max, newValue));

      console.info(
        `[DICE]safeUpdateAttribute: ${characterName}.${attrName} ${oldValue} → ${newValue} (${operation} ${value})`,
      );

      // 8. 更新数据
      sheet.content[targetRowIndex + 1][targetColIndex] = newValue;

      // 9. 使用 JSON.parse(JSON.stringify()) 去除 Proxy 层后导入
      const cleanData = JSON.parse(JSON.stringify(data));
      const importResult = await api.importTableAsJson(cleanData);

      if (importResult === false) {
        const error = '数据导入失败（返回 false）';
        console.error(`[DICE]safeUpdateAttribute: ${error}`);
        return { success: false, oldValue, newValue, error };
      }

      console.info(`[DICE]safeUpdateAttribute: 成功修改 ${characterName}.${attrName}`);
      return { success: true, oldValue, newValue };
    } catch (e) {
      const error = `修改属性时发生异常: ${e instanceof Error ? e.message : String(e)}`;
      console.error(`[DICE]safeUpdateAttribute: ${error}`, e);
      return { success: false, oldValue: 0, newValue: 0, error };
    }
  }

  /**
   * 执行检定后果效果
   * 在 MESSAGE_SENT 事件中调用，异步执行不阻塞消息发送
   * @param pendingCtx 待执行的后果上下文
   * @returns 执行结果数组
   */
  async function executeEffects(pendingCtx: PendingEffectContext): Promise<EffectResult[]> {
    const results: EffectResult[] = [];
    const { preset, matchedOutcome, context } = pendingCtx;
    const replayOperations: EffectReplayOperation[] = [];
    const deferredSecondaryCallbacks: Array<() => void> = [];
    const baseData = cachedRawData || getTableData();
    if (!baseData) {
      throw new Error('效果执行失败：无法获取表格数据');
    }
    const transactionalData = JSON.parse(JSON.stringify(baseData));
    const modifiedSheetKeys = new Set<string>();
    const overrideMap = new Map<string, ComputedEffect>();
    if (pendingCtx.effectOverrides && pendingCtx.effectOverrides.length > 0) {
      pendingCtx.effectOverrides.forEach(item => {
        overrideMap.set(item.effectId, item);
      });
    }

    if (!matchedOutcome.effects || matchedOutcome.effects.length === 0) {
      return results;
    }

    console.info(`[DICE] Executing ${matchedOutcome.effects.length} effects for outcome "${matchedOutcome.name}"`);

    for (const effect of matchedOutcome.effects) {
      // 1. 检查条件
      if (effect.condition) {
        const condContext = {
          $roll: context.roll,
          $attr: context.attributeValue,
          $mod: context.modifier,
          $dc: context.dc,
        };
        const condResult = evaluateCondition(effect.condition, condContext);
        if (!condResult.success || !condResult.value) {
          console.info(`[DICE] Effect ${effect.id} skipped: condition "${effect.condition}" not met`);
          continue;
        }
      }

      // 2. 检查 allowedTargets
      if (preset.effectsConfig?.allowedTargets && preset.effectsConfig.allowedTargets.length > 0) {
        if (!preset.effectsConfig.allowedTargets.includes(effect.target)) {
          console.warn(`[DICE] Effect ${effect.id} blocked: target "${effect.target}" not in allowedTargets`);
          continue;
        }
      }

      // 3. 解析 value（支持骰子表达式）
      let finalValue = 0;
      let formulaText = '';
      let rolledValue: number | undefined;
      const override = overrideMap.get(effect.id);
      if (override) {
        finalValue = Math.abs(override.computedValue);
        formulaText = override.formula || String(effect.value || '0');
        rolledValue = Number.isFinite(override.rolledValue) ? override.rolledValue : undefined;
        console.info(
          `[DICE] Effect ${effect.id}: use confirmed override "${override.formula}" => ${override.computedValue}`,
        );
      } else {
        const parsedValue = parseEffectValueInput(effect.value, `Effect ${effect.id}`);
        formulaText = parsedValue.formulaText;
        finalValue = parsedValue.finalValue;
        rolledValue = parsedValue.rolledValue;
        if (parsedValue.valid) {
          console.info(`[DICE] Effect ${effect.id}: rolled "${formulaText}" = ${finalValue}`);
        }
      }

      // 4. 执行属性更新（使用 updateSingleAttribute 支持属性字符串格式）
      const aliasCandidates = [...(preset.effectsConfig?.allowedTargets || []), context.attributeName].filter(
        (name, idx, arr) => Boolean(name) && arr.indexOf(name) === idx,
      );

      const updateResult = await updateSingleAttribute(
        context.characterName,
        effect.target,
        effect.operation,
        finalValue,
        {
          initValue: effect.initValue,
          min: effect.min,
          max: effect.max,
          aliasCandidates,
          skipSave: true,
          dataOverride: transactionalData,
        },
      );
      if (updateResult.modifiedSheetKey) modifiedSheetKeys.add(updateResult.modifiedSheetKey);

      // 5. 记录结果
      const effectResult: EffectResult = {
        effectId: effect.id,
        success: updateResult.success,
        oldValue: updateResult.oldValue,
        newValue: updateResult.newValue,
        error: updateResult.error,
        target: updateResult.resolvedAttrName || effect.target,
        level: 1,
        triggerType: 'primary',
        branchLabel: `L1/${matchedOutcome.name}`,
        formulaText,
        rolledValue,
      };
      results.push(effectResult);

      if (updateResult.success) {
        replayOperations.push({
          characterName: context.characterName,
          target: effect.target,
          operation: effect.operation,
          value: finalValue,
          initValue: effect.initValue,
          min: effect.min,
          max: effect.max,
          aliasCandidates,
          resultRef: effectResult,
        });
      }

      if (updateResult.success) {
        console.info(
          `[DICE] Effect executed: ${context.characterName}.${updateResult.resolvedAttrName || effect.target} ${effect.operation} ${finalValue} (${updateResult.oldValue} → ${updateResult.newValue})`,
        );
      } else {
        console.error(`[DICE] Effect ${effect.id} failed: ${updateResult.error}`);
      }
    }

    const secondaryResults = await executeSecondaryEffectsChain(
      preset,
      results,
      {
        characterName: context.characterName,
        attributeName: context.attributeName,
        attributeValue: context.attributeValue,
      },
      transactionalData,
      modifiedSheetKeys,
      replayOperations,
      deferredSecondaryCallbacks,
    );

    const allResults = [...results, ...secondaryResults];
    const hasFailure = allResults.some(r => !r.success);

    // all-or-nothing: 任一效果失败则整批回滚（不提交 transactionalData）
    if (hasFailure) {
      return allResults.map(r =>
        r.success
          ? {
              ...r,
              success: false,
              error: r.error || '事务回滚：同批次存在失败效果，整批未提交',
            }
          : r,
      );
    }

    // 在保存队列的同一临界区内读取最新数据、重放补丁并提交
    return runInSaveQueue(async () => {
      const latestData = cachedRawData || getTableData();
      if (!latestData) {
        return allResults.map(r =>
          r.success
            ? {
                ...r,
                success: false,
                error: r.error || '事务回滚：提交阶段无法读取最新数据',
              }
            : r,
        );
      }

      const latestTransactionalData = JSON.parse(JSON.stringify(latestData));
      const latestModifiedSheetKeys = new Set<string>();
      for (const op of replayOperations) {
        const replayResult = await updateSingleAttribute(op.characterName, op.target, op.operation, op.value, {
          initValue: op.initValue,
          min: op.min,
          max: op.max,
          aliasCandidates: op.aliasCandidates,
          skipSave: true,
          dataOverride: latestTransactionalData,
        });

        if (!replayResult.success) {
          return allResults.map(r =>
            r.success
              ? {
                  ...r,
                  success: false,
                  error: r.error || `事务回滚：最新数据重放失败 (${replayResult.error || 'unknown'})`,
                }
              : r,
          );
        }

        if (replayResult.modifiedSheetKey) latestModifiedSheetKeys.add(replayResult.modifiedSheetKey);
        op.resultRef.oldValue = replayResult.oldValue;
        op.resultRef.newValue = replayResult.newValue;
        op.resultRef.target = replayResult.resolvedAttrName || op.resultRef.target;
        op.resultRef.error = undefined;
      }

      if (latestModifiedSheetKeys.size > 0) {
        await performSaveDataOnly(latestTransactionalData, Array.from(latestModifiedSheetKeys));
      }

      deferredSecondaryCallbacks.forEach(run => run());

      return allResults;
    });
  }

  function parseEffectValueInput(
    rawValue: unknown,
    traceLabel: string,
  ): {
    formulaText: string;
    finalValue: number;
    rolledValue: number;
    valid: boolean;
  } {
    const formulaText = String(rawValue ?? '').trim() || '0';
    const rollResult = rollComplexDiceExpression(formulaText);
    if (Number.isNaN(rollResult.total)) {
      console.warn(`[DICE] ${traceLabel} 效果值解析失败: "${formulaText}"，按 0 处理`);
      return {
        formulaText,
        finalValue: 0,
        rolledValue: 0,
        valid: false,
      };
    }

    const value = Math.round(rollResult.total);
    return {
      formulaText,
      finalValue: value,
      rolledValue: value,
      valid: true,
    };
  }

  async function executeSecondaryEffectsChain(
    preset: AdvancedDicePreset,
    effectResults: EffectResult[],
    context: { characterName: string; attributeName: string; attributeValue: number },
    transactionalData?: Record<string, { name: string; content: (string | number | null)[][] }>,
    modifiedSheetKeys?: Set<string>,
    replayOperations?: EffectReplayOperation[],
    deferredSecondaryCallbacks?: Array<() => void>,
  ): Promise<EffectResult[]> {
    const secondaryEffects = preset.secondaryEffects;
    if (!secondaryEffects || secondaryEffects.length === 0) return [];

    const clamp = (num: number, min: number, max: number): number => Math.max(min, Math.min(max, num));
    const maxDepth = clamp(Number(preset.secondaryMaxDepth ?? 3), 1, 8);
    const triggerCounts = new Map<string, number>();
    const allGenerated: EffectResult[] = [];
    const localDeferredCallbacks: Array<() => void> = [];
    const callbackQueue = deferredSecondaryCallbacks || localDeferredCallbacks;
    let currentLevelResults = effectResults.filter(r => r.success);

    const buildFormulaContext = (): Record<string, number> => {
      const currentAttrs = getFullAttributesForCharacter(context.characterName, transactionalData);
      const formulaContext: Record<string, number> = {};
      currentAttrs.forEach(attr => {
        if (attr && typeof attr.name === 'string' && typeof attr.value === 'number' && !isNaN(attr.value)) {
          formulaContext[attr.name] = attr.value;
        }
      });
      return formulaContext;
    };

    const compare = (operator: SecondaryEffect['trigger']['operator'], left: number, right: number): boolean => {
      switch (operator) {
        case 'gt':
          return left > right;
        case 'gte':
          return left >= right;
        case 'lt':
          return left < right;
        case 'lte':
          return left <= right;
        case 'eq':
          return left === right;
        default:
          return false;
      }
    };

    const resolveThresholdValue = (value: string, result: EffectResult, depth: number): number => {
      const rawExpr = String(value || '').trim();
      if (!rawExpr) return 0;

      // 兼容 {意志}/5 形式
      const expr = rawExpr.replace(/\{([^}]+)\}/g, '$1');
      const delta = Math.abs(result.newValue - result.oldValue);
      const liveFormulaContext = buildFormulaContext();
      const exprContext: Record<string, number> = {
        ...liveFormulaContext,
        $attr: result.newValue,
        $old: result.oldValue,
        $new: result.newValue,
        $delta: delta,
        $depth: depth,
      };

      const condResult = evaluateCondition(expr, exprContext);
      if (condResult.success && condResult.value !== undefined) {
        const val = typeof condResult.value === 'boolean' ? (condResult.value ? 1 : 0) : Number(condResult.value);
        if (Number.isFinite(val)) return val;
      }

      const formulaExpr = expr.replace(/\$[a-zA-Z_]\w*/g, token => {
        const val = exprContext[token];
        return typeof val === 'number' && Number.isFinite(val) ? String(val) : '0';
      });
      const formulaValue = evaluateFormula(formulaExpr, liveFormulaContext);
      if (typeof formulaValue === 'number' && Number.isFinite(formulaValue)) return formulaValue;

      const fallbackNum = parseFloat(expr);
      return Number.isFinite(fallbackNum) ? fallbackNum : 0;
    };

    const renderTemplateText = (text: string, vars: Record<string, string | number | boolean | undefined>): string => {
      return String(text || '').replace(/\$([a-zA-Z_]\w*)/g, (match, key: string) => {
        const varKey = `$${key}`;
        const val = vars[varKey];
        if (val === undefined || val === null) return match;
        return String(val);
      });
    };

    const renderTemplateTextTwice = (
      text: string,
      vars: Record<string, string | number | boolean | undefined>,
    ): string => {
      const pass1 = renderTemplateText(text, vars);
      return renderTemplateText(pass1, vars);
    };

    const appendNamedRandomTables = (
      outputVars: Record<string, string | number | boolean>,
      randomTables?: SecondaryEffect['randomTables'],
    ): void => {
      if (!randomTables) return;
      for (const [tableKey, tableDef] of Object.entries(randomTables)) {
        if (!tableDef || !tableDef.dice) continue;
        const tableRoll = rollComplexDiceExpression(tableDef.dice);
        outputVars[`$${tableKey}Roll`] = tableRoll.total;
        const rawResult = tableDef.entries?.[tableRoll.total] ?? String(tableRoll.total);
        outputVars[`$${tableKey}Result`] = renderTemplateTextTwice(rawResult, outputVars);
      }
    };

    for (let depth = 2; depth <= maxDepth + 1; depth++) {
      if (currentLevelResults.length === 0) break;
      const nextLevelResults: EffectResult[] = [];

      const secondaryTriggerMode: 'first' | 'all' = preset.secondaryTriggerMode === 'all' ? 'all' : 'first';

      for (const secEffect of secondaryEffects) {
        if (secEffect.enabled === false) continue;
        const maxTriggerCount = Math.max(1, secEffect.maxTriggerCount ?? 1);
        const currentCount = triggerCounts.get(secEffect.id) || 0;
        if (currentCount >= maxTriggerCount) continue;

        const matchedCandidates: Array<{ result: EffectResult; thresholdValue: number }> = [];
        for (const result of currentLevelResults) {
          if (!result.success) continue;
          const resultTarget = result.target || result.effectId;
          if (!isSameAttributeAlias(resultTarget, secEffect.trigger.attribute)) continue;

          const attrValue = result.newValue;
          const delta = Math.abs(result.newValue - result.oldValue);
          const thresholdValue = resolveThresholdValue(secEffect.trigger.value, result, depth);
          const compareValue = secEffect.trigger.type === 'threshold' ? attrValue : delta;
          const isTriggered = compare(secEffect.trigger.operator, compareValue, thresholdValue);
          if (!isTriggered) continue;

          matchedCandidates.push({ result, thresholdValue });
          if (secondaryTriggerMode === 'first') break;
        }

        if (matchedCandidates.length === 0) continue;

        const remainingTriggerCount = Math.max(0, maxTriggerCount - currentCount);
        if (remainingTriggerCount === 0) continue;

        let consumedMatches = 0;
        const generatedByMatch: EffectResult[][] = [];

        for (let candidateIndex = 0; candidateIndex < matchedCandidates.length; candidateIndex++) {
          if (consumedMatches >= remainingTriggerCount) break;

          const matched = matchedCandidates[candidateIndex];
          const matchedResult = matched.result;
          const matchedThresholdValue = matched.thresholdValue;
          const attrValue = matchedResult.newValue;
          const delta = Math.abs(matchedResult.newValue - matchedResult.oldValue);
          const nextMatchIndex = consumedMatches + 1;
          let callbackScheduled = false;

          if (secEffect.callback) {
            const callbackFn = (window as Record<string, unknown>)[secEffect.callback];
            if (typeof callbackFn === 'function') {
              const callbackPayload: Record<string, unknown> = {
                attrValue,
                delta,
                context,
                depth,
                thresholdValue: matchedThresholdValue,
                matchIndex: nextMatchIndex,
                chainMode: secondaryTriggerMode,
              };
              callbackScheduled = true;
              const runCallback = () => {
                try {
                  (callbackFn as (effect: SecondaryEffect, data: Record<string, unknown>) => void)(
                    secEffect,
                    callbackPayload,
                  );
                  console.info(
                    `[DICE] Secondary effect callback triggered: ${secEffect.id} (depth=${depth}, mode=${secondaryTriggerMode}, match=${nextMatchIndex}, ${secEffect.trigger.type} ${secEffect.trigger.operator} ${matchedThresholdValue})`,
                  );
                } catch (e) {
                  console.error(`[DICE] Secondary effect callback error:`, e);
                }
              };

              callbackQueue.push(runCallback);
            }
          }

          const effectsToRun: Effect[] = [...(secEffect.effects || [])];
          const generatedForCurrentMatch: EffectResult[] = [];
          const baseOutputVars: Record<string, string | number | boolean> = {
            $delta: delta,
            $old: matchedResult.oldValue,
            $new: matchedResult.newValue,
            $attr: attrValue,
            $depth: depth,
            $initiator: context.characterName,
            $attribute: matchedResult.target || context.attributeName,
          };

          // 渲染 outputText 模板并生成信息型 EffectResult
          if (secEffect.outputText) {
            const outputVars: Record<string, string | number | boolean> = {
              ...baseOutputVars,
            };
            // 随机表: 投骰并查表，注入 $tableRoll 和 $tableResult
            if (secEffect.randomTable) {
              const tableRoll = rollComplexDiceExpression(secEffect.randomTable.dice);
              outputVars.$tableRoll = tableRoll.total;
              const rawTableResult = secEffect.randomTable.entries[tableRoll.total] || `未知(${tableRoll.total})`;
              outputVars.$tableResult = renderTemplateTextTwice(rawTableResult, outputVars);
            }
            appendNamedRandomTables(outputVars, secEffect.randomTables);
            const renderedText = renderTemplateTextTwice(secEffect.outputText, outputVars);
            const infoResult: EffectResult = {
              effectId: secEffect.id,
              success: true,
              oldValue: matchedResult.oldValue,
              newValue: matchedResult.newValue,
              target: matchedResult.target,
              level: depth,
              triggerType: secEffect.trigger.type,
              triggerSourceId: secEffect.id,
              triggerThreshold: matchedThresholdValue,
              triggerMatchIndex: nextMatchIndex,
              outputMessage: renderedText,
              branchLabel: `L${depth}/${secEffect.id}`,
            };
            // infoResult 只进 allGenerated（最终返回）和 generatedForCurrentMatch（当次统计），
            // 不进 nextLevelResults（下一层级输入），避免其继承的 delta/oldValue/newValue 误触发下游 delta/threshold 效果
            allGenerated.push(infoResult);
            generatedForCurrentMatch.push(infoResult);
          }

          if (secEffect.subCheck) {
            const subCheck = secEffect.subCheck;
            const subCheckCandidates = [subCheck.attribute, ...(subCheck.attributeCandidates || [])].filter(
              (item, idx, arr) => Boolean(item) && arr.indexOf(item) === idx,
            );
            const subCheckLabel = subCheck.label || subCheck.attribute;
            let subCheckAttrName = subCheck.attribute;
            let subCheckAttrValue: number | null = null;
            for (const candidate of subCheckCandidates) {
              const value = getAttributeValue(context.characterName, candidate, subCheckCandidates);
              if (typeof value === 'number' && Number.isFinite(value)) {
                subCheckAttrName = candidate;
                subCheckAttrValue = value;
                break;
              }
            }

            if (subCheckAttrValue === null) {
              const fallbackText =
                subCheck.missingAttributeText ||
                '⚠ 无法自动进行$subCheckLabel：发起者缺少属性[$subCheckAttrName]，请手动判定。';
              const missingVars: Record<string, string | number | boolean> = {
                ...baseOutputVars,
                $subCheckLabel: subCheckLabel,
                $subCheckAttrName: subCheckAttrName,
              };
              const infoResult: EffectResult = {
                effectId: `${secEffect.id}_subcheck_missing`,
                success: true,
                oldValue: matchedResult.oldValue,
                newValue: matchedResult.newValue,
                target: matchedResult.target,
                level: depth,
                triggerType: secEffect.trigger.type,
                triggerSourceId: secEffect.id,
                triggerThreshold: matchedThresholdValue,
                triggerMatchIndex: nextMatchIndex,
                outputMessage: renderTemplateText(fallbackText, missingVars),
                branchLabel: `L${depth}/${secEffect.id}/${subCheckLabel}:缺失属性`,
              };
              allGenerated.push(infoResult);
              generatedForCurrentMatch.push(infoResult);
            } else {
              const subCheckDice = subCheck.dice || '1d100';
              const subCheckRoll = rollComplexDiceExpression(subCheckDice).total;
              const subCheckTarget =
                typeof subCheck.targetValue === 'string' && subCheck.targetValue.trim().length > 0
                  ? resolveThresholdValue(subCheck.targetValue, matchedResult, depth)
                  : subCheckAttrValue;
              const subCheckOperator = subCheck.operator || 'lte';
              const subCheckPassed = compare(subCheckOperator, subCheckRoll, subCheckTarget);
              const subCheckJudge = subCheckPassed ? '成立' : '不成立';
              const branch = subCheckPassed ? subCheck.success : subCheck.failure;
              const subCheckVars: Record<string, string | number | boolean> = {
                ...baseOutputVars,
                $subCheckLabel: subCheckLabel,
                $subCheckAttrName: subCheckAttrName,
                $subCheckAttrValue: subCheckAttrValue,
                $subCheckDice: subCheckDice,
                $subCheckRoll: subCheckRoll,
                $subCheckTarget: subCheckTarget,
                $subCheckOperator: subCheckOperator,
                $subCheckPassed: subCheckPassed ? 1 : 0,
                $subCheckJudge: subCheckJudge,
              };

              if (branch?.randomTable) {
                const tableRoll = rollComplexDiceExpression(branch.randomTable.dice);
                subCheckVars.$tableRoll = tableRoll.total;
                const rawTableResult = branch.randomTable.entries[tableRoll.total] || `未知(${tableRoll.total})`;
                subCheckVars.$tableResult = renderTemplateTextTwice(rawTableResult, subCheckVars);
              }
              appendNamedRandomTables(
                subCheckVars,
                branch?.randomTables as SecondaryEffect['randomTables'] | undefined,
              );

              if (branch?.outputText) {
                const infoResult: EffectResult = {
                  effectId: `${secEffect.id}_subcheck_${subCheckPassed ? 'success' : 'failure'}`,
                  success: true,
                  oldValue: matchedResult.oldValue,
                  newValue: matchedResult.newValue,
                  target: matchedResult.target,
                  level: depth,
                  triggerType: secEffect.trigger.type,
                  triggerSourceId: secEffect.id,
                  triggerThreshold: matchedThresholdValue,
                  triggerMatchIndex: nextMatchIndex,
                  outputMessage: renderTemplateTextTwice(branch.outputText, subCheckVars),
                  branchLabel: `L${depth}/${secEffect.id}/${subCheckLabel}:${subCheckPassed ? '成功' : '失败'}`,
                };
                allGenerated.push(infoResult);
                generatedForCurrentMatch.push(infoResult);
              }

              if (branch?.effects && branch.effects.length > 0) {
                effectsToRun.push(...branch.effects);
              }
            }
          }

          for (const effect of effectsToRun) {
            if (effect.condition) {
              const formulaContextForCondition = buildFormulaContext();
              const condContext = {
                $roll: 0,
                $attr: matchedResult.newValue,
                $old: matchedResult.oldValue,
                $new: matchedResult.newValue,
                $delta: delta,
                $depth: depth,
                $mod: 0,
                $dc: 0,
                ...formulaContextForCondition,
              };
              const condResult = evaluateCondition(effect.condition, condContext);
              if (!condResult.success || !condResult.value) continue;
            }

            if (preset.effectsConfig?.allowedTargets && preset.effectsConfig.allowedTargets.length > 0) {
              if (!preset.effectsConfig.allowedTargets.includes(effect.target)) continue;
            }

            const parsedValue = parseEffectValueInput(effect.value, `Secondary ${secEffect.id}/${effect.id}`);
            const finalValue = parsedValue.finalValue;

            const aliasCandidates = [...(preset.effectsConfig?.allowedTargets || []), context.attributeName].filter(
              (name, idx, arr) => Boolean(name) && arr.indexOf(name) === idx,
            );

            const updateResult = await updateSingleAttribute(
              context.characterName,
              effect.target,
              effect.operation,
              finalValue,
              {
                initValue: effect.initValue,
                min: effect.min,
                max: effect.max,
                aliasCandidates,
                skipSave: Boolean(transactionalData),
                dataOverride: transactionalData,
              },
            );
            if (updateResult.modifiedSheetKey && modifiedSheetKeys)
              modifiedSheetKeys.add(updateResult.modifiedSheetKey);

            const generatedResult: EffectResult = {
              effectId: effect.id,
              success: updateResult.success,
              oldValue: updateResult.oldValue,
              newValue: updateResult.newValue,
              error: updateResult.error,
              target: updateResult.resolvedAttrName || effect.target,
              level: depth,
              triggerType: secEffect.trigger.type,
              triggerSourceId: secEffect.id,
              triggerThreshold: matchedThresholdValue,
              triggerMatchIndex: nextMatchIndex,
              branchLabel: `L${depth}/${secEffect.id}`,
              formulaText: parsedValue.formulaText,
              rolledValue: parsedValue.rolledValue,
            };
            nextLevelResults.push(generatedResult);
            allGenerated.push(generatedResult);
            generatedForCurrentMatch.push(generatedResult);

            if (updateResult.success && replayOperations) {
              replayOperations.push({
                characterName: context.characterName,
                target: effect.target,
                operation: effect.operation,
                value: finalValue,
                initValue: effect.initValue,
                min: effect.min,
                max: effect.max,
                aliasCandidates,
                resultRef: generatedResult,
              });
            }
          }

          if (!callbackScheduled && generatedForCurrentMatch.length === 0) {
            continue;
          }

          consumedMatches += 1;
          generatedByMatch.push(generatedForCurrentMatch);
        }

        if (consumedMatches === 0) continue;

        triggerCounts.set(secEffect.id, currentCount + consumedMatches);

        for (const grouped of generatedByMatch) {
          grouped.forEach(item => {
            item.triggerMatchCount = consumedMatches;
          });
        }
      }

      currentLevelResults = nextLevelResults.filter(r => r.success);
    }

    if (!deferredSecondaryCallbacks) {
      const hasFailure = allGenerated.some(item => !item.success);
      if (!hasFailure) {
        localDeferredCallbacks.forEach(run => run());
      }
    }

    return allGenerated;
  }

  /**
   * 根据后果执行结果计算输出模板变量
   * @param results 后果执行结果数组
   * @returns 可用于 outputContext 的变量对象
   */
  function computeEffectVariables(results: EffectResult[]): Record<string, string | number | boolean> {
    if (!results || results.length === 0) {
      return {
        effectTarget: '',
        effectOperation: '',
        effectDelta: 0,
        effectDeltaFormula: '',
        effectOldValue: 0,
        effectNewValue: 0,
        effectSummary: '',
        effectText: '',
        hasEffect: false,
        effectCount: 0,
        effectResults: '[]',
      };
    }

    // 使用最后一个成功的结果，若全部失败则使用最后一个
    const successResults = results.filter(r => r.success);
    const lastSuccess =
      successResults.length > 0 ? successResults[successResults.length - 1] : results[results.length - 1];

    const delta = lastSuccess.newValue - lastSuccess.oldValue;
    const operation = delta > 0 ? '增加' : delta < 0 ? '减少' : '设置为';

    // 生成所有成功效果的摘要
    const summaries = successResults.map(r => {
      const d = r.newValue - r.oldValue;
      const op = d > 0 ? '+' : '';
      return `${r.effectId}: ${op}${d} (${r.oldValue}→${r.newValue})`;
    });

    return {
      effectTarget: lastSuccess.effectId,
      effectOperation: operation,
      effectDelta: Math.abs(delta),
      effectDeltaFormula: `${Math.abs(delta)}`,
      effectOldValue: lastSuccess.oldValue,
      effectNewValue: lastSuccess.newValue,
      effectSummary:
        successResults.length > 0
          ? `${operation} ${Math.abs(delta)} (${lastSuccess.oldValue} → ${lastSuccess.newValue})`
          : '',
      effectText: summaries.join('; '),
      hasEffect: successResults.length > 0,
      effectCount: successResults.length,
      effectResults: JSON.stringify(results),
    };
  }

  function buildEffectTraceLines(results: EffectResult[]): string[] {
    if (!results || results.length === 0) return [];
    return results.map(item => {
      const prefix = item.branchLabel ? `[${item.branchLabel}] ` : item.level ? `[L${item.level}] ` : '';
      const target = item.target || '-';
      // 失败条目优先（事务回滚时所有结果被标记 success:false，outputMessage 条目也不应显示为成功）
      if (!item.success && item.error) {
        return `${prefix}✗ ${target} 变更失败: ${item.error}`;
      }
      // 信息输出型条目（来自 secondaryEffect.outputText）
      if (item.outputMessage) {
        return `${prefix}${item.outputMessage}`;
      }
      const delta = item.newValue - item.oldValue;
      const sign = delta > 0 ? '+' : '';
      const icon = item.success ? '✓' : '✗';
      const formulaInfo = item.formulaText
        ? ` ｜算式:${item.formulaText}${item.rolledValue !== undefined ? ` ｜掷值:${item.rolledValue}` : ''}`
        : '';
      return `${prefix}${icon} ${target} ${item.oldValue} → ${item.newValue} (${sign}${delta})${formulaInfo}`;
    });
  }

  function buildEffectMetaLines(
    results: EffectResult[],
    options?: {
      branchReasonText?: string;
    },
  ): string[] {
    if (!results || results.length === 0) return [];
    const settledHeader = '【已填表】以下数值效果已同步填表，无需重复填表。';
    const lines = results
      .filter(item => item.success)
      .map(item => {
        if (item.outputMessage) {
          return item.outputMessage;
        }

        const target = item.target || '属性';
        const delta = item.newValue - item.oldValue;
        const sign = delta > 0 ? '+' : '';
        const primaryBranch = item.branchLabel?.startsWith('L1/') ? item.branchLabel.slice(3) : '';
        const formulaDetail =
          item.formulaText && item.rolledValue !== undefined
            ? `，${primaryBranch ? `按${primaryBranch}分支` : '按当前分支'}算式${item.formulaText}得到${item.rolledValue}`
            : '';

        const reasonPrefix = primaryBranch ? `命中${primaryBranch}分支后，` : '';
        return `${reasonPrefix}${target}从${item.oldValue}变为${item.newValue}（变化${sign}${delta}${formulaDetail}）`;
      });

    // 避免与主检定叙事重复：优先输出效果行，仅在没有效果行时回退到分支原因
    if (lines.length > 0) return [settledHeader, ...lines];
    if (options?.branchReasonText) return [settledHeader, options.branchReasonText];
    return [];
  }

  /**
   * 根据待执行的效果定义预计算输出模板变量
   * 用于在输出模板中显示预期的效果信息（实际执行在消息发送后）
   * @param effects 效果定义数组
   * @returns 可用于 outputContext 的变量对象
   */
  function computePendingEffectVariables(effects: Effect[] | undefined): Record<string, string | number | boolean> {
    if (!effects || effects.length === 0) {
      return {
        effectTarget: '',
        effectOperation: '',
        effectDelta: 0,
        effectDeltaFormula: '',
        effectOldValue: 0,
        effectNewValue: 0,
        effectSummary: '',
        effectText: '',
        hasEffect: false,
        effectCount: 0,
        effectResults: '[]',
      };
    }

    // 使用第一个效果作为主要显示
    const firstEffect = effects[0];
    const operationMap: Record<string, string> = {
      add: '增加',
      subtract: '减少',
      set: '设置为',
    };
    const operation = operationMap[firstEffect.operation] || firstEffect.operation;

    // 生成所有效果的预期摘要
    const summaries = effects.map(e => {
      const op = operationMap[e.operation] || e.operation;
      return `${e.target}: ${op} ${e.value}`;
    });

    return {
      effectTarget: firstEffect.target,
      effectOperation: operation,
      effectDelta: 0, // 未执行，无法知道实际变化量
      effectDeltaFormula: firstEffect.value,
      effectOldValue: 0, // 未执行，无法知道原值
      effectNewValue: 0, // 未执行，无法知道新值
      effectSummary: `${firstEffect.target} ${operation} ${firstEffect.value}`,
      effectText: summaries.join('; '),
      hasEffect: true,
      effectCount: effects.length,
      effectResults: JSON.stringify(effects.map(e => ({ effectId: e.id, pending: true }))),
    };
  }

  // ========================================
  // BookmarkManager - 书签管理器（按聊天隔离）
  // ========================================
  const BookmarkManager = {
    STORAGE_KEY_PREFIX: 'acu_bookmarks_v1_',
    MAX_CONTEXTS: 20, // 最多保留多少个聊天的bookmark数据

    _cache: null,
    _currentContextId: null,

    // 获取当前上下文专属的存储键
    _getStorageKey(ctxId) {
      return this.STORAGE_KEY_PREFIX + (ctxId || getCurrentContextFingerprint());
    },

    // 清理过旧的bookmark数据，只保留最近使用的 N 个
    _cleanupOldContexts() {
      try {
        const prefix = this.STORAGE_KEY_PREFIX;
        const allKeys = [];

        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith(prefix)) {
            allKeys.push(key);
          }
        }

        if (allKeys.length <= this.MAX_CONTEXTS) {
          // 数据量在限制内，无需清理
          return;
        }

        // 按最后访问时间排序（通过内部 _lastAccess 字段）
        const keyWithTime = allKeys.map(key => {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            return { key, time: data?._lastAccess || 0 };
          } catch {
            return { key, time: 0 };
          }
        });

        keyWithTime.sort((a, b) => b.time - a.time);

        // 删除超出限制的旧数据
        const toDelete = keyWithTime.slice(this.MAX_CONTEXTS);
        toDelete.forEach(item => {
          localStorage.removeItem(item.key);
        });

        if (toDelete.length > 0) {
          console.log(
            `[DICE]BookmarkManager 清理了 ${toDelete.length} 个过期的bookmark数据（当前保留 ${this.MAX_CONTEXTS} 个聊天的数据，清理前共有 ${allKeys.length} 个）`,
          );
        }
      } catch (e) {
        console.warn('[DICE]BookmarkManager 清理失败', e);
      }
    },

    _load() {
      const ctxId = getCurrentContextFingerprint();

      // 上下文变化时清空缓存
      if (this._currentContextId !== ctxId) {
        this._cache = null;
        this._currentContextId = ctxId;
      }

      if (!this._cache) {
        try {
          const stored = localStorage.getItem(this._getStorageKey());
          this._cache = stored ? JSON.parse(stored) : {};
          // 移除内部元数据字段，不暴露给业务逻辑
          delete this._cache._lastAccess;
        } catch (e) {
          this._cache = {};
        }
      }
      return this._cache;
    },

    _save() {
      try {
        // 写入时附带最后访问时间戳
        const dataToSave = { ...this._cache, _lastAccess: Date.now() };
        localStorage.setItem(this._getStorageKey(), JSON.stringify(dataToSave));

        // 每次保存后尝试清理（内部有数量判断，不会频繁执行）
        this._cleanupOldContexts();
      } catch (e) {
        console.warn('[DICE]BookmarkManager 保存失败', e);
      }
    },

    isBookmarked(tableName, rowKey) {
      const data = this._load();
      return !!(data[tableName] && data[tableName][rowKey]);
    },

    toggleBookmark(tableName, rowKey) {
      const data = this._load();
      if (!data[tableName]) data[tableName] = {};

      if (data[tableName][rowKey]) {
        // 取消bookmark
        delete data[tableName][rowKey];
        if (Object.keys(data[tableName]).length === 0) {
          delete data[tableName];
        }
      } else {
        // 添加bookmark
        data[tableName][rowKey] = true;
      }
      this._save();
    },

    getBookmarks(tableName) {
      const data = this._load();
      if (!data[tableName]) return [];
      return Object.keys(data[tableName]);
    },

    // 清理当前聊天的所有bookmark（调试用）
    clearCurrentContext() {
      localStorage.removeItem(this._getStorageKey());
      this._cache = null;
    },
  };
  const escapeHtml = s =>
    String(s ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');

  const stripLoneSurrogates = (value: string): string => {
    let sanitized = '';
    for (let i = 0; i < value.length; i++) {
      const code = value.charCodeAt(i);
      if (code >= 0xd800 && code <= 0xdbff) {
        const next = value.charCodeAt(i + 1);
        if (next >= 0xdc00 && next <= 0xdfff) {
          sanitized += value[i] + value[i + 1];
          i++;
        } else {
          sanitized += '\uFFFD';
        }
        continue;
      }
      if (code >= 0xdc00 && code <= 0xdfff) {
        sanitized += '\uFFFD';
        continue;
      }
      sanitized += value[i];
    }
    return sanitized;
  };

  const safeEncodeURIComponent = (value: unknown): string => {
    const text = String(value ?? '');
    try {
      return encodeURIComponent(text);
    } catch {
      return encodeURIComponent(stripLoneSurrogates(text));
    }
  };

  const safeDecodeURIComponent = (value: unknown): string => {
    const text = String(value ?? '');
    try {
      return decodeURIComponent(text);
    } catch {
      return stripLoneSurrogates(text);
    }
  };

  /**
   * 设置弹窗点击遮罩关闭的事件监听
   * - PC端：需要 mousedown 和 mouseup 都在遮罩上才关闭（防止选择文本时误关闭）
   * - Mobile端：保持原有行为，触摸点击遮罩即关闭
   * @param $overlay jQuery对象，弹窗遮罩层
   * @param overlayClass 遮罩层的类名（用于判断点击目标）
   * @param onClose 关闭时的回调函数
   */
  const setupOverlayClose = ($overlay: JQuery, overlayClass: string, onClose: () => void) => {
    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    if (isMobile) {
      // Mobile: 触摸点击遮罩即关闭
      $overlay.on('click', function (e) {
        if ($(e.target).hasClass(overlayClass)) {
          onClose();
        }
      });
    } else {
      // PC: 需要 mousedown 和 mouseup 都在遮罩上才关闭
      let mouseDownOnOverlay = false;

      $overlay.on('mousedown', function (e) {
        mouseDownOnOverlay = $(e.target).hasClass(overlayClass);
      });

      $overlay.on('mouseup', function (e) {
        if (mouseDownOnOverlay && $(e.target).hasClass(overlayClass)) {
          onClose();
        }
        mouseDownOnOverlay = false;
      });
    }
  };

  // [新增] 生成唯一名称（用于预设导入时处理重名）
  const generateUniqueName = (baseName: string, existingNames: string[]): string => {
    if (!existingNames.includes(baseName)) return baseName;
    let counter = 2;
    let newName = `${baseName} (${counter})`;
    while (existingNames.includes(newName)) {
      counter++;
      newName = `${baseName} (${counter})`;
    }
    return newName;
  };

  // [新增] 通用预设导入冲突弹窗（复用头像导入弹窗样式）
  const showPresetConflictDialog = (options: {
    presetName: string;
    presetType: string;
    onOverwrite: () => void;
    onRename: (newName: string) => void;
    onCancel: () => void;
    existingNames: string[];
  }) => {
    const { $ } = getCore();
    $('.acu-import-confirm-overlay').remove();

    const config = getConfig();
    const suggestedName = generateUniqueName(options.presetName, options.existingNames);

    const dialogHtml = `
      <div class="acu-import-confirm-overlay acu-theme-${config.theme}">
        <div class="acu-import-confirm-dialog">
          <div class="acu-import-confirm-header">
            <i class="fa-solid fa-file-import"></i> 导入${options.presetType}预设
          </div>
          <div class="acu-import-confirm-body">
            <div class="acu-import-warning-container">
              <i class="fa-solid fa-exclamation-triangle acu-import-warning-icon"></i>
              <div class="acu-import-warning-title">发现同名预设</div>
              <div class="acu-import-warning-message">预设「${escapeHtml(options.presetName)}」已存在，请选择处理方式：</div>
            </div>
            <div class="acu-import-conflict-options">
              <label class="acu-import-radio">
                <input type="radio" name="preset-conflict-mode" value="overwrite" checked />
                <span>覆盖现有预设</span>
              </label>
              <label class="acu-import-radio">
                <input type="radio" name="preset-conflict-mode" value="rename" />
                <span>新建副本（命名为「${escapeHtml(suggestedName)}」）</span>
              </label>
            </div>
          </div>
          <div class="acu-import-confirm-footer">
            <button class="acu-import-cancel-btn">取消</button>
            <button class="acu-import-confirm-btn">确认导入</button>
          </div>
        </div>
      </div>
    `;

    const $dialog = $(dialogHtml);
    $('body').append($dialog);

    // 强制样式（与头像导入弹窗一致）
    const overlayEl = $dialog[0];
    overlayEl.style.cssText = `
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      background: rgba(0,0,0,0.6) !important;
      z-index: 31300 !important;
      display: flex;
      justify-content: center !important;
      align-items: center !important;
      padding: 16px;
      box-sizing: border-box !important;
    `;

    const closeDialog = () => $dialog.remove();

    $dialog.find('.acu-import-cancel-btn').click(() => {
      closeDialog();
      options.onCancel();
    });

    setupOverlayClose($dialog, 'acu-import-confirm-overlay', () => {
      closeDialog();
      options.onCancel();
    });

    $dialog.find('.acu-import-confirm-btn').click(function () {
      const mode = $dialog.find('input[name="preset-conflict-mode"]:checked').val();
      closeDialog();
      if (mode === 'overwrite') {
        options.onOverwrite();
      } else {
        options.onRename(suggestedName);
      }
    });
  };
  // [新增] 智能填充输入栏函数
  const smartInsertToTextarea = (newContent, contentType) => {
    // contentType: 'action' (交互选项) 或 'dice' (骰子结果)
    const { $ } = getCore();
    const $ta = $('#send_textarea');
    if (!$ta.length) return;

    const normalizeTextareaContent = (text: unknown): string => {
      return String(text ?? '')
        .replace(/\r\n?/g, '\n')
        .replace(/[ \t]+\n/g, '\n')
        .replace(/\n[ \t]+/g, '\n')
        .replace(/\n{2,}/g, '\n')
        .trim();
    };

    const normalizedNewContent = normalizeTextareaContent(newContent);
    const currentVal = normalizeTextareaContent($ta.val() || '');

    // 统一检定结果标签正则（匹配 <meta:检定结果>...</meta:检定结果>）
    const metaCheckResultRegex = /<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g;

    // 交互选项的识别正则（以<user>开头，匹配到句末标点）
    const actionRegex = /<user>(?:(?!<user>).)*?[。！？]/g;

    // 占位符识别正则
    const placeholderRegex = /\[投骰结果已隐藏\]/g;

    // [修复] 如果配置启用隐藏，且是骰子结果，则使用占位符显示，但保存真实结果
    const diceCfg = getDiceConfig();
    let contentToInsert = normalizedNewContent;
    let shouldSaveOriginal = false;
    if (contentType === 'dice' && diceCfg.hideDiceResultFromUser) {
      contentToInsert = '[投骰结果已隐藏]';
      shouldSaveOriginal = true;
    }

    // 如果输入栏为空，直接填入
    if (!currentVal) {
      $ta.val(contentToInsert).trigger('input').trigger('change');
      // [修复] 始终保存真实结果到 data 属性（即使不隐藏也要保存，以便后续处理）
      if (contentType === 'dice') {
        $ta.data('acu-original-dice-text', normalizedNewContent);
        // [性能优化] 同时设置 DOM 属性作为缓存，避免 getter 中频繁调用 jQuery
        const textarea = $ta[0] as any;
        textarea._acuOriginalDiceText = normalizedNewContent;
        textarea._acuHasDiceData = true;
      }
      return;
    }

    // 解析当前内容，分离三个部分
    let workingText = currentVal;
    let existingAction = '';
    let existingDice = '';
    let existingDiceOriginal = '';

    // [修复] 0. 先检查是否有占位符（需要替换而不是添加）
    if (placeholderRegex.test(workingText)) {
      // 如果有占位符，说明之前已经有骰子结果，需要替换
      const originalText = $ta.data('acu-original-dice-text') || '';
      if (originalText) {
        // 用原始文本替换占位符，以便后续处理
        workingText = workingText.replace(placeholderRegex, originalText);
        existingDice = originalText;
        existingDiceOriginal = originalText;
      } else {
        // 如果没有保存的原始文本，直接移除占位符
        workingText = workingText.replace(placeholderRegex, '').trim();
      }
    }

    // 1. 提取 <meta:检定结果> 标签块（统一格式）
    const metaMatches = workingText.match(metaCheckResultRegex);
    if (metaMatches && metaMatches.length > 0) {
      existingDice = metaMatches[metaMatches.length - 1];
      existingDiceOriginal = existingDice;
      workingText = workingText.replace(metaCheckResultRegex, '\u0000').trim();
      console.log(
        '[DICE]ACU SmartInsert Found and extracted meta check result:',
        existingDice.substring(0, 50) + '...',
      );
    }

    // 2. 提取交互选项
    const actionMatches = workingText.match(actionRegex);
    if (actionMatches && actionMatches.length > 0) {
      existingAction = actionMatches[actionMatches.length - 1];
      workingText = workingText.replace(actionRegex, '\u0001').trim();
      console.log('[DICE]ACU SmartInsert Found and extracted action:', existingAction);
    }

    // 3. 移除占位符，剩下的就是用户输入
    let userInput = workingText
      .replace(/[\u0000\u0001]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    // [修复] 清理历史遗留的“骰子输出前缀残片”
    // 某些旧异常文本会形成："前缀文本 + <meta:检定结果>..."。
    // 这里在插入新骰子结果时，若 userInput 只是新结果首行的前缀/近似前缀，则自动丢弃，避免重复。
    if (contentType === 'dice' && normalizedNewContent.includes('<meta:检定结果>') && userInput) {
      const diceBody = normalizeTextareaContent(
        normalizedNewContent.replace(/<meta:检定结果>/g, '').replace(/<\/meta:检定结果>/g, ''),
      );
      const firstLine = (diceBody.split('\n')[0] || '').trim();
      const normalizeFragment = (text: string): string => {
        return String(text || '')
          .replace(/\s+/g, '')
          .replace(/[：:，。,！？!?.]+$/g, '')
          .trim();
      };
      const userNorm = normalizeFragment(userInput);
      const firstNorm = normalizeFragment(firstLine);
      if (userNorm && firstNorm && (firstNorm.startsWith(userNorm) || userNorm.startsWith(firstNorm))) {
        userInput = '';
      }
    }

    // 4. 根据新内容类型，更新对应部分
    if (contentType === 'dice') {
      // [修复] 保存真实结果，显示占位符（如果配置启用）
      existingDice = contentToInsert;
      existingDiceOriginal = normalizedNewContent;
      // 始终保存真实结果到 data 属性
      $ta.data('acu-original-dice-text', normalizedNewContent);
      // [性能优化] 同时设置 DOM 属性作为缓存，避免 getter 中频繁调用 jQuery
      const textarea = $ta[0] as any;
      textarea._acuOriginalDiceText = normalizedNewContent;
      textarea._acuHasDiceData = true;
    } else if (contentType === 'action') {
      existingAction = normalizedNewContent;
    }

    // 5. 重新组合：用户输入 + 交互选项 + 骰子结果
    const parts = [];
    if (userInput) parts.push(userInput);
    if (existingAction) parts.push(existingAction);
    if (existingDice) parts.push(existingDice);

    const finalVal = normalizeTextareaContent(parts.join(' '));
    $ta.val(finalVal).trigger('input').trigger('change');
  };

  // [新增] 在发送消息前恢复真实结果
  const restoreDiceResultBeforeSend = () => {
    const { $ } = getCore();
    const diceCfg = getDiceConfig();
    const hideInput = diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
    if (hideInput) return;
    const $ta = $('#send_textarea');
    if (!$ta.length) return;

    const currentVal = $ta.val() || '';
    const originalText = $ta.data('acu-original-dice-text');

    // 如果有占位符且有保存的原始文本，替换为真实结果
    if (currentVal.includes('[投骰结果已隐藏]') && originalText) {
      const restoredVal = currentVal.replace(/\[投骰结果已隐藏\]/g, originalText);
      $ta.val(restoredVal);
      // 发送后不需要再保存，因为消息已经发送
      $ta.removeData('acu-original-dice-text');
      // [性能优化] 同时清除 DOM 属性缓存
      const textarea = $ta[0] as any;
      textarea._acuOriginalDiceText = null;
      textarea._acuHasDiceData = false;
    }
  };

  // [新增] 拦截输入框的 value 属性，确保读取时自动替换占位符
  const interceptTextareaValue = () => {
    const { $ } = getCore();
    const $ta = $('#send_textarea');
    if (!$ta.length) return;

    const textarea = $ta[0] as HTMLTextAreaElement;
    if (!textarea || (textarea as any)._acuValueIntercepted) return;

    // 标记已拦截，避免重复拦截
    (textarea as any)._acuValueIntercepted = true;

    // 保存原始的 value 属性描述符
    const originalDescriptor = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value');
    const originalValue = textarea.value;

    // 拦截 value 属性的 getter
    Object.defineProperty(textarea, 'value', {
      get: function (this: HTMLTextAreaElement) {
        // 先获取原始值
        let val: string;
        if (originalDescriptor && originalDescriptor.get) {
          val = originalDescriptor.get.call(this);
        } else {
          val = (this as any)._value || originalValue || '';
        }

        // [性能优化] 快速路径：如果没有骰子数据标记，直接返回
        // 使用 DOM 属性而非 jQuery data，避免每次 getter 都调用 jQuery
        // 解决输入 ) 等字符时卡顿的问题
        if (!(this as any)._acuHasDiceData) {
          return val;
        }

        // 检查是否有占位符需要替换
        const originalText = (this as any)._acuOriginalDiceText;
        if (val && typeof val === 'string' && val.includes('[投骰结果已隐藏]') && originalText) {
          return val.replace(/\[投骰结果已隐藏\]/g, originalText);
        }
        return val;
      },
      set: function (this: HTMLTextAreaElement, val: string) {
        if (originalDescriptor && originalDescriptor.set) {
          originalDescriptor.set.call(this, val);
        } else {
          (this as any)._value = val;
        }
      },
      configurable: true,
    });
  };
  const STORAGE_KEY_TABLE_ORDER = 'acu_table_order';
  const STORAGE_KEY_ACTION_ORDER = 'acu_action_order';

  const STORAGE_KEY_ACTIVE_TAB = 'acu_active_tab';
  const STORAGE_KEY_UI_CONFIG = 'acu_ui_config_v19';
  const STORAGE_KEY_LAST_SNAPSHOT = 'acu_data_snapshot_v19';
  const STORAGE_KEY_IS_COLLAPSED = 'acu_ui_collapsed_state';
  const STORAGE_KEY_OPTIONS_COLLAPSED = 'acu_options_collapsed'; // [新增] 选项面板独立折叠状态
  const STORAGE_KEY_DASHBOARD_ACTIVE = 'acu_dashboard_active';
  // [新增] 移植功能所需的存储键
  const STORAGE_KEY_TABLE_HEIGHTS = 'acu_table_heights_v19';
  const STORAGE_KEY_TABLE_STYLES = 'acu_table_styles_v19';
  const STORAGE_KEY_HIDDEN_TABLES = 'acu_hidden_tables_v19';
  const STORAGE_KEY_GM_CONFIG = 'acu_gm_engine_config_v1';
  const STORAGE_KEY_REVERSE_TABLES = 'acu_reverse_tables_v1';
  const MAX_ACTION_BUTTONS = 6; // 活动栏最大按钮数
  const MIN_PANEL_HEIGHT = 200; // 面板最小高度
  const MAX_PANEL_HEIGHT = 1200; // 面板最大高度

  const STORAGE_KEY_DICE_CONFIG = 'acu_dice_config_v1';
  const STORAGE_KEY_ATTRIBUTE_PRESETS = 'acu_attribute_presets_v1';
  const STORAGE_KEY_ACTIVE_ATTR_PRESET = 'acu_active_attr_preset_v1';
  const STORAGE_KEY_ACTION_PRESETS = 'acu_action_presets_v1';
  const STORAGE_KEY_ACTIVE_ACTION_PRESET = 'acu_active_action_preset_v1';
  const STORAGE_KEY_ADVANCED_PRESETS = 'acu_advanced_presets_v1';
  const STORAGE_KEY_BUILTIN_PRESET_VISIBILITY = 'acu_builtin_preset_visibility';
  const STORAGE_KEY_BUILTIN_PRESET_ORDER = 'acu_builtin_preset_order';
  const STORAGE_KEY_LAST_PRESET = 'acu_dice_last_preset';
  const STORAGE_KEY_CRAZY_MODE = 'acu_dice_crazy_mode';

  // 自定义掷骰模式常量
  const CUSTOM_ROLL_MODE = {
    id: '__custom__',
    name: '自定义',
  } as const;
  const DEFAULT_CRAZY_MODE_CONFIG = {
    enabled: false,
    crazyLevel: 50,
    playerWeight: 80,
    inSceneNpcWeight: 15,
    offSceneNpcWeight: 5,
  };
  const PRESET_FORMAT_VERSION = '1.7.0'; // 预设格式版本号（全局共享，用于数据验证规则、管理属性规则等）
  const SCRIPT_VERSION = 'v4.03'; // 脚本版本号

  // 比较版本号（简单比较，假设版本号格式为 "x.y.z"）
  const compareVersion = (v1, v2) => {
    // 处理数字版本号（向后兼容）
    const normalizeVersion = v => {
      if (typeof v === 'number') return `${v}.0.0`;
      if (typeof v !== 'string') return '0.0.0';
      return v;
    };
    const nv1 = normalizeVersion(v1);
    const nv2 = normalizeVersion(v2);
    const parts1 = nv1.split('.').map(Number);
    const parts2 = nv2.split('.').map(Number);
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const p1 = parts1[i] || 0;
      const p2 = parts2[i] || 0;
      if (p1 < p2) return -1;
      if (p1 > p2) return 1;
    }
    return 0;
  };

  const STORAGE_KEY_AVATAR_MAP = 'acu_avatar_map_v1';
  const STORAGE_KEY_MAP_FOCUS = 'acu_map_focus_v1';

  // ========================================
  // ConsoleCaptureManager - Console日志抓取管理器
  // ========================================
  const ConsoleCaptureManager = {
    logs: [],
    maxLogs: 1000,
    filters: { log: true, info: true, warn: true, error: true },
    originalMethods: {},
    isIntercepted: false,
    enabled: false, // 默认关闭，需要手动开启或错误时自动开启

    restore() {
      // 从 localStorage 恢复状态
      const saved = localStorage.getItem('acu_console_capture_enabled');
      if (saved === 'true') {
        this.enable();
      }
    },

    enable() {
      if (this.enabled) return;
      this.enabled = true;
      localStorage.setItem('acu_console_capture_enabled', 'true');
      this.intercept();
    },

    disable() {
      if (!this.enabled) return;
      this.enabled = false;
      localStorage.setItem('acu_console_capture_enabled', 'false');
      // 清除错误标志（尊重用户选择）
      localStorage.removeItem('acu_script_error_detected');
      // 隐藏紧急入口按钮
      const emergencyBtn = document.getElementById('acu-emergency-debug-btn');
      if (emergencyBtn) {
        emergencyBtn.style.display = 'none';
      }
    },

    intercept() {
      if (this.isIntercepted) return;
      this.isIntercepted = true;

      ['log', 'info', 'warn', 'error'].forEach(type => {
        this.originalMethods[type] = console[type];
        const self = this;
        console[type] = function (...args) {
          // 调用原方法
          self.originalMethods[type].apply(console, args);
          // 记录日志（仅在启用时）
          if (self.enabled) {
            self.capture(type, args);
          }
        };
      });
    },

    capture(type, args) {
      if (!this.enabled) return; // 仅在启用时捕获
      try {
        const timestamp = new Date();
        const timeStr = timestamp.toLocaleTimeString('zh-CN', { hour12: false });

        // 将参数转换为字符串
        const content = args
          .map(arg => {
            if (typeof arg === 'object') {
              try {
                return JSON.stringify(arg, null, 2);
              } catch {
                return String(arg);
              }
            }
            return String(arg);
          })
          .join(' ');

        // 获取堆栈信息（仅error）
        let stack = null;
        if (type === 'error' && args[0] instanceof Error) {
          stack = args[0].stack || null;
        }

        const logEntry = {
          id: Date.now() + Math.random(),
          timestamp,
          timeStr,
          type,
          content,
          stack,
          rawArgs: args,
        };

        this.logs.push(logEntry);

        // 限制日志数量
        if (this.logs.length > this.maxLogs) {
          this.logs.shift();
        }
      } catch (e) {
        // 捕获失败不影响原console功能
      }
    },

    clear() {
      this.logs = [];
    },

    getFilteredLogs() {
      return this.logs.filter(log => this.filters[log.type]);
    },

    setFilters(filters) {
      this.filters = { ...this.filters, ...filters };
    },
  };

  // 不自动初始化拦截，需要手动开启或错误时自动开启
  // ConsoleCaptureManager.intercept();

  // ========================================
  // 全局错误处理机制（高阈值，仅致命错误）
  // ========================================
  const ErrorHandler = {
    errorCount: 0,
    errorThreshold: 3, // 连续3次致命错误才触发
    lastErrorTime: 0,
    errorWindow: 5000, // 5秒内的错误才计入
    fatalErrorDetected: false,

    // 判断是否为致命错误（高阈值）
    isFatalError(error, source, lineno, colno, stack) {
      // 排除第三方库错误
      const thirdPartyPatterns = [/jquery/i, /lodash/i, /vue/i, /react/i, /pixi/i, /gsap/i, /toastr/i, /node_modules/i];

      const errorInfo = stack || error?.stack || '';
      const errorSource = source || '';

      // 检查是否来自第三方库
      for (const pattern of thirdPartyPatterns) {
        if (pattern.test(errorInfo) || pattern.test(errorSource)) {
          return false;
        }
      }

      // 检查是否来自骰子系统核心代码
      const corePatterns = [
        /acu_visualizer/i,
        /骰子系统/i,
        /LockManager/i,
        /Store/i,
        /ConsoleCaptureManager/i,
        /renderInterface/i,
        /init\s*\(/i,
      ];

      let isCoreError = false;
      for (const pattern of corePatterns) {
        if (pattern.test(errorInfo) || pattern.test(errorSource)) {
          isCoreError = true;
          break;
        }
      }

      // 必须是核心错误才可能是致命错误
      return isCoreError;
    },

    // 处理错误
    handleError(error, source, lineno, colno, stack) {
      try {
        // 检查是否为致命错误
        if (!this.isFatalError(error, source, lineno, colno, stack)) {
          return; // 非致命错误，忽略
        }

        const now = Date.now();

        // 如果距离上次错误超过时间窗口，重置计数
        if (now - this.lastErrorTime > this.errorWindow) {
          this.errorCount = 0;
        }

        this.errorCount++;
        this.lastErrorTime = now;

        // 达到阈值，触发致命错误处理
        if (this.errorCount >= this.errorThreshold && !this.fatalErrorDetected) {
          this.fatalErrorDetected = true;
          this.triggerFatalError();
        }
      } catch (e) {
        // 错误处理本身出错时，避免无限循环
        console.error('[DICE]ErrorHandler 处理错误时失败:', e);
      }
    },

    // 触发致命错误处理
    triggerFatalError() {
      try {
        // 自动开启 console 抓取
        if (!ConsoleCaptureManager.enabled) {
          ConsoleCaptureManager.enable();
        }

        // 设置错误标志
        localStorage.setItem('acu_script_error_detected', 'true');

        // 显示紧急入口按钮
        this.showEmergencyButton();
      } catch (e) {
        console.error('[DICE]ErrorHandler 触发致命错误处理时失败:', e);
      }
    },

    // 显示紧急入口按钮
    showEmergencyButton() {
      try {
        // 检查是否已存在
        let btn = document.getElementById('acu-emergency-debug-btn');
        if (btn) {
          btn.style.display = 'block';
          return;
        }

        // 创建紧急入口按钮
        btn = document.createElement('button');
        btn.id = 'acu-emergency-debug-btn';
        btn.innerHTML = '<i class="fa-solid fa-bug"></i> 调试';
        btn.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 99999;
          padding: 10px 16px;
          background: #e74c3c;
          color: #fff;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
          display: flex;
          align-items: center;
          gap: 6px;
          transition: all 0.2s;
        `;

        btn.onmouseenter = function () {
          this.style.background = '#c0392b';
          this.style.transform = 'scale(1.05)';
        };
        btn.onmouseleave = function () {
          this.style.background = '#e74c3c';
          this.style.transform = 'scale(1)';
        };

        btn.onclick = function () {
          try {
            // 尝试调用全局的 showDebugConsoleModal
            if (typeof window.showDebugConsoleModal === 'function') {
              window.showDebugConsoleModal();
            } else {
              // 降级方案：提示用户打开浏览器控制台
              alert('脚本出现错误，请打开浏览器开发者工具（F12）查看控制台');
            }
          } catch (e) {
            console.error('[DICE]紧急入口按钮点击失败:', e);
            alert('脚本出现错误，请打开浏览器开发者工具（F12）查看控制台');
          }
        };

        document.body.appendChild(btn);
      } catch (e) {
        console.error('[DICE]显示紧急入口按钮失败:', e);
      }
    },

    // 检查并恢复错误状态
    checkAndRestore() {
      try {
        const errorDetected = localStorage.getItem('acu_script_error_detected') === 'true';
        if (errorDetected) {
          // 自动开启 console 抓取（仅本次会话）
          if (!ConsoleCaptureManager.enabled) {
            ConsoleCaptureManager.enable();
          }
          // 显示紧急入口按钮
          this.showEmergencyButton();
        }
      } catch (e) {
        console.error('[DICE]ErrorHandler 检查错误状态失败:', e);
      }
    },
  };

  // 注册全局错误处理器
  window.onerror = function (message, source, lineno, colno, error) {
    ErrorHandler.handleError(error || message, source, lineno, colno, error?.stack);
    return false; // 不阻止默认错误处理
  };

  // 注册 Promise 拒绝处理器
  window.addEventListener('unhandledrejection', function (event) {
    ErrorHandler.handleError(event.reason, null, null, null, event.reason?.stack);
  });

  // 在脚本初始化时检查错误状态
  // 这个会在 init 函数中调用

  // ========================================
  // 正则转换系统 - 类型定义 (Phase 1.1)
  // ========================================

  /**
   * 正则转换操作类型
   * - replace: 替换匹配的内容
   * - extract: 提取匹配的内容(暂未实现)
   * - delete: 删除匹配的内容
   * - validate: 验证格式(与ValidationEngine不同,这是转换验证)
   */
  type RegexOperation = 'replace' | 'extract' | 'delete' | 'validate';

  /**
   * 正则转换作用域类型
   * - global: 所有表格的所有列
   * - table: 指定表格的所有列
   * - column: 指定表格的指定列
   */
  type RegexScopeType = 'global' | 'table' | 'column';

  /**
   * 正则转换执行模式
   * - auto: 数据更新时自动执行
   * - manual: 用户手动触发
   * - preview: 预览影响,确认后应用
   */
  type RegexExecutionMode = 'auto' | 'manual' | 'preview';

  /**
   * 正则标志位选项
   */
  interface RegexFlags {
    caseInsensitive?: boolean; // i - 忽略大小写
    global?: boolean; // g - 全局匹配
    multiline?: boolean; // m - 多行模式
    unicode?: boolean; // u - Unicode模式
    sticky?: boolean; // y - 粘性匹配
  }

  /**
   * 作用域配置
   */
  interface RegexScopeConfig {
    type: RegexScopeType;
    tableNames?: string[]; // 作用域为table或column时指定表格名
    columnNames?: string[]; // 作用域为column时指定列名
  }

  /**
   * 安全配置
   */
  interface RegexSecurityConfig {
    maxMatchTime: number; // 单次匹配最大耗时(毫秒),默认100
    maxMatches: number; // 最大匹配次数,默认1000
    maxInputLength: number; // 最大输入长度,默认10000
  }

  /**
   * 测试用例
   */
  interface RegexTestCase {
    input: string;
    expected: string;
    description?: string;
  }

  /**
   * 正则转换规则
   */
  interface RegexTransformationRule {
    id: string; // 唯一标识
    name: string; // 规则名称
    description?: string; // 规则描述
    operation: RegexOperation; // 操作类型
    pattern: string; // 正则表达式字符串
    flags?: RegexFlags; // 正则标志位
    replacement?: string; // 替换内容(仅replace操作)
    scope: RegexScopeConfig; // 作���域配置
    enabled: boolean; // 是否启用
    priority: number; // 优先级(1-100),数值越大优先级越高
    executeMode: RegexExecutionMode; // 执行模式
    testCases?: RegexTestCase[]; // 测试用例
    security?: RegexSecurityConfig; // 安全配置
    createdAt?: number; // 创建时间戳
    updatedAt?: number; // 更新时间戳
  }

  /**
   * 转换结果
   */
  interface RegexTransformResult {
    success: boolean;
    oldValue: string;
    newValue: string;
    matched: boolean;
    error?: string;
  }

  /**
   * 批量转换结果
   */
  interface RegexBatchTransformResult {
    tableName: string;
    columnIndex: number;
    rowIndex: number;
    result: RegexTransformResult;
  }

  /**
   * 预览结果
   */
  interface RegexPreviewResult {
    rule: RegexTransformationRule;
    affectedCells: Array<{
      tableName: string;
      rowIndex: number;
      columnIndex: number;
      columnName: string;
      oldValue: string;
      newValue: string;
    }>;
    totalAffected: number;
  }

  /**
   * 预设配置
   */
  interface RegexPreset {
    id: string;
    name: string;
    description?: string;
    version: string;
    rules: RegexTransformationRule[];
    createdAt?: number;
    updatedAt?: number;
  }

  // 正则转换系统存储键
  const STORAGE_KEY_REGEX_RULES = 'acu_regex_rules_v1';
  const STORAGE_KEY_REGEX_PRESETS = 'acu_regex_presets_v1';
  const STORAGE_KEY_REGEX_ACTIVE_PRESET = 'acu_regex_active_preset_v1';
  const STORAGE_KEY_REGEX_ENABLED = 'acu_regex_enabled_v1';

  // ========================================
  // 酒馆原生正则格式兼容 (Tavern Regex Import)
  // ========================================

  /**
   * 酒馆原生正则格式
   * @see https://docs.sillytavern.app/usage/core-concepts/regex/
   */
  interface TavernRegex {
    id?: string;
    scriptName: string;
    findRegex: string;
    replaceString: string;
    trimStrings?: string[];
    placement?: number[];
    disabled?: boolean;
    markdownOnly?: boolean;
    promptOnly?: boolean;
    runOnEdit?: boolean;
    substituteRegex?: number;
    minDepth?: number | null;
    maxDepth?: number | null;
  }

  /**
   * 解析酒馆正则的 findRegex 字段
   * 格式: /pattern/flags
   */
  function parseTavernFindRegex(findRegex: string): { pattern: string; flags: RegexFlags } {
    // 匹配 /pattern/flags 格式，使用惰性匹配和末尾锚定
    const match = findRegex.match(/^\/(.+)\/([gimsuy]*)$/s);
    if (match) {
      const [, pattern, flagStr] = match;
      return {
        pattern,
        flags: {
          global: flagStr.includes('g'),
          caseInsensitive: flagStr.includes('i'),
          multiline: flagStr.includes('m'),
          unicode: flagStr.includes('u'),
          sticky: flagStr.includes('y'),
        },
      };
    }
    // 非标准格式，直接作为pattern，默认全局匹配
    return { pattern: findRegex, flags: { global: true } };
  }

  /**
   * 将酒馆正则格式转换为本系统的 RegexTransformationRule
   */
  function convertTavernRegexToRule(tavernRegex: TavernRegex): RegexTransformationRule {
    const { pattern, flags } = parseTavernFindRegex(tavernRegex.findRegex);

    // 构建额外信息描述，保留酒馆正则的原始配置供参考
    const extraInfo: string[] = [];
    if (tavernRegex.placement?.length) extraInfo.push(`placement: [${tavernRegex.placement.join(',')}]`);
    if (tavernRegex.markdownOnly) extraInfo.push('markdownOnly');
    if (tavernRegex.promptOnly) extraInfo.push('promptOnly');
    if (tavernRegex.minDepth != null) extraInfo.push(`minDepth: ${tavernRegex.minDepth}`);
    if (tavernRegex.maxDepth != null) extraInfo.push(`maxDepth: ${tavernRegex.maxDepth}`);

    const description = extraInfo.length > 0 ? `[从酒馆正则导入] ${extraInfo.join(', ')}` : '[从酒馆正则导入]';

    return {
      id: `tavern_import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: tavernRegex.scriptName,
      description,
      operation: 'replace',
      pattern,
      flags,
      replacement: tavernRegex.replaceString || '',
      scope: { type: 'global' },
      enabled: !tavernRegex.disabled,
      priority: 50,
      executeMode: tavernRegex.runOnEdit ? 'auto' : 'manual',
      security: { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
  }

  // ========================================
  // 内置正则转换规则 (Phase 2.2)
  // ========================================
  const BUILTIN_REGEX_RULES: RegexTransformationRule[] = [
    // 清除极端词
    {
      id: 'builtin_clear_extreme_words',
      name: '清除极端词',
      description: '清除AI常用的极端程度副词和形容词',
      operation: 'replace',
      pattern: '极度|激烈的|剧烈的|强烈|深刻|极其|极高的|完全|未知',
      flags: { global: false, caseInsensitive: false, multiline: false },
      replacement: '',
      scope: { type: 'global' },
      enabled: true,
      priority: 50,
      executeMode: 'auto',
      security: { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
    },
    // 去八股
    {
      id: 'builtin_remove_cliche',
      name: '去八股',
      description: '移除AI常见的八股文风格表达',
      operation: 'replace',
      pattern:
        '一(丝+)|(、?)不容置疑([的地]?)|(、?)(不易|难以)(觉察|察觉)([的地]?)|(微|几)不可(查|察|闻)([的地]?)|，([^，]*?)指(关节|节|尖)(.*?)白|，([^，]*?)(一抹|弧度)(.*?)([^，]*?)(?=[。，])|支配|掌控|崩溃',
      flags: { global: false, caseInsensitive: false, multiline: false },
      replacement: '',
      scope: { type: 'global' },
      enabled: true,
      priority: 50,
      executeMode: 'auto',
      security: { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
    },
    // 统一用户称呼（默认关闭）
    {
      id: 'builtin_replace_user',
      name: '统一用户称呼',
      description: '将常见的用户称呼统一替换为指定名称，可自行修改替换目标',
      operation: 'replace',
      pattern: '主角|<user>|{{user}}',
      flags: { global: false, caseInsensitive: false, multiline: false },
      replacement: '！！请输入你的角色名！！',
      scope: { type: 'global' },
      enabled: false,
      priority: 50,
      executeMode: 'auto',
      security: { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
    },
    // 去除特殊属性中的负面情绪
    {
      id: 'builtin_remove_negative_traits',
      name: '去除特殊属性中的负面情绪',
      description: '删除主角信息表与重要人物表中过于陈腐的性格标签',
      operation: 'replace',
      pattern:
        '[^;：:\\s]*(绝望|崩溃|崩坏|恐惧|NTR|羞耻|快感|顺从|侵犯|服从|逻辑|决绝|臣服|屈服|敏感|洗脑)[^;：:\\s]*[:：]\\d+;?\\s?',
      flags: { global: false, caseInsensitive: false, multiline: false },
      replacement: '',
      scope: { type: 'table', tableNames: ['主角信息', '重要人物表', '重要角色表'] },
      enabled: true,
      priority: 50,
      executeMode: 'auto',
      security: { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
    },
  ];

  // ========================================
  // ValidationRuleManager - 数据验证规则系统
  // ========================================
  const STORAGE_KEY_VALIDATION_RULES = 'acu_validation_rules_v1';
  const STORAGE_KEY_VALIDATION_ENABLED = 'acu_validation_enabled_v1';
  const STORAGE_KEY_VALIDATION_MODE = 'acu_validation_mode'; // 数据验证模式（只显示验证错误）

  // 规则类型信息（用于 UI 显示和分组）
  const RULE_TYPE_INFO = {
    // 表级规则
    tableReadonly: { name: '表级只读', scope: 'table', icon: 'fa-lock', desc: '禁止修改整个表' },
    rowLimit: { name: '行数限制', scope: 'table', icon: 'fa-arrows-up-down', desc: '限制表的行数范围' },
    sequence: { name: '序列递增', scope: 'table', icon: 'fa-sort-numeric-up', desc: '检查字段值是否严格递增' },
    // 字段级规则
    required: { name: '必填', scope: 'field', icon: 'fa-asterisk', desc: '字段不能为空' },
    format: { name: '格式验证', scope: 'field', icon: 'fa-font', desc: '正则表达式匹配' },
    enum: { name: '枚举验证', scope: 'field', icon: 'fa-list', desc: '值必须在列表中' },
    numeric: { name: '数值范围', scope: 'field', icon: 'fa-hashtag', desc: '数值必须在范围内' },
    relation: { name: '关联验证', scope: 'field', icon: 'fa-link', desc: '引用其他表的值' },
    keyValue: { name: '键值对验证', scope: 'field', icon: 'fa-key', desc: '验证键值对格式和数值范围' },
  };

  // 内置验证规则定义
  const BUILTIN_VALIDATION_RULES = [
    // 总结表编码递增验证
    {
      id: 'summary_code_sequence',
      name: '总结表编码递增',
      description: '编码索引必须从AM0001开始严格递增，不可跳号或重复',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '总结表',
      targetColumn: '编码索引',
      ruleType: 'sequence',
      config: { prefix: 'AM', startFrom: 1 },
      errorMessage: '编码索引必须从AM0001开始严格递增，发现跳号或重复',
    },
    // 总体大纲编码递增验证
    {
      id: 'outline_code_sequence',
      name: '总体大纲编码递增',
      description: '编码索引必须从AM0001开始严格递增，不可跳号或重复',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '总体大纲',
      targetColumn: '编码索引',
      ruleType: 'sequence',
      config: { prefix: 'AM', startFrom: 1 },
      errorMessage: '编码索引必须从AM0001开始严格递增，发现跳号或重复',
    },
    // 总结表编码索引必填验证
    {
      id: 'summary_code_required',
      name: '总结表编码索引必填',
      description: '编码索引不能为空',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '总结表',
      targetColumn: '编码索引',
      ruleType: 'required',
      config: {},
      errorMessage: '编码索引不能为空',
    },
    // 总体大纲编码索引必填验证
    {
      id: 'outline_code_required',
      name: '总体大纲编码索引必填',
      description: '编码索引不能为空',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '总体大纲',
      targetColumn: '编码索引',
      ruleType: 'required',
      config: {},
      errorMessage: '编码索引不能为空',
    },
    // 任务表状态枚举
    {
      id: 'quest_status_enum',
      name: '任务表状态',
      description: '任务状态必须为指定的枚举值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '任务表',
      targetColumn: '状态(Enum Tag)',
      ruleType: 'enum',
      config: { values: ['进行中', '已完成', '已失败', '已放弃'] },
      errorMessage: '状态必须为枚举值之一：进行中、已完成、已失败、已放弃',
    },
    // 任务表类型枚举
    {
      id: 'quest_type_enum',
      name: '任务表类型',
      description: '任务类型必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '任务表',
      targetColumn: '类型',
      ruleType: 'enum',
      config: { values: ['主线', '支线', '日常'] },
      errorMessage: '类型必须为：主线、支线、日常',
    },
    // 任务表优先级枚举
    {
      id: 'quest_priority_enum',
      name: '任务表优先级',
      description: '任务优先级必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '任务表',
      targetColumn: '优先级',
      ruleType: 'enum',
      config: { values: ['紧急', '重要', '普通'] },
      errorMessage: '优先级必须为：紧急、重要、普通',
    },
    // 任务表进度格式
    {
      id: 'quest_progress_format',
      name: '任务表进度',
      description: '进度必须为0%~100%格式',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '任务表',
      targetColumn: '进度(%)',
      ruleType: 'format',
      config: { pattern: '^(100|[1-9]?\\d)%$' },
      errorMessage: '进度必须为0%~100%格式（如：0%、50%、100%）',
    },
    // 装备表状态枚举
    {
      id: 'equip_status_enum',
      name: '装备表状态',
      description: '装备状态必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '装备表',
      targetColumn: '状态',
      ruleType: 'enum',
      config: { values: ['已装备', '闲置'] },
      errorMessage: '状态必须为：已装备、闲置',
    },
    // 装备表品质枚举
    {
      id: 'equip_quality_enum',
      name: '装备表品质',
      description: '装备品质必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '装备表',
      targetColumn: '品质',
      ruleType: 'enum',
      config: { values: ['普通', '优秀', '稀有', '史诗', '传说', '神话'] },
      errorMessage: '品质必须为：普通、优秀、稀有、史诗、传说、神话',
    },
    // 物品表品质枚举
    {
      id: 'item_quality_enum',
      name: '物品表品质',
      description: '物品品质必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '物品表',
      targetColumn: '品质',
      ruleType: 'enum',
      config: { values: ['普通', '优秀', '稀有', '史诗', '传说', '神话'] },
      errorMessage: '品质必须为：普通、优秀、稀有、史诗、传说、神话',
    },
    // 技能表类型枚举
    {
      id: 'skill_type_enum',
      name: '技能表类型',
      description: '技能类型必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '技能表',
      targetColumn: '类型',
      ruleType: 'enum',
      config: { values: ['主动', '被动', '特质'] },
      errorMessage: '类型必须为：主动、被动、特质',
    },
    // 技能表品质枚举
    {
      id: 'skill_quality_enum',
      name: '技能表品质',
      description: '技能品质必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '技能表',
      targetColumn: '品质',
      ruleType: 'enum',
      config: { values: ['普通', '优秀', '稀有', '史诗', '传说', '神话'] },
      errorMessage: '品质必须为：普通、优秀、稀有、史诗、传说、神话',
    },
    // 技能表熟练度数值范围
    {
      id: 'skill_proficiency_range',
      name: '技能熟练度范围',
      description: '技能熟练度必须在 0-100 之间',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '技能表',
      targetColumn: '熟练度',
      ruleType: 'numeric',
      config: { min: 0, max: 100 },
      errorMessage: '熟练度必须在 0-100 之间',
    },
    // 重要人物表在场状态枚举
    {
      id: 'npc_presence_enum',
      name: '重要人物在场状态',
      description: '在场状态必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '重要人物表',
      targetColumn: '在场状态',
      ruleType: 'enum',
      config: { values: ['在场', '离场'] },
      errorMessage: '在场状态必须为：在场、离场',
    },
    // 世界地图点探索状态枚举
    {
      id: 'map_explore_enum',
      name: '地图点探索状态',
      description: '探索状态必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '世界地图点',
      targetColumn: '探索状态',
      ruleType: 'enum',
      config: { values: ['未探索', '部分探索', '已探索'] },
      errorMessage: '探索状态必须为：未探索、部分探索、已探索',
    },
    // 世界地图点重要度枚举
    {
      id: 'map_importance_enum',
      name: '地图点重要度',
      description: '重要度必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '世界地图点',
      targetColumn: '重要度',
      ruleType: 'enum',
      config: { values: ['核心', '重要', '普通'] },
      errorMessage: '重要度必须为：核心、重要、普通',
    },
    // 重要情报重要度枚举
    {
      id: 'intel_importance_enum',
      name: '情报重要度',
      description: '重要度必须为指定值之一',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '重要情报',
      targetColumn: '重要度',
      ruleType: 'enum',
      config: { values: ['核心', '重要', '普通'] },
      errorMessage: '重要度必须为：核心、重要、普通',
    },
    // 主角所在地点关联验证
    {
      id: 'player_location_relation',
      name: '主角地点关联',
      description: '主角所在地点必须存在于世界地图点表',
      enabled: false,
      builtin: true,
      intercept: false,
      targetTable: '主角信息',
      targetColumn: '所在地点',
      ruleType: 'relation',
      config: { refTable: '世界地图点', refColumn: '详细地点' },
      errorMessage: '所在地点必须是世界地图点表中已存在的详细地点',
    },
    // NPC所在地点关联验证
    {
      id: 'npc_location_relation',
      name: 'NPC地点关联',
      description: 'NPC所在地点必须存在于世界地图点表',
      enabled: false,
      builtin: true,
      intercept: false,
      targetTable: '重要人物表',
      targetColumn: '所在地点',
      ruleType: 'relation',
      config: { refTable: '世界地图点', refColumn: '详细地点' },
      errorMessage: '所在地点必须是世界地图点表中已存在的详细地点',
    },
    // 地图元素所在地点关联验证（只允许详细地点，与表格模板保持一致）
    {
      id: 'element_location_relation',
      name: '元素地点关联',
      description: '元素所在地点必须存在于世界地图点表的详细地点',
      enabled: false,
      builtin: true,
      intercept: false,
      targetTable: '地图元素表',
      targetColumn: '所在地点',
      ruleType: 'relation',
      config: { refTable: '世界地图点', refColumn: '详细地点' },
      errorMessage: '所在地点必须是世界地图点表中已存在的详细地点',
    },
    // 全局数据表当前详细地点关联验证
    {
      id: 'global_detail_location_relation',
      name: '全局详细地点关联',
      description: '当前详细地点必须存在于世界地图点表',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '全局数据表',
      targetColumn: '当前详细地点',
      ruleType: 'relation',
      config: { refTable: '世界地图点', refColumn: '详细地点' },
      errorMessage: '当前详细地点必须是世界地图点表中已存在的详细地点',
    },
    // 主角信息表 - 基本属性（键值对，数值型）
    {
      id: 'player_base_attributes_keyvalue',
      name: '主角基本属性',
      description: '基本属性必须为键值对格式，数值范围[0,100]',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '主角信息',
      targetColumn: '基础属性',
      ruleType: 'keyValue',
      config: { valueType: 'numeric', valueMin: 0, valueMax: 100 },
      errorMessage: '基础属性格式必须为"属性名:数值;属性名:数值"，数值范围[0,100]',
    },
    // 主角信息表 - 特有属性（键值对，数值型）
    {
      id: 'player_special_attributes_keyvalue',
      name: '主角特有属性',
      description: '特有属性必须为键值对格式，数值范围[0,100]',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '主角信息',
      targetColumn: '特有属性',
      ruleType: 'keyValue',
      config: { valueType: 'numeric', valueMin: 0, valueMax: 100 },
      errorMessage: '特有属性格式必须为"属性名:数值;属性名:数值"，数值范围[0,100]',
    },
    // 主角信息表 - 人际关系（键值对，文本型）
    {
      id: 'player_relationships_keyvalue',
      name: '主角人际关系',
      description: '人际关系必须为键值对格式',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '主角信息',
      targetColumn: '人际关系',
      ruleType: 'keyValue',
      config: { valueType: 'text' },
      errorMessage: '人际关系格式必须为"角色名:关系词;角色名:关系词"',
    },
    // 重要人物表 - 基本属性（键值对，数值型）
    {
      id: 'npc_base_attributes_keyvalue',
      name: 'NPC基本属性',
      description: '基本属性必须为键值对格式，数值范围[0,100]',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '重要人物表',
      targetColumn: '基础属性',
      ruleType: 'keyValue',
      config: { valueType: 'numeric', valueMin: 0, valueMax: 100 },
      errorMessage: '基础属性格式必须为"属性名:数值;属性名:数值"，数值范围[0,100]',
    },
    // 重要人物表 - 特有属性（键值对，数值型）
    {
      id: 'npc_special_attributes_keyvalue',
      name: 'NPC特有属性',
      description: '特有属性必须为键值对格式，数值范围[0,100]',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '重要人物表',
      targetColumn: '特有属性',
      ruleType: 'keyValue',
      config: { valueType: 'numeric', valueMin: 0, valueMax: 100 },
      errorMessage: '特有属性格式必须为"属性名:数值;属性名:数值"，数值范围[0,100]',
    },
    // 重要人物表 - 人际关系（键值对，文本型）
    {
      id: 'npc_relationships_keyvalue',
      name: 'NPC人际关系',
      description: '人际关系必须为键值对格式',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '重要人物表',
      targetColumn: '人际关系',
      ruleType: 'keyValue',
      config: { valueType: 'text' },
      errorMessage: '人际关系格式必须为"角色名:关系词;角色名:关系词"',
    },
    // 选项表行数限制（有且仅有一行）
    {
      id: 'option_table_single_row',
      name: '选项表单行限制',
      description: '选项表必须有且仅有一行数据',
      enabled: true,
      builtin: true,
      intercept: false,
      targetTable: '选项表',
      targetColumn: null,
      ruleType: 'rowLimit',
      config: { min: 0, max: 1 },
      errorMessage: '选项表必须有且仅有一行数据',
    },
  ];

  // ========================================
  // BlacklistManager - 黑名单管理器（用于过滤MVU变量和表格列）
  // ========================================
  const STORAGE_KEY_BLACKLIST = 'acu_filter_blacklist_v1';
  const STORAGE_KEY_BLACKLIST_VERSION = 'acu_filter_blacklist_version';
  const DEFAULT_BLACKLIST = [
    '时间',
    '地点',
    '备忘',
    '总结',
    '日期',
    '选项',
    '任务',
    '纪要',
    '服装',
    '头像',
    '进度',
    '编码',
    '上限',
    '经验值',
    '消耗',
    '数量',
    '等级',
    '位置',
    'ID',
    '编号',
    '三围',
    'measurements',
    'ages',
    '年龄',
    'order',
    '号码',
    'time',
    'cost',
    'chapter',
    'location',
    'calendar',
    'day',
    'year',
    'month',
  ];

  const BlacklistManager = {
    // 获取当前黑名单数组（自动检测并更新版本）
    getBlacklist() {
      const stored = Store.get(STORAGE_KEY_BLACKLIST, null);
      const storedVersion = Store.get(STORAGE_KEY_BLACKLIST_VERSION, null);

      // 如果存储不存在或不是数组，返回默认值
      if (!stored || !Array.isArray(stored)) {
        // 初始化时保存默认值和版本号
        Store.set(STORAGE_KEY_BLACKLIST, [...DEFAULT_BLACKLIST]);
        Store.set(STORAGE_KEY_BLACKLIST_VERSION, PRESET_FORMAT_VERSION);
        return [...DEFAULT_BLACKLIST];
      }

      // 检测版本并自动更新
      if (!storedVersion || compareVersion(storedVersion, PRESET_FORMAT_VERSION) < 0) {
        console.log(`[DICE]BlacklistManager 检测到黑名单版本较旧 (${storedVersion || '无版本'})，自动合并新版本`);

        // 合并逻辑：保留用户自定义项，添加新的默认项
        const userItems = new Set(stored);
        const defaultItems = new Set(DEFAULT_BLACKLIST);
        const mergedItems = [...DEFAULT_BLACKLIST]; // 先添加所有默认项

        // 添加用户自定义项（不在默认列表中的项）
        stored.forEach(item => {
          if (!defaultItems.has(item)) {
            mergedItems.push(item);
          }
        });

        // 保存更新后的黑名单和版本号
        Store.set(STORAGE_KEY_BLACKLIST, mergedItems);
        Store.set(STORAGE_KEY_BLACKLIST_VERSION, PRESET_FORMAT_VERSION);
        return mergedItems;
      }

      return stored;
    },

    // 设置黑名单
    setBlacklist(list) {
      if (!Array.isArray(list)) {
        console.warn('[DICE]BlacklistManager 设置失败：必须是数组');
        return false;
      }
      Store.set(STORAGE_KEY_BLACKLIST, list);
      Store.set(STORAGE_KEY_BLACKLIST_VERSION, PRESET_FORMAT_VERSION);
      return true;
    },

    // 重置为默认值
    resetToDefault() {
      Store.set(STORAGE_KEY_BLACKLIST, [...DEFAULT_BLACKLIST]);
      Store.set(STORAGE_KEY_BLACKLIST_VERSION, PRESET_FORMAT_VERSION);
      return true;
    },

    // 检查key是否在黑名单中（智能匹配最下一层）
    // 对于路径 "场景 > 人物状态 > 圆 > 服装部件"，只匹配最后一级 "服装部件"
    isBlacklisted(key) {
      if (!key || typeof key !== 'string') return false;
      const blacklist = this.getBlacklist();
      if (blacklist.length === 0) return false;

      // 如果key包含分隔符（如 ">" 或 " > "），提取最后一部分
      const parts = key
        .split(/>| > /)
        .map(s => s.trim())
        .filter(s => s);
      const lastPart = parts.length > 0 ? parts[parts.length - 1] : key;

      // 检查最后一级key是否包含黑名单中的任何词
      return blacklist.some(item => lastPart.includes(item));
    },
  };

  // ========================================
  // PresetManager - 验证规则预设管理
  // ========================================
  const STORAGE_KEY_PRESETS = 'acu_validation_presets_v1';
  const STORAGE_KEY_ACTIVE_PRESET = 'acu_active_preset_id';

  const PresetManager = {
    _cache: null,

    // 获取所有预设（自动检测并更新版本）
    getAllPresets() {
      const stored = Store.get(STORAGE_KEY_PRESETS, null);
      if (!stored) {
        this._initDefaultPreset();
        return this._cache;
      }

      let needsSave = false;
      stored.forEach(preset => {
        if (!preset.version || this._compareVersion(preset.version, PRESET_FORMAT_VERSION) < 0) {
          console.log(
            `[DICE]PresetManager 检测到预设 "${preset.name}" 版本较旧 (${preset.version || '无版本'})，自动更新`,
          );

          if (preset.id === 'default') {
            // 默认预设：强制替换内置规则，只保留用户自定义规则和开关状态
            const customRules = preset.rules.filter(r => !r.builtin);
            // 创建现有内置规则的开关状态映射
            const existingBuiltinMap = new Map();
            preset.rules
              .filter(r => r.builtin)
              .forEach(r => {
                const key = r.id || r.targetTable + '_' + r.ruleType;
                existingBuiltinMap.set(key, { enabled: r.enabled, intercept: r.intercept });
              });
            // 替换内置规则，保留用户的开关设置
            preset.rules = [
              ...BUILTIN_VALIDATION_RULES.map(r => {
                const key = r.id || r.targetTable + '_' + r.ruleType;
                const existing = existingBuiltinMap.get(key);
                return {
                  ...r,
                  builtin: true,
                  ...(existing ? { enabled: existing.enabled, intercept: existing.intercept } : {}),
                };
              }),
              ...customRules,
            ];
          } else {
            // 用户预设：智能合并（保留用户对内置规则的修改）
            this._mergeBuiltinRules(preset);
          }

          preset.version = PRESET_FORMAT_VERSION;
          needsSave = true;
        }
      });

      if (needsSave) {
        this._save(stored);
        ValidationRuleManager.clearCache();
        this._cache = null;
      }

      if (!needsSave && this._cache) {
        return this._cache;
      }
      this._cache = stored;
      return stored;
    },

    // 获取当前激活的预设
    getActivePreset() {
      const presets = this.getAllPresets();
      const activeId = Store.get(STORAGE_KEY_ACTIVE_PRESET, 'default');
      return presets.find(p => p.id === activeId) || presets[0];
    },

    // 设置激活预设
    setActivePreset(id) {
      if (!this.getAllPresets().find(p => p.id === id)) return false;
      Store.set(STORAGE_KEY_ACTIVE_PRESET, id);
      ValidationRuleManager.clearCache();
      console.log('[DICE]PresetManager 切换预设:', id);
      return true;
    },

    // 创建新预设
    createPreset(name) {
      const presets = this.getAllPresets();
      const newPreset = {
        id: 'preset_' + Date.now(),
        name: name || '新预设',
        builtin: false,
        rules: [],
        version: PRESET_FORMAT_VERSION,
        createdAt: new Date().toISOString(),
      };
      presets.push(newPreset);
      this._save(presets);
      return newPreset;
    },

    // 复制预设
    duplicatePreset(id) {
      const source = this.getAllPresets().find(p => p.id === id);
      if (!source) return null;
      const presets = this.getAllPresets();
      const newPreset = {
        id: 'preset_' + Date.now(),
        name: source.name + ' (副本)',
        builtin: false,
        rules: JSON.parse(JSON.stringify(source.rules)),
        version: source.version || PRESET_FORMAT_VERSION,
        createdAt: new Date().toISOString(),
      };
      presets.push(newPreset);
      this._save(presets);
      console.log('[DICE]PresetManager 复制预设:', source.name, '->', newPreset.name);
      return newPreset;
    },

    // 删除预设（只保护 id='default' 的默认预设）
    deletePreset(id) {
      const presets = this.getAllPresets();
      const preset = presets.find(p => p.id === id);
      if (!preset || preset.id === 'default') return false; // 只保护默认预设
      const filtered = presets.filter(p => p.id !== id);
      this._save(filtered);
      if (Store.get(STORAGE_KEY_ACTIVE_PRESET) === id) {
        Store.set(STORAGE_KEY_ACTIVE_PRESET, 'default');
        ValidationRuleManager.clearCache();
      }
      console.log('[DICE]PresetManager 删除预设:', id);
      return true;
    },

    // 更新预设规则
    updatePresetRules(id, rules) {
      const presets = this.getAllPresets();
      const preset = presets.find(p => p.id === id);
      if (!preset) return false;
      preset.rules = rules;
      this._save(presets);
      ValidationRuleManager.clearCache();
      return true;
    },

    // 导出预设
    exportPreset(id) {
      const preset = this.getAllPresets().find(p => p.id === id);
      if (!preset) return null;
      const json = JSON.stringify(
        {
          format: 'acu_preset_v1',
          version: PRESET_FORMAT_VERSION,
          preset: { name: preset.name, rules: preset.rules },
        },
        null,
        2,
      );
      return json;
    },

    // 比较版本号（使用全局函数）
    _compareVersion(v1, v2) {
      return compareVersion(v1, v2);
    },

    // 合并预设与默认值（智能合并：保留用户自定义，添加新规则，更新默认值）
    mergePresetWithDefaults(presetId) {
      const presets = this.getAllPresets();
      const preset = presets.find(p => p.id === presetId);
      if (!preset) return false;

      // 分离内置规则和用户自定义规则
      const customRules = preset.rules.filter(r => !r.builtin);
      const builtinRuleIds = new Set(BUILTIN_VALIDATION_RULES.map(r => r.id || r.targetTable + '_' + r.ruleType));

      // 创建内置规则映射（用于检测用户是否修改过）
      const builtinRuleMap = new Map();
      BUILTIN_VALIDATION_RULES.forEach(r => {
        const key = r.id || r.targetTable + '_' + r.ruleType;
        builtinRuleMap.set(key, r);
      });

      // 合并规则：保留用户自定义，添加新规则，更新未修改的默认值
      const mergedRules = [];
      const processedCustomIds = new Set();

      // 1. 添加所有内置规则（如果用户未修改，使用新版本；如果修改过，保留用户版本）
      BUILTIN_VALIDATION_RULES.forEach(newRule => {
        const key = newRule.id || newRule.targetTable + '_' + newRule.ruleType;
        const existingRule = preset.rules.find(r => (r.id || r.targetTable + '_' + r.ruleType) === key && r.builtin);
        if (existingRule) {
          // 检查用户是否修改过（简单比较：如果规则内容完全相同，认为未修改）
          const isModified = JSON.stringify(existingRule) !== JSON.stringify(newRule);
          if (isModified) {
            // 用户修改过，保留用户版本但标记为内置（以便后续更新）
            mergedRules.push({ ...existingRule, builtin: true });
          } else {
            // 未修改，使用新版本
            mergedRules.push({ ...newRule, builtin: true });
          }
        } else {
          // 新规则，直接添加
          mergedRules.push({ ...newRule, builtin: true });
        }
        processedCustomIds.add(key);
      });

      // 2. 添加用户自定义规则（不属于内置规则的）
      customRules.forEach(rule => {
        const key = rule.id || rule.targetTable + '_' + rule.ruleType;
        if (!builtinRuleIds.has(key)) {
          mergedRules.push({ ...rule, builtin: false });
        }
      });

      preset.rules = mergedRules;
      preset.version = PRESET_FORMAT_VERSION;
      this._save(presets);
      ValidationRuleManager.clearCache();
      console.log('[DICE]PresetManager 合并预设:', preset.name);
      return true;
    },

    // 导入预设
    importPreset(json, autoMerge = false) {
      try {
        const data = JSON.parse(json);
        if (data.format !== 'acu_preset_v1' || !data.preset) return null;

        const importedVersion = data.version || '0.0.0';
        const needsMerge = this._compareVersion(importedVersion, PRESET_FORMAT_VERSION) < 0;

        const presets = this.getAllPresets();
        const newPreset = {
          id: 'imported_' + Date.now(),
          name: data.preset.name || '导入的预设',
          builtin: false,
          rules: data.preset.rules || [],
          version: importedVersion,
          createdAt: new Date().toISOString(),
        };

        // 如果版本较旧且允许自动合并，则合并
        if (needsMerge && autoMerge) {
          presets.push(newPreset);
          this._save(presets);
          this.mergePresetWithDefaults(newPreset.id);
          console.log('[DICE]PresetManager 导入并合并预设:', newPreset.name);
        } else {
          presets.push(newPreset);
          this._save(presets);
          console.log('[DICE]PresetManager 导入预设:', newPreset.name);
          if (needsMerge) {
            console.warn('[DICE]PresetManager 预设版本较旧，建议使用 mergePresetWithDefaults 方法合并新版本的默认值');
          }
        }

        return { preset: newPreset, needsMerge: needsMerge && !autoMerge };
      } catch (e) {
        console.error('[DICE]PresetManager 导入失败:', e);
        return null;
      }
    },

    // 初始化默认预设
    _initDefaultPreset() {
      const stored = Store.get(STORAGE_KEY_PRESETS, null);

      // 如果已有存储数据，直接使用（版本更新逻辑在 getAllPresets 中处理）
      if (stored && Array.isArray(stored)) {
        this._cache = stored;
        return;
      }

      // 首次初始化：创建默认预设
      const defaultPreset = {
        id: 'default',
        name: '默认预设',
        builtin: true,
        rules: BUILTIN_VALIDATION_RULES.map(r => ({ ...r })),
        version: PRESET_FORMAT_VERSION,
        createdAt: new Date().toISOString(),
      };

      // 迁移旧版自定义规则
      const oldCustom = Store.get(STORAGE_KEY_VALIDATION_RULES, []);
      if (oldCustom.length > 0) {
        defaultPreset.rules.push(...oldCustom.map(r => ({ ...r, builtin: false })));
        console.log('[DICE]PresetManager 迁移旧规则:', oldCustom.length, '条');
      }

      this._cache = [defaultPreset];
      this._save(this._cache);
      Store.set(STORAGE_KEY_ACTIVE_PRESET, 'default');
    },

    // 恢复默认预设的规则
    resetDefaultPreset() {
      const presets = this.getAllPresets();
      const defaultPreset = presets.find(p => p.id === 'default');
      if (defaultPreset) {
        // 保留自定义规则（非内置规则）
        const customRules = defaultPreset.rules.filter(r => !r.builtin);
        defaultPreset.rules = [...BUILTIN_VALIDATION_RULES.map(r => ({ ...r })), ...customRules];
        defaultPreset.version = PRESET_FORMAT_VERSION;
        this._save(presets);
        ValidationRuleManager.clearCache();
        return true;
      }
      return false;
    },

    // 智能合并内置规则（用于非默认预设）
    _mergeBuiltinRules(preset) {
      const customRules = preset.rules.filter(r => !r.builtin);
      const builtinRuleIds = new Set(BUILTIN_VALIDATION_RULES.map(r => r.id || r.targetTable + '_' + r.ruleType));

      // 创建现有内置规则映射
      const existingBuiltinMap = new Map();
      preset.rules
        .filter(r => r.builtin)
        .forEach(r => {
          const key = r.id || r.targetTable + '_' + r.ruleType;
          existingBuiltinMap.set(key, r);
        });

      const mergedRules = [];

      // 处理内置规则：新增的用新版本，已有的保留用户修改
      BUILTIN_VALIDATION_RULES.forEach(newRule => {
        const key = newRule.id || newRule.targetTable + '_' + newRule.ruleType;
        const existing = existingBuiltinMap.get(key);
        if (existing) {
          // 保留用户的启用状态、拦截设置和错误消息，但更新规则定义
          mergedRules.push({
            ...newRule,
            enabled: existing.enabled,
            intercept: existing.intercept,
            errorMessage: existing.errorMessage,
            builtin: true,
          });
        } else {
          mergedRules.push({ ...newRule, builtin: true });
        }
      });

      // 添加用户自定义规则（排除与内置规则ID冲突的）
      customRules.forEach(rule => {
        const key = rule.id || rule.targetTable + '_' + rule.ruleType;
        if (!builtinRuleIds.has(key)) {
          mergedRules.push({ ...rule, builtin: false });
        }
      });

      preset.rules = mergedRules;
    },

    _save(presets) {
      Store.set(STORAGE_KEY_PRESETS, presets);
      this._cache = presets;
    },

    clearCache() {
      this._cache = null;
    },
  };

  // 验证规则管理器（从 PresetManager 获取规则）
  const ValidationRuleManager = {
    _cache: null,
    _enabledCache: null,

    // 获取所有规则（从当前激活预设）
    getAllRules() {
      if (this._cache) return this._cache;

      const preset = PresetManager.getActivePreset();
      const enabledStates = this.getEnabledStates();

      // 应用启用状态
      const allRules = (preset?.rules || []).map(rule => ({
        ...rule,
        enabled: enabledStates[rule.id] !== undefined ? enabledStates[rule.id] : rule.enabled,
      }));

      this._cache = allRules;
      return allRules;
    },

    // 获取启用状态映射
    getEnabledStates() {
      if (this._enabledCache) return this._enabledCache;
      this._enabledCache = Store.get(STORAGE_KEY_VALIDATION_ENABLED, {});
      return this._enabledCache;
    },

    // 切换规则启用状态
    toggleRuleEnabled(ruleId, enabled) {
      const states = this.getEnabledStates();
      states[ruleId] = enabled;
      Store.set(STORAGE_KEY_VALIDATION_ENABLED, states);
      this._enabledCache = states;
      this._cache = null; // 清除缓存以便下次重新计算
    },

    // 切换规则拦截状态
    toggleRuleIntercept(ruleId, intercept) {
      const preset = PresetManager.getActivePreset();
      if (!preset) return false;

      const rule = preset.rules.find(r => r.id === ruleId);
      if (!rule) return false;

      rule.intercept = intercept;
      PresetManager.updatePresetRules(preset.id, preset.rules);
      return true;
    },

    // 获取启用的规则
    getEnabledRules() {
      return this.getAllRules().filter(rule => rule.enabled);
    },

    // 添加自定义规则（到当前激活预设）
    addCustomRule(rule) {
      if (!rule.id || !rule.name || !rule.targetTable) {
        console.error('[DICE]ValidationRuleManager 规则缺少必要字段');
        return false;
      }

      const preset = PresetManager.getActivePreset();
      if (!preset) return false;

      // 检查 ID 是否重复
      if (preset.rules.some(r => r.id === rule.id)) {
        console.error('[DICE]ValidationRuleManager 规则 ID 已存在:', rule.id);
        return false;
      }

      const newRule = { ...rule, builtin: false, enabled: true };
      preset.rules.push(newRule);
      PresetManager.updatePresetRules(preset.id, preset.rules);
      console.log('[DICE]ValidationRuleManager 添加规则:', newRule.name);
      return true;
    },

    // 删除规则
    removeCustomRule(ruleId) {
      const preset = PresetManager.getActivePreset();
      if (!preset) return false;

      const index = preset.rules.findIndex(r => r.id === ruleId);
      if (index === -1) return false;

      preset.rules.splice(index, 1);
      PresetManager.updatePresetRules(preset.id, preset.rules);

      // 清理启用状态
      const states = this.getEnabledStates();
      delete states[ruleId];
      Store.set(STORAGE_KEY_VALIDATION_ENABLED, states);
      this._enabledCache = states;

      console.log('[DICE]ValidationRuleManager 删除规则:', ruleId);
      return true;
    },

    // 更新规则
    updateCustomRule(ruleId, updates) {
      const preset = PresetManager.getActivePreset();
      if (!preset) return false;

      const index = preset.rules.findIndex(r => r.id === ruleId);
      if (index === -1) return false;

      preset.rules[index] = { ...preset.rules[index], ...updates, id: ruleId };
      PresetManager.updatePresetRules(preset.id, preset.rules);
      return true;
    },

    // 获取单个规则
    getRule(ruleId) {
      return this.getAllRules().find(r => r.id === ruleId);
    },

    // 清除缓存
    clearCache() {
      this._cache = null;
      this._enabledCache = null;
    },

    // 获取按表名分组的规则
    getRulesByTable(tableName) {
      return this.getEnabledRules().filter(
        rule => rule.targetTable === tableName || (isNpcTableName(rule.targetTable) && isNpcTableName(tableName)),
      );
    },
  };

  // ========================================
  // RegexTransformationManager - 正则转换规则管理器 (Phase 1.2)
  // ========================================
  const RegexTransformationManager = {
    _cache: null,
    _enabledCache: null,

    // 生成唯一ID
    _generateId() {
      return `regex_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },

    // 获取所有规则
    getAllRules() {
      if (this._cache) return this._cache;

      const rules = Store.get(STORAGE_KEY_REGEX_RULES, []);
      // 直接使用规则中存储的 enabled 状态，不再从全局 enabledStates 覆盖
      // 这确保了每个预设的开关状态是独立的
      this._cache = rules;
      return rules;
    },

    // 获取启用状态映射
    getEnabledStates() {
      if (this._enabledCache) return this._enabledCache;
      this._enabledCache = Store.get(STORAGE_KEY_REGEX_ENABLED, {});
      return this._enabledCache;
    },

    // 保存启用状态
    _saveEnabledStates(states) {
      Store.set(STORAGE_KEY_REGEX_ENABLED, states);
      this._enabledCache = states;
    },

    // 获取启用的规则
    getEnabledRules() {
      return this.getAllRules().filter(rule => rule.enabled !== false);
    },

    // 根据作用域获取适用的规则
    getApplicableRules(tableName, columnName) {
      const allRules = this.getEnabledRules();

      return allRules
        .filter(rule => {
          // 检查作用域是否匹配
          switch (rule.scope.type) {
            case 'global':
              return true;
            case 'table':
              return rule.scope.tableNames && rule.scope.tableNames.includes(tableName);
            case 'column':
              return (
                rule.scope.tableNames &&
                rule.scope.tableNames.includes(tableName) &&
                rule.scope.columnNames &&
                rule.scope.columnNames.includes(columnName)
              );
            default:
              return false;
          }
        })
        .sort((a, b) => b.priority - a.priority); // 按优先级降序排列
    },

    // 切换规则启用状态
    toggleRuleEnabled(ruleId, enabled) {
      // 更新 STORAGE_KEY_REGEX_RULES 中的规则状态
      const rules = Store.get(STORAGE_KEY_REGEX_RULES, []);
      const ruleIndex = rules.findIndex(r => r.id === ruleId);
      if (ruleIndex !== -1) {
        rules[ruleIndex].enabled = enabled;
        Store.set(STORAGE_KEY_REGEX_RULES, rules);
      }

      // 同时更新当前激活预设中的规则状态
      const activePreset = RegexPresetManager.getActivePreset();
      if (activePreset) {
        RegexPresetManager.updatePresetRules(activePreset.id, rules);
      }

      this.clearCache();
    },

    // 添加自定义规则
    addCustomRule(rule) {
      const rules = Store.get(STORAGE_KEY_REGEX_RULES, []);

      // 验证必填字段
      if (!rule.name || !rule.pattern || !rule.scope) {
        console.error('[DICE]RegexTransformationManager: 规则缺少必填字段');
        return false;
      }

      const newRule: RegexTransformationRule = {
        id: this._generateId(),
        name: rule.name,
        description: rule.description,
        operation: rule.operation || 'replace',
        pattern: rule.pattern,
        flags: rule.flags || {},
        replacement: rule.replacement,
        scope: rule.scope,
        enabled: rule.enabled !== undefined ? rule.enabled : true,
        priority: rule.priority || 50,
        executeMode: rule.executeMode || 'auto',
        testCases: rule.testCases || [],
        security: rule.security || { maxMatchTime: 100, maxMatches: 1000, maxInputLength: 10000 },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      rules.push(newRule);
      Store.set(STORAGE_KEY_REGEX_RULES, rules);
      this.clearCache();

      // 同步规则到当前激活预设
      this._syncRulesToActivePreset();

      return newRule;
    },

    // 同步规则到当前激活预设
    _syncRulesToActivePreset() {
      const activePreset = RegexPresetManager.getActivePreset();
      if (activePreset) {
        const allRules = Store.get(STORAGE_KEY_REGEX_RULES, []);
        RegexPresetManager.updatePresetRules(activePreset.id, allRules);
      }
    },

    // 删除规则
    removeRule(ruleId) {
      const rules = Store.get(STORAGE_KEY_REGEX_RULES, []);
      const index = rules.findIndex(r => r.id === ruleId);
      if (index === -1) return false;

      rules.splice(index, 1);
      Store.set(STORAGE_KEY_REGEX_RULES, rules);
      this.clearCache();

      // 同步规则到当前激活预设
      this._syncRulesToActivePreset();

      return true;
    },

    // 更新规则
    updateRule(ruleId, updates) {
      const rules = Store.get(STORAGE_KEY_REGEX_RULES, []);
      const index = rules.findIndex(r => r.id === ruleId);
      if (index === -1) return false;

      rules[index] = {
        ...rules[index],
        ...updates,
        id: ruleId,
        updatedAt: Date.now(),
      };
      Store.set(STORAGE_KEY_REGEX_RULES, rules);
      this.clearCache();

      // 同步规则到当前激活预设
      this._syncRulesToActivePreset();

      return true;
    },

    // 获取单个规则
    getRule(ruleId) {
      return this.getAllRules().find(r => r.id === ruleId);
    },

    // 清除缓存
    clearCache() {
      this._cache = null;
      this._enabledCache = null;
    },
  };

  // ========================================
  // RegexPresetManager - 正则转换预设管理器 (Phase 1.3)
  // ========================================
  const RegexPresetManager = {
    _cache: null,

    // 版本比较（复用全局 compareVersion）
    _compareVersion(v1, v2) {
      return compareVersion(v1, v2);
    },

    // 获取所有预设（自动检测并更新版本）
    getAllPresets() {
      const stored = Store.get(STORAGE_KEY_REGEX_PRESETS, null);

      // 首次初始化
      if (!stored || stored.length === 0) {
        const defaultPreset: RegexPreset = {
          id: 'regex_default',
          name: '默认预设',
          description: '系统默认的正则转换规则预设',
          version: PRESET_FORMAT_VERSION,
          rules: BUILTIN_REGEX_RULES.map(r => ({ ...r, builtin: true })),
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };
        this._cache = [defaultPreset];
        Store.set(STORAGE_KEY_REGEX_PRESETS, this._cache);
        return this._cache;
      }

      // 自动检测并更新版本
      let needsSave = false;
      stored.forEach(preset => {
        if (!preset.version || this._compareVersion(preset.version, PRESET_FORMAT_VERSION) < 0) {
          console.log(
            `[DICE]RegexPresetManager 检测到预设 "${preset.name}" 版本较旧 (${preset.version || '无版本'})，自动更新`,
          );

          if (preset.id === 'regex_default') {
            // 默认预设：强制替换内置规则，只保留用户自定义规则和开关状态
            const customRules = (preset.rules || []).filter(r => !r.builtin);
            // 创建现有内置规则的开关状态映射
            const existingBuiltinMap = new Map();
            (preset.rules || [])
              .filter(r => r.builtin)
              .forEach(r => {
                existingBuiltinMap.set(r.id, { enabled: r.enabled });
              });
            // 替换内置规则，保留用户的开关设置
            preset.rules = [
              ...BUILTIN_REGEX_RULES.map(r => {
                const existing = existingBuiltinMap.get(r.id);
                return {
                  ...r,
                  builtin: true,
                  ...(existing ? { enabled: existing.enabled } : {}),
                };
              }),
              ...customRules,
            ];
          } else {
            // 用户预设：智能合并
            this._mergeBuiltinRules(preset);
          }

          preset.version = PRESET_FORMAT_VERSION;
          preset.updatedAt = Date.now();
          needsSave = true;
        }
      });

      if (needsSave) {
        this._save(stored);
        RegexTransformationManager.clearCache();
        this._cache = null;
      }

      if (!needsSave && this._cache) {
        return this._cache;
      }
      this._cache = stored;
      return stored;
    },

    // 智能合并内置规则（用于非默认预设）
    _mergeBuiltinRules(preset) {
      const customRules = (preset.rules || []).filter(r => !r.builtin);
      const builtinRuleIds = new Set(BUILTIN_REGEX_RULES.map(r => r.id));

      // 创建现有内置规则映射
      const existingBuiltinMap = new Map();
      (preset.rules || [])
        .filter(r => r.builtin)
        .forEach(r => {
          existingBuiltinMap.set(r.id, r);
        });

      const mergedRules = [];

      // 处理内置规则：新增的用新版本，已有的保留用户修改
      BUILTIN_REGEX_RULES.forEach(newRule => {
        const existing = existingBuiltinMap.get(newRule.id);
        if (existing) {
          // 保留用户的启用状态，但更新规则定义
          mergedRules.push({
            ...newRule,
            enabled: existing.enabled,
            builtin: true,
          });
        } else {
          mergedRules.push({ ...newRule, builtin: true });
        }
      });

      // 添加用户自定义规则（排除与内置规则ID冲突的）
      customRules.forEach(rule => {
        if (!builtinRuleIds.has(rule.id)) {
          mergedRules.push({ ...rule, builtin: false });
        }
      });

      preset.rules = mergedRules;
    },

    // 获取当前激活的预设
    getActivePreset() {
      const activeId = Store.get(STORAGE_KEY_REGEX_ACTIVE_PRESET, 'regex_default');
      const presets = this.getAllPresets();
      const preset = presets.find(p => p.id === activeId) || presets[0];

      // 确保规则存储与当前预设同步
      // 检查预设中的内置规则是否已存在于规则存储中，如果缺失则合并
      const storedRules: RegexTransformationRule[] = Store.get(STORAGE_KEY_REGEX_RULES, []);
      if (preset && preset.rules && preset.rules.length > 0) {
        // 找出预设中标记为 builtin 但存储中缺失的规则
        const storedRuleIds = new Set(storedRules.map(r => r.id));
        const missingBuiltinRules = preset.rules.filter(r => r.builtin && !storedRuleIds.has(r.id));

        if (missingBuiltinRules.length > 0) {
          // 将缺失的内置规则添加到存储的规则列表开头
          const mergedRules = [...missingBuiltinRules, ...storedRules];
          Store.set(STORAGE_KEY_REGEX_RULES, mergedRules);
          RegexTransformationManager.clearCache();
          console.log(`[DICE]RegexPresetManager: 已合并 ${missingBuiltinRules.length} 条缺失的内置规则`);
        }
      }

      return preset;
    },

    // 设置激活预设
    setActivePreset(presetId) {
      const presets = this.getAllPresets();
      const preset = presets.find(p => p.id === presetId);
      if (!preset) {
        console.error('[DICE]RegexPresetManager: 预设不存在', presetId);
        return false;
      }

      Store.set(STORAGE_KEY_REGEX_ACTIVE_PRESET, presetId);

      // 同步预设规则到实际规则存储
      Store.set(STORAGE_KEY_REGEX_RULES, preset.rules || []);

      // 清除RegexTransformationManager的缓存
      RegexTransformationManager.clearCache();

      return true;
    },

    // 创建新预设
    createPreset(name, sourcePresetId) {
      const presets = this.getAllPresets();

      // 验证名称不重复
      if (presets.some(p => p.name === name)) {
        console.error('[DICE]RegexPresetManager: 预设名称已存在', name);
        return false;
      }

      const sourcePreset = sourcePresetId ? presets.find(p => p.id === sourcePresetId) : this.getActivePreset();

      const newPreset: RegexPreset = {
        id: `regex_preset_${Date.now()}`,
        name: name,
        description: sourcePreset?.description,
        version: PRESET_FORMAT_VERSION,
        rules: sourcePreset ? JSON.parse(JSON.stringify(sourcePreset.rules)) : [],
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      presets.push(newPreset);
      this._save(presets);
      return newPreset;
    },

    // 更新预设规则
    updatePresetRules(presetId, rules) {
      const presets = this.getAllPresets();
      const index = presets.findIndex(p => p.id === presetId);
      if (index === -1) return false;

      presets[index].rules = JSON.parse(JSON.stringify(rules));
      presets[index].updatedAt = Date.now();

      this._save(presets);

      // 如果更新的是当前激活预设,清除规则缓存
      if (presetId === Store.get(STORAGE_KEY_REGEX_ACTIVE_PRESET)) {
        RegexTransformationManager.clearCache();
      }

      return true;
    },

    // 删除预设
    deletePreset(presetId) {
      const presets = this.getAllPresets();

      // 不允许删除最后一个预设
      if (presets.length <= 1) {
        console.error('[DICE]RegexPresetManager: 不能删除最后一个预设');
        return false;
      }

      const index = presets.findIndex(p => p.id === presetId);
      if (index === -1) return false;

      presets.splice(index, 1);
      this._save(presets);

      // 如果删除的是当前激活预设,切换到第一个预设
      if (presetId === Store.get(STORAGE_KEY_REGEX_ACTIVE_PRESET)) {
        this.setActivePreset(presets[0].id);
      }

      return true;
    },

    // 导出预设为JSON
    exportPreset(presetId) {
      const preset = this.getAllPresets().find(p => p.id === presetId);
      if (!preset) return null;

      // 如果是当前激活预设，从实际存储读取最新规则
      const activePreset = this.getActivePreset();
      const isActivePreset = activePreset && activePreset.id === presetId;
      const rules = isActivePreset ? Store.get(STORAGE_KEY_REGEX_RULES, []) : preset.rules;

      const exportData = {
        ...preset,
        rules: rules,
      };

      return JSON.stringify(exportData, null, 2);
    },

    // 从JSON导入预设
    importPreset(jsonString) {
      try {
        const data = JSON.parse(jsonString);

        // 验证基本结构
        if (!data.name || !Array.isArray(data.rules)) {
          console.error('[DICE]RegexPresetManager: 预设格式无效');
          return false;
        }

        const presets = this.getAllPresets();

        // 生成新ID避免冲突
        const newPreset: RegexPreset = {
          id: `regex_preset_${Date.now()}`,
          name: data.name,
          description: data.description,
          version: data.version || PRESET_FORMAT_VERSION,
          rules: data.rules.map((rule: RegexTransformationRule) => ({
            ...rule,
            id: RegexTransformationManager._generateId(),
          })),
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        presets.push(newPreset);
        this._save(presets);
        return newPreset;
      } catch (e) {
        console.error('[DICE]RegexPresetManager: 导入预设失败', e);
        return false;
      }
    },

    // 保存到存储
    _save(presets) {
      Store.set(STORAGE_KEY_REGEX_PRESETS, presets);
      this._cache = presets;
    },

    // 清除缓存
    clearCache() {
      this._cache = null;
    },
  };

  // ========================================
  // RegexTransformationEngine - 正则转换引擎 (Phase 2.1)
  // ========================================
  const RegexTransformationEngine = {
    // 正则表达式缓存
    _regexCache: new Map<string, RegExp>(),

    // 构建正则标志位字符串
    _buildFlags(flags: RegexFlags): string {
      const result: string[] = [];
      if (flags.caseInsensitive) result.push('i');
      if (flags.global) result.push('g');
      if (flags.multiline) result.push('m');
      if (flags.unicode) result.push('u');
      if (flags.sticky) result.push('y');
      return result.join('');
    },

    // 获取或创建正则表达式(带缓存)
    _getRegex(pattern: string, flags: RegexFlags): RegExp | null {
      // 检测是否需要 unicode 标志（负向后顾断言和正向后顾断言需要）
      const hasLookbehind = pattern.includes('(?<') || pattern.includes('(?<=');
      const hasLookahead = pattern.includes('(?=') || pattern.includes('(?!');
      const needsUnicode = hasLookbehind || hasLookahead;

      // 如果检测到需要 unicode 标志但未设置，自动添加
      if (needsUnicode && !flags.unicode) {
        flags = { ...flags, unicode: true };
      }

      const flagsStr = this._buildFlags(flags);
      const cacheKey = `${pattern}/${flagsStr}`;

      if (this._regexCache.has(cacheKey)) {
        const regex = this._regexCache.get(cacheKey)!;
        regex.lastIndex = 0;
        return regex;
      }

      try {
        const regex = new RegExp(pattern, flagsStr);
        this._regexCache.set(cacheKey, regex);
        return regex;
      } catch (e) {
        console.error('[DICE]RegexTransformationEngine: 正则表达式错误', pattern, e);
        return null;
      }
    },

    // ReDoS防护: 评分正则复杂度
    _scoreRegexComplexity(pattern: string): number {
      let score = 0;

      // 嵌套量词 +50分
      if (/(\*|\+|\{)\1{2,}/.test(pattern)) score += 50;

      // 回溯风险 +30分
      if (/(\.\*|\.\+)[^\[]*\1/.test(pattern)) score += 30;

      // 捕获组过多 +10分
      const captureGroups = (pattern.match(/\(/g) || []).length;
      score += Math.min(captureGroups * 5, 20);

      return score;
    },

    // ReDoS防护: 获取规则的超时时间
    _getTimeoutForRule(rule: RegexTransformationRule): number {
      const complexity = this._scoreRegexComplexity(rule.pattern);
      const baseTimeout = rule.security?.maxMatchTime || 100;
      // 复杂度越高,超时时间越短
      return Math.max(baseTimeout - complexity * 2, 50);
    },

    // 安全地应用正则替换
    _safeReplace(value: string, rule: RegexTransformationRule, regex: RegExp): RegexTransformResult {
      const oldValue = value;

      // 检查输入长度
      const maxInputLength = rule.security?.maxInputLength || 10000;
      if (value.length > maxInputLength) {
        return {
          success: false,
          oldValue,
          newValue: oldValue,
          matched: false,
          error: `输入长度超过限制(${maxInputLength})`,
        };
      }

      try {
        const timeout = this._getTimeoutForRule(rule);
        const startTime = Date.now();

        // 执行替换
        let newValue: string;
        switch (rule.operation) {
          case 'replace':
            newValue = value.replace(regex, rule.replacement || '');
            break;
          case 'delete':
            newValue = value.replace(regex, '');
            break;
          case 'validate':
            const isValid = regex.test(value);
            newValue = value;
            break;
          default:
            newValue = value;
        }

        // 检查超时
        const elapsed = Date.now() - startTime;
        if (elapsed > timeout) {
          console.warn('[DICE]RegexTransformationEngine: 正则匹配超时', rule.pattern, elapsed);
          return {
            success: false,
            oldValue,
            newValue: oldValue,
            matched: false,
            error: `匹配超时(${elapsed}ms > ${timeout}ms)`,
          };
        }

        // 检查是否匹配
        const matched = oldValue !== newValue || regex.test(oldValue);

        return {
          success: true,
          oldValue,
          newValue,
          matched,
        };
      } catch (e) {
        console.error('[DICE]RegexTransformationEngine: 正则替换错误', rule.pattern, e);
        return {
          success: false,
          oldValue,
          newValue: oldValue,
          matched: false,
          error: String(e),
        };
      }
    },

    // 对单个值应用规则
    applyToValue(value: string, rule: RegexTransformationRule): RegexTransformResult {
      if (value === null || value === undefined) {
        return {
          success: true,
          oldValue: '',
          newValue: '',
          matched: false,
        };
      }

      const strValue = String(value);

      // 如果 pattern 包含内联 flags（如 /pattern/flags），先提取它们
      let pattern = rule.pattern;
      let flags = rule.flags || {};

      // 检查是否是 /pattern/flags 格式
      const extracted = this._extractFlags(pattern);
      if (extracted.patternWithoutFlags !== pattern) {
        // 如果提取成功，使用提取后的 pattern 和合并后的 flags
        pattern = extracted.patternWithoutFlags;
        flags = { ...flags, ...extracted.flags };
      }

      // 对于数据转换场景，默认使用全局替换（除非明确指定不全局）
      // 如果 flags 中没有明确设置 global，默认设为 true
      if (flags.global === undefined) {
        flags.global = true;
      }

      const regex = this._getRegex(pattern, flags);

      if (!regex) {
        return {
          success: false,
          oldValue: strValue,
          newValue: strValue,
          matched: false,
          error: '无效的正则表达式',
        };
      }

      return this._safeReplace(strValue, rule, regex);
    },

    // 从模式字符串中提取内联flags (例如: /test/g 中的 'g')
    _extractFlags(patternStr: string): { flags: RegexFlags; patternWithoutFlags: string } {
      const flags: RegexFlags = {
        global: false,
        caseInsensitive: false,
        multiline: false,
        unicode: false,
        sticky: false,
      };

      // 检查是否是 /pattern/flags 格式
      const inlineFlagMatch = patternStr.match(/^\/(.+)\/([gimuy]*)$/);
      if (inlineFlagMatch) {
        const [, patternWithoutFlags, flagStr] = inlineFlagMatch;
        if (flagStr.includes('g')) flags.global = true;
        if (flagStr.includes('i')) flags.caseInsensitive = true;
        if (flagStr.includes('m')) flags.multiline = true;
        if (flagStr.includes('u')) flags.unicode = true;
        if (flagStr.includes('y')) flags.sticky = true;
        return { flags, patternWithoutFlags };
      }

      // 否则返回原始模式和空flags
      return { flags, patternWithoutFlags: patternStr };
    },

    // 对整个表格应用规则
    applyToTable(
      tableData:
        | { name: string; headers: string[]; rows: string[][] }
        | { [key: string]: { name?: string; content?: string[][] } },
      rules: RegexTransformationRule[],
    ): { totalApplied: number; errors: string[]; modifiedSheetKeys: string[] } {
      let totalApplied = 0;
      const errors: string[] = [];
      const modifiedSheetKeys: string[] = [];

      try {
        // 兼容神数据库格式和简化格式
        let isSimpleFormat = false;
        let sheetMap: Map<
          string,
          { sheet: any; sheetKey: string; name: string; headers: string[]; contentRowIndex: number }
        > = new Map();

        if ('name' in tableData && 'headers' in tableData && 'rows' in tableData) {
          // 简化格式: { name, headers, rows }
          isSimpleFormat = true;
          const simpleTable = tableData as { name: string; headers: string[]; rows: string[][] };
          sheetMap.set(simpleTable.name, {
            sheet: simpleTable,
            sheetKey: simpleTable.name,
            name: simpleTable.name,
            headers: simpleTable.headers,
            contentRowIndex: -1, // 简化格式不使用 contentRowIndex
          });
        } else {
          // 神数据库格式: { sheet_xxx: { name, content: [headers, ...rows] } }
          const dataObj = tableData as { [key: string]: { name?: string; content?: string[][] } };

          Object.keys(dataObj).forEach(sheetKey => {
            if (!sheetKey.startsWith('sheet_')) return;

            const sheet = dataObj[sheetKey];
            if (!sheet || !sheet.content || !Array.isArray(sheet.content) || sheet.content.length < 1) {
              console.warn(`[DICE]applyToTable: 跳过无效表格 ${sheetKey}`);
              return;
            }

            const tableName = sheet.name || sheetKey;
            sheetMap.set(tableName, {
              sheet,
              sheetKey,
              name: tableName,
              headers: sheet.content[0] || [],
              contentRowIndex: 0, // 表头在 content[0]
            });
          });
        }

        if (sheetMap.size === 0) {
          console.warn('[DICE]applyToTable: 没有有效的表格数据');
          return { totalApplied: 0, errors: ['没有有效的表格数据'], modifiedSheetKeys: [] };
        }

        // 对每个表格应用规则
        for (const [tableName, tableInfo] of sheetMap.entries()) {
          const { sheet, headers, sheetKey } = tableInfo;
          let tableModified = false;

          for (const rule of rules) {
            if (!rule.enabled) continue;

            // 获取规则作用域
            const scope = rule.scope;
            const shouldProcessTable = scope.type === 'global' || scope.tableNames?.includes(tableName);

            if (!shouldProcessTable) continue;

            try {
              // 处理每一行
              if (isSimpleFormat) {
                // 简化格式：直接修改 rows
                const rows = (sheet as { rows: string[][] }).rows;
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                  const row = rows[rowIndex];

                  // 处理每个单元格
                  for (let colIndex = 0; colIndex < row.length; colIndex++) {
                    const columnName = headers[colIndex];

                    // 检查列级作用域
                    if (scope.type === 'column') {
                      if (!scope.columnNames?.includes(columnName)) continue;
                    }

                    // 应用规则
                    const result = this.applyToValue(row[colIndex], rule);
                    if (result.success) {
                      if (result.matched) {
                        row[colIndex] = result.newValue;
                        totalApplied++;
                        tableModified = true;
                      }
                    } else {
                      errors.push(`${rule.name} [${tableName}]: ${result.error}`);
                    }
                  }
                }
              } else {
                // 神数据库格式：直接修改 content 数组（跳过表头，从 content[1] 开始）
                const content = sheet.content;
                for (let contentRowIndex = 1; contentRowIndex < content.length; contentRowIndex++) {
                  const row = content[contentRowIndex];
                  if (!Array.isArray(row)) continue;

                  // 处理每个单元格
                  for (let colIndex = 0; colIndex < row.length; colIndex++) {
                    const columnName = headers[colIndex];

                    // 检查列级作用域
                    if (scope.type === 'column') {
                      if (!scope.columnNames?.includes(columnName)) continue;
                    }

                    // 应用规则
                    const oldValue = row[colIndex];
                    const result = this.applyToValue(oldValue, rule);

                    if (result.success) {
                      if (result.matched) {
                        row[colIndex] = result.newValue;
                        totalApplied++;
                        tableModified = true;
                        console.debug(
                          `[DICE]正则转换: ${tableName}[${contentRowIndex}].${columnName}`,
                          `"${result.oldValue}" -> "${result.newValue}"`,
                        );
                      }
                    } else {
                      errors.push(`${rule.name} [${tableName}]: ${result.error}`);
                    }
                  }
                }
              }
            } catch (tableError) {
              const errorMsg = tableError instanceof Error ? tableError.message : String(tableError);
              console.error(`[DICE]applyToTable: 处理表格 ${tableName} 时出错:`, tableError);
              errors.push(`${rule.name} [${tableName}]: 处理表格时出错 - ${errorMsg}`);
            }
          }
          if (tableModified && sheetKey) {
            modifiedSheetKeys.push(sheetKey);
          }
        }

        if (totalApplied > 0) {
          console.info(`[DICE]applyToTable: 成功应用 ${totalApplied} 处转换`);
        }
        if (errors.length > 0) {
          console.warn(`[DICE]applyToTable: 遇到 ${errors.length} 个错误`);
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : String(e);
        console.error('[DICE]applyToTable: 执行失败:', e);
        errors.push(`执行失败: ${errorMsg}`);
      }

      return { totalApplied, errors, modifiedSheetKeys };
    },

    // 对单元格应用规则
    applyToCell(
      value: string,
      tableName: string,
      columnName: string,
      executeMode?: RegexExecutionMode,
    ): RegexTransformResult {
      // 获取适用的规则
      const rules = RegexTransformationManager.getApplicableRules(tableName, columnName);

      // 如果没有规则,直接返回
      if (rules.length === 0) {
        return {
          success: true,
          oldValue: value || '',
          newValue: value || '',
          matched: false,
        };
      }

      // 过滤执行模式
      let applicableRules = rules;
      if (executeMode) {
        applicableRules = rules.filter(r => r.executeMode === executeMode || r.executeMode === 'auto');
      }

      if (applicableRules.length === 0) {
        return {
          success: true,
          oldValue: value || '',
          newValue: value || '',
          matched: false,
        };
      }

      // 依次应用规则
      let currentValue = value || '';
      let wasMatched = false;

      for (const rule of applicableRules) {
        const result = this.applyToValue(currentValue, rule);
        if (!result.success) {
          return result;
        }
        if (result.matched) {
          wasMatched = true;
        }
        currentValue = result.newValue;
      }

      return {
        success: true,
        oldValue: value || '',
        newValue: currentValue,
        matched: wasMatched,
      };
    },

    // 对行数据应用规则
    applyToRow(row: string[], headers: string[], tableName: string, executeMode?: RegexExecutionMode): string[] {
      return row.map((cell, index) => {
        const columnName = headers[index];
        const result = this.applyToCell(cell, tableName, columnName, executeMode);
        return result.newValue;
      });
    },

    // 预览批量转换结果
    previewBatchTransform(
      tableData: { name: string; headers: string[]; rows: string[][] },
      executeMode?: RegexExecutionMode,
    ): RegexPreviewResult[] {
      const tableName = tableData.name;
      const rules = RegexTransformationManager.getApplicableRules(tableName, null).filter(
        r => r.scope.type === 'global' || r.scope.tableNames?.includes(tableName),
      );

      const results: RegexPreviewResult[] = [];

      for (const rule of rules) {
        const affectedCells: RegexPreviewResult['affectedCells'] = [];
        let totalAffected = 0;

        for (let rowIndex = 0; rowIndex < tableData.rows.length; rowIndex++) {
          const row = tableData.rows[rowIndex];
          for (let colIndex = 0; colIndex < row.length; colIndex++) {
            const columnName = tableData.headers[colIndex];
            const value = row[colIndex];

            // 检查作用域
            if (rule.scope.type === 'column') {
              if (!rule.scope.columnNames?.includes(columnName) || !rule.scope.tableNames?.includes(tableName)) {
                continue;
              }
            } else if (rule.scope.type === 'table') {
              if (!rule.scope.tableNames?.includes(tableName)) {
                continue;
              }
            }

            const result = this.applyToValue(value, rule);
            if (result.matched && result.oldValue !== result.newValue) {
              affectedCells.push({
                tableName,
                rowIndex,
                columnIndex: colIndex,
                columnName,
                oldValue: result.oldValue,
                newValue: result.newValue,
              });
              totalAffected++;
            }
          }
        }

        if (totalAffected > 0) {
          results.push({
            rule,
            affectedCells,
            totalAffected,
          });
        }
      }

      return results;
    },

    // 清除正则缓存
    clearRegexCache() {
      this._regexCache.clear();
    },
  };

  // ========================================
  // ValidationEngine - 数据验证引擎
  // ========================================
  const ValidationEngine = {
    // 查找列索引（支持精确匹配和模糊 fallback）
    // 先精确匹配，找不到时 fallback 到"列名包含目标列名"的模糊匹配
    findColumnIndex(headers: (string | null)[], targetColumn: string): number {
      // 1. 精确匹配
      const exactIndex = headers.indexOf(targetColumn);
      if (exactIndex !== -1) return exactIndex;

      // 2. 模糊匹配 fallback：找包含目标列名的列
      for (let i = 0; i < headers.length; i++) {
        const header = headers[i];
        if (header && header.includes(targetColumn)) {
          return i;
        }
      }

      return -1; // 未找到
    },

    // 格式验证（正则表达式）
    validateFormat(value, pattern) {
      if (value === null || value === undefined || value === '') return true; // 空值不验证
      try {
        const regex = new RegExp(pattern);
        return regex.test(String(value));
      } catch (e) {
        console.error('[DICE]ValidationEngine 正则表达式错误:', pattern, e);
        return true; // 正则错误时跳过验证
      }
    },

    // 枚举验证
    validateEnum(value, allowedValues) {
      if (value === null || value === undefined || value === '') return true; // 空值不验证
      if (!Array.isArray(allowedValues) || allowedValues.length === 0) return true;
      return allowedValues.includes(String(value));
    },

    // 数值范围验证
    validateNumeric(value, min, max) {
      if (value === null || value === undefined || value === '') return true; // 空值不验证

      // 提取数值（支持 "50/100" 或 "力量:80" 等格式）
      const strVal = String(value);
      let numVal;

      // 尝试解析百分比格式 "50%"
      if (strVal.endsWith('%')) {
        numVal = parseFloat(strVal);
      }
      // 尝试解析分数格式 "50/100"
      else if (strVal.includes('/')) {
        const parts = strVal.split('/');
        numVal = parseFloat(parts[0]);
      }
      // 尝试解析 "属性:数值" 格式
      else if (strVal.includes(':')) {
        const parts = strVal.split(':');
        numVal = parseFloat(parts[parts.length - 1]);
      }
      // 直接解析数字
      else {
        numVal = parseFloat(strVal);
      }

      if (isNaN(numVal)) return false; // 非数值验证失败

      if (min !== undefined && min !== null && numVal < min) return false;
      if (max !== undefined && max !== null && numVal > max) return false;
      return true;
    },

    // 关联验证（检查值是否存在于另一表的某列，支持多列 OR 检查）
    validateRelation(value, rawData, refTable, refColumn) {
      if (value === null || value === undefined || value === '') return true; // 空值不验证
      if (!rawData || !refTable || !refColumn) return true;

      // 查找引用表
      let refSheet = null;
      for (const sheetId in rawData) {
        if (rawData[sheetId]?.name === refTable) {
          refSheet = rawData[sheetId];
          break;
        }
      }

      if (!refSheet || !refSheet.content || refSheet.content.length < 2) {
        return true; // 引用表不存在或为空时跳过
      }

      const headers = refSheet.content[0];
      const strVal = String(value);

      // 支持 refColumn 为数组，任一列匹配即可
      const columns = Array.isArray(refColumn) ? refColumn : [refColumn];

      for (const col of columns) {
        const refColIndex = headers.indexOf(col);
        if (refColIndex === -1) continue; // 该列不存在，跳过检查下一列

        // 检查值是否存在于该引用列
        for (let i = 1; i < refSheet.content.length; i++) {
          if (String(refSheet.content[i][refColIndex] || '') === strVal) {
            return true; // 任一列匹配即通过
          }
        }
      }

      return columns.length === 0; // 空列数组返回 true，否则返回 false（所有列都未匹配）
    },

    // 必填验证
    validateRequired(value) {
      return value !== null && value !== undefined && String(value).trim() !== '';
    },

    // 键值对验证
    validateKeyValue(value, ruleConfig) {
      if (value === null || value === undefined || value === '') return true; // 空值不验证

      const valueType = ruleConfig?.valueType || 'text';
      const valueMin = ruleConfig?.valueMin;
      const valueMax = ruleConfig?.valueMax;

      // 预处理：修正中文标点符号和去除空格
      let processedValue = String(value);

      // 修正中文标点符号
      processedValue = processedValue
        .replace(/：/g, ':') // 中文冒号 → 英文冒号
        .replace(/；/g, ';') // 中文分号 → 英文分号
        .replace(/，/g, ';'); // 中文逗号 → 英文分号（键值对分隔符）

      // 去除所有空格
      processedValue = processedValue.replace(/\s+/g, '');

      // 解析键值对
      const pairs = processedValue.split(';').filter(p => p.trim());

      if (pairs.length === 0) return false; // 至少需要一个键值对

      // 验证每个键值对
      for (const pair of pairs) {
        const colonIndex = pair.indexOf(':');
        if (colonIndex === -1 || colonIndex === 0 || colonIndex === pair.length - 1) {
          return false; // 格式错误：缺少冒号或键/值为空
        }

        const key = pair.substring(0, colonIndex);
        const val = pair.substring(colonIndex + 1);

        if (!key || !val) return false; // 键或值不能为空

        // 如果是数值型，验证数值范围
        if (valueType === 'numeric') {
          // 验证值必须是纯数字（不能包含非数字字符）
          if (!/^-?\d+(\.\d+)?$/.test(val.trim())) return false; // 不是纯数字格式

          const numVal = parseFloat(val);
          if (isNaN(numVal)) return false; // 不是有效数字

          if (valueMin !== undefined && valueMin !== null && numVal < valueMin) return false;
          if (valueMax !== undefined && valueMax !== null && numVal > valueMax) return false;
        }
        // 文本型只验证格式，不验证值内容
      }

      return true;
    },

    // 表级只读验证（比较新旧数据）
    validateTableReadonly(oldContent, newContent) {
      if (!oldContent || !newContent) return true;
      return JSON.stringify(oldContent) === JSON.stringify(newContent);
    },

    // 行数限制验证
    validateRowLimit(rowCount, min, max) {
      if (min !== undefined && min !== null && rowCount < min) return false;
      if (max !== undefined && max !== null && rowCount > max) return false;
      return true;
    },

    // 序列递增验证（检查字段值是否严格递增）
    validateSequence(sheet, columnName, config) {
      if (!sheet || !sheet.content || sheet.content.length < 2) return true; // 空表或只有表头，通过验证
      if (!columnName || !config) return true;

      const headers = sheet.content[0] || [];
      const rows = sheet.content.slice(1) || [];
      const colIndex = headers.indexOf(columnName);
      if (colIndex < 0) return true; // 列不存在，跳过验证

      const prefix = config.prefix || '';
      const startFrom = config.startFrom !== undefined ? config.startFrom : 1;

      // 提取所有编码索引的数字部分
      const numbers = [];
      const allRowValues = []; // 记录所有行的原始值用于调试
      for (let i = 0; i < rows.length; i++) {
        const value = rows[i]?.[colIndex];
        allRowValues.push({ rowIndex: i, rawValue: value, type: typeof value });
        if (value === null || value === undefined || value === '') continue;

        const strValue = String(value).trim();
        if (!strValue) continue;

        // 匹配前缀+数字格式
        if (prefix) {
          const escapedPrefix = prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(`^${escapedPrefix}(\\d+)$`);
          const match = strValue.match(regex);
          if (match) {
            const num = parseInt(match[1], 10);
            if (!isNaN(num)) numbers.push({ rowIndex: i, value: strValue, num });
          }
        } else {
          // 无前缀，直接解析数字
          const num = parseInt(strValue, 10);
          if (!isNaN(num)) numbers.push({ rowIndex: i, value: strValue, num });
        }
      }

      if (numbers.length === 0) return true; // 没有有效值，通过验证

      // 按行索引排序（保持原始顺序）
      numbers.sort((a, b) => a.rowIndex - b.rowIndex);

      // 检查是否有重复值
      const numSet = new Set(numbers.map(n => n.num));
      if (numSet.size !== numbers.length) {
        return false; // 有重复值
      }

      // 检查是否从startFrom开始严格递增
      // 要求：第一行必须是startFrom，第二行必须是startFrom+1，以此类推
      for (let i = 0; i < numbers.length; i++) {
        const expectedNum = startFrom + i;
        const actualNum = numbers[i].num;
        if (actualNum !== expectedNum) {
          return false; // 发现跳号、重复或不是从startFrom开始
        }
      }

      return true;
    },

    // 检查拦截规则（用于更新拦截，检查所有启用了 intercept 的规则）
    checkTableRules(snapshot, newData, rules) {
      const violations = [];
      if (!snapshot || !newData || !rules) return violations;

      for (const rule of rules) {
        // 只检查启用了拦截的规则
        if (!rule.enabled || !rule.intercept) continue;
        const typeInfo = RULE_TYPE_INFO[rule.ruleType];
        if (!typeInfo) continue;

        // 查找目标表
        let oldSheet = null,
          newSheet = null;
        for (const sheetId in snapshot) {
          if (
            snapshot[sheetId]?.name === rule.targetTable ||
            (isNpcTableName(snapshot[sheetId]?.name) && isNpcTableName(rule.targetTable))
          ) {
            oldSheet = snapshot[sheetId];
            break;
          }
        }
        for (const sheetId in newData) {
          if (
            newData[sheetId]?.name === rule.targetTable ||
            (isNpcTableName(newData[sheetId]?.name) && isNpcTableName(rule.targetTable))
          ) {
            newSheet = newData[sheetId];
            break;
          }
        }

        // 表不存在时，对于 rowLimit 规则视为 0 行
        if (!newSheet) {
          if (rule.ruleType === 'rowLimit' && rule.config?.min && rule.config.min > 0) {
            violations.push({
              rule,
              tableName: rule.targetTable,
              message: rule.errorMessage || `表 "${rule.targetTable}" 不存在或为空 (需要至少 ${rule.config.min} 行)`,
            });
          }
          continue;
        }

        // 表级规则检查
        if (typeInfo.scope === 'table') {
          if (rule.ruleType === 'tableReadonly') {
            if (!this.validateTableReadonly(oldSheet?.content, newSheet?.content)) {
              violations.push({
                rule,
                tableName: rule.targetTable,
                message: rule.errorMessage || `表 "${rule.targetTable}" 为只读，不允许修改`,
              });
            }
          } else if (rule.ruleType === 'rowLimit') {
            const rowCount = (newSheet.content?.length || 1) - 1; // 减去表头
            if (!this.validateRowLimit(rowCount, rule.config?.min, rule.config?.max)) {
              violations.push({
                rule,
                tableName: rule.targetTable,
                message:
                  rule.errorMessage ||
                  `表 "${rule.targetTable}" 行数 ${rowCount} 超出限制 (${rule.config?.min || 0}-${rule.config?.max || '∞'})`,
              });
            }
          } else if (rule.ruleType === 'sequence' && rule.targetColumn) {
            // 序列递增验证
            if (!this.validateSequence(newSheet, rule.targetColumn, rule.config || {})) {
              violations.push({
                rule,
                tableName: rule.targetTable,
                message:
                  rule.errorMessage ||
                  `字段 "${rule.targetColumn}" 的编码索引必须从${rule.config?.prefix || ''}${String(rule.config?.startFrom || 1).padStart(4, '0')}开始严格递增，不可跳号或重复`,
              });
            }
          }
        }
        // 字段级规则检查
        else if (typeInfo.scope === 'field' && rule.targetColumn) {
          const headers = newSheet.content?.[0] || [];
          const colIndex = this.findColumnIndex(headers, rule.targetColumn);
          if (colIndex === -1) continue;

          // 检查新数据中的每一行
          for (let rowIdx = 1; rowIdx < (newSheet.content?.length || 0); rowIdx++) {
            const row = newSheet.content[rowIdx];
            const value = row?.[colIndex];
            const isValid = this.validateValue(value, rule, newData);

            if (!isValid) {
              violations.push({
                rule,
                tableName: rule.targetTable,
                rowIndex: rowIdx,
                columnName: rule.targetColumn,
                currentValue: String(value ?? ''),
                message: rule.errorMessage || `字段 "${rule.targetColumn}" 验证失败`,
              });
              // 只报告第一个违规即可触发回滚
              break;
            }
          }
        }
      }
      return violations;
    },

    // 验证单个值
    validateValue(value, rule, rawData) {
      switch (rule.ruleType) {
        case 'format':
          return this.validateFormat(value, rule.config?.pattern);
        case 'enum':
          return this.validateEnum(value, rule.config?.values);
        case 'numeric':
          return this.validateNumeric(value, rule.config?.min, rule.config?.max);
        case 'relation':
          return this.validateRelation(value, rawData, rule.config?.refTable, rule.config?.refColumn);
        case 'required':
          return this.validateRequired(value);
        case 'keyValue':
          return this.validateKeyValue(value, rule.config);
        default:
          return true;
      }
    },

    // 验证单行数据
    validateRow(row, headers, tableName, rowIndex, rules, rawData) {
      const errors = [];
      // 获取第一列的值（通常是名称列，优先使用第二列，否则使用第一列）
      const rowTitle = row[1] || row[0] || `行 ${rowIndex + 1}`;

      for (const rule of rules) {
        if (rule.targetTable !== tableName && !(isNpcTableName(rule.targetTable) && isNpcTableName(tableName)))
          continue;
        if (!rule.enabled) continue;

        // 找到目标列
        const colIndex = this.findColumnIndex(headers, rule.targetColumn);
        if (colIndex === -1) continue;

        const value = row[colIndex];
        const isValid = this.validateValue(value, rule, rawData);

        if (!isValid) {
          errors.push({
            ruleId: rule.id,
            ruleName: rule.name,
            ruleType: rule.ruleType,
            rule: rule, // 保存完整规则对象用于智能修改
            tableName: tableName,
            rowIndex: rowIndex,
            columnName: rule.targetColumn,
            currentValue: String(value ?? ''),
            rowTitle: rowTitle, // 添加第一列的值，用于标识错误行
            errorMessage: rule.errorMessage,
            severity: 'error',
          });
        }
      }

      return errors;
    },

    // 验证整个数据集
    validateAllData(rawData) {
      if (!rawData) return [];

      const rules = ValidationRuleManager.getEnabledRules();
      if (rules.length === 0) return [];

      const allErrors = [];

      for (const sheetId in rawData) {
        if (!sheetId.startsWith('sheet_')) continue;
        const sheet = rawData[sheetId];
        if (!sheet?.name || !sheet?.content) continue;

        const tableName = sheet.name;
        const headers = sheet.content[0];
        const tableRules = rules.filter(r => r.targetTable === tableName);

        if (tableRules.length === 0) continue;

        // 检查表级规则（如行数限制、序列递增）—— 即使表格为空也要检查
        for (const rule of tableRules) {
          const typeInfo = RULE_TYPE_INFO[rule.ruleType];
          if (typeInfo?.scope === 'table') {
            if (rule.ruleType === 'rowLimit') {
              const rowCount = sheet.content.length - 1;
              if (!this.validateRowLimit(rowCount, rule.config?.min, rule.config?.max)) {
                allErrors.push({
                  ruleId: rule.id,
                  ruleName: rule.name,
                  ruleType: rule.ruleType,
                  rule: rule, // 保存完整规则对象用于智能修改
                  tableName: tableName,
                  rowIndex: -1, // 表级错误
                  columnName: '',
                  currentValue: `${rowCount} 行`,
                  errorMessage:
                    rule.errorMessage ||
                    `行数 ${rowCount} 超出限制 (${rule.config?.min || 0}-${rule.config?.max || '∞'})`,
                  severity: 'warning',
                });
              }
            } else if (rule.ruleType === 'sequence' && rule.targetColumn) {
              // 序列递增验证
              const isValid = this.validateSequence(sheet, rule.targetColumn, rule.config || {});
              if (!isValid) {
                const error = {
                  ruleId: rule.id,
                  ruleName: rule.name,
                  ruleType: rule.ruleType,
                  rule: rule, // 保存完整规则对象用于智能修改
                  tableName: tableName,
                  rowIndex: -1, // 表级错误
                  columnName: rule.targetColumn,
                  currentValue: '',
                  errorMessage:
                    rule.errorMessage ||
                    `字段 "${rule.targetColumn}" 的编码索引必须从${rule.config?.prefix || ''}${String(rule.config?.startFrom || 1).padStart(4, '0')}开始严格递增，不可跳号或重复`,
                  severity: 'error',
                };
                allErrors.push(error);
              }
            }
            // tableReadonly 不在这里检查（需要对比快照）
          }
        }

        // 验证每一行（字段级规则）
        const fieldRules = tableRules.filter(r => RULE_TYPE_INFO[r.ruleType]?.scope !== 'table');
        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          const rowErrors = this.validateRow(row, headers, tableName, i - 1, fieldRules, rawData);
          allErrors.push(...rowErrors);
        }
      }

      return allErrors;
    },

    // 验证特定表的数据
    validateTable(rawData, tableName) {
      if (!rawData) return [];

      const rules = ValidationRuleManager.getRulesByTable(tableName);
      if (rules.length === 0) return [];

      // 查找表
      let targetSheet = null;
      for (const sheetId in rawData) {
        if (rawData[sheetId]?.name === tableName) {
          targetSheet = rawData[sheetId];
          break;
        }
      }

      if (!targetSheet || !targetSheet.content || targetSheet.content.length < 2) {
        return [];
      }

      const headers = targetSheet.content[0];
      const allErrors = [];

      for (let i = 1; i < targetSheet.content.length; i++) {
        const row = targetSheet.content[i];
        const rowErrors = this.validateRow(row, headers, tableName, i - 1, rules, rawData);
        allErrors.push(...rowErrors);
      }

      return allErrors;
    },

    // 按表名分组验证结果
    groupErrorsByTable(errors) {
      const grouped = {};
      for (const error of errors) {
        if (!grouped[error.tableName]) {
          grouped[error.tableName] = [];
        }
        grouped[error.tableName].push(error);
      }
      return grouped;
    },

    // 获取验证错误数量
    getErrorCount(rawData) {
      return this.validateAllData(rawData).length;
    },
  };

  // ========================================
  // LocalAvatarDB - 本地头像 IndexedDB 存储
  // ========================================
  const LocalAvatarDB = {
    DB_NAME: 'acu_local_avatars',
    STORE_NAME: 'avatars',
    DB_VERSION: 1,
    _db: null,
    _urlCache: new Map(), // 缓存 ObjectURL 避免重复创建

    // 初始化数据库
    async init() {
      if (this._db) return this._db;

      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

        request.onerror = () => {
          console.error('[DICE]LocalAvatarDB 打开数据库失败:', request.error);
          reject(request.error);
        };

        request.onsuccess = () => {
          this._db = request.result;
          resolve(this._db);
        };

        request.onupgradeneeded = event => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            // 主键为角色名
            db.createObjectStore(this.STORE_NAME, { keyPath: 'name' });
          }
        };
      });
    },

    // 保存图片（自动去重：相同 name 会覆盖）
    async save(name, blob) {
      if (!name || !blob) return false;

      try {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);

          // 清理旧的 ObjectURL 缓存
          if (this._urlCache.has(name)) {
            URL.revokeObjectURL(this._urlCache.get(name));
            this._urlCache.delete(name);
          }

          const data = {
            name: name,
            blob: blob,
            size: blob.size,
            type: blob.type,
            updatedAt: Date.now(),
          };

          const request = store.put(data);
          request.onsuccess = () => resolve(true);
          request.onerror = () => {
            console.error('[DICE]LocalAvatarDB 保存失败:', request.error);
            reject(request.error);
          };
        });
      } catch (e) {
        console.error('[DICE]LocalAvatarDB save error:', e);
        return false;
      }
    },

    // 获取图片 URL（返回 ObjectURL）
    async get(name) {
      if (!name) return null;

      // 先查缓存
      if (this._urlCache.has(name)) {
        return this._urlCache.get(name);
      }

      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.get(name);

          request.onsuccess = () => {
            const data = request.result;
            if (data && data.blob) {
              const url = URL.createObjectURL(data.blob);
              this._urlCache.set(name, url);
              resolve(url);
            } else {
              resolve(null);
            }
          };

          request.onerror = () => resolve(null);
        });
      } catch (e) {
        console.error('[DICE]LocalAvatarDB get error:', e);
        return null;
      }
    },

    // 检查是否存在本地图片
    async has(name) {
      if (!name) return false;

      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.getKey(name);

          request.onsuccess = () => resolve(request.result !== undefined);
          request.onerror = () => resolve(false);
        });
      } catch (e) {
        return false;
      }
    },

    // 删除图片
    async delete(name) {
      if (!name) return false;

      try {
        // 清理 ObjectURL 缓存
        if (this._urlCache.has(name)) {
          URL.revokeObjectURL(this._urlCache.get(name));
          this._urlCache.delete(name);
        }

        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.delete(name);

          request.onsuccess = () => resolve(true);
          request.onerror = () => resolve(false);
        });
      } catch (e) {
        console.error('[DICE]LocalAvatarDB delete error:', e);
        return false;
      }
    },

    // 获取所有已存储的角色名列表
    async getAllNames() {
      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.getAllKeys();

          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => resolve([]);
        });
      } catch (e) {
        return [];
      }
    },

    // 获取存储统计信息
    async getStats() {
      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.getAll();

          request.onsuccess = () => {
            const items = request.result || [];
            const totalSize = items.reduce((sum, item) => sum + (item.size || 0), 0);
            resolve({
              count: items.length,
              totalSize: totalSize,
              totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
            });
          };

          request.onerror = () => resolve({ count: 0, totalSize: 0, totalSizeMB: '0' });
        });
      } catch (e) {
        return { count: 0, totalSize: 0, totalSizeMB: '0' };
      }
    },

    // 清理所有数据
    async clearAll() {
      try {
        // 清理所有 ObjectURL 缓存
        this._urlCache.forEach(url => URL.revokeObjectURL(url));
        this._urlCache.clear();

        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.clear();

          request.onsuccess = () => resolve(true);
          request.onerror = () => resolve(false);
        });
      } catch (e) {
        console.error('[DICE]LocalAvatarDB clearAll error:', e);
        return false;
      }
    },
  };

  // ========================================
  // FavoritesDB - 收藏夹 IndexedDB 存储
  // ========================================
  /**
   * @typedef {Object} FavoriteItem
   * @property {string} id - UUID
   * @property {string[]} header - 列名数组 (不含首列null)
   * @property {(string|number)[]} rowData - 值数组 (与header对应)
   * @property {string[]} tags - 用户标签
   * @property {number} createdAt - 创建时间戳
   * @property {number} updatedAt - 最后修改时间戳
   * @property {{tableUid: string, tableName: string, chatId: string}} [sourceInfo] - 来源信息
   */
  interface FavoriteItem {
    id: string;
    header: string[];
    rowData: (string | number)[];
    tags: string[];
    createdAt: number;
    updatedAt: number;
    sourceInfo?: {
      tableUid: string;
      tableName: string;
      chatId: string;
    };
  }

  const FavoritesDB = {
    DB_NAME: 'acu_favorites',
    STORE_NAME: 'items',
    DB_VERSION: 1,
    _db: null as IDBDatabase | null,

    // 初始化数据库
    async init(): Promise<IDBDatabase> {
      if (this._db) return this._db;

      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

        request.onerror = () => {
          console.error('[DICE]FavoritesDB 打开数据库失败:', request.error);
          reject(request.error);
        };

        request.onsuccess = () => {
          this._db = request.result;
          resolve(this._db);
        };

        request.onupgradeneeded = event => {
          const db = (event.target as IDBOpenDBRequest).result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            // 主键为 id (UUID)
            db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    },

    // 添加收藏项
    async add(item: FavoriteItem): Promise<boolean> {
      if (!item || !item.id) return false;

      try {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);

          const request = store.add(item);
          request.onsuccess = () => resolve(true);
          request.onerror = () => {
            console.error('[DICE]FavoritesDB add 失败:', request.error);
            reject(request.error);
          };
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB add error:', e);
        return false;
      }
    },

    // 按ID获取
    async get(id: string): Promise<FavoriteItem | null> {
      if (!id) return null;

      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.get(id);

          request.onsuccess = () => {
            resolve(request.result || null);
          };

          request.onerror = () => resolve(null);
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB get error:', e);
        return null;
      }
    },

    // 更新收藏项 (合并更新)
    async update(id: string, updates: Partial<FavoriteItem>): Promise<boolean> {
      if (!id) return false;

      try {
        const existing = await this.get(id);
        if (!existing) return false;

        const updated = {
          ...existing,
          ...updates,
          id: existing.id, // 确保 id 不被覆盖
          updatedAt: Date.now(),
        };

        const db = await this.init();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);

          const request = store.put(updated);
          request.onsuccess = () => resolve(true);
          request.onerror = () => {
            console.error('[DICE]FavoritesDB update 失败:', request.error);
            reject(request.error);
          };
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB update error:', e);
        return false;
      }
    },

    // 删除收藏项
    async delete(id: string): Promise<boolean> {
      if (!id) return false;

      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.delete(id);

          request.onsuccess = () => resolve(true);
          request.onerror = () => resolve(false);
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB delete error:', e);
        return false;
      }
    },

    // 获取所有收藏项
    async getAll(): Promise<FavoriteItem[]> {
      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.getAll();

          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => resolve([]);
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB getAll error:', e);
        return [];
      }
    },

    // 获取所有唯一标签
    async getAllTags(): Promise<string[]> {
      try {
        const items = await this.getAll();
        const tagSet = new Set<string>();
        for (const item of items) {
          if (item.tags && Array.isArray(item.tags)) {
            for (const tag of item.tags) {
              if (tag) tagSet.add(tag);
            }
          }
        }
        return Array.from(tagSet).sort();
      } catch (e) {
        console.error('[DICE]FavoritesDB getAllTags error:', e);
        return [];
      }
    },

    // 按标签筛选
    async getByTag(tag: string): Promise<FavoriteItem[]> {
      if (!tag) return [];

      try {
        const items = await this.getAll();
        return items.filter(item => item.tags && item.tags.includes(tag));
      } catch (e) {
        console.error('[DICE]FavoritesDB getByTag error:', e);
        return [];
      }
    },

    // 清空所有
    async clear(): Promise<boolean> {
      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.clear();

          request.onsuccess = () => resolve(true);
          request.onerror = () => resolve(false);
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB clear error:', e);
        return false;
      }
    },

    // 获取总数
    async count(): Promise<number> {
      try {
        const db = await this.init();
        return new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const store = tx.objectStore(this.STORE_NAME);
          const request = store.count();

          request.onsuccess = () => resolve(request.result || 0);
          request.onerror = () => resolve(0);
        });
      } catch (e) {
        console.error('[DICE]FavoritesDB count error:', e);
        return 0;
      }
    },
  };

  type DiceHistoryEventType = 'check' | 'contest';

  interface DiceHistoryStatRecord {
    id?: number;
    eventType: DiceHistoryEventType;
    timestamp: number;
    chatId: string;
    characterId: string;
    success: boolean;
    attrName: string;
    formula: string;
    total: number;
    target: number;
    outcomeText: string;
  }

  interface DiceHistoryStatsSummary {
    total: number;
    checks: number;
    contests: number;
    checkSuccess: number;
    checkSuccessRate: number;
  }

  const DiceHistoryStatsDB = {
    DB_NAME: 'acu_dice_history_stats',
    STORE_NAME: 'records',
    DB_VERSION: 1,
    _db: null as IDBDatabase | null,

    async init(): Promise<IDBDatabase> {
      if (this._db) return this._db;

      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

        request.onerror = () => {
          console.error('[DICE]DiceHistoryStatsDB 打开数据库失败:', request.error);
          reject(request.error);
        };

        request.onsuccess = () => {
          this._db = request.result;
          resolve(this._db);
        };

        request.onupgradeneeded = event => {
          const db = (event.target as IDBOpenDBRequest).result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            const store = db.createObjectStore(this.STORE_NAME, {
              keyPath: 'id',
              autoIncrement: true,
            });
            store.createIndex('eventType', 'eventType', { unique: false });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('chatId', 'chatId', { unique: false });
            store.createIndex('characterId', 'characterId', { unique: false });
            store.createIndex('chatCharacter', ['chatId', 'characterId'], { unique: false });
          }
        };
      });
    },

    async add(record: DiceHistoryStatRecord): Promise<void> {
      try {
        const db = await this.init();
        await new Promise<void>(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => {
            console.warn('[DICE]DiceHistoryStatsDB add 失败:', tx.error);
            resolve();
          };
          tx.objectStore(this.STORE_NAME).add(record);
        });
      } catch (error) {
        console.warn('[DICE]DiceHistoryStatsDB add error:', error);
      }
    },

    async getAll(): Promise<DiceHistoryStatRecord[]> {
      try {
        const db = await this.init();
        return await new Promise(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readonly');
          const request = tx.objectStore(this.STORE_NAME).getAll();
          request.onsuccess = () => resolve((request.result || []) as DiceHistoryStatRecord[]);
          request.onerror = () => resolve([]);
        });
      } catch (error) {
        console.warn('[DICE]DiceHistoryStatsDB getAll error:', error);
        return [];
      }
    },

    async clear(): Promise<void> {
      try {
        const db = await this.init();
        await new Promise<void>(resolve => {
          const tx = db.transaction(this.STORE_NAME, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => resolve();
          tx.objectStore(this.STORE_NAME).clear();
        });
      } catch (error) {
        console.warn('[DICE]DiceHistoryStatsDB clear error:', error);
      }
    },

    async recordEvent(event: string, payload: unknown): Promise<void> {
      if (event !== 'check' && event !== 'contest') return;

      const context = getDiceStatsContext();
      const record = payload as Record<string, unknown>;
      const now = Date.now();
      const timestampRaw = Number(record.timestamp);
      const timestamp = Number.isFinite(timestampRaw) ? timestampRaw : now;

      const entry: DiceHistoryStatRecord = {
        eventType: event,
        timestamp,
        chatId: context.chatId,
        characterId: context.characterId,
        success: false,
        attrName: '',
        formula: '',
        total: 0,
        target: 0,
        outcomeText: '',
      };

      if (event === 'check') {
        entry.success = Boolean(record.success);
        entry.attrName = String(record.attrName || '检定');
        entry.formula = String(record.formula || '');
        entry.total = Number(record.total) || 0;
        entry.target = Number(record.target) || 0;
        entry.outcomeText = String(record.outcomeText || (entry.success ? '成功' : '失败'));
      } else {
        const winner = String(record.winner || 'tie');
        entry.success = winner !== 'tie';
        const left = (record.left || {}) as Record<string, unknown>;
        const right = (record.right || {}) as Record<string, unknown>;
        entry.attrName = `${String(left.attribute || '')} vs ${String(right.attribute || '')}`.trim() || '对抗检定';
        entry.formula = 'contest';
        entry.total = Number(left.roll) || 0;
        entry.target = Number(left.target) || 0;
        entry.outcomeText = String(record.message || (winner === 'tie' ? '平局' : '分出胜负'));
      }

      await this.add(entry);
    },

    summarize(records: DiceHistoryStatRecord[]): DiceHistoryStatsSummary {
      const checks = records.filter(item => item.eventType === 'check');
      const contests = records.filter(item => item.eventType === 'contest');
      const checkSuccess = checks.filter(item => item.success).length;
      const checkSuccessRate = checks.length > 0 ? Number(((checkSuccess / checks.length) * 100).toFixed(1)) : 0;
      return {
        total: records.length,
        checks: checks.length,
        contests: contests.length,
        checkSuccess,
        checkSuccessRate,
      };
    },

    async getDashboardStats(): Promise<Record<DiceStatsScope, DiceHistoryStatsSummary>> {
      const all = await this.getAll();
      const context = getDiceStatsContext();
      const hasChatScope = context.chatId !== 'unknown_chat';
      const hasCharacterScope = context.characterId !== 'unknown_character';

      const chatRecords = hasChatScope
        ? all.filter(item => item.chatId === context.chatId && item.chatId !== 'unknown_chat')
        : [];
      const characterRecords = hasCharacterScope
        ? all.filter(item => item.characterId === context.characterId && item.characterId !== 'unknown_character')
        : [];

      return {
        chat: this.summarize(chatRecords),
        character: this.summarize(characterRecords),
        global: this.summarize(all),
      };
    },
  };

  // ========================================
  // FavoritesManager - 收藏夹业务逻辑层
  // ========================================

  interface TableCompatibility {
    tableUid: string;
    tableName: string;
    mode: 'strict' | 'loose' | 'incompatible';
    matchedCols: string[];
    unmatchedCols: string[];
    matchRatio: number;
  }

  const FavoritesManager = {
    // 添加收藏
    async addFavorite(
      tableUid: string,
      tableName: string,
      header: string[],
      rowData: (string | number)[],
      tags: string[] = [],
    ): Promise<FavoriteItem | null> {
      try {
        const chatId = SillyTavern.getCurrentChatId() || '';
        const item: FavoriteItem = {
          id: crypto.randomUUID(),
          header: header,
          rowData: rowData,
          tags: tags,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          sourceInfo: {
            tableUid,
            tableName,
            chatId,
          },
        };

        const success = await FavoritesDB.add(item);
        if (success) {
          console.log('[DICE]FavoritesManager 添加收藏:', item.id);
          return item;
        }
        return null;
      } catch (e) {
        console.error('[DICE]FavoritesManager addFavorite error:', e);
        return null;
      }
    },

    // 更新收藏
    async updateFavorite(id: string, updates: Partial<FavoriteItem>): Promise<boolean> {
      try {
        const success = await FavoritesDB.update(id, updates);
        if (success) {
          console.log('[DICE]FavoritesManager 更新收藏:', id);
        }
        return success;
      } catch (e) {
        console.error('[DICE]FavoritesManager updateFavorite error:', e);
        return false;
      }
    },

    // 复制收藏
    async duplicateFavorite(id: string): Promise<FavoriteItem | null> {
      try {
        const original = await FavoritesDB.get(id);
        if (!original) return null;

        const copy: FavoriteItem = {
          ...original,
          id: crypto.randomUUID(),
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        const success = await FavoritesDB.add(copy);
        if (success) {
          console.log('[DICE]FavoritesManager 复制收藏:', id, '->', copy.id);
          return copy;
        }
        return null;
      } catch (e) {
        console.error('[DICE]FavoritesManager duplicateFavorite error:', e);
        return null;
      }
    },

    // 删除收藏
    async deleteFavorite(id: string): Promise<boolean> {
      try {
        const success = await FavoritesDB.delete(id);
        if (success) {
          console.log('[DICE]FavoritesManager 删除收藏:', id);
        }
        return success;
      } catch (e) {
        console.error('[DICE]FavoritesManager deleteFavorite error:', e);
        return false;
      }
    },

    // 添加标签
    async addTag(id: string, tag: string): Promise<boolean> {
      try {
        const item = await FavoritesDB.get(id);
        if (!item) return false;

        if (!item.tags.includes(tag)) {
          item.tags.push(tag);
          return await FavoritesDB.update(id, { tags: item.tags });
        }
        return true;
      } catch (e) {
        console.error('[DICE]FavoritesManager addTag error:', e);
        return false;
      }
    },

    // 移除标签
    async removeTag(id: string, tag: string): Promise<boolean> {
      try {
        const item = await FavoritesDB.get(id);
        if (!item) return false;

        const index = item.tags.indexOf(tag);
        if (index > -1) {
          item.tags.splice(index, 1);
          return await FavoritesDB.update(id, { tags: item.tags });
        }
        return true;
      } catch (e) {
        console.error('[DICE]FavoritesManager removeTag error:', e);
        return false;
      }
    },

    // 获取所有标签
    async getAllTags(): Promise<string[]> {
      return await FavoritesDB.getAllTags();
    },

    // 获取所有收藏
    async getAll(): Promise<FavoriteItem[]> {
      return await FavoritesDB.getAll();
    },

    // 按标签获取
    async getByTag(tag: string): Promise<FavoriteItem[]> {
      return await FavoritesDB.getByTag(tag);
    },

    // 按ID获取
    async getById(id: string): Promise<FavoriteItem | null> {
      return await FavoritesDB.get(id);
    },

    // 查找兼容表格
    findCompatibleTables(favorite: FavoriteItem, currentTables: Record<string, any>): TableCompatibility[] {
      const results: TableCompatibility[] = [];

      for (const uid in currentTables) {
        const table = currentTables[uid];
        if (!table || !table.content || !table.content[0]) continue;

        // 获取表头（去掉首列null）
        const tableHeader: string[] = table.content[0].slice(1).map((h: any) => String(h || ''));

        // 检查是否严格匹配
        const isStrict =
          favorite.header.length === tableHeader.length && favorite.header.every((h, i) => h === tableHeader[i]);

        // 计算匹配列
        const matchedCols = favorite.header.filter(h => tableHeader.includes(h));
        const unmatchedCols = favorite.header.filter(h => !tableHeader.includes(h));
        const matchRatio = favorite.header.length > 0 ? matchedCols.length / favorite.header.length : 0;

        if (isStrict) {
          results.push({
            tableUid: uid,
            tableName: table.name || uid,
            mode: 'strict',
            matchedCols,
            unmatchedCols,
            matchRatio: 1,
          });
        } else if (matchRatio > 0) {
          results.push({
            tableUid: uid,
            tableName: table.name || uid,
            mode: 'loose',
            matchedCols,
            unmatchedCols,
            matchRatio,
          });
        }
      }

      // 按匹配度排序（strict优先，然后按matchRatio降序）
      return results.sort((a, b) => {
        if (a.mode === 'strict' && b.mode !== 'strict') return -1;
        if (a.mode !== 'strict' && b.mode === 'strict') return 1;
        return b.matchRatio - a.matchRatio;
      });
    },

    // 映射行数据到目标表格
    mapRowToTable(favorite: FavoriteItem, targetHeader: string[]): (string | number | null)[] {
      const newRow: (string | number | null)[] = [null]; // 首列固定null
      for (const col of targetHeader) {
        const srcIndex = favorite.header.indexOf(col);
        newRow.push(srcIndex >= 0 ? favorite.rowData[srcIndex] : '');
      }
      return newRow;
    },

    // 导出收藏夹
    async exportFavorites(): Promise<string> {
      try {
        const items = await FavoritesDB.getAll();
        const exportData = {
          version: 1,
          exportedAt: Date.now(),
          items: items,
        };
        return JSON.stringify(exportData, null, 2);
      } catch (e) {
        console.error('[DICE]FavoritesManager exportFavorites error:', e);
        return '';
      }
    },

    // 导入收藏夹
    async importFavorites(jsonStr: string): Promise<{ added: number; updated: number } | null> {
      try {
        const data = JSON.parse(jsonStr);
        if (!data || !data.items || !Array.isArray(data.items)) {
          console.error('[DICE]FavoritesManager 导入格式无效');
          return null;
        }

        let added = 0;
        let updated = 0;

        for (const item of data.items) {
          if (!item.id || !item.header || !item.rowData) continue;

          const existing = await FavoritesDB.get(item.id);
          if (existing) {
            // 覆盖更新
            await FavoritesDB.update(item.id, {
              header: item.header,
              rowData: item.rowData,
              tags: item.tags || [],
              updatedAt: Date.now(),
              sourceInfo: item.sourceInfo,
            });
            updated++;
          } else {
            // 新增
            const newItem: FavoriteItem = {
              id: item.id,
              header: item.header,
              rowData: item.rowData,
              tags: item.tags || [],
              createdAt: item.createdAt || Date.now(),
              updatedAt: Date.now(),
              sourceInfo: item.sourceInfo,
            };
            await FavoritesDB.add(newItem);
            added++;
          }
        }

        console.log('[DICE]FavoritesManager 导入完成:', added, '新增,', updated, '更新');
        return { added, updated };
      } catch (e) {
        console.error('[DICE]FavoritesManager importFavorites error:', e);
        return null;
      }
    },
  };

  // [新增] 获取 SillyTavern 用户头像 URL
  const getUserAvatarUrl = () => {
    try {
      // 方法1: 从页面 DOM 中查找用户头像元素
      const w = window.parent || window;
      const $ = w.jQuery || window.jQuery;
      if ($) {
        // SillyTavern 用户头像通常在 #user_avatar_block img 或 .avatar[title="You"] img
        const $avatar = $('#user_avatar_block img').first();
        if ($avatar.length && $avatar.attr('src')) {
          return $avatar.attr('src');
        }
        // 备选：查找聊天中用户消息的头像
        const $userMes = $('.mes[is_user="true"]').last().find('.avatar img');
        if ($userMes.length && $userMes.attr('src')) {
          return $userMes.attr('src');
        }
      }
      // 方法2: 尝试从 SillyTavern API 获取
      const ST = w.SillyTavern || window.SillyTavern;
      if (ST && ST.getContext) {
        const ctx = ST.getContext();
        if (ctx && ctx.userAvatar) {
          return ctx.userAvatar;
        }
      }
    } catch (e) {
      console.warn('[DICE]ACU getUserAvatarUrl error:', e);
    }
    return null;
  };

  // [新增] 获取主角名字（用于判断是否是主角）
  const getPlayerName = () => {
    const rawData = cachedRawData || (typeof getTableData === 'function' ? getTableData() : null);
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (sheet?.name?.includes('主角') && sheet.content?.[1]?.[1]) {
          return getDisplayName(sheet.content[1][1]);
        }
      }
    }
    return null;
  };

  // [新增] 获取 SillyTavern Persona 名称（用于显示）
  const getPersonaName = () => {
    try {
      // 方法1: SillyTavern 标准 API
      const w = window.parent || window;
      if (w.SillyTavern?.getContext) {
        const ctx = w.SillyTavern.getContext();
        if (ctx?.name1) return ctx.name1;
      }
      // 方法2: 直接访问全局变量
      if (typeof name1 !== 'undefined' && name1) return name1;
      if (w.name1) return w.name1;
      // 方法3: 从 DOM 中查找
      const $ = w.jQuery || window.jQuery;
      if ($) {
        const $persona = $('#user_avatar_block .avatar-name, #persona_name_input').first();
        if ($persona.length) {
          const name = $persona.val?.() || $persona.text?.();
          if (name && name.trim()) return name.trim();
        }
      }
    } catch (e) {
      console.warn('[DICE]ACU getPersonaName error:', e);
    }
    return null;
  };

  // [新增] 获取用于显示的玩家名称（优先 Persona，其次主角表，最后默认值）
  const getDisplayPlayerName = () => {
    return getPersonaName() || getPlayerName() || '主角';
  };

  // [新增] 替换文本中的用户占位符为 Persona 名称（仅用于显示）
  const replaceUserPlaceholders = text => {
    if (!text || typeof text !== 'string') return text;
    const displayName = getDisplayPlayerName();
    // 替换 <user>、{{user}}（不区分大小写）
    let result = text.replace(/<user>/gi, displayName);
    result = result.replace(/\{\{user\}\}/gi, displayName);
    return result;
  };

  type DiceStatsScope = 'chat' | 'character' | 'global';

  interface DiceStatsContext {
    chatId: string;
    characterId: string;
  }

  const getDiceStatsContext = (): DiceStatsContext => {
    const ST = SillyTavern;
    let chatId = 'unknown_chat';
    let characterId = 'unknown_character';

    try {
      if (typeof getCurrentChatId === 'function') {
        const directChatId = getCurrentChatId();
        if (directChatId !== null && directChatId !== undefined) {
          const parsed = String(directChatId).trim();
          if (parsed) chatId = parsed;
        }
      }
      if (typeof ST?.getCurrentChatId === 'function') {
        const currentChatId = ST.getCurrentChatId();
        if (currentChatId !== null && currentChatId !== undefined) {
          const parsed = String(currentChatId).trim();
          if (parsed) chatId = parsed;
        }
      }
    } catch {
      // ignore
    }

    try {
      if (typeof getCharData === 'function') {
        const currentChar = getCharData('current', true);
        const avatarId = String(currentChar?.avatar || '').trim();
        if (avatarId) {
          characterId = avatarId;
        }
      }

      if (characterId === 'unknown_character') {
        const cid = ST?.characterId;
        const chars = ST?.characters;
        const idx = Number.parseInt(String(cid ?? ''), 10);
        if (!Number.isNaN(idx) && idx >= 0 && Array.isArray(chars) && idx < chars.length) {
          const avatarId = String(chars[idx]?.avatar || '').trim();
          if (avatarId) {
            characterId = avatarId;
          }
        }
      }
    } catch {
      // ignore
    }

    return { chatId, characterId };
  };
  // 头像管理工具（支持裁剪偏移）
  const AvatarManager = {
    _cache: null,

    load() {
      if (!this._cache) {
        const raw = Store.get(STORAGE_KEY_AVATAR_MAP, {});
        this._cache = {};
        for (const name in raw) {
          if (typeof raw[name] === 'string') {
            this._cache[name] = { url: raw[name], offsetX: 50, offsetY: 50, scale: 150, aliases: [], createdAt: 0 };
          } else {
            this._cache[name] = {
              url: raw[name].url || '',
              offsetX: raw[name].offsetX ?? 50,
              offsetY: raw[name].offsetY ?? 50,
              scale: raw[name].scale ?? 150,
              aliases: raw[name].aliases || [],
              createdAt: raw[name].createdAt ?? 0,
            };
          }
        }
      }
      return this._cache;
    },

    save() {
      Store.set(STORAGE_KEY_AVATAR_MAP, this._cache || {});
      this._cache = null;
    },

    // 同步获取（仅 URL 和 ST 头像，不含本地图片）
    get(name) {
      const data = this.load()[name];
      if (data && data.url) return data.url;

      for (const key in this._cache) {
        if (this._cache[key].aliases && this._cache[key].aliases.includes(name)) {
          if (this._cache[key].url) return this._cache[key].url;
        }
      }

      return null;
    },

    // 异步获取（优先级：本地图片 > URL > ST头像）
    async getAsync(name) {
      if (!name) return null;

      // 判断是否是主角
      const playerName = getPlayerName();
      const isPlayer = name === '<user>' || name === '主角' || (playerName && name === playerName);

      // 1. 优先查本地 IndexedDB
      const localUrl = await LocalAvatarDB.get(name);
      if (localUrl) return localUrl;

      // 2. 如果是主角，也尝试用 <user> 查找
      if (isPlayer && name !== '<user>') {
        const userLocalUrl = await LocalAvatarDB.get('<user>');
        if (userLocalUrl) return userLocalUrl;
      }

      // 3. 检查别名对应的本地图片
      const primaryName = this.getPrimaryName(name);
      if (primaryName !== name) {
        const aliasLocalUrl = await LocalAvatarDB.get(primaryName);
        if (aliasLocalUrl) return aliasLocalUrl;
      }

      // 4. 回退到同步方法（URL / ST头像）
      return this.get(name);
    },

    // 检查是否有本地图片
    async hasLocalAvatar(name) {
      if (!name) return false;
      const has = await LocalAvatarDB.has(name);
      if (has) return true;

      const primaryName = this.getPrimaryName(name);
      if (primaryName !== name) {
        return await LocalAvatarDB.has(primaryName);
      }
      return false;
    },

    // 保存本地图片
    async saveLocalAvatar(name, blob) {
      return await LocalAvatarDB.save(name, blob);
    },

    // 删除本地图片
    async deleteLocalAvatar(name) {
      return await LocalAvatarDB.delete(name);
    },

    getOffsetX(name) {
      const data = this._resolveByAlias(name);
      return data ? (data.offsetX ?? 50) : 50;
    },

    getOffsetY(name) {
      const data = this._resolveByAlias(name);
      return data ? (data.offsetY ?? 50) : 50;
    },

    getScale(name) {
      const data = this._resolveByAlias(name);
      return data ? (data.scale ?? 150) : 150;
    },

    // 根据名字或别名找到主记录
    _resolveByAlias(name) {
      const data = this.load()[name];
      if (data) return data;
      for (const key in this._cache) {
        if (this._cache[key].aliases && this._cache[key].aliases.includes(name)) {
          return this._cache[key];
        }
      }
      return null;
    },

    // 获取主名称（如果传入的是别名，返回主名称）
    getPrimaryName(name) {
      if (this.load()[name]) return name;
      for (const key in this._cache) {
        if (this._cache[key].aliases && this._cache[key].aliases.includes(name)) {
          return key;
        }
      }
      return name;
    },

    set(name, url, offsetX = 50, offsetY = 50, scale = 150, aliases = []) {
      const existing = this.load()[name];
      const createdAt = existing ? (existing.createdAt ?? 0) : Date.now();
      this.load()[name] = { url, offsetX, offsetY, scale, aliases, createdAt };
      this.save();
    },

    setPosition(name, offsetX, offsetY) {
      const data = this.load()[name];
      if (data) {
        data.offsetX = offsetX;
        data.offsetY = offsetY;
        this.save();
      }
    },

    setScale(name, scale) {
      const data = this.load()[name];
      if (data) {
        data.scale = scale;
        this.save();
      }
    },

    setAliases(name, aliases) {
      const data = this.load()[name];
      if (data) {
        data.aliases = aliases;
        this.save();
      }
    },

    remove(name) {
      delete this.load()[name];
      this.save();
    },

    getAll() {
      return this.load();
    },

    // 导出为JSON对象
    exportData() {
      return {
        version: 1,
        exportTime: new Date().toISOString(),
        avatars: this.load(),
      };
    },

    // 导入数据，返回统计信息
    importData(jsonData, overwriteConflicts = true) {
      if (!jsonData || !jsonData.avatars) {
        throw new Error('无效的配置文件格式');
      }

      const current = this.load();
      const stats = { added: 0, updated: 0, skipped: 0 };

      for (const name in jsonData.avatars) {
        const imported = jsonData.avatars[name];
        if (!imported.url) continue;

        if (current[name]) {
          // 冲突
          if (overwriteConflicts) {
            current[name] = {
              url: imported.url,
              offsetX: imported.offsetX ?? 50,
              offsetY: imported.offsetY ?? 50,
              scale: imported.scale ?? 150,
              aliases: imported.aliases || [],
              createdAt: imported.createdAt ?? 0,
            };
            stats.updated++;
          } else {
            stats.skipped++;
          }
        } else {
          // 新增
          current[name] = {
            url: imported.url,
            offsetX: imported.offsetX ?? 50,
            offsetY: imported.offsetY ?? 50,
            scale: imported.scale ?? 150,
            aliases: imported.aliases || [],
            createdAt: imported.createdAt ?? 0,
          };
          stats.added++;
        }
      }

      this.save();
      return stats;
    },

    // 分析导入文件，返回冲突信息
    analyzeImport(jsonData) {
      if (!jsonData || !jsonData.avatars) {
        return { valid: false, error: '无效的配置文件格式' };
      }

      const current = this.load();
      const result = { valid: true, total: 0, newItems: [], conflicts: [] };

      for (const name in jsonData.avatars) {
        if (!jsonData.avatars[name].url) continue;
        result.total++;
        if (current[name]) {
          result.conflicts.push(name);
        } else {
          result.newItems.push(name);
        }
      }

      return result;
    },
  };

  // ========================================
  // 角色名称解析与别名系统
  // ========================================

  /**
   * 解析逗号分隔的角色名称，提取主名称（display name）和别名
   * 规则：最长的名称为主key，长度相同时靠前的优先
   * 例如："千早爱音,千早,爱音" → { displayName: "千早爱音", aliases: ["千早", "爱音"] }
   * 例如："奥兹艾萨克，奥兹，艾萨克" → { displayName: "奥兹艾萨克", aliases: ["奥兹", "艾萨克"] }
   */
  const parseCharacterName = (rawName: string): { displayName: string; aliases: string[] } => {
    if (!rawName) return { displayName: '', aliases: [] };
    const trimmed = String(rawName).trim();
    const parts = trimmed
      .split(/[,，]/)
      .map(s => s.trim())
      .filter(Boolean);
    if (parts.length <= 1) return { displayName: trimmed, aliases: [] };

    // 找到最长的名称作为主key；长度相同时，靠前的优先
    let bestIdx = 0;
    for (let i = 1; i < parts.length; i++) {
      if (parts[i].length > parts[bestIdx].length) bestIdx = i;
    }
    const displayName = parts[bestIdx];
    const aliases = parts.filter((_, i) => i !== bestIdx);
    return { displayName, aliases };
  };

  /**
   * 获取角色的显示名称（主key）
   * 如果原始名称包含逗号分隔的多个名称，返回最长的那个
   * 如果不含逗号，原样返回
   */
  const getDisplayName = (rawName: string): string => {
    return parseCharacterName(rawName).displayName;
  };

  /**
   * 判断一个表格是否是角色相关表格（主角信息、NPC、角色等）
   * 用于决定是否对该表格的名称列应用 getDisplayName
   */
  const isCharacterTable = (tableName: string): boolean => {
    const keywords = ['主角', '角色', '人物', 'NPC', '伙伴', '队友', '宠物', '弟子', '成员', 'player', 'character'];
    return keywords.some(kw => tableName.toLowerCase().includes(kw.toLowerCase()));
  };

  /**
   * 全局角色名别名注册表（运行时，非持久化）
   * 从角色表格中解析逗号分隔的名称，自动建立别名映射
   * 与 AvatarManager 的手动别名互补：手动别名优先级更高
   */
  const NameAliasRegistry = {
    // alias → primaryName（自动检测，无冲突）
    _autoAliases: new Map<string, string>(),
    // 冲突别名：alias → [primaryName1, primaryName2, ...]
    _conflicts: new Map<string, string[]>(),
    // 所有主名称 → 原始名称（含逗号）的映射
    _displayNames: new Map<string, string>(),

    /**
     * 从所有角色表重建别名映射
     * 扫描角色表中的名称列，解析逗号分隔格式，建立别名关系
     * 冲突的别名（同一别名出现在多个角色中）不会自动注册
     */
    rebuild(allTables: Record<string, { headers: string[]; rows: (string | number | null)[][]; key?: string }>) {
      this._autoAliases.clear();
      this._conflicts.clear();
      this._displayNames.clear();

      // alias → 拥有该别名的所有主名称
      const aliasOwners = new Map<string, string[]>();

      for (const tableName in allTables) {
        if (!isCharacterTable(tableName)) continue;
        const table = allTables[tableName];
        const headers = table.headers || [];
        const rows = table.rows || [];

        // 查找名称列
        let nameIdx = headers.findIndex(h => h && (String(h).includes('姓名') || String(h).includes('名称')));
        if (nameIdx < 0) nameIdx = 1; // 回退到第二列（跳过行号）

        rows.forEach(row => {
          const rawName = String(row[nameIdx] || '').trim();
          if (!rawName) return;
          const { displayName, aliases } = parseCharacterName(rawName);
          if (!displayName) return;

          // 记录 displayName → rawName 映射
          this._displayNames.set(displayName, rawName);

          if (aliases.length === 0) return;

          for (const alias of aliases) {
            if (!aliasOwners.has(alias)) aliasOwners.set(alias, []);
            const owners = aliasOwners.get(alias)!;
            if (!owners.includes(displayName)) owners.push(displayName);
          }
        });
      }

      // 分类：无冲突 → _autoAliases，有冲突 → _conflicts
      for (const [alias, owners] of aliasOwners) {
        if (owners.length === 1) {
          this._autoAliases.set(alias, owners[0]);
        } else {
          this._conflicts.set(alias, [...owners]);
        }
      }

      if (this._autoAliases.size > 0) {
        console.info(
          `[DICE]别名注册表: 自动注册 ${this._autoAliases.size} 个别名` +
            (this._conflicts.size > 0 ? `, ${this._conflicts.size} 个冲突已跳过` : ''),
        );
      }
    },

    /**
     * 将名称解析为主名称（display name）
     * 优先级：直接逗号解析 > AvatarManager手动别名 > 自动检测别名 > 原名
     */
    resolve(name: string): string {
      if (!name) return name;

      // 1. 如果名称本身包含逗号，直接解析出主名称
      if (name.includes(',') || name.includes('，')) {
        return getDisplayName(name);
      }

      // 2. 检查 AvatarManager 手动别名（优先级最高）
      const manualPrimary = AvatarManager.getPrimaryName(name);
      if (manualPrimary !== name) return manualPrimary;

      // 3. 检查自动检测的别名
      const autoPrimary = this._autoAliases.get(name);
      if (autoPrimary) return autoPrimary;

      return name;
    },

    /**
     * 获取某个主名称的所有别名（合并自动检测 + AvatarManager手动别名）
     */
    getAliases(primaryName: string): string[] {
      const result: string[] = [];

      // 自动检测的别名
      for (const [alias, owner] of this._autoAliases) {
        if (owner === primaryName && !result.includes(alias)) result.push(alias);
      }

      // AvatarManager 手动别名
      const manualAliases = AvatarManager.load()[primaryName]?.aliases || [];
      for (const a of manualAliases) {
        if (!result.includes(a)) result.push(a);
      }

      return result;
    },

    /**
     * 获取冲突的别名信息
     */
    getConflicts(): Map<string, string[]> {
      return new Map(this._conflicts);
    },

    /**
     * 检查某个名称是否是已知的主名称
     */
    isDisplayName(name: string): boolean {
      return this._displayNames.has(name);
    },
  };

  // 渲染图标：支持 fa:xxx 简写格式和原生emoji
  const renderIcon = (icon: string | null): string => {
    if (!icon) return '';
    if (icon.startsWith('fa:')) {
      const name = icon.slice(3);
      return `<i class="fa-solid fa-${name} acu-icon"></i>`;
    }
    return icon; // 原样返回emoji
  };

  const getLocationEmoji = name => {
    if (!name) return null;
    const lowerName = name.toLowerCase();
    for (const [pattern, emoji] of LOCATION_EMOJI_MAP) {
      if (pattern.test(lowerName)) return emoji;
    }
    return null;
  };

  // 获取地点名的所有候选emoji（用于去重分配）
  const getEmojiCandidates = (name: string): string[] => {
    if (!name) return [];
    const lowerName = name.toLowerCase();
    const candidates: string[] = [];
    for (const [pattern, emoji] of LOCATION_EMOJI_MAP) {
      if (pattern.test(lowerName)) {
        candidates.push(emoji);
      }
    }
    return candidates;
  };

  // 批量分配emoji，实现去重（最短名称优先）
  const resolveBatchLocationEmojis = (names: string[]): Map<string, string | null> => {
    // 1. 计算每个地点的候选列表
    const candidatesMap = new Map<string, string[]>();
    for (const name of names) {
      candidatesMap.set(name, getEmojiCandidates(name));
    }

    // 2. 按长度排序（最短优先），同长度按字母序
    const sortedNames = [...names].sort((a, b) => {
      if (a.length !== b.length) return a.length - b.length;
      return a.localeCompare(b);
    });

    // 3. 贪心分配
    const usedEmojis = new Set<string>();
    const result = new Map<string, string | null>();

    for (const name of sortedNames) {
      const candidates = candidatesMap.get(name) || [];
      const available = candidates.find(e => !usedEmojis.has(e));
      if (available) {
        result.set(name, available);
        usedEmojis.add(available);
      } else {
        // 所有候选都被占用，回退到第一个候选（允许重复显示）
        result.set(name, candidates.length > 0 ? candidates[0] : null);
      }
    }

    return result;
  };

  const getElementEmoji = (name, type) => {
    if (!name && !type) return null;
    const lowerName = name?.toLowerCase();
    const lowerType = type?.toLowerCase();
    for (const [pattern, emoji] of ELEMENT_EMOJI_MAP) {
      if (lowerName && pattern.test(lowerName)) return emoji;
    }
    for (const [pattern, emoji] of ELEMENT_EMOJI_MAP) {
      if (lowerType && pattern.test(lowerType)) return emoji;
    }
    return null;
  };

  // ========================================
  // MVU 变量可视化模块 v2.0
  // 独立模块 - 卡片分组式 UI
  // ========================================
  const MvuModule = (function () {
    'use strict';

    // [新增] MVU 路径解析函数 - 用于投骰快捷选择（移到模块内部避免影响执行顺序）
    function parseMvuPathForDice(path, value) {
      try {
        if (!path || typeof path !== 'string') {
          return { initiator: null, attrName: null, candidates: [] };
        }

        // 用 . 分割路径
        const parts = path.split('.').filter(p => p && p.trim());

        if (parts.length === 0) {
          return { initiator: null, attrName: null, candidates: [] };
        }

        // 定义黑名单：绝对不是属性名的词
        const blacklist = [
          '角色列表',
          '系统',
          '列表',
          '表',
          '数据',
          '信息',
          '变量',
          '属性',
          '状态',
          'stat_data',
          'delta_data',
        ];

        // 变量过滤黑名单
        const filteredParts = parts.filter(p => !blacklist.includes(p));

        // 提取可能的发起者（通常是倒数第二或第三层，排除黑名单后）
        let initiator = null;
        if (filteredParts.length >= 2) {
          // 倒数第二层通常是角色名
          initiator = filteredParts[filteredParts.length - 2];
        } else if (filteredParts.length === 1) {
          // 只有一层，可能是角色名
          initiator = filteredParts[0];
        }

        // 提取属性名（通常是最后一层）
        let attrName = null;
        if (filteredParts.length > 0) {
          attrName = filteredParts[filteredParts.length - 1];
        } else if (parts.length > 0) {
          // 如果所有部分都在黑名单中，至少取最后一部分
          attrName = parts[parts.length - 1];
        }

        // 生成候选列表（所有非黑名单的部分）
        const candidates = filteredParts.length > 0 ? filteredParts : parts.slice(-1);

        return {
          initiator: initiator || null,
          attrName: attrName || null,
          candidates: candidates,
        };
      } catch (e) {
        console.warn('[DICE]parseMvuPathForDice 解析路径时出错', e);
        return { initiator: null, attrName: null, candidates: [] };
      }
    }

    // ===== 私有变量 =====
    const MODULE_ID = '__mvu__';
    let cachedEraData = null; // 缓存 ERA 数据
    let cachedEraDataChatId: string | null = null;

    function getCurrentChatIdSafe(): string | null {
      const ST = window.SillyTavern || window.parent?.SillyTavern;
      try {
        return typeof ST?.getCurrentChatId === 'function' ? ST.getCurrentChatId() : null;
      } catch {
        return null;
      }
    }

    function clearMvuCacheIfChatChanged() {
      const chatId = getCurrentChatIdSafe();
      if (!cachedEraData) return;
      if (!chatId) return;
      if (cachedEraDataChatId && cachedEraDataChatId !== chatId) {
        cachedEraData = null;
        cachedEraDataChatId = null;
      }
    }

    function isLwbChatContext(): boolean {
      const lwbGuard = globalThis.LWB_Guard || window.LWB_Guard || window.parent?.LWB_Guard;
      if (typeof lwbGuard !== 'object' || lwbGuard === null) return false;

      const ST = window.SillyTavern || window.parent?.SillyTavern;
      const chatMetadata = ST?.chatMetadata;
      if (typeof chatMetadata !== 'object' || chatMetadata === null) return false;

      // 关键修复：如果 ERA 框架存在且有 ERA 数据，优先使用 ERA 而非 LWB
      const eventEmit = window.eventEmit || window.parent?.eventEmit;
      const eventOn = window.eventOn || window.parent?.eventOn;
      if (typeof eventEmit === 'function' && typeof eventOn === 'function') {
        const variablesUnknown = (chatMetadata as { variables?: unknown }).variables;
        if (typeof variablesUnknown === 'object' && variablesUnknown !== null) {
          const variables = variablesUnknown as Record<string, unknown>;
          // 如果有 ERA 保留键，明确是 ERA 卡
          if (variables.ERAMetaData !== undefined || variables.stat_data !== undefined) {
            return false;
          }
        }
      }

      // 关键修复：如果 MVU 框架存在，优先使用 MVU 而非 LWB
      // MVU 数据存储在消息楼层变量中，不在 chatMetadata.variables 中
      // 因此即使 chatMetadata 有 LWB_* 残留键，也应该优先使用 MVU
      if (typeof window.Mvu !== 'undefined' && typeof window.Mvu.getMvuData === 'function') {
        // MVU 框架可用，尝试检查是否有 MVU 数据
        try {
          const mvuData = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });
          // 如果能成功获取 MVU 数据（即使 stat_data 为空），说明这是 MVU 卡
          if (mvuData !== null && mvuData !== undefined) {
            return false;
          }
        } catch {
          // MVU 获取失败，继续检查 LWB
        }
      }

      // LWB_Guard 是全局的，安装扩展后一直存在，不能作为单独判据。
      // 必须有明确的 LWB 标记才能判定为 LWB 卡。

      // 检查 chatMetadata 顶层是否有 LWB_* 标记
      const hasLwbMetaKey = Object.keys(chatMetadata).some(k => k.startsWith('LWB_') || k.startsWith('lwb_'));
      if (hasLwbMetaKey) return true;

      const variablesUnknown = (chatMetadata as { variables?: unknown }).variables;
      if (typeof variablesUnknown !== 'object' || variablesUnknown === null) return false;

      const variables = variablesUnknown as Record<string, unknown>;

      // 检查 variables 中是否有 LWB_* 标记
      const hasLwbVarKey = Object.keys(variables).some(k => k.startsWith('LWB_') || k.startsWith('lwb_'));
      if (hasLwbVarKey) return true;

      // 关键修复：只有当有明确的 LWB 标记时才认为是 LWB
      // 不再使用启发式检测（JSON 字符串值），因为这会误判 MVU 卡
      // MVU 卡的数据存储在消息楼层变量中，不在 chatMetadata.variables 中
      // 如果没有 LWB_* 标记，就不是 LWB 卡
      return false;
    }

    // ===== 检测当前聊天是否有 ERA 特征数据 =====
    function hasEraDataInCurrentChat(): boolean {
      const ST = window.SillyTavern || window.parent?.SillyTavern;
      const chatMetadata = ST?.chatMetadata;
      if (typeof chatMetadata !== 'object' || chatMetadata === null) return false;

      const variablesUnknown = (chatMetadata as { variables?: unknown }).variables;
      if (typeof variablesUnknown !== 'object' || variablesUnknown === null) return false;

      const variables = variablesUnknown as Record<string, unknown>;
      // ERA 特征：有 ERAMetaData 或 stat_data 键
      return variables.ERAMetaData !== undefined || variables.stat_data !== undefined;
    }

    // ===== 智能检测变量源 =====
    function detectMode() {
      clearMvuCacheIfChatChanged();

      // 如果有缓存数据，检查数据来源标记
      if (cachedEraData && cachedEraData._source) {
        return cachedEraData._source;
      }

      // [新增] 优先检测 LWB (小白X)，因为 LWB 需要特殊处理
      if (isLwbChatContext()) {
        console.log('[DICE]MvuModule 智能检测到 LWB (小白X) 框架');
        return 'lwb';
      }

      // 检测 ERA：框架存在 且 当前聊天有 ERA 特征数据
      const eventEmit = window.eventEmit || window.parent?.eventEmit;
      const eventOn = window.eventOn || window.parent?.eventOn;
      const eraFrameworkExists = typeof eventEmit === 'function' && typeof eventOn === 'function';

      if (eraFrameworkExists && hasEraDataInCurrentChat()) {
        console.log('[DICE]MvuModule 智能检测到 ERA 框架（当前聊天有 ERA 数据）');
        return 'era';
      }

      // 其次检测 MVU
      if (typeof window.Mvu !== 'undefined' && typeof window.Mvu.getMvuData === 'function') {
        console.log('[DICE]MvuModule 智能检测到 MVU 框架');
        return 'mvu';
      }

      // 如果 ERA 框架存在但当前聊天无数据，仍返回 ERA（新建聊天场景）
      if (eraFrameworkExists) {
        console.log('[DICE]MvuModule 智能检测到 ERA 框架（新聊天，无数据）');
        return 'era';
      }

      // 默认 MVU
      console.log('[DICE]MvuModule 未检测到框架，默认使用 MVU 模式');
      return 'mvu';
    }

    // ===== 增强的智能检测（带数据验证）=====
    async function detectModeWithData() {
      // [新增] 1. 优先尝试 LWB（因为需要特殊处理）
      if (isLwbChatContext()) {
        const lwbData = getLwbData();
        console.log('[DICE]检测到 LWB 框架，数据条目数:', Object.keys(lwbData.stat_data).length);
        return { mode: 'lwb', data: lwbData };
      }

      // 2. 检测 ERA：框架存在 且 当前聊天有 ERA 特征数据
      const eventEmit = window.eventEmit || window.parent?.eventEmit;
      const eventOn = window.eventOn || window.parent?.eventOn;
      const eraFrameworkExists = typeof eventEmit === 'function' && typeof eventOn === 'function';

      if (eraFrameworkExists && hasEraDataInCurrentChat()) {
        try {
          // 尝试实际获取 ERA 数据（带超时）
          const eraData = await Promise.race([
            getEraData(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('ERA timeout')), 2000)),
          ]);

          if (eraData && eraData.stat_data) {
            console.log('[DICE]检测到 ERA 框架且数据可用');
            return { mode: 'era', data: eraData };
          }
        } catch (e) {
          console.warn('[DICE]ERA 框架存在但数据不可用:', e.message);
        }
      }

      // 3. 尝试 MVU
      try {
        await waitGlobalInitialized('Mvu');

        if (typeof window.Mvu !== 'undefined' && typeof window.Mvu.getMvuData === 'function') {
          const mvuData = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });

          if (mvuData && mvuData.stat_data) {
            console.log('[DICE]检测到 MVU 框架且数据可用');
            return {
              mode: 'mvu',
              data: {
                stat_data: mvuData.stat_data || null,
                display_data: mvuData.display_data || {},
                delta_data: mvuData.delta_data || {},
                schema: mvuData.schema || null,
                _source: 'mvu', // 标记数据来源
              },
            };
          }
        }
      } catch (e) {
        console.warn('[DICE]MVU 框架检测失败:', e);
      }

      // 3. 都不可用，返回默认 MVU 模式（向后兼容）
      console.warn('[DICE]未检测到可用的变量框架，默认使用 MVU 模式');
      return { mode: 'mvu', data: null };
    }

    // ===== LWB (小白X) 数据获取函数 =====
    // JSON解析辅助函数（基于 LWB 源码分析，只需单次解析）
    // 注意：LWB 不存在双重序列化，只做单次 JSON.parse
    function parseJsonSafe(value: unknown): unknown {
      if (typeof value !== 'string') return value;

      const trimmed = value.trim();
      if (!trimmed.startsWith('{') && !trimmed.startsWith('[')) return value;

      try {
        return JSON.parse(trimmed) as unknown;
      } catch {
        return value;
      }
    }

    // 获取小白X变量数据
    function getLwbData() {
      try {
        // iframe 兼容的 SillyTavern 访问
        const ST = window.SillyTavern || window.parent?.SillyTavern;
        const variables = ST?.chatMetadata?.variables || {};
        const stat_data: Record<string, unknown> = {};

        for (const [key, value] of Object.entries(variables)) {
          // 跳过小白X内部键（防御性编程）
          if (key.startsWith('LWB_') || key.startsWith('lwb_')) continue;

          // 使用 parseJsonSafe 处理 JSON 字符串（单次解析）
          const parsed = parseJsonSafe(value);

          // 只保留嵌套对象（plot-log特征）
          if (typeof parsed === 'object' && parsed !== null) {
            stat_data[key] = parsed;
          }
        }

        // 关键：始终返回对象，即使 stat_data 为空
        // 确保 _source: 'lwb' 进入缓存，使 detectMode() 返回 'lwb'
        // 注意：不在此处更新 cachedEraData，由调用方负责
        return {
          stat_data,
          display_data: {},
          delta_data: {},
          _source: 'lwb',
        };
      } catch (e) {
        console.warn('[DICE]获取LWB变量失败:', e);
        // 即使出错也返回空的 LWB 数据对象，确保模式标记正确
        return {
          stat_data: {},
          display_data: {},
          delta_data: {},
          _source: 'lwb',
        };
      }
    }

    // ===== ERA 数据获取函数 =====
    // 异步获取ERA变量数据
    async function getEraData() {
      return new Promise(resolve => {
        const timeoutId = setTimeout(() => {
          console.warn('[DICE]MvuModule ERA查询超时');
          resolve(null);
        }, 5000);

        // 尝试获取 eventEmit 和 eventOn（支持 iframe 环境）
        const eventEmit = window.eventEmit || window.parent?.eventEmit;
        const eventOn = window.eventOn || window.parent?.eventOn;
        const eventOff = window.eventOff || window.parent?.eventOff;

        const onResult = detail => {
          clearTimeout(timeoutId);
          // 移除事件监听（如果 eventOff 不可用，则忽略）
          if (typeof eventOff === 'function') {
            try {
              eventOff('era:queryResult', onResult);
            } catch (e) {
              console.warn('[DICE]MvuModule 移除事件监听失败:', e);
            }
          }

          // console.log('[DICE]MvuModule 收到ERA查询结果:', JSON.stringify(detail, null, 2));
          // console.log('[DICE]MvuModule detail.result:', JSON.stringify(detail.result, null, 2));

          if (detail.result && detail.result.error) {
            console.error('[DICE]MvuModule ERA查询失败:', detail.result.error);
            resolve(null);
            return;
          }

          const statData = detail.result?.statWithoutMeta || null;
          // console.log('[DICE]MvuModule 提取的 stat_data:', JSON.stringify(statData, null, 2));

          const result = {
            stat_data: statData,
            delta_data: {},
            schema: null,
            _source: 'era', // 标记数据来源
          };

          // 缓存数据
          cachedEraData = result;
          cachedEraDataChatId = getCurrentChatIdSafe();

          resolve(result);
        };

        try {
          console.log('[DICE]MvuModule 开始获取ERA数据...');
          console.log('[DICE]MvuModule ERA API 检查:', {
            eventEmit: typeof eventEmit === 'function',
            eventOn: typeof eventOn === 'function',
            eventOff: typeof eventOff === 'function',
          });

          if (typeof eventOn !== 'function') {
            console.error('[DICE]MvuModule eventOn 不可用');
            clearTimeout(timeoutId);
            resolve(null);
            return;
          }
          if (typeof eventEmit !== 'function') {
            console.error('[DICE]MvuModule eventEmit 不可用');
            clearTimeout(timeoutId);
            resolve(null);
            return;
          }

          eventOn('era:queryResult', onResult);
          eventEmit('era:getCurrentVars');
        } catch (e) {
          clearTimeout(timeoutId);
          console.error('[DICE]MvuModule ERA API调用失败:', e);
          resolve(null);
        }
      });
    }

    // ERA 变量设置函数
    async function setEraValue(path, newValue) {
      return new Promise(resolve => {
        const timeoutId = setTimeout(() => {
          console.warn('[DICE]MvuModule ERA写入超时');
          resolve(false);
        }, 5000);

        // 尝试获取 eventEmit 和 eventOn（支持 iframe 环境）
        const eventEmit = window.eventEmit || window.parent?.eventEmit;
        const eventOn = window.eventOn || window.parent?.eventOn;
        const eventOff = window.eventOff || window.parent?.eventOff;

        const onWriteDone = detail => {
          clearTimeout(timeoutId);
          if (typeof eventOff === 'function') {
            eventOff('era:writeDone', onWriteDone);
          }
          console.log('[DICE]MvuModule ERA写入成功');
          resolve(true);
        };

        try {
          console.log('[DICE]MvuModule 开始设置ERA变量:', path, newValue);

          if (typeof eventOn !== 'function') {
            console.error('[DICE]MvuModule eventOn 不可用');
            clearTimeout(timeoutId);
            resolve(false);
            return;
          }
          if (typeof eventEmit !== 'function') {
            console.error('[DICE]MvuModule eventEmit 不可用');
            clearTimeout(timeoutId);
            resolve(false);
            return;
          }

          eventOn('era:writeDone', onWriteDone);
          eventEmit('era:updateByPath', {
            path: path,
            value: newValue,
          });
        } catch (e) {
          clearTimeout(timeoutId);
          console.error('[DICE]MvuModule ERA API调用失败:', e);
          resolve(false);
        }
      });
    }

    // ===== 样式定义 =====
    const STYLES = `
            /* MVU 面板容器 */
            .acu-mvu-panel {
                height: 100%;
                display: flex;
                flex-direction: column;
                min-height: 300px; /* 确保面板有足够的最小高度，避免显示为白条 */
                overflow: hidden; /* 不在这里滚动，让父容器处理 */
            }
            .acu-mvu-panel .acu-panel-header {
                background: var(--acu-table-head);
                border-bottom: 1px solid var(--acu-border);
                padding: 10px 12px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                flex-shrink: 0;
            }
            .acu-mvu-panel .acu-panel-header .acu-panel-title {
                display: flex;
                align-items: center;
                gap: 8px;
                font-weight: 600;
                color: var(--acu-text-main);
            }
            .acu-mvu-panel .acu-panel-header .acu-panel-title i {
                color: var(--acu-accent);
            }
            .acu-mvu-panel .acu-header-actions {
                display: flex;
                gap: 4px;
            }
            .acu-mvu-panel .mvu-header-btn {
                background: transparent;
                border: none;
                color: var(--acu-text-sub);
                cursor: pointer;
                padding: 4px;
                font-size: 14px;
                border-radius: 4px;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 4px;
            }
            .acu-mvu-panel .mvu-header-btn:hover {
                background: transparent;
                color: var(--acu-accent);
            }
            .acu-mvu-panel .mvu-header-btn.active {
                background: transparent;
                color: var(--acu-accent);
                font-weight: bold;
            }
            /* [新增] 数值模式样式 */
            .mvu-numeric-mode {
                padding: 0;
            }
            .mvu-numeric-level-controls {
                position: sticky;
                top: 0;
                z-index: 10;
            }
            /* [新增] 可折叠层级控制样式 */
            .mvu-level-controls-collapsible {
                margin-bottom: 8px;
            }
            .mvu-level-controls-header {
                transition: background 0.2s;
            }
            .mvu-level-controls-header:hover {
                background: var(--acu-table-hover) !important;
            }
            .mvu-level-controls-body {
                overflow-y: auto;
                overflow-x: hidden;
                transition: max-height 0.3s ease-out, padding-top 0.3s ease-out, padding-bottom 0.3s ease-out, border-bottom 0.3s ease-out;
                max-height: 300px; /* 限制最大高度，超出时可滚动 */
                scrollbar-width: thin;
            }
            /* 移动端使用更小的最大高度 */
            @media (max-width: 768px) {
                .mvu-level-controls-body {
                    max-height: 200px;
                }
            }
            .mvu-level-controls-body::-webkit-scrollbar {
                width: 6px;
            }
            .mvu-level-controls-body::-webkit-scrollbar-track {
                background: transparent;
            }
            .mvu-level-controls-body::-webkit-scrollbar-thumb {
                background: var(--acu-border);
                border-radius: 3px;
            }
            .mvu-level-controls-body::-webkit-scrollbar-thumb:hover {
                background: var(--acu-text-sub);
            }
            .mvu-level-controls-collapsible.collapsed .mvu-level-controls-body {
                max-height: 0 !important;
                padding-top: 0 !important;
                padding-bottom: 0 !important;
                border-bottom: none !important;
                margin: 0 !important;
            }
            .mvu-level-controls-toggle-icon {
                transition: transform 0.3s ease-out;
            }
            .mvu-level-controls-collapsible.collapsed .mvu-level-controls-toggle-icon {
                transform: rotate(-90deg);
            }
            .mvu-numeric-items {
                max-height: calc(100vh - 200px);
                overflow-y: auto;
            }
            .mvu-numeric-item {
                transition: background 0.2s;
            }
            .mvu-numeric-item:hover {
                background: var(--acu-table-hover) !important;
            }
            .mvu-dice-icon {
                transition: opacity 0.2s, transform 0.2s;
            }
            .mvu-dice-icon:hover {
                opacity: 1 !important;
                transform: scale(1.1);
            }
            .mvu-level-toggle:hover {
                opacity: 1 !important;
            }
            .mvu-level-toggle[data-visible="true"]:hover {
                background: var(--acu-accent) !important;
                color: var(--acu-btn-active-text) !important;
                border-color: var(--acu-accent) !important;
            }
            .mvu-level-toggle[data-visible="false"]:hover,
            .mvu-level-toggle[data-visible=""]:hover {
                background: var(--acu-table-hover) !important;
                color: var(--acu-text-sub) !important;
                border-color: var(--acu-border) !important;
            }

            /* MVU 内容区 - 始终使用竖向滚动模式 */
            .mvu-content {
                display: flex;
                flex-direction: column;
                overflow-x: hidden;
                overflow-y: auto; /* 直接在内容区启用滚动 */
                flex: 1 1 auto;
                min-height: 0; /* 关键：允许 flex 子项缩小以启用滚动 */
                max-height: 100%; /* 限制最大高度为父容器 */
                padding: 12px;
                scrollbar-width: thin;
            }
            .mvu-content::-webkit-scrollbar {
                display: none;
            }
            .mvu-content .mvu-card {
                flex: 0 0 auto; /* 不拉伸，保持自然高度 */
                min-width: 100%;
                max-width: 100%;
                width: 100%;
            }
            /* MVU面板始终支持滚动 */
            .acu-mvu-panel {
                overflow-y: auto !important;
                overflow-x: hidden !important;
                flex: 1 1 0; /* 关键：使用 flex-basis: 0 让容器可以正确计算滚动 */
                min-height: 300px; /* 确保面板有足够的最小高度，避免显示为白条 */
            }

            /* MVU 卡片 */
            .mvu-card {
                background: var(--acu-bg-panel);
                border: 1px solid var(--acu-border);
                border-radius: 8px;
                margin-bottom: 10px;
                overflow: hidden;
            }
            .mvu-card:last-child {
                margin-bottom: 0;
            }
            .mvu-card-header {
                background: var(--acu-table-head);
                padding: 8px 12px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                cursor: pointer;
                user-select: none;
                transition: background 0.2s;
            }
            .mvu-card-header:hover {
                background: var(--acu-table-hover);
            }
            .mvu-card-title {
                font-weight: 600;
                color: var(--acu-accent);
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .mvu-card-count {
                font-size: 11px;
                color: var(--acu-text-sub);
                font-weight: normal;
            }
            .mvu-card-toggle {
                color: var(--acu-text-sub);
                font-size: 10px;
                transition: transform 0.2s;
            }
            .mvu-card.collapsed .mvu-card-toggle {
                transform: rotate(-90deg);
            }
            .mvu-card-body {
                padding: 8px 12px;
                display: block;
                overflow: hidden; /* 为 slideUp/slideDown 动画提供支持 */
            }
            .mvu-card.collapsed .mvu-card-body {
                display: none;
            }

            /* 嵌套卡片 */
            .mvu-card .mvu-card {
                background: var(--acu-table-head);
                margin: 6px 0;
            }
            .mvu-card .mvu-card .mvu-card-header {
                background: rgba(128,128,128,0.1);
                padding: 6px 10px;
            }
            .mvu-card .mvu-card .mvu-card-body {
                padding: 6px 10px;
            }

            /* 嵌套卡片横向布局 - 只对嵌套卡片生效，键值对保持正常块级显示 */
            .mvu-card-body.horizontal-nested {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 12px;
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 8px;
                align-items: flex-start;
            }
            /* 如果父卡片有 has-nested-cards 类，使用 wrap 布局，让键值对和嵌套卡片可以换行 */
            .mvu-card.has-nested-cards .mvu-card-body.horizontal-nested {
                flex-wrap: wrap;
            }
            /* 键值对行保持正常块级显示，占满一行 */
            .mvu-card-body.horizontal-nested > .mvu-row {
                display: flex;
                flex: 0 0 100%;
                width: 100%;
                max-width: 100%; /* 确保不超过容器宽度 */
                box-sizing: border-box;
            }
            /* 如果父卡片有 has-nested-cards 类，键值对应该根据内容自适应宽度，但仍然占满一行 */
            .mvu-card.has-nested-cards .mvu-card-body.horizontal-nested > .mvu-row {
                flex: 0 0 auto; /* 根据内容自适应宽度 */
                min-width: 100%; /* 确保占满一行 */
                width: auto; /* 根据内容自适应宽度 */
                max-width: 450px; /* 限制键值对的最大宽度，避免占用过多横向空间 */
                box-sizing: border-box;
            }
            @media (min-width: 769px) {
                .mvu-card.has-nested-cards .mvu-card-body.horizontal-nested > .mvu-row {
                    max-width: 550px; /* 大屏幕下也限制键值对的最大宽度 */
                }
            }
            /* 只有嵌套卡片才横向排列 - 智能宽度 */
            .mvu-card-body.horizontal-nested > .mvu-card {
                flex: 0 0 auto; /* 根据内容自动调整宽度 */
                min-width: 200px;
                max-width: 350px;
                width: auto;
            }
            /* 如果嵌套卡片内部也有横向排列的子卡片，移除最大宽度限制，允许根据内容自适应 */
            .mvu-card-body.horizontal-nested > .mvu-card.has-nested-cards {
                min-width: 400px; /* 为包含嵌套卡片的嵌套卡片设置更大的最小宽度 */
                max-width: none; /* 移除最大宽度限制，允许根据内容自适应 */
            }
            @media (min-width: 769px) {
                .mvu-card-body.horizontal-nested > .mvu-card {
                    min-width: 240px;
                    max-width: 400px;
                }
                .mvu-card-body.horizontal-nested > .mvu-card.has-nested-cards {
                    min-width: 500px; /* 为包含嵌套卡片的嵌套卡片设置更大的最小宽度 */
                    max-width: none; /* 移除最大宽度限制，允许根据内容自适应 */
                }
            }

            /* 键值对行 */
            .mvu-row {
                display: flex;
                align-items: flex-start;
                padding: 5px 0;
                border-bottom: 1px dashed var(--acu-border);
            }
            .mvu-row:last-child {
                border-bottom: none;
            }
            .mvu-key {
                color: var(--acu-text-sub);
                min-width: 80px;
                max-width: 120px;
                flex-shrink: 0;
                font-size: 12px;
                padding-right: 8px;
                word-break: break-all;
            }
            .mvu-value-wrap {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 6px;
                min-width: 0;
            }
            .mvu-value {
                color: var(--acu-text-main);
                font-size: var(--acu-font-size, 13px);
                cursor: pointer;
                padding: 1px 6px;
                border-radius: 4px;
                transition: background 0.2s;
                word-break: break-word;
                flex: 0 1 auto;
            }
            .mvu-value:hover {
                background: var(--acu-table-hover);
            }
            .mvu-value.mvu-array-value {
                font-size: calc(var(--acu-font-size, 13px) * 0.92);
                color: var(--acu-text-sub);
            }
            .mvu-change-indicator {
                color: var(--acu-success-text);
                font-weight: bold;
                font-size: 12px;
                flex-shrink: 0;
            }
            .mvu-row.mvu-changed {
                background: var(--acu-success-bg);
                margin: 0 -12px;
                padding: 5px 12px;
                border-radius: 4px;
            }
            .mvu-card .mvu-card .mvu-row.mvu-changed {
                margin: 0 -10px;
                padding: 5px 10px;
            }

            /* 空状态 */
            .mvu-empty {
                text-align: center;
                padding: 40px 20px;
                color: var(--acu-text-sub);
                flex: 1;
                min-width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            .mvu-empty i {
                font-size: 32px;
                margin-bottom: 12px;
                display: block;
                opacity: 0.5;
            }
            .mvu-empty p {
                margin: 0 0 6px 0;
            }
            .mvu-empty .mvu-empty-hint {
                font-size: 12px;
                opacity: 0.7;
            }

            /* 编辑弹窗 */
            .mvu-edit-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 99999;
                animation: mvuFadeIn 0.15s ease-out;
            }
            .mvu-edit-dialog {
                background: var(--acu-bg-panel);
                border: 1px solid var(--acu-border);
                border-radius: 8px;
                padding: 16px;
                width: 90%;
                max-width: 400px;
                animation: mvuSlideIn 0.2s ease-out;
            }
            .mvu-edit-title {
                font-weight: 600;
                color: var(--acu-text-main);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .mvu-edit-path {
                font-size: 11px;
                color: var(--acu-text-sub);
                background: var(--acu-table-head);
                padding: 6px 10px;
                border-radius: 4px;
                margin-bottom: 12px;
                word-break: break-all;
                font-family: monospace;
            }
            .mvu-edit-textarea {
                width: 100%;
                min-height: 80px;
                padding: 10px;
                border: 1px solid var(--acu-border);
                border-radius: 4px;
                background: var(--acu-input-bg, var(--acu-bg-panel));
                color: var(--acu-text-main);
                font-size: 13px;
                resize: vertical;
                box-sizing: border-box;
            }
            .mvu-edit-textarea:focus {
                outline: none;
                border-color: var(--acu-accent);
            }
            .mvu-edit-hint {
                font-size: 11px;
                color: var(--acu-text-sub);
                margin-top: 8px;
                opacity: 0.7;
            }
            .mvu-edit-btns {
                display: flex;
                justify-content: flex-end;
                gap: 8px;
                margin-top: 16px;
            }
            .mvu-edit-btn {
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 13px;
                display: flex;
                align-items: center;
                gap: 6px;
                transition: all 0.2s;
            }
            .mvu-edit-btn.mvu-btn-cancel {
                background: transparent;
                border: 1px solid var(--acu-border);
                color: var(--acu-text-sub);
            }
            .mvu-edit-btn.mvu-btn-cancel:hover {
                background: var(--acu-table-hover);
            }
            .mvu-edit-btn.mvu-btn-save {
                background: var(--acu-accent);
                border: 1px solid var(--acu-accent);
                color: var(--acu-btn-active-text);
            }
            .mvu-edit-btn.mvu-btn-save:hover {
                opacity: 0.9;
            }

            @keyframes mvuFadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes mvuSlideIn {
                from { transform: translateY(-20px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }

            /* 导航按钮 */
            .acu-nav-btn.acu-mvu-btn.active {
                background: var(--acu-btn-active-bg);
                color: var(--acu-btn-active-text);
            }
        `;

    // ===== 工具函数 =====
    function escapeHtml(s) {
      return String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function isAvailable() {
      const mode = detectMode();

      if (mode === 'era') {
        // ERA 模式：检查 eventEmit 和 eventOn 是否可用（支持 iframe 环境）
        const eventEmit = window.eventEmit || window.parent?.eventEmit;
        const eventOn = window.eventOn || window.parent?.eventOn;
        const emitAvailable = typeof eventEmit === 'function';
        const onAvailable = typeof eventOn === 'function';
        return emitAvailable && onAvailable;
      } else if (mode === 'lwb') {
        // [新增] LWB 模式：检查 chatMetadata.variables 是否可访问
        const ST = window.SillyTavern || window.parent?.SillyTavern;
        return ST?.chatMetadata !== undefined;
      } else {
        // MVU 模式：检查 MVU 框架是否加载
        const mvuAvailable = typeof window.Mvu !== 'undefined' && typeof window.Mvu.getMvuData === 'function';
        return mvuAvailable;
      }
    }

    function getData() {
      console.warn('[DICE]警告: getData() 是同步函数，可能无法正确获取 MVU 数据。建议使用 getDataWithRetry()');

      clearMvuCacheIfChatChanged();

      // 优先返回缓存（可能来自 ERA 或 MVU）
      if (cachedEraData) {
        return cachedEraData;
      }

      // [新增] 尝试同步获取 LWB
      if (isLwbChatContext()) {
        const lwbData = getLwbData();
        cachedEraData = lwbData;
        cachedEraDataChatId = getCurrentChatIdSafe();
        console.log('[DICE]LWB 数据同步获取成功');
        return lwbData;
      }

      // 尝试同步获取 MVU（可能失败）
      try {
        if (typeof window.Mvu !== 'undefined' && typeof window.Mvu.getMvuData === 'function') {
          const allVars = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });

          if (allVars && allVars.stat_data) {
            const data = {
              stat_data: allVars.stat_data || null,
              display_data: allVars.display_data || {},
              delta_data: allVars.delta_data || {},
              schema: allVars.schema || null,
              _source: 'mvu', // 标记数据来源
            };

            cachedEraData = data; // 更新缓存
            cachedEraDataChatId = getCurrentChatIdSafe();
            return data;
          }
        }
      } catch (e) {
        console.warn('[DICE]同步获取 MVU 数据失败:', e);
      }

      return null;
    }

    // ===== MVU 专用重试函数 =====
    async function getMvuDataWithRetry(maxRetries = 3, retryDelay = 500) {
      try {
        // [修复] 首先检查 MVU API 是否已经可用，避免不必要的等待
        if (typeof window.Mvu === 'undefined' || typeof window.Mvu.getMvuData !== 'function') {
          // 只有在 MVU 未初始化时才等待，使用较短的超时时间
          try {
            await Promise.race([
              waitGlobalInitialized('Mvu'),
              new Promise((_, reject) => setTimeout(() => reject(new Error('等待 MVU 初始化超时')), 3000)),
            ]);
          } catch (e) {
            console.warn('[DICE]等待 MVU 初始化失败，尝试直接获取:', e.message);
            // 继续尝试，可能 MVU 已经部分可用
          }
        }

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            if (typeof window.Mvu === 'undefined' || typeof window.Mvu.getMvuData !== 'function') {
              throw new Error('MVU API 不可用');
            }

            const allVars = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });

            if (allVars && allVars.stat_data) {
              const data = {
                stat_data: allVars.stat_data || null,
                display_data: allVars.display_data || {},
                delta_data: allVars.delta_data || {},
                schema: allVars.schema || null,
                _source: 'mvu', // 标记数据来源
              };

              // 为 MVU 也添加缓存
              cachedEraData = data;
              cachedEraDataChatId = getCurrentChatIdSafe();
              console.log('[DICE]MVU 数据获取成功');
              return data;
            }
          } catch (e) {
            console.warn(`[DICE]MVU 数据获取失败 (尝试 ${attempt}/${maxRetries}):`, e);
          }

          if (attempt < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }

        return null;
      } catch (e) {
        console.error('[DICE]MVU 初始化失败:', e);
        return null;
      }
    }

    // 支持重试获取数据的函数
    async function getDataWithRetry(maxRetries = 3, retryDelay = 500) {
      try {
        // 使用增强的检测函数
        const detection = await detectModeWithData();

        // 如果检测时已经获取到数据，直接返回
        if (detection.data) {
          cachedEraData = detection.data; // 更新缓存
          cachedEraDataChatId = getCurrentChatIdSafe();
          return detection.data;
        }

        // 否则根据模式进行重试
        const mode = detection.mode;

        if (mode === 'era') {
          // ERA 模式：重试获取
          for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
              const data = await getEraData();
              if (data && data.stat_data) {
                cachedEraData = data;
                cachedEraDataChatId = getCurrentChatIdSafe();
                return data;
              }
            } catch (e) {
              console.warn(`[DICE]ERA 数据获取失败 (尝试 ${attempt}/${maxRetries}):`, e);
            }

            if (attempt < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          }

          // ERA 失败，尝试降级到 MVU
          console.warn('[DICE]ERA 数据获取失败，尝试降级到 MVU');
          return await getMvuDataWithRetry(maxRetries, retryDelay);
        } else if (mode === 'lwb') {
          // [新增] LWB 模式：重新获取
          const lwbData = getLwbData();
          cachedEraData = lwbData;
          cachedEraDataChatId = getCurrentChatIdSafe();
          return lwbData;
        } else {
          // MVU 模式
          return await getMvuDataWithRetry(maxRetries, retryDelay);
        }
      } catch (e) {
        console.error('[DICE]数据获取失败:', e);
        return null;
      }
    }

    // 判断是否是 ValueWithDescription 格式 [值, "描述"]
    function isVWD(value) {
      return (
        Array.isArray(value) &&
        value.length === 2 &&
        typeof value[1] === 'string' &&
        (typeof value[0] === 'number' || typeof value[0] === 'string' || typeof value[0] === 'boolean')
      );
    }

    // 判断是否是简单数组（元素都是原始值）
    function isSimpleArray(value) {
      if (!Array.isArray(value)) return false;
      return value.every(
        item => typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean' || item === null,
      );
    }

    // 获取变化指示器
    function getChangeIndicator(path, deltaData) {
      if (!deltaData || !path) return '';

      const parts = path.split('.');
      let current = deltaData;
      for (const part of parts) {
        if (current === null || current === undefined) return '';
        current = current[part];
      }

      if (!current) return '';

      if (typeof current === 'string' && current.includes('->')) {
        const match = current.match(/^(-?[\d.]+)->(-?[\d.]+)/);
        if (match) {
          const oldVal = parseFloat(match[1]);
          const newVal = parseFloat(match[2]);
          if (!isNaN(oldVal) && !isNaN(newVal)) {
            return newVal > oldVal ? '↑' : newVal < oldVal ? '↓' : '';
          }
        }
        return '•';
      }
      return '';
    }

    // 统计对象/数组的子项数量
    function countChildren(value) {
      if (Array.isArray(value)) {
        if (isVWD(value)) return 0;
        return value.length;
      }
      if (value && typeof value === 'object') {
        return Object.keys(value).filter(k => !k.startsWith('$')).length;
      }
      return 0;
    }

    // ===== 渲染函数 =====

    // 智能提取数值部分的显示值
    // 处理三种情况：纯数值、数值+描述、数值+范围+描述
    function extractNumericDisplayValue(value, isArray = false) {
      // 处理 null/undefined
      if (value === null || value === undefined) {
        return '';
      }

      // 数组类型：保持原有逻辑
      if (isArray || Array.isArray(value)) {
        if (isVWD(value)) {
          return String(value[0]);
        } else if (isSimpleArray(value)) {
          return value.map(v => String(v ?? '')).join(', ');
        } else {
          // 复杂数组，返回原始表示
          return String(value);
        }
      }

      // 转换为字符串处理
      const str = String(value).trim();

      // 1. 纯数值：匹配纯数字格式（如 "85", "-20", "100%"）
      if (/^-?\d+(\.\d+)?%?$/.test(str)) {
        return str;
      }

      // 2. 数值+范围+描述：匹配 "数值,[范围] 描述" 格式
      // 例如："0,[-20, 120] 对User的好感度。通过积极互动提升..."
      const rangeMatch = str.match(/^(-?\d+(?:\.\d+)?%?)(,\s*\[[^\]]+\])?\s+/);
      if (rangeMatch) {
        // 如果匹配到范围部分，返回数值和范围
        if (rangeMatch[2]) {
          return rangeMatch[1] + rangeMatch[2].trim();
        }
        // 如果没有范围，只返回数值部分
        return rangeMatch[1];
      }

      // 2.5. 数值/数值,描述：匹配 "数值/数值,描述" 格式
      // 例如："100/100,当前/最大生命值，格式为'当前/最大'。归零时你将陷入濒死或死亡状态。"
      const slashNumericMatch = str.match(/^(-?\d+(?:\.\d+)?%?\/-?\d+(?:\.\d+)?%?),/);
      if (slashNumericMatch) {
        return slashNumericMatch[1];
      }

      // 3. 数值,描述：匹配 "数值,描述" 格式（逗号后直接跟描述，没有空格和方括号）
      // 例如："150000,记录当前持有的资金，单位为蓝星币..."
      const commaDescMatch = str.match(/^(-?\d+(?:\.\d+)?%?),/);
      if (commaDescMatch) {
        return commaDescMatch[1];
      }

      // 4. 数值+描述：匹配 "数值 描述" 格式（数值后跟非数字字符）
      // 例如："85 对高坂月的好感度"
      const numericDescMatch = str.match(/^(-?\d+(?:\.\d+)?%?)\s+[^\d]/);
      if (numericDescMatch) {
        return numericDescMatch[1];
      }

      // 5. 其他情况：返回原始值
      return str;
    }

    // 从显示值中提取第一个数值（用于投骰）
    // 例如："85" -> 85, "85,[0,100]" -> 85, "0,[-20, 120]" -> 0
    function extractFirstNumericValue(displayValue) {
      if (!displayValue) return 0;
      const str = String(displayValue).trim();

      // 提取第一个数字（支持负数、小数、百分比）
      const match = str.match(/^(-?\d+(?:\.\d+)?)/);
      if (match) {
        const num = parseFloat(match[1]);
        return isNaN(num) ? 0 : num;
      }

      return 0;
    }

    // 渲染单个键值对行
    function renderRow(key, value, path, deltaData) {
      const changeIndicator = getChangeIndicator(path, deltaData);
      const changedClass = changeIndicator ? 'mvu-changed' : '';

      let displayValue;
      let valueClass = 'mvu-value';

      if (isVWD(value)) {
        displayValue = String(value[0]);
      } else if (isSimpleArray(value)) {
        displayValue = value.map(v => String(v ?? '')).join(', ');
        valueClass += ' mvu-array-value';
      } else {
        // 使用智能提取函数，只显示数值部分
        displayValue = extractNumericDisplayValue(value ?? '', false);
      }

      // [新增] 判断是否为数字或包含数字，如果是则添加骰子图标
      let diceIconHtml = '';
      try {
        // 先使用 extractNumericDisplayValue 提取显示值，然后提取第一个数值
        // 这样可以正确处理 "85,[0,100]" 这样的格式，提取 85 而不是 100
        if (typeof isNumericCell === 'function' && isNumericCell(displayValue)) {
          // 从显示值中提取第一个数值（用于投骰）
          const numericValue = extractFirstNumericValue(displayValue);
          if (numericValue > 0) {
            // 提取属性名：优先使用 key，如果 key 包含路径信息则提取最后一部分
            let attrName = key;
            if (key.includes('.')) {
              const parts = key.split('.');
              attrName = parts[parts.length - 1];
            }
            // 如果路径也包含信息，尝试从路径提取属性名
            if (path && path.includes('.')) {
              const pathParts = path.split('.');
              const lastPart = pathParts[pathParts.length - 1];
              // 如果路径最后一部分看起来像属性名（不是纯数字），使用它
              if (lastPart && !/^\d+$/.test(lastPart) && lastPart !== key) {
                attrName = lastPart;
              }
            }
            diceIconHtml = `<i class="fa-solid fa-dice-d20 mvu-dice-icon acu-mvu-dice-icon" data-path="${escapeHtml(path)}" data-attr-name="${escapeHtml(attrName)}" data-attr-value="${numericValue}" title="快捷投骰"></i>`;
          }
        }
      } catch (e) {
        console.warn('[DICE]MvuModule renderRow: 判断数字时出错', e);
      }

      return `
                <div class="mvu-row ${changedClass}">
                    <div class="mvu-key">${escapeHtml(key)}</div>
                    <div class="mvu-value-wrap">
                        <span class="${valueClass}" data-path="${escapeHtml(path)}">${escapeHtml(displayValue)}</span>
                        ${diceIconHtml}
                        ${changeIndicator ? `<span class="mvu-change-indicator">${changeIndicator}</span>` : ''}
                    </div>
                </div>
            `;
    }

    // 渲染卡片（递归）
    function renderCard(key, value, path, deltaData, depth, defaultExpanded, isHorizontal) {
      const childCount = countChildren(value);
      const collapsedClass = defaultExpanded ? '' : 'collapsed';

      let bodyHtml = '';
      let hasNestedCards = false; // 标记是否有嵌套卡片
      let nestedCardCount = 0; // 统计嵌套卡片数量（用于计算宽度）
      let rowCount = 0; // 统计键值对数量

      if (Array.isArray(value) && !isVWD(value) && !isSimpleArray(value)) {
        // 复杂数组：每个元素作为子卡片或行
        value.forEach((item, index) => {
          const itemPath = `${path}[${index}]`;

          if (item && typeof item === 'object' && !isVWD(item) && !isSimpleArray(item)) {
            hasNestedCards = true;
            nestedCardCount++;
            bodyHtml += renderCard(`[${index}]`, item, itemPath, deltaData, depth + 1, false, isHorizontal);
          } else {
            rowCount++;
            bodyHtml += renderRow(`[${index}]`, item, itemPath, deltaData);
          }
        });
      } else if (value && typeof value === 'object' && !isVWD(value)) {
        // 对象：遍历键值
        const entries = Object.entries(value).filter(([k]) => !k.startsWith('$'));

        for (const [childKey, childValue] of entries) {
          const childPath = path ? `${path}.${childKey}` : childKey;

          if (childValue && typeof childValue === 'object' && !isVWD(childValue) && !isSimpleArray(childValue)) {
            // 嵌套对象/数组 → 子卡片
            hasNestedCards = true;
            nestedCardCount++;
            bodyHtml += renderCard(childKey, childValue, childPath, deltaData, depth + 1, false, isHorizontal);
          } else {
            // 原始值或简单数组 → 行
            rowCount++;
            bodyHtml += renderRow(childKey, childValue, childPath, deltaData);
          }
        }
      }

      const countText = Array.isArray(value) ? `[${childCount}]` : `(${childCount})`;

      // 如果是横向模式且有嵌套卡片，为 card-body 添加 horizontal-nested 类
      const bodyClass = isHorizontal && hasNestedCards ? 'mvu-card-body horizontal-nested' : 'mvu-card-body';

      // 检查嵌套卡片是否需要更大的宽度（递归检查）
      let nestedCardsNeedWidth = false;
      if (isHorizontal && hasNestedCards && depth === 0) {
        // 对于顶层卡片，检查嵌套卡片内部是否有多个子卡片（需要横向排列）
        if (Array.isArray(value) && !isVWD(value) && !isSimpleArray(value)) {
          // 数组：检查每个嵌套项
          value.forEach(item => {
            if (item && typeof item === 'object' && !isVWD(item) && !isSimpleArray(item)) {
              const itemChildCount = countChildren(item);
              if (itemChildCount >= 2) nestedCardsNeedWidth = true;
            }
          });
        } else if (value && typeof value === 'object' && !isVWD(value)) {
          // 对象：检查每个嵌套键值
          const entries = Object.entries(value).filter(([k]) => !k.startsWith('$'));
          for (const [childKey, childValue] of entries) {
            if (childValue && typeof childValue === 'object' && !isVWD(childValue) && !isSimpleArray(childValue)) {
              const childChildCount = countChildren(childValue);
              if (childChildCount >= 2) nestedCardsNeedWidth = true;
            }
          }
        }
      }

      // 在横向模式下，只有当卡片内部主要是嵌套卡片（键值对很少或没有）时，才添加 has-nested-cards 类
      // 这样可以避免键值对占用过多横向空间
      // 对于顶层卡片（depth === 0）：
      //   - 如果嵌套卡片数量 >= 2 且键值对数量 <= 1，添加 has-nested-cards
      //   - 或者，如果嵌套卡片本身需要更大的宽度（内部有多个子卡片），也添加 has-nested-cards
      // 对于嵌套卡片（depth > 0），只有当只有嵌套卡片（rowCount === 0）且嵌套卡片数量 >= 2 时，才添加 has-nested-cards
      const shouldAddHasNestedClass =
        isHorizontal &&
        hasNestedCards &&
        ((depth === 0 && ((nestedCardCount >= 2 && rowCount <= 1) || nestedCardsNeedWidth)) || // 顶层卡片：嵌套卡片数量 >= 2 且键值对 <= 1，或者嵌套卡片需要更大宽度
          (depth > 0 && rowCount === 0 && nestedCardCount >= 2)); // 嵌套卡片：没有键值对且嵌套卡片数量 >= 2
      const hasNestedClass = shouldAddHasNestedClass ? ' has-nested-cards' : '';

      return `
                <div class="mvu-card${hasNestedClass} ${collapsedClass}" data-path="${escapeHtml(path)}" data-depth="${depth}">
                    <div class="mvu-card-header">
                        <div class="mvu-card-title">
                            <span>${escapeHtml(key)}</span>
                            <span class="mvu-card-count">${countText}</span>
                        </div>
                        <span class="mvu-card-toggle">▼</span>
                    </div>
                    <div class="${bodyClass}">
                        ${bodyHtml}
                    </div>
                </div>
            `;
    }

    // [新增] 渲染数值过滤模式
    function renderNumericMode(mvuData) {
      if (!mvuData || !mvuData.stat_data) {
        return '<div class="mvu-empty"><i class="fa-solid fa-inbox"></i><p>当前没有变量数据</p></div>';
      }

      // [新增] 读取层级显示偏好
      let visibleLevels = {};
      try {
        const saved = localStorage.getItem('acu_mvu_numeric_mode_visible_levels');
        if (saved) {
          visibleLevels = JSON.parse(saved);
        }
      } catch (e) {
        console.warn('[DICE]MvuModule 读取层级显示偏好失败', e);
      }

      // 收集所有数值项
      const numericItems = [];

      // 递归遍历收集数值项
      function collectNumericItems(obj, path, levelNames) {
        if (!obj || typeof obj !== 'object') return;

        if (Array.isArray(obj)) {
          if (isVWD(obj) || isSimpleArray(obj)) {
            // 简单数组，检查每个元素
            obj.forEach((item, index) => {
              const itemPath = path ? `${path}[${index}]` : `[${index}]`;
              const itemValue = String(item ?? '').trim();
              if (typeof isNumericCell === 'function' && isNumericCell(itemValue)) {
                // 先提取显示值，然后提取第一个数值（用于投骰）
                const displayValue = extractNumericDisplayValue(itemValue, false);
                const numValue = extractFirstNumericValue(displayValue);
                if (numValue > 0) {
                  numericItems.push({
                    path: itemPath,
                    key: `[${index}]`,
                    value: itemValue,
                    numericValue: numValue,
                    levelNames: [...levelNames],
                  });
                }
              }
            });
          } else {
            // 复杂数组，递归处理
            obj.forEach((item, index) => {
              const itemPath = path ? `${path}[${index}]` : `[${index}]`;
              const newLevelNames = [...levelNames, `[${index}]`];
              collectNumericItems(item, itemPath, newLevelNames);
            });
          }
        } else {
          // 对象，遍历键值
          const entries = Object.entries(obj).filter(([k]) => !k.startsWith('$'));
          for (const [key, value] of entries) {
            const childPath = path ? `${path}.${key}` : key;
            const newLevelNames = [...levelNames, key];

            if (value && typeof value === 'object' && !isVWD(value) && !isSimpleArray(value)) {
              // 嵌套对象，递归处理
              collectNumericItems(value, childPath, newLevelNames);
            } else {
              // 原始值，检查是否为数字
              const itemValue = String(value ?? '').trim();
              if (typeof isNumericCell === 'function' && isNumericCell(itemValue)) {
                // 先提取显示值，然后提取第一个数值（用于投骰）
                const displayValue = extractNumericDisplayValue(itemValue, false);
                const numValue = extractFirstNumericValue(displayValue);
                if (numValue > 0) {
                  numericItems.push({
                    path: childPath,
                    key: key,
                    value: itemValue,
                    numericValue: numValue,
                    levelNames: newLevelNames,
                  });
                }
              }
            }
          }
        }
      }

      // 收集所有数值项
      const topKeys = Object.keys(mvuData.stat_data).filter(k => !k.startsWith('$'));
      for (const key of topKeys) {
        const value = mvuData.stat_data[key];
        collectNumericItems(value, key, [key]);
      }

      // [新增] 黑名单过滤：检查路径中的所有层级
      const filteredNumericItems = numericItems.filter(item => {
        // 获取所有非数组索引的层级名称
        const nonArrayLevels = item.levelNames.filter(level => level && !level.startsWith('['));
        // 检查路径中的任意层级是否在黑名单中
        // 只要有一个层级匹配黑名单，就过滤掉整个项
        for (const levelKey of nonArrayLevels) {
          if (BlacklistManager.isBlacklisted(levelKey)) {
            return false;
          }
        }
        return true;
      });

      if (filteredNumericItems.length === 0) {
        return '<div class="mvu-empty"><i class="fa-solid fa-filter"></i><p>当前没有数值项</p></div>';
      }

      // 收集所有唯一的层级名称（使用过滤后的列表）
      // 【修复 2】排除最下层的属性名，只收集层级名
      const allLevelNames = new Set();
      filteredNumericItems.forEach(item => {
        // 排除最下层的属性名，只收集层级名
        const hierarchyLevels =
          item.levelNames.length > 1
            ? item.levelNames.slice(0, -1) // 排除最后一个
            : [];

        hierarchyLevels.forEach(level => {
          if (level && !level.startsWith('[')) {
            // 排除数组索引
            allLevelNames.add(level);
          }
        });
      });

      const levelNamesArray = Array.from(allLevelNames).sort();

      // 生成层级 toggle 控制区域（可折叠）
      let levelTogglesHtml = '';
      if (levelNamesArray.length > 0) {
        // 生成层级按钮内容
        let levelButtonsHtml = '';
        levelNamesArray.forEach(levelName => {
          const isVisible = visibleLevels[levelName] !== false; // 默认显示
          const activeClass = isVisible ? 'active' : '';
          levelButtonsHtml += `<button class="mvu-level-toggle acu-mvu-level-toggle ${activeClass}" data-level="${escapeHtml(levelName)}" data-visible="${isVisible}" title="${isVisible ? '隐藏' : '显示'}层级: ${escapeHtml(levelName)}"><span>${escapeHtml(levelName)}</span></button>`;
        });

        // 包装为可折叠结构，默认折叠
        levelTogglesHtml = `
          <div class="mvu-level-controls-collapsible collapsed">
            <div class="mvu-level-controls-header acu-mvu-header">
              <span class="acu-mvu-header-text">显示层级</span>
              <i class="fa-solid fa-chevron-down mvu-level-controls-toggle-icon acu-mvu-toggle-icon"></i>
            </div>
            <div class="mvu-level-controls-body acu-mvu-body">
              ${levelButtonsHtml}
            </div>
          </div>
        `;
      }

      // 生成数值项列表（使用过滤后的列表）
      let itemsHtml = '';
      filteredNumericItems.forEach(item => {
        // 计算非数组层级（用于 data-levels 属性）
        const nonArrayLevels = item.levelNames.filter(level => !level.startsWith('['));

        // 根据层级显示偏好过滤显示的层级名称
        const visibleLevels = item.levelNames.filter(level => {
          if (level.startsWith('[')) return false; // 排除数组索引
          try {
            const saved = localStorage.getItem('acu_mvu_numeric_mode_visible_levels');
            if (saved) {
              const prefs = JSON.parse(saved);
              return prefs[level] !== false; // 默认显示
            }
          } catch (e) {
            // 忽略错误，默认显示
          }
          return true;
        });

        // 【修复 1】排除最下层名称，避免与属性名重复
        // 如果 visibleLevels 有多个元素，移除最后一个
        const pathLevels = visibleLevels.length > 1 ? visibleLevels.slice(0, -1) : [];

        // 检查该项的所有层级是否都可见（用于初始显示状态）
        // 注意：这里使用 nonArrayLevels 的前 N-1 个层级（排除最下层）
        const hierarchyLevels = nonArrayLevels.length > 1 ? nonArrayLevels.slice(0, -1) : [];

        const allLevelsVisible = hierarchyLevels.every(level => {
          try {
            const saved = localStorage.getItem('acu_mvu_numeric_mode_visible_levels');
            if (saved) {
              const prefs = JSON.parse(saved);
              return prefs[level] !== false; // 默认显示
            }
          } catch (e) {
            // 忽略错误，默认显示
          }
          return true;
        });

        // 生成路径显示（使用排除最下层后的层级）
        const pathDisplay = pathLevels.length > 0 ? pathLevels.join(' > ') : '';
        const attrName = item.key;

        // 提取属性名（从路径最后一部分）
        let finalAttrName = attrName;
        if (item.path && item.path.includes('.')) {
          const parts = item.path.split('.');
          finalAttrName = parts[parts.length - 1];
        }

        // 生成骰子图标
        const diceIconHtml = `<i class="fa-solid fa-dice-d20 mvu-dice-icon acu-mvu-dice-icon" data-path="${escapeHtml(item.path)}" data-attr-name="${escapeHtml(finalAttrName)}" data-attr-value="${item.numericValue}" title="快捷投骰"></i>`;

        // 使用智能提取函数，只显示数值部分
        let displayValue = extractNumericDisplayValue(item.value, false);
        // 在数值模式下，去掉范围部分（如去掉 ",[0, 100]"）
        displayValue = displayValue.replace(/,\s*\[[^\]]+\]/g, '');

        // 生成初始显示状态和 data-levels 属性
        // 注意：data-levels 存储的是层级名（排除最下层属性名）
        const displayStyle = allLevelsVisible ? '' : 'display:none;';
        const levelsJson = JSON.stringify(hierarchyLevels);

        itemsHtml += `
          <div class="mvu-numeric-item acu-mvu-item" data-levels='${escapeHtml(levelsJson)}' style="${displayStyle}">
            <div class="acu-mvu-item-content">
              <div class="mvu-path-display acu-mvu-path">${escapeHtml(pathDisplay)}</div>
              <div class="acu-mvu-item-row">
                <span class="acu-mvu-attr-name">${escapeHtml(finalAttrName)}</span>
                <span class="mvu-value acu-mvu-val" data-path="${escapeHtml(item.path)}" title="点击编辑">${escapeHtml(displayValue)}</span>
                ${diceIconHtml}
              </div>
            </div>
          </div>
        `;
      });

      return levelTogglesHtml + '<div class="mvu-numeric-items acu-mvu-list">' + itemsHtml + '</div>';
    }

    // ===== 公开 API =====
    return {
      MODULE_ID: MODULE_ID,

      isAvailable: isAvailable,
      getData: getData,
      getDataWithRetry: getDataWithRetry,

      // 诊断工具：检查变量框架状态
      diagnoseVariableFramework: async function () {
        const result = {
          timestamp: new Date().toISOString(),
          era: {
            available: false,
            eventEmit: typeof (window.eventEmit || window.parent?.eventEmit) === 'function',
            eventOn: typeof (window.eventOn || window.parent?.eventOn) === 'function',
            dataAvailable: false,
            error: null,
          },
          mvu: {
            available: false,
            apiExists: typeof window.Mvu !== 'undefined',
            getDataExists: typeof window.Mvu?.getMvuData === 'function',
            dataAvailable: false,
            error: null,
          },
          cache: {
            hasCache: !!cachedEraData,
            cacheKeys: cachedEraData ? Object.keys(cachedEraData) : [],
          },
          recommendation: '',
        };

        // 测试 ERA
        if (result.era.eventEmit && result.era.eventOn) {
          try {
            const eraData = await Promise.race([
              getEraData(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000)),
            ]);
            result.era.available = true;
            result.era.dataAvailable = !!(eraData && eraData.stat_data);
          } catch (e) {
            result.era.error = e.message;
          }
        }

        // 测试 MVU
        if (result.mvu.apiExists && result.mvu.getDataExists) {
          try {
            // [修复] 使用较短的超时，避免阻塞诊断
            await Promise.race([
              waitGlobalInitialized('Mvu'),
              new Promise((_, reject) => setTimeout(() => reject(new Error('等待超时')), 2000)),
            ]);
            const mvuData = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });
            result.mvu.available = true;
            result.mvu.dataAvailable = !!(mvuData && mvuData.stat_data);
          } catch (e) {
            result.mvu.error = e.message;
          }
        }

        // 生成建议
        if (result.era.dataAvailable) {
          result.recommendation = 'ERA 框架可用且数据正常';
        } else if (result.mvu.dataAvailable) {
          result.recommendation = 'MVU 框架可用且数据正常';
        } else if (result.era.available || result.mvu.available) {
          result.recommendation = '框架已安装但数据不可用，请检查角色卡是否正确初始化变量';
        } else {
          result.recommendation = '未检测到任何变量框架，请确认已安装 MVU 或 ERA 插件';
        }

        return result;
      },

      injectStyles: function () {
        // 获取主页面的 document（兼容 iframe 环境）
        const targetDoc = window.parent?.document || document;
        if (targetDoc.getElementById('mvu-module-styles')) return;
        const styleEl = targetDoc.createElement('style');
        styleEl.id = 'mvu-module-styles';
        styleEl.textContent = STYLES;
        targetDoc.head.appendChild(styleEl);
      },

      renderNavButton: function (isActive) {
        // 总是显示按钮，不检查 isAvailable()，让用户可以随时尝试查看变量
        const activeClass = isActive ? 'active' : '';
        return `<button class="acu-nav-btn acu-mvu-btn $${activeClass}" id="acu-btn-mvu" data-table="$${MODULE_ID}" style="order:-1;">
                    <i class="fa-solid fa-code-branch"></i><span>变量</span>
                </button>`;
      },

      renderPanel: function () {
        // 简化逻辑：总是显示面板，不依赖复杂的加载状态判断
        // 直接尝试获取数据，如果失败或为空，显示相应的提示信息，但始终显示刷新按钮

        const mvuData = getData();

        // 智能检测当前模式（MVU 或 ERA）
        const varMode = (mvuData && mvuData._source) || detectMode();
        const isEraMode = varMode === 'era';

        // [新增] 读取数值模式状态
        let isNumericMode = false;
        try {
          const saved = localStorage.getItem('acu_mvu_numeric_mode');
          isNumericMode = saved === 'true';
        } catch (e) {
          console.warn('[DICE]MvuModule 读取数值模式状态失败', e);
        }

        // MVU面板始终使用竖向滚动模式，不受全局布局配置影响
        const layoutMode = 'vertical-layout';

        // 生成面板标题
        const panelTitle = varMode === 'lwb' ? 'LWB 变量' : varMode === 'era' ? 'ERA 变量' : 'MVU 变量';

        // 如果无法获取数据（MVU 框架未加载或数据为 null）
        if (!mvuData) {
          return `
                        <div class="acu-panel-header">
                            <div class="acu-panel-title">
                                <div class="acu-title-main"><i class="fa-solid fa-code-branch"></i> <span class="acu-title-text">${panelTitle}</span></div>
                                <div class="acu-title-sub">(0项)</div>
                            </div>
                            <div class="acu-header-actions">
                                <div class="acu-height-control">
                                    <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="${MvuModule.MODULE_ID}" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                                </div>
                                <button class="mvu-header-btn mvu-btn-refresh" title="刷新（自动重试获取变量）">
                                    <i class="fa-solid fa-sync-alt"></i>
                                </button>
                                <button class="acu-close-btn" title="关闭">
                                    <i class="fa-solid fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mvu-content ${layoutMode}">
                            <div class="mvu-empty">
                                <i class="fa-solid fa-exclamation-circle"></i>
                                <p>无法获取 ${isEraMode ? 'ERA' : 'MVU'} 数据</p>
                                <p class="mvu-empty-hint">请确保角色卡已配置 ${isEraMode ? 'ERA 框架' : 'MVU 框架'}，或点击刷新按钮自动重试获取变量</p>
                            </div>
                        </div>
                    `;
        }

        // 如果 stat_data 为空或 null，显示空状态（但数据对象存在）
        if (
          !mvuData.stat_data ||
          (typeof mvuData.stat_data === 'object' && Object.keys(mvuData.stat_data).length === 0)
        ) {
          return `
                        <div class="acu-panel-header">
                            <div class="acu-panel-title">
                                <div class="acu-title-main"><i class="fa-solid fa-code-branch"></i> <span class="acu-title-text">${panelTitle}</span></div>
                                <div class="acu-title-sub">(0项)</div>
                            </div>
                            <div class="acu-header-actions">
                                <div class="acu-height-control">
                                    <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="${MvuModule.MODULE_ID}" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                                </div>
                                <button class="mvu-header-btn mvu-btn-refresh" title="刷新（自动重试获取变量）">
                                    <i class="fa-solid fa-sync-alt"></i>
                                </button>
                                <button class="acu-close-btn" title="关闭">
                                    <i class="fa-solid fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mvu-content ${layoutMode}">
                            <div class="mvu-empty">
                                <i class="fa-solid fa-inbox"></i>
                                <p>当前没有变量数据</p>
                                <p class="mvu-empty-hint">${varMode === 'lwb' ? '当前没有变量数据，变量将在 AI 通过 plot-log 输出后显示' : '变量数据将在 AI 回复后自动初始化，或点击刷新按钮自动重试获取变量'}</p>
                            </div>
                        </div>
                    `;
        }

        // [新增] 如果启用数值模式，使用专门的渲染函数
        if (isNumericMode) {
          const numericHtml = renderNumericMode(mvuData);
          return `
                    <div class="acu-panel-header">
                        <div class="acu-panel-title">
                            <div class="acu-title-main"><i class="fa-solid fa-code-branch"></i> <span class="acu-title-text">${panelTitle}</span> <span style="font-size:calc(var(--acu-font-size,13px) * 0.85);color:var(--acu-text-sub);margin-left:6px;">(数值模式)</span></div>
                            <div class="acu-title-sub">(数值过滤)</div>
                        </div>
                        <div class="acu-header-actions">
                            <div class="acu-height-control">
                                <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="${MvuModule.MODULE_ID}" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                            </div>
                            <button class="mvu-header-btn mvu-btn-numeric-mode active" title="切换到普通模式">
                                <i class="fa-solid fa-list"></i>
                            </button>
                            <button class="mvu-header-btn mvu-btn-refresh" title="刷新（自动重试获取变量）">
                                <i class="fa-solid fa-sync-alt"></i>
                            </button>
                            <button class="acu-close-btn" title="关闭">
                                <i class="fa-solid fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mvu-content ${layoutMode} mvu-numeric-mode">
                        ${numericHtml}
                    </div>
                `;
        }

        // 有数据，正常显示
        const topKeys = Object.keys(mvuData.stat_data).filter(k => !k.startsWith('$'));

        let cardsHtml = '';
        for (const key of topKeys) {
          const value = mvuData.stat_data[key];
          const childCount = countChildren(value);

          if (value && typeof value === 'object' && !isVWD(value) && !isSimpleArray(value)) {
            // 对象/复杂数组 → 卡片（顶层默认展开）
            // MVU面板始终使用竖向滚动，所以 isHorizontal 始终为 false
            cardsHtml += renderCard(key, value, key, mvuData.delta_data, 0, true, false);
          } else {
            // 原始值或简单数组 → 单独一个迷你卡片
            cardsHtml += `
                            <div class="mvu-card" data-path="${escapeHtml(key)}" data-depth="0">
                                <div class="mvu-card-body">
                                    ${renderRow(key, value, key, mvuData.delta_data)}
                                </div>
                            </div>
                        `;
          }
        }

        return `
                    <div class="acu-panel-header">
                        <div class="acu-panel-title">
                            <div class="acu-title-main"><i class="fa-solid fa-code-branch"></i> <span class="acu-title-text">${panelTitle}</span></div>
                            <div class="acu-title-sub">(${topKeys.length}项)</div>
                        </div>
                        <div class="acu-header-actions">
                            <div class="acu-height-control">
                                <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="${MvuModule.MODULE_ID}" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                            </div>
                            <button class="mvu-header-btn mvu-btn-numeric-mode" title="切换到数值模式（仅显示数值项）">
                                <i class="fa-solid fa-filter"></i>
                            </button>
                            <button class="mvu-header-btn mvu-btn-refresh" title="刷新（自动重试获取变量）">
                                <i class="fa-solid fa-sync-alt"></i>
                            </button>
                            <button class="acu-close-btn" title="关闭">
                                <i class="fa-solid fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mvu-content ${layoutMode}">
                        ${cardsHtml}
                    </div>
                `;
      },

      bindEvents: function ($container) {
        // 使用主页面的 jQuery
        const $ = window.parent?.jQuery || window.jQuery;
        if (!$ || !$container || !$container.length) {
          console.warn('[DICE]MvuModule bindEvents: jQuery or container not available');
          return;
        }

        // 使用主页面的 jQuery 重新获取容器
        const $panel = $('#acu-data-area');
        if (!$panel.length) {
          console.warn('[DICE]MvuModule bindEvents: #acu-data-area not found');
          return;
        }

        // 解绑旧事件
        $panel.off('.mvu');

        // 卡片折叠/展开（改进版，添加平滑动画）
        $panel.on('click.mvu', '.mvu-card-header', function (e) {
          e.stopPropagation();
          const $card = $(this).closest('.mvu-card');
          const $body = $card.find('> .mvu-card-body').first();

          // 防止动画过程中重复点击
          if ($body.is(':animated') || $body.hasClass('animating')) return;

          if ($card.hasClass('collapsed')) {
            // 展开：先用 hide() 确保元素隐藏，移除 collapsed 类后再播放动画
            $body.hide();
            $card.removeClass('collapsed');
            $body.addClass('animating').slideDown(180, function () {
              $(this).removeClass('animating');
            });
          } else {
            // 收起
            $body.addClass('animating').slideUp(180, function () {
              $card.addClass('collapsed');
              $(this).removeClass('animating');
            });
          }
        });

        // 刷新按钮
        $panel.on('click.mvu', '.mvu-btn-refresh', function (e) {
          e.stopPropagation();
          MvuModule.refresh($panel);
        });

        // [新增] 数值模式切换按钮
        $panel.on('click.mvu', '.mvu-btn-numeric-mode', function (e) {
          e.stopPropagation();
          try {
            const isCurrentlyNumeric = $(this).hasClass('active');
            const newMode = !isCurrentlyNumeric;
            localStorage.setItem('acu_mvu_numeric_mode', String(newMode));
            // 刷新面板
            if (typeof saveActiveTabState === 'function') {
              const currentTab = getActiveTabState();
              saveActiveTabState(currentTab);
            }
            if (typeof renderInterface === 'function') {
              renderInterface();
            }
          } catch (e) {
            console.warn('[DICE]MvuModule 切换数值模式失败', e);
            if (window.toastr) window.toastr.error('切换模式失败');
          }
        });

        // [新增] 层级控制折叠/展开
        $panel.on('click.mvu', '.mvu-level-controls-header', function (e) {
          e.stopPropagation();
          const $header = $(this);
          const $collapsible = $header.closest('.mvu-level-controls-collapsible');

          // 切换 collapsed 类，CSS 会自动处理动画
          $collapsible.toggleClass('collapsed');
        });

        // [新增] 层级显示 toggle
        $panel.on('click.mvu', '.mvu-level-toggle', function (e) {
          e.stopPropagation();
          const $button = $(this);
          const levelName = $button.data('level');
          const currentVisible = $button.data('visible') === 'true' || $button.data('visible') === true;
          const isVisible = !currentVisible;

          try {
            const saved = localStorage.getItem('acu_mvu_numeric_mode_visible_levels');
            const visibleLevels = saved ? JSON.parse(saved) : {};
            visibleLevels[levelName] = isVisible;
            localStorage.setItem('acu_mvu_numeric_mode_visible_levels', JSON.stringify(visibleLevels));

            // 更新按钮样式和状态
            $button.data('visible', isVisible);
            if (isVisible) {
              $button.css({
                background: 'var(--acu-accent)',
                color: 'var(--acu-btn-active-text)',
                borderColor: 'var(--acu-accent)',
                opacity: '1',
              });
              $button.attr('title', `隐藏层级: ${levelName}`);
            } else {
              $button.css({
                background: 'transparent',
                color: 'var(--acu-text-sub)',
                borderColor: 'var(--acu-border)',
                opacity: '0.5',
              });
              $button.attr('title', `显示层级: ${levelName}`);
            }

            // 【修复 3】局部更新路径显示，而不是全量重渲染
            $('.mvu-numeric-item').each(function () {
              const $item = $(this);
              try {
                const levels = JSON.parse($item.attr('data-levels') || '[]');
                if (levels.includes(levelName)) {
                  // 重新计算路径显示
                  const visibleLevels = levels.filter(level => {
                    const saved = localStorage.getItem('acu_mvu_numeric_mode_visible_levels');
                    const prefs = saved ? JSON.parse(saved) : {};
                    return prefs[level] !== false;
                  });

                  // 排除最下层，避免重复（这里 levels 已经是排除了最下层的）
                  const pathLevels = visibleLevels;

                  const newPathDisplay = pathLevels.length > 0 ? pathLevels.join(' > ') : '';

                  // 更新路径显示文本
                  $item.find('.mvu-path-display').text(newPathDisplay);
                }
              } catch (e) {
                console.warn('[DICE]MvuModule 更新路径显示失败', e);
              }
            });
          } catch (e) {
            console.warn('[DICE]MvuModule 更新层级显示偏好失败', e);
          }
        });

        // 点击值编辑
        $panel.on('click.mvu', '.mvu-value', function (e) {
          e.stopPropagation();
          const $value = $(this);
          const path = $value.data('path');
          if (!path) {
            console.warn('[DICE]MvuModule No path on value element');
            return;
          }
          const currentValue = $value
            .text()
            .replace(/\s*\$\s*$/, '')
            .trim(); // 移除末尾的 $

          MvuModule.showEditDialog(path, currentValue, async function (newValue) {
            if (newValue !== null && newValue !== currentValue) {
              const success = await MvuModule.setValue(path, newValue);
              const toastr = window.parent?.toastr || window.toastr;
              if (success) {
                $value.text(newValue);
                $value.css('background', 'var(--acu-success-bg)');
                setTimeout(() => $value.css('background', ''), 1500);
              } else {
                if (toastr) toastr.error('保存失败');
              }
            }
          });
        });

        // [新增] 点击骰子图标快捷投骰
        $panel.on('click.mvu', '.mvu-dice-icon', function (e) {
          e.stopPropagation();
          e.preventDefault();
          const $icon = $(this);
          const path = $icon.data('path');
          const attrName = $icon.data('attr-name') || '属性';
          const attrValue = parseInt($icon.data('attr-value'), 10) || 50;

          // 验证路径有效性
          if (!path) {
            console.warn('[DICE]MvuModule 骰子图标缺少路径信息');
            return;
          }

          // 检查 MVU 框架是否可用
          if (typeof window.Mvu === 'undefined' || typeof window.Mvu.getMvuData !== 'function') {
            console.warn('[DICE]MvuModule MVU 框架未加载，降级为普通投骰');
            // 降级为普通投骰，不解析路径
            if (typeof showDicePanel === 'function') {
              showDicePanel({
                attrValue: attrValue,
                targetValue: null, // 让showDicePanel根据模式自动计算
                targetName: attrName,
                initiatorName: '<user>',
                fromMvu: false,
              });
            }
            return;
          }

          // 尝试从路径解析发起者和属性名
          let parsedInfo = null;
          try {
            parsedInfo = parseMvuPathForDice(path, attrValue);
          } catch (e) {
            console.warn('[DICE]MvuModule 解析路径时出错', e);
          }

          // 调用投骰面板
          if (typeof showDicePanel === 'function') {
            showDicePanel({
              attrValue: attrValue,
              targetValue: null, // 让showDicePanel根据模式自动计算
              targetName: attrName,
              initiatorName: parsedInfo?.initiator || '<user>',
              fromMvu: true,
              mvuPath: path,
              mvuParsedInfo: parsedInfo,
            });
          }
        });

        // 阻止水平滑动冒泡，防止触发 ST 的 swipe regenerate
        (function () {
          // 使用主页面的 document（iframe 环境）
          const targetDoc = window.parent?.document || document;
          const $doc = $(targetDoc);

          // 先解绑旧事件，避免重复绑定
          $doc.off('touchstart.mvuSwipeFix touchmove.mvuSwipeFix touchend.mvuSwipeFix', '#acu-data-area');

          let touchStartX = 0;
          let touchStartY = 0;
          let isHorizontalSwipe = false;

          // 在 #acu-data-area 上处理，但检查是否是 MVU 面板
          $doc.on('touchstart.mvuSwipeFix', '#acu-data-area', function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;

            // 检查是否在 MVU 面板内
            if (!isInMvuPanel) return;

            if (e.originalEvent.touches.length === 1) {
              touchStartX = e.originalEvent.touches[0].clientX;
              touchStartY = e.originalEvent.touches[0].clientY;
              isHorizontalSwipe = false;
            }
          });

          $doc.on('touchmove.mvuSwipeFix', '#acu-data-area', function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;

            // 检查是否在 MVU 面板内
            if (!isInMvuPanel) {
              return;
            }

            if (e.originalEvent.touches.length !== 1) return;

            const touch = e.originalEvent.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);

            // 如果是水平滑动为主（X位移 > Y位移 * 1.5），阻止冒泡和默认行为
            // 修改判断逻辑：当deltaY很小时，降低deltaX阈值；否则使用原来的判断
            const isHorizontal =
              deltaY < 5
                ? deltaX > 5 && deltaX > deltaY * 2 // deltaY很小时，只要deltaX > 5且明显大于deltaY就认为是水平滑动
                : deltaX > deltaY * 1.5 && deltaX > 10; // 正常情况使用原判断

            if (isHorizontal) {
              isHorizontalSwipe = true;
              e.stopImmediatePropagation();
              e.stopPropagation();
            }
          });

          $doc.on('touchend.mvuSwipeFix', '#acu-data-area', function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;

            // 检查是否在 MVU 面板内
            if (!isInMvuPanel) {
              isHorizontalSwipe = false;
              touchStartX = 0;
              touchStartY = 0;
              return;
            }

            // 如果是水平滑动，阻止冒泡和默认行为
            if (isHorizontalSwipe) {
              e.stopImmediatePropagation();
              e.stopPropagation();
              isHorizontalSwipe = false;
            }
            touchStartX = 0;
            touchStartY = 0;
          });

          // 尝试在捕获阶段也监听
          const captureHandlerTouchStart = function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;
            if (isInMvuPanel && e.touches && e.touches.length === 1) {
              touchStartX = e.touches[0].clientX;
              touchStartY = e.touches[0].clientY;
            }
          };
          const captureHandlerTouchMove = function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;
            if (isInMvuPanel && e.touches && e.touches.length === 1 && touchStartX && touchStartY) {
              const touch = e.touches[0];
              const deltaX = Math.abs(touch.clientX - touchStartX);
              const deltaY = Math.abs(touch.clientY - touchStartY);
              // 使用与冒泡阶段相同的判断逻辑
              const isHorizontal =
                deltaY < 5 ? deltaX > 5 && deltaX > deltaY * 2 : deltaX > deltaY * 1.5 && deltaX > 10;
              if (isHorizontal) {
                e.stopImmediatePropagation();
                e.stopPropagation();
                e.preventDefault();
              }
            }
          };
          const captureHandlerTouchEnd = function (e) {
            const $target = $(e.target);
            const isInMvuPanel = $target.closest('.acu-mvu-panel').length > 0;
            if (isInMvuPanel && isHorizontalSwipe) {
              e.stopImmediatePropagation();
              e.stopPropagation();
              e.preventDefault();
            }
          };
          // 在捕获阶段也监听
          targetDoc.addEventListener('touchstart', captureHandlerTouchStart, true);
          targetDoc.addEventListener('touchmove', captureHandlerTouchMove, true);
          targetDoc.addEventListener('touchend', captureHandlerTouchEnd, true);
        })();

        // 关闭按钮
        $panel.on('click.mvu', '.acu-close-btn', function (e) {
          e.stopPropagation();
          const $input = $panel.find('.acu-search-input');

          // 如果搜索框有内容，清空搜索框
          if ($input.length && $input.val()) {
            $input.val('').trigger('input').focus();
            return;
          }

          // 变量面板状态：关闭变量面板，重新渲染到默认状态
          if (typeof saveActiveTabState === 'function') {
            saveActiveTabState(null);
          }
          if (typeof renderInterface === 'function') {
            renderInterface();
          }
        });

        // 高度拖拽
        $panel.on('pointerdown.mvu', '.acu-height-drag-handle', function (e) {
          if (e.button !== 0) return;
          e.preventDefault();
          e.stopPropagation();
          const handle = this;
          handle.setPointerCapture(e.pointerId);
          $(handle).addClass('active');
          const startHeight = $panel.height();
          const startY = e.clientY;
          const tableName = $(handle).data('table');

          // 定义 MIN_PANEL_HEIGHT 和 MAX_PANEL_HEIGHT（如果未定义）
          const MIN_PANEL_HEIGHT = typeof window.MIN_PANEL_HEIGHT !== 'undefined' ? window.MIN_PANEL_HEIGHT : 200;
          const MAX_PANEL_HEIGHT = typeof window.MAX_PANEL_HEIGHT !== 'undefined' ? window.MAX_PANEL_HEIGHT : 800;

          handle.onpointermove = function (moveE) {
            const dy = moveE.clientY - startY;
            let newHeight = startHeight - dy; // 向上拖动增加高度
            if (newHeight < MIN_PANEL_HEIGHT) newHeight = MIN_PANEL_HEIGHT;
            if (newHeight > MAX_PANEL_HEIGHT) newHeight = MAX_PANEL_HEIGHT;
            $panel.css('height', newHeight + 'px');
          };
          handle.onpointerup = function (upE) {
            $(handle).removeClass('active');
            handle.releasePointerCapture(upE.pointerId);
            handle.onpointermove = null;
            handle.onpointerup = null;
            if (tableName && typeof getTableHeights === 'function' && typeof saveTableHeights === 'function') {
              const heights = getTableHeights();
              heights[tableName] = parseInt($panel.css('height'));
              saveTableHeights(heights);
              $panel.addClass('acu-manual-mode');
            }
          };
        });

        // 双击重置高度
        $panel.on('dblclick.mvu', '.acu-height-drag-handle', function (e) {
          e.preventDefault();
          e.stopPropagation();
          const tableName = $(this).data('table');
          if (tableName && typeof getTableHeights === 'function' && typeof saveTableHeights === 'function') {
            const heights = getTableHeights();
            delete heights[tableName];
            saveTableHeights(heights);
            $panel.css('height', '').removeClass('acu-manual-mode');
          }
        });

        // 双击头部任意位置也可重置高度
        $panel.on('dblclick.mvu', '.acu-panel-header', function (e) {
          if ($(e.target).closest('.acu-search-input, .acu-close-btn, .mvu-header-btn').length) return;
          e.preventDefault();
          e.stopPropagation();
          const tableName = MvuModule.MODULE_ID;
          if (tableName && typeof getTableHeights === 'function' && typeof saveTableHeights === 'function') {
            const heights = getTableHeights();
            delete heights[tableName];
            saveTableHeights(heights);
            $panel.css('height', '').removeClass('acu-manual-mode');
          }
        });
      },

      showEditDialog: function (path, currentValue, onSave) {
        // 使用主页面的 jQuery 和 document
        const $ = window.parent?.jQuery || window.jQuery;
        const targetDoc = window.parent?.document || document;
        if (!$) return;

        // 移除已有弹窗
        $(targetDoc).find('.mvu-edit-overlay').remove();

        const currentTheme = (typeof getConfig === 'function' ? getConfig().theme : null) || 'retro';

        const html = `
                    <div class="mvu-edit-overlay acu-edit-overlay acu-theme-${currentTheme}">
                        <div class="mvu-edit-dialog acu-edit-dialog">
                            <div class="acu-edit-title">
                                <i class="fa-solid fa-edit acu-edit-icon-muted"></i>
                                <span>编辑变量</span>
                            </div>
                            <div class="mvu-edit-path">${escapeHtml(path)}</div>
                            <textarea class="mvu-edit-textarea acu-edit-textarea">${escapeHtml(currentValue)}</textarea>
                            <div class="mvu-edit-hint">Ctrl+Enter 保存 | Esc 取消</div>
                            <div class="acu-dialog-btns">
                                <button class="acu-dialog-btn mvu-btn-cancel">
                                    <i class="fa-solid fa-times"></i> 取消
                                </button>
                                <button class="acu-dialog-btn acu-btn-confirm mvu-btn-save">
                                    <i class="fa-solid fa-check"></i> 保存
                                </button>
                            </div>
                        </div>
                    </div>
                `;

        $(targetDoc.body).append(html);
        const $overlay = $(targetDoc).find('.mvu-edit-overlay');
        const $input = $overlay.find('.mvu-edit-textarea');

        setTimeout(() => $input.focus().select(), 50);

        // 取消按钮
        $overlay.on('click', '.mvu-btn-cancel', function (e) {
          e.preventDefault();
          e.stopPropagation();
          $overlay.remove();
          onSave(null);
        });

        // 保存按钮
        $overlay.on('click', '.mvu-btn-save', function (e) {
          e.preventDefault();
          e.stopPropagation();
          const newValue = $input.val();
          $overlay.remove();
          onSave(newValue);
        });

        // 点击遮罩关闭
        setupOverlayClose($overlay, 'mvu-edit-overlay', () => {
          $overlay.remove();
          onSave(null);
        });

        // 键盘快捷键
        $input.on('keydown', function (e) {
          if (e.key === 'Escape') {
            e.preventDefault();
            $overlay.remove();
            onSave(null);
          } else if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            const newValue = $input.val();
            $overlay.remove();
            onSave(newValue);
          }
        });
      },

      // ===== LWB 路径解析和写入函数 =====
      // 解析路径，支持 "根变量.子路径" 和 "根变量[0].子路径" 格式
      parsePath: function (path: string): { rootName: string; subPath: string } {
        const match = path.match(/^([^.\[]+)/);
        const rootName = match ? match[1] : path;

        let subPath = path.slice(rootName.length);
        if (subPath.startsWith('.')) subPath = subPath.slice(1);

        return { rootName, subPath };
      },

      // LWB 变量写入函数
      setLwbValue: function (path: string, value: unknown) {
        try {
          const ST = window.SillyTavern || window.parent?.SillyTavern;
          if (!ST?.chatMetadata) {
            console.error('[DICE]无法访问 chatMetadata');
            return;
          }

          if (!ST.chatMetadata.variables) {
            ST.chatMetadata.variables = {};
          }

          const { rootName, subPath } = this.parsePath(path);

          if (!subPath) {
            // 直接设置根变量
            ST.chatMetadata.variables[rootName] =
              typeof value === 'object' && value !== null ? JSON.stringify(value) : String(value ?? '');
          } else {
            // 设置嵌套路径
            const currentRaw = ST.chatMetadata.variables[rootName];
            let current = parseJsonSafe(currentRaw);

            if (typeof current !== 'object' || current === null) {
              current = {};
            }

            // lodash _.set 原生支持 "a[0].b" 格式
            _.set(current as object, subPath, value);

            ST.chatMetadata.variables[rootName] = JSON.stringify(current);
          }

          // 保存元数据
          ST.saveMetadata?.();

          // 刷新缓存
          cachedEraData = null;
          cachedEraDataChatId = null;

          console.log('[DICE]LWB 变量已更新:', path, '=', value);
        } catch (e) {
          console.error('[DICE]LWB 变量写入失败:', e);
        }
      },

      setValue: async function (path, newValue) {
        if (!isAvailable()) return false;

        const mode = detectMode();

        try {
          let parsedValue = newValue;
          if (newValue === 'true') parsedValue = true;
          else if (newValue === 'false') parsedValue = false;
          else if (!isNaN(Number(newValue)) && String(newValue).trim() !== '') {
            parsedValue = Number(newValue);
          }

          if (mode === 'era') {
            return await setEraValue(path, parsedValue);
          } else if (mode === 'lwb') {
            // [新增] LWB 模式：写入到 chatMetadata.variables
            this.setLwbValue(path, parsedValue);
            return true;
          } else {
            const mvuData = window.Mvu.getMvuData({ type: 'message', message_id: 'latest' });
            if (!mvuData) {
              console.error('[DICE]MvuModule 无法获取 MVU 数据');
              return false;
            }

            const success = await window.Mvu.setMvuVariable(mvuData, path, parsedValue, {
              reason: '手动编辑',
              is_recursive: false,
            });

            if (success) {
              await window.Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
            } else {
              console.warn('[DICE]MvuModule setMvuVariable 返回 false');
            }

            return success;
          }
        } catch (e) {
          console.error('[DICE]MvuModule setValue error:', e);
          return false;
        }
      },

      isModuleTab: function (tableName) {
        return tableName === MODULE_ID;
      },

      // 清除 ERA 缓存（当 ERA 变量更新时调用）
      clearCache: function () {
        cachedEraData = null;
        cachedEraDataChatId = null;
        console.log('[DICE]MvuModule 已清除 ERA 缓存');
      },

      // 检测当前使用的变量框架模式
      detectMode: function () {
        return detectMode();
      },

      refresh: function ($container) {
        // 清除缓存，强制重新获取数据
        this.clearCache();

        if (!$container || !$container.length) {
          const $panel = $('#acu-data-area');
          if (!$panel.length) return;
          $container = $panel;
        }
        // 显示加载状态（带刷新动画）
        const $refreshBtn = $container.find('.mvu-btn-refresh');
        if ($refreshBtn.length) {
          $refreshBtn.find('i').addClass('fa-spin');
        }

        // 使用重试机制获取最新变量数据（增加重试次数和延迟，让用户可以反复尝试）
        // 最多重试 10 次，每次延迟 1 秒，总共最多等待 10 秒
        this.getDataWithRetry(10, 1000)
          .then(mvuData => {
            // 移除加载动画
            if ($refreshBtn.length) {
              $refreshBtn.find('i').removeClass('fa-spin');
            }

            // [修复] 如果用户已切走到其它面板，不要用异步回调覆盖当前内容
            if (!canWriteMvuPanel()) return;

            // 无论成功失败，都重新渲染面板（简化后的 renderPanel 会处理所有状态）
            $container.html('<div class="acu-mvu-panel">' + this.renderPanel() + '</div>');
            this.bindEvents($container);

            // [修复] 使用 toastr 提示结果：检查 renderPanel 实际使用的数据（缓存）
            // 而不是仅依赖 getDataWithRetry 的返回值
            const toastr = window.parent?.toastr || window.toastr;
            const actualData = this.getData();
            if (toastr && !actualData) {
              toastr.warning('无法获取变量数据，请稍后重试或确保角色卡已配置 MVU 框架');
            }
          })
          .catch(err => {
            console.error('[DICE]MvuModule Error refreshing data:', err);

            // 移除加载动画
            if ($refreshBtn.length) {
              $refreshBtn.find('i').removeClass('fa-spin');
            }

            // [修复] 如果用户已切走到其它面板，不要用异步回调覆盖当前内容
            if (!canWriteMvuPanel()) return;

            // 显示错误状态（简化后的 renderPanel 会处理）
            $container.html('<div class="acu-mvu-panel">' + this.renderPanel() + '</div>');
            this.bindEvents($container);

            // [修复] 只有当实际没有数据时才显示错误
            const toastr = window.parent?.toastr || window.toastr;
            const actualData = this.getData();
            if (toastr && !actualData) {
              toastr.error('获取变量数据时出错');
            }
          });
      },
    };
  })();
  // MVU 变量可视化模块结束
  // 默认骰子配置（COC规则）
  const DEFAULT_DICE_CONFIG = {
    critSuccessMax: 5,
    hardSuccessDiv: 5,
    difficultSuccessDiv: 2,
    critFailMin: 96,
    ruleType: 'high_good',
    lastDiceType: '1d100',
    // DND 专用配置
    dndCritSuccess: 20,
    dndCritFail: 1,
    // 对抗平手规则: initiator_lose | tie | initiator_win
    contestTieRule: 'initiator_lose',
    // 隐藏输入栏中的检定结果
    hideDiceResultFromUser: false,
    // 隐藏聊天记录中的检定结果
    hideDiceResultInChat: false,
    autoMergeProtagonist: true,
  };

  const getDiceConfig = () => Store.get(STORAGE_KEY_DICE_CONFIG, DEFAULT_DICE_CONFIG);
  const saveDiceConfig = cfg => {
    const oldCfg = getDiceConfig();
    const newCfg = { ...oldCfg, ...cfg };
    Store.set(STORAGE_KEY_DICE_CONFIG, newCfg);
    // 记录配置变更
    const changedKeys = Object.keys(cfg).filter(k => oldCfg[k] !== newCfg[k]);
    if (changedKeys.length > 0) {
      console.info(`[DICE]投骰配置已更新: ${changedKeys.join(', ')}`);
    }
  };

  // [新增] 隐藏用户消息中的投骰结果（也处理输入栏）
  const hideDiceResultsInUserMessages = () => {
    try {
      const diceCfg = getDiceConfig();
      const hideInput = diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
      const hideChat = diceCfg.hideDiceResultInChat !== undefined ? diceCfg.hideDiceResultInChat : false;

      // 统一检定结果标签正则（匹配 <meta:检定结果>...</meta:检定结果>）
      const metaCheckResultRegex = /<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g;

      // ========== 第一部分：处理输入栏（由 hideInput 控制） ==========
      try {
        const $ta = $('#send_textarea');
        if ($ta.length) {
          let textareaVal = $ta.val() || '';
          let modifiedText = textareaVal;

          if (hideInput) {
            // 隐藏模式：替换为占位符
            if (metaCheckResultRegex.test(modifiedText)) {
              modifiedText = modifiedText.replace(metaCheckResultRegex, '[投骰结果已隐藏]');
            }
          } else {
            // 显示模式：如果有保存的原始文本，恢复它
            const originalText = $ta.data('acu-original-dice-text');
            if (originalText && textareaVal.includes('[投骰结果已隐藏]')) {
              // 替换占位符为原始文本
              modifiedText = textareaVal.replace(/\[投骰结果已隐藏\]/g, originalText);
              $ta.removeData('acu-original-dice-text');
            }
          }

          if (modifiedText !== textareaVal) {
            $ta.val(modifiedText).trigger('input').trigger('change');
          }
        }
      } catch (e) {
        console.warn('[DICE]ACU 处理输入栏投骰结果失败:', e);
      }

      // ========== 第二部分：处理聊天记录（由 hideChat 控制，独立于输入栏） ==========
      // 先检查聊天是否已加载，避免在首次启动时显示不必要的错误
      let lastMessageId;
      try {
        lastMessageId = getLastMessageId();
      } catch (e) {
        // 如果获取 lastMessageId 失败，说明聊天未加载，静默返回
        return;
      }

      // 如果聊天未加载或没有消息，直接返回，不显示错误
      if (lastMessageId < 0) {
        return;
      }

      try {
        const userMessages = getChatMessages(`0-${lastMessageId}`, { role: 'user' });
        // 如果没有用户消息，直接返回
        if (!userMessages || userMessages.length === 0) {
          return;
        }

        if (hideChat) {
          // 隐藏模式：处理已存在的消息
          let hiddenCount = 0;
          userMessages.forEach(msg => {
            try {
              const getMessageElement = (messageId: number | string) => {
                if (typeof retrieveDisplayedMessage === 'function') {
                  try {
                    const $el = retrieveDisplayedMessage(messageId);
                    if ($el && $el.length) return $el;
                  } catch (e) {
                    // fallback to DOM selector
                  }
                }
                const idText = String(messageId);
                const $chat = $('#chat');
                if (!$chat.length) return $();
                const $byMesId = $chat.find(
                  `.mes[mesid="${idText}"], .mes[data-message-id="${idText}"], .mes#mes_${idText}, .message-body[data-message-id="${idText}"]`,
                );
                return $byMesId.first();
              };

              const $msgElement = getMessageElement(msg.message_id);
              if (!$msgElement || !$msgElement.length) {
                return;
              }

              // 尝试多种可能的选择器
              let $mesText = $msgElement.find('.mes_text');
              if (!$mesText || !$mesText.length) {
                // 尝试其他可能的选择器
                $mesText = $msgElement.find('.message-text, .text, [class*="text"], [class*="message"]').first();
                if (!$mesText || !$mesText.length) {
                  // 如果都找不到，直接使用消息元素本身
                  $mesText = $msgElement;
                }
              }

              // 获取当前DOM显示的文本
              const currentDomText = $mesText.text();
              // 如果已经是占位符，跳过
              if (currentDomText.includes('[投骰结果已隐藏]')) {
                return;
              }

              // 使用消息数据中的原始文本作为源进行匹配（这是发送给AI的完整文本）
              const originalText = msg.message || '';
              if (!originalText) {
                return;
              }

              // 优先在HTML中直接替换，避免依赖消息数据
              const currentHtml = $mesText.html() || '';
              let modifiedHtml = currentHtml;

              // 使用统一的 <meta:检定结果> 标签正则（需要转义HTML实体）
              // 注意：HTML中可能已经被转义，所以匹配时需要考虑两种情况
              modifiedHtml = modifiedHtml.replace(
                /(&lt;|<)meta:检定结果(&gt;|>)[\s\S]*?(&lt;|<)\/meta:检定结果(&gt;|>)/g,
                '[投骰结果已隐藏]',
              );
              if (modifiedHtml === currentHtml) {
                modifiedHtml = modifiedHtml.replace(/<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g, '[投骰结果已隐藏]');
              }

              if (modifiedHtml !== currentHtml) {
                $mesText.html(modifiedHtml);
                hiddenCount++;
                return;
              }

              // HTML 未命中时，回退到文本替换（可能是纯文本渲染）
              const metaRegex = /<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g;
              const replacedText = currentDomText.replace(metaRegex, '[投骰结果已隐藏]');
              if (replacedText !== currentDomText) {
                $mesText.text(replacedText);
                hiddenCount++;
                return;
              }

              // DOM 中没有标签时，根据原始消息内容强制替换并重新渲染
              const replacedFromOriginal = originalText.replace(metaRegex, '[投骰结果已隐藏]');
              if (replacedFromOriginal !== originalText && replacedFromOriginal !== currentDomText) {
                if (typeof formatAsDisplayedMessage === 'function') {
                  $mesText.html(formatAsDisplayedMessage(replacedFromOriginal));
                } else {
                  $mesText.text(replacedFromOriginal);
                }
                hiddenCount++;
              }
            } catch (e) {
              console.warn(`[DICE]ACU 隐藏第 ${msg.message_id} 楼投骰结果失败:`, e);
            }
          });
          if (hiddenCount === 0) {
            const $chat = $('#chat');
            if ($chat.length) {
              $chat.find('.mes, .message-body').each((_, elem) => {
                const $elem = $(elem);
                const $target = $elem.find('.mes_text').length ? $elem.find('.mes_text') : $elem;
                const html = $target.html() || '';
                let replaced = html.replace(
                  /(&lt;|<)meta:检定结果(&gt;|>)[\s\S]*?(&lt;|<)\/meta:检定结果(&gt;|>)/g,
                  '[投骰结果已隐藏]',
                );
                if (replaced === html) {
                  replaced = html.replace(/<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g, '[投骰结果已隐藏]');
                }
                if (replaced !== html) {
                  $target.html(replaced);
                  hiddenCount++;
                }
              });
            }
          }
          if (hiddenCount > 0) {
            console.info(`[DICE]已隐藏 ${hiddenCount} 条消息的投骰结果`);
          }
        } else {
          // 显示模式：恢复已隐藏的消息
          let restoredCount = 0;
          userMessages.forEach(msg => {
            try {
              const getMessageElement = (messageId: number | string) => {
                if (typeof retrieveDisplayedMessage === 'function') {
                  try {
                    const $el = retrieveDisplayedMessage(messageId);
                    if ($el && $el.length) return $el;
                  } catch (e) {
                    // fallback to DOM selector
                  }
                }
                const idText = String(messageId);
                const $chat = $('#chat');
                if (!$chat.length) return $();
                const $byMesId = $chat.find(
                  `.mes[mesid="${idText}"], .mes[data-message-id="${idText}"], .mes#mes_${idText}, .message-body[data-message-id="${idText}"]`,
                );
                return $byMesId.first();
              };

              const $msgElement = getMessageElement(msg.message_id);
              if (!$msgElement || !$msgElement.length) return;

              const $mesText = $msgElement.find('.mes_text');
              if (!$mesText || !$mesText.length) return;

              // 如果显示的是占位符，从消息数据恢复原始文本
              const currentText = $mesText.text();
              if (currentText.includes('[投骰结果已隐藏]')) {
                // 从消息数据获取原始文本
                const originalText = msg.message || '';
                if (originalText) {
                  $mesText.text(originalText);
                  restoredCount++;
                }
              }
            } catch (e) {
              // 单个消息恢复失败，静默处理
            }
          });
          if (restoredCount > 0) {
            console.info(`[DICE]已恢复 ${restoredCount} 条消息的投骰结果`);
          }
        }
      } catch (e) {
        // 首次启动时聊天可能未完全加载，静默处理所有错误
        // 避免在控制台显示不必要的警告信息
        if (hideChat) {
          console.warn('[DICE]ACU 处理聊天记录投骰结果失败:', e);
        }
      }
    } catch (e) {
      // [修复] 最外层错误处理，静默处理配置获取失败等错误
      // 避免在未启用隐藏功能时显示错误
      const diceCfg = getDiceConfig();
      if (diceCfg && (diceCfg.hideDiceResultFromUser || diceCfg.hideDiceResultInChat)) {
        console.warn('[DICE]ACU 隐藏投骰结果失败:', e);
      }
    }
  };

  // ========================================
  // 高级骰子预设系统
  // ========================================

  /** 多级结果定义 */
  interface OutcomeLevel {
    id: string; // 唯一标识
    name: string; // 显示名称 (如 "大成功")
    condition: string; // 判定表达式 (使用 evaluateCondition 评估)
    priority: number; // 优先级 (数字越小越优先)
    contestRank?: number; // 对抗等级 (可选)
    outputText?: string; // 输出文本模板 (可选)
    displayExpr?: string; // 显示用的算式表达式 (可选,不填则用 condition)
    style?: {
      color?: string;
    };
    /** 触发的效果列表 */
    effects?: Effect[];
  }

  /** 对抗规则配置 */
  interface ContestRule {
    /** 是否禁用对抗检定（如 PbtA 等规则不支持对抗检定） */
    disabled?: boolean;
    mode?: 'rank' | 'value' | 'margin' | 'custom'; // 对抗模式
    tieBreakers?: string[]; // 链式平局处理规则
    tieBreaker?: string; // 旧版单一平局处理(兼容)
    customExpr?: string; // 自定义表达式 (mode='custom' 时使用)
    hideDc?: boolean; // 对抗检定时隐藏DC字段
    hideMod?: boolean; // 对抗检定时隐藏修正值字段
    hideSkillMod?: boolean; // 对抗检定时隐藏技能加值字段
  }

  /** 后果系统：效果定义 */
  interface Effect {
    /** 唯一标识 */
    id: string;
    /** 目标属性名 */
    target: string;
    /** 操作类型 */
    operation: 'add' | 'subtract' | 'set';
    /** 变更值 (支持骰子表达式) */
    value: string;
    /** 执行条件表达式 (可选) */
    condition?: string;
    /** 属性不存在时的初始值 (可选) */
    initValue?: number;
    /** 最小值限制 (可选) */
    min?: number;
    /** 最大值限制 (可选) */
    max?: number;
    /** 自定义输出文本 (可选) */
    outputText?: string;
    /** 是否需要用户确认后才执行，默认 true (可选) */
    needsConfirm?: boolean;
    /** 确认输入框的标签文本，如 "成功时扣除" (可选) */
    label?: string;
    /** 确认输入框的占位符文本 (可选) */
    inputPlaceholder?: string;
  }

  /** 后果系统：全局配置 */
  interface EffectsConfig {
    /** 触发模式 (用于识别哪些检定可能触发效果) */
    triggerPatterns: string[];
    /** 允许修改的目标属性 */
    allowedTargets: string[];
    /** 按结果等级分组的效果列表 (可选) */
    outcomes?: {
      [outcomeName: string]: Effect[];
    };
    /** 各结果等级的默认值 (可选) */
    defaultValues?: {
      [outcomeName: string]: string;
    };
  }

  /** 后果系统：资源消耗 (Lucky Burner 等) */
  interface ResourceBurner {
    /** 唯一标识 */
    id: string;
    /** 资源属性名 */
    resourceName: string;
    /** 显示/可用条件 (表达式，如 "$roll > $attr" 仅失败时显示) */
    condition?: string;
    /** 影响目标: roll=修改投骰结果, mod=修改修正值, dc=修改难度, attribute=修改属性值 */
    target: 'roll' | 'mod' | 'dc' | 'attribute';
    /** 转换比例 (如 1点资源 = 1点投骰结果) */
    ratio: number;
    /** 影响方向 (increase=增加目标值, decrease=减少目标值) */
    direction: 'increase' | 'decrease';
    /** 资源操作方向: subtract=消耗/减少资源(默认), add=增加/累积资源 */
    resourceOperation?: 'subtract' | 'add';
    /** 建议消耗量表达式 (如 "$roll.total - $attr"，计算"刚好通过"需消耗的资源量) */
    suggestedAmount?: string;
    /** 适用范围选择器 (用于过滤哪些检定可以使用此消耗器) */
    selector?: CheckSelector;
    /** UI 显示配置 */
    ui?: {
      icon?: string;
      color?: string;
      tooltip?: string;
    };
  }

  interface QuickActionBase {
    /** 唯一标识 */
    id: string;
    /** 图标 (fa- 前缀) */
    icon?: string;
    /** 按钮提示 */
    tooltip?: string;
    /** 显示条件（基于当前面板上下文） */
    condition?: string;
  }

  interface WorkflowQuickAction extends QuickActionBase {
    kind: 'workflow_shortcut';
    config: {
      /** 目标预设ID */
      presetId: string;
      /** 切换时是否沿用当前输入 */
      carryInitiator?: boolean;
      carryAttrName?: boolean;
      carryAttrValue?: boolean;
      carryTarget?: boolean;
      carryModifier?: boolean;
      carrySkillMod?: boolean;
      /** 未沿用属性名时可指定默认属性名 */
      attrName?: string;
      /** 切换后自定义字段默认值 */
      customFieldValues?: Record<string, string | number | boolean>;
    };
  }

  interface AttrShortcutQuickAction extends QuickActionBase {
    kind: 'attr_shortcut';
    config: {
      /** 切换到目标预设（通常是常规检定预设） */
      presetId: string;
      /** 候选属性名（按顺序匹配角色现有属性） */
      attrAliasCandidates: string[];
      /** 未匹配到时的回退属性名 */
      fallbackAttrName?: string;
      /** 是否沿用当前发起者 */
      carryInitiator?: boolean;
      /** 是否沿用当前属性值 */
      carryAttrValue?: boolean;
      /** 是否沿用目标值 */
      carryTarget?: boolean;
      /** 是否沿用修正值 */
      carryModifier?: boolean;
      /** 是否沿用技能加值 */
      carrySkillMod?: boolean;
    };
  }

  type PresetQuickAction = WorkflowQuickAction | AttrShortcutQuickAction;

  interface CurrentAttrAutoUpdate {
    /** 是否启用 */
    enabled?: boolean;
    /** 触发时机 */
    when?: 'success' | 'failure' | 'always';
    /** 属性操作 */
    operation: 'add' | 'subtract' | 'set';
    /** 变化值表达式，支持变量 */
    valueExpr: string;
    /** 属性不存在时初始值 */
    initValue?: number;
    /** 最小值 */
    min?: number;
    /** 最大值 */
    max?: number;
    /** 属性别名候选 */
    aliasCandidates?: string[];
    /** 变化标签（如：成长/增加/减少） */
    changeLabel?: string;
    /** 已填表输出模板（可选）。可用变量：$attr, $attrPlain, $old, $new, $delta, $expr, $rolled, $operation, $changeLabel */
    outputTextTemplate?: string;
  }

  /** 检定范围选择器 (用于 Effects 和 ResourceBurner 的过滤) */
  interface CheckSelector {
    /** 属性名模式匹配 */
    namePatterns?: {
      /** 包含模式，默认 ['*'] 匹配所有 */
      include?: string[];
      /** 排除模式，优先于 include，默认 [] 无排除 */
      exclude?: string[];
    };
    /** 标签匹配 (用于非名称类例外，如 damage/pushed/luck) */
    tags?: {
      /** 包含标签 */
      include?: string[];
      /** 排除标签 */
      exclude?: string[];
    };
  }

  /** 后果系统：执行结果 */
  interface EffectResult {
    /** 效果 ID */
    effectId: string;
    /** 是否执行成功 */
    success: boolean;
    /** 变更前的值 */
    oldValue: number;
    /** 变更后的值 */
    newValue: number;
    /** 错误信息 */
    error?: string;
    /** 目标属性名 */
    target?: string;
    /** 效果链层级（1=一级效果） */
    level?: number;
    /** 触发来源（二级效果ID等） */
    triggerSourceId?: string;
    /** 触发阈值（若有） */
    triggerThreshold?: number;
    /** 触发类型（threshold/delta/primary） */
    triggerType?: 'threshold' | 'delta' | 'primary';
    /** 命中序号（all 模式下可用于追踪） */
    triggerMatchIndex?: number;
    /** 命中总数（all 模式下可用于追踪） */
    triggerMatchCount?: number;
    /** 信息输出文本（由 secondaryEffect.outputText 渲染，非数值变更） */
    outputMessage?: string;
    /** 执行来源分支标识（用于UI和提示词追踪） */
    branchLabel?: string;
    /** 计算公式文本（如 4d4 / 1d6 / 3） */
    formulaText?: string;
    /** 公式掷值（有掷骰时） */
    rolledValue?: number;
  }

  /**
   * 计算后的效果 (用于确认弹窗)
   */
  interface ComputedEffect {
    /** 关联效果ID */
    effectId: string;
    /** 目标属性名 */
    target: string;
    /** 解析后的目标属性名（若有） */
    resolvedTarget?: string;
    /** 计算后的变化值 */
    computedValue: number;
    /** 骰子或数字求值后的绝对值 */
    rolledValue: number;
    /** 原始公式 */
    formula: string;
    /** 展开文本,如 "1d6 → 3" */
    displayText: string;
    /** 执行前数值（若可读取） */
    beforeValue?: number | null;
    /** 执行后数值（若可预测） */
    afterValue?: number | null;
    /** 效果条件原始表达式（为空表示命中分支即执行） */
    conditionExpr?: string;
    /** 效果条件替换变量后的展示文本 */
    resolvedConditionExpr?: string;
    /** 效果条件是否成立 */
    conditionPassed?: boolean;
    /** 效果条件的自然语言说明 */
    conditionSummary?: string;
  }

  interface EffectConfirmUiConfig {
    /** 确认弹窗标题 */
    title?: string;
    /** 效果列表说明文本 */
    effectListTitle?: string;
    /** 分支说明标题 */
    branchReasonLabel?: string;
  }

  /**
   * 检定历史记录扩展字段
   * 用于在 AcuDice.CheckResult 基础上添加效果确认相关状态
   */
  interface CheckHistoryExtension {
    /** 效果执行状态 */
    effectStatus?: 'planned' | 'confirmed' | 'committed' | 'failed' | 'cancelled';
    /** 效果执行结果列表 */
    effectResults?: EffectResult[];
    /** 效果执行批次ID */
    effectRunId?: string;
    /** 效果执行错误 */
    effectError?: string;
    /** 效果执行追踪（按层级展开） */
    effectTrace?: string[];
    /** 运行事件序号（单调递增） */
    effectEventSeq?: number;
    /** 是否为孤注一掷（Pushed Roll） */
    isPushed?: boolean;
    /** 历史详情展开ID */
    detailId?: string;
    /** 历史详情行 */
    detailLines?: string[];
    /** 发起者名称 */
    initiatorName?: string;
    /** 检定显示类型 */
    historyType?: 'check' | 'contest';
  }

  interface EffectRunEventPayload {
    seq: number;
    runId: string;
    status: 'planned' | 'confirmed' | 'committed' | 'failed' | 'cancelled';
    characterName: string;
    attributeName: string;
    historyIndex: number;
    effectResults: EffectResult[];
    effectTrace: string[];
    chainMode?: 'first' | 'all';
    error?: string;
    timestamp: number;
  }

  interface EffectReplayOperation {
    characterName: string;
    target: string;
    operation: 'add' | 'subtract' | 'set';
    value: number;
    initValue?: number;
    min?: number;
    max?: number;
    aliasCandidates: string[];
    resultRef: EffectResult;
  }

  /**
   * 二级效果定义 (预留架构)
   * 用于定义基于属性变化触发的连锁效果
   */
  interface SecondaryEffect {
    /** 唯一标识 */
    id: string;
    /** 触发条件 */
    trigger: {
      /** 触发类型: threshold=基于阈值, delta=基于变化量 */
      type: 'threshold' | 'delta';
      /** 目标属性名 */
      attribute: string;
      /** 比较运算符 */
      operator: 'gt' | 'gte' | 'lt' | 'lte' | 'eq';
      /** 比较值，支持表达式如 "{意志}/5" */
      value: string;
    };
    /** 回调函数名或钩子标识 (可选) */
    callback?: string;
    /** 命中后要执行的后续效果（可选） */
    effects?: Effect[];
    /** 触发时输出的提示文本 (可选，支持变量: $delta, $old, $new, $attr, $depth, $tableRoll, $tableResult) */
    outputText?: string;
    /** 随机表: 触发时投骰并从表中查找结果，可通过 $tableRoll/$tableResult 在 outputText 中引用 */
    randomTable?: {
      /** 骰子表达式 (如 '1d10') */
      dice: string;
      /** 结果映射: key=投骰结果, value=对应文本 */
      entries: Record<number, string>;
    };
    /** 命名随机表：可一次投多个骰，变量名为 $<key>Roll / $<key>Result */
    randomTables?: Record<
      string,
      {
        /** 骰子表达式 (如 '1d10') */
        dice: string;
        /** 可选映射，不提供时 $<key>Result 默认等于点数 */
        entries?: Record<number, string>;
      }
    >;
    /** 子检定：用于自动化三级效果（例如 INT 检定） */
    subCheck?: {
      /** 显示标签 */
      label?: string;
      /** 目标属性名（主候选） */
      attribute: string;
      /** 目标属性名候选（用于别名/本地化） */
      attributeCandidates?: string[];
      /** 子检定骰子，默认 1d100 */
      dice?: string;
      /** 比较符，默认 lte（低于等于成功） */
      operator?: 'gt' | 'gte' | 'lt' | 'lte' | 'eq';
      /** 目标值表达式，默认使用读取到的属性值 */
      targetValue?: string;
      /** 属性缺失时提示文本（支持模板变量） */
      missingAttributeText?: string;
      /** 成功分支 */
      success?: {
        outputText?: string;
        randomTable?: {
          dice: string;
          entries: Record<number, string>;
        };
        randomTables?: Record<
          string,
          {
            dice: string;
            entries?: Record<number, string>;
          }
        >;
        effects?: Effect[];
      };
      /** 失败分支 */
      failure?: {
        outputText?: string;
        randomTable?: {
          dice: string;
          entries: Record<number, string>;
        };
        randomTables?: Record<
          string,
          {
            dice: string;
            entries?: Record<number, string>;
          }
        >;
        effects?: Effect[];
      };
    };
    /** 是否启用，默认 true */
    enabled?: boolean;
    /** 最大触发次数，默认 1 */
    maxTriggerCount?: number;
  }

  /** 表单字段配置 */
  interface FieldConfig {
    /** 输入框上方的标签文本 */
    label?: string;
    /** 输入框内的 placeholder 文本 */
    placeholder?: string;
    /** 留空时的默认值,支持数字或表达式字符串(必填) */
    defaultValue: number | string;
    /** 是否隐藏整个输入框区域 */
    hidden?: boolean;
  }

  interface AdvancedDicePreset {
    kind: 'advanced';
    id: string;
    name: string;
    description?: string;
    version: string;
    builtin: boolean;
    visible?: boolean;
    order?: number;
    createdAt?: string;

    // 骰子表达式
    diceExpression: string;

    // 属性/技能名称输入框（第一行右侧）
    attributeName?: FieldConfig;

    // 属性值来源（第二行）
    attribute: FieldConfig & {
      key?: string; // 属性名
    };

    // DC来源
    dc: FieldConfig;

    // 修正值来源
    mod?: FieldConfig;

    // 技能加值（与 attribute/mod 平行，用于 DND5e 等规则）
    skillMod?: FieldConfig;

    /**
     * 属性填入目标映射
     * - key: 目标字段 ID ('attribute' | 'skillMod' | 'mod' | customField.id)
     * - value: 属性名数组（精确匹配）
     * - 未匹配的属性 fallback 到 'attribute'
     */
    attrTargetMapping?: Record<string, string[]>;

    // 自定义字段
    customFields?: CustomFieldConfig[];

    // 派生变量
    derivedVars?: DerivedVarSpec[];

    // 骰子表达式补丁
    dicePatches?: DiceExprPatch[];

    // 多级结果定义
    outcomes: OutcomeLevel[];

    // 对抗规则
    contestRule?: ContestRule;

    // 输出模板
    outputTemplate?: string;

    // 对抗检定专用输出模板（与 outputTemplate 独立）
    contestOutputTemplate?: string;

    // 判定结果检查策略
    outcomePolicy?: OutcomePolicy;

    /** 后果系统配置 */
    effectsConfig?: EffectsConfig;
    /** 后果确认弹窗文案配置 */
    effectConfirmUi?: EffectConfirmUiConfig;
    /** 资源消耗配置 */
    resourceBurners?: ResourceBurner[];
    /** 预设快捷操作区（标题右侧小图标） */
    quickActions?: PresetQuickAction[];
    /** 检定后自动修改“当前属性” */
    currentAttrAutoUpdate?: CurrentAttrAutoUpdate;
    /** 二级/多级效果配置（可选） */
    secondaryEffects?: SecondaryEffect[];
    /** 二级效果链最大深度（可选，默认 3） */
    secondaryMaxDepth?: number;
    /** 二级效果触发策略（first=首命中，all=全部命中） */
    secondaryTriggerMode?: 'first' | 'all';

    /** 孤注一掷配置 (COC7等规则) */
    pushedRoll?: {
      /** 是否启用 */
      enabled: boolean;
      /** 允许push的outcome ID列表 (匹配到这些outcome才显示push按钮)
       *  未定义时: 回退到 isSuccess === false 的行为（向后兼容） */
      pushableOutcomes?: string[];
      /** 禁止push的outcome ID列表 (优先于pushableOutcomes) */
      blockedOutcomes?: string[];
      /** 排除的属性名模式 (通配符,如 'SAN*','*闪避*') */
      excludePatterns?: string[];
      /** @deprecated 使用 blockedOutcomes: ['crit_failure'] 替代 */
      blockOnCritFailure?: boolean;
      /** push后各outcome的输出标注
       *  key: outcome ID 或 '*'(默认)
       *  value: 标注文本 */
      outcomeLabels?: Record<string, string>;
    };

    // 错误处理
    errorHandling?: {
      undefinedVariable: 'zero' | 'error';
      parseError: 'fail' | 'warn';
    };
  }

  interface PendingEffectContext {
    runId: string;
    historyIndex: number;
    messageId?: string;
    expiresAt?: number;
    preset: AdvancedDicePreset;
    matchedOutcome: OutcomeLevel;
    context: {
      characterName: string;
      attributeName: string;
      attributeValue: number;
      roll: number;
      modifier: number;
      dc: number;
    };
    effectOverrides?: ComputedEffect[];
    /** 进入当前结果分支的说明文本（用于确认弹窗与注入文本） */
    branchReasonText?: string;
    timestamp: number;
  }

  // 内置高级骰子预设
  const BUILTIN_ADVANCED_PRESETS: AdvancedDicePreset[] = [
    // CoC7 规则: 1d100 <= 属性值
    {
      kind: 'advanced',
      id: 'coc7_check',
      name: 'CoC7',
      description: '克苏鲁的呼唤7版: 1d100 <= 属性值即成功',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      diceExpression: '1d100',
      attribute: {
        label: '技能值',
        placeholder: '留空=50',
        defaultValue: 50,
        key: '技能值',
      },
      dc: {
        hidden: true,
        defaultValue: 0,
      },
      mod: {
        hidden: true,
        defaultValue: 0,
      },
      customFields: [
        {
          id: 'bonusPenalty',
          type: 'number',
          label: '奖惩骰',
          defaultValue: '',
          placeholder: '+1 奖励, -1 惩罚',
        },
        {
          id: 'requiredRank',
          type: 'select',
          label: '最低成功等级',
          defaultValue: 1,
          options: [
            { label: '成功', value: 1 },
            { label: '困难成功', value: 2 },
            { label: '极难成功', value: 3 },
          ],
          contestOverride: { hidden: true },
        },
      ],
      derivedVars: [{ id: 'absBp', expr: 'abs($bonusPenalty)' }],
      dicePatches: [
        { when: '$bonusPenalty > 0', op: 'append', template: 'b$absBp' },
        { when: '$bonusPenalty < 0', op: 'append', template: 'p$absBp' },
      ],
      effectsConfig: {
        triggerPatterns: ['SAN*', 'SAN值*', '*理智*', '*sanity*', '*Sanity*'],
        allowedTargets: ['SAN', 'SAN值', '理智', 'Sanity', 'san'],
      },
      // CoC7 孤注一掷：失败时可重掷一次，大失败/SAN检定/闪避等不可
      pushedRoll: {
        enabled: true,
        pushableOutcomes: ['warning', 'failure'], // 仅失败/未达标可push
        blockedOutcomes: ['crit_failure'], // 大失败不可push
        excludePatterns: ['SAN*', 'SAN值*', '*理智*', '*sanity*', '*Sanity*', '*闪避*', '*dodge*', '*Dodge*'],
        outcomeLabels: {
          crit_success: '🎲 孤注一掷 — 大成功！',
          extreme_success: '🎲 孤注一掷 — 极难成功！',
          success: '🎲 孤注一掷成功！',
          '*': '⚠ 孤注一掷失败！',
        },
      },
      // CoC7 燃运：消耗幸运降低骰子结果
      // 根据规则：几乎所有检定可燃运，但 SAN检定、幸运检定、伤害骰、孤注一掷不可
      resourceBurners: [
        {
          id: 'coc7_luck_burn',
          resourceName: '幸运',
          target: 'roll',
          ratio: 1, // 1点幸运 = 1点骰子结果
          direction: 'decrease', // 降低骰子结果（CoC 低好）
          suggestedAmount: '$roll.total - $attr', // 刚好让投骰结果 <= 属性值
          condition: '$roll.total > $attr && $isPushed == 0', // 仅在失败时显示，孤注一掷时不可燃运
          selector: {
            namePatterns: {
              include: ['*'], // 适用于所有属性名
              exclude: [
                'SAN*',
                'SAN值*',
                '*理智*',
                '*sanity*',
                '*Sanity*', // SAN 检定不可燃运
                '幸运*',
                '*Luck*',
                '*luck*', // 幸运检定不可燃运
              ],
            },
          },
          ui: {
            icon: 'fa-clover',
            color: 'var(--acu-accent)',
            tooltip: '消耗幸运降低骰子结果 (1:1)',
          },
        },
      ],
      quickActions: [
        {
          id: 'to_san_check',
          kind: 'attr_shortcut',
          icon: 'fa-brain',
          tooltip: 'SAN检定',
          config: {
            presetId: 'coc7_check',
            carryInitiator: true,
            carryAttrValue: false,
            carryTarget: false,
            carryModifier: false,
            carrySkillMod: false,
            attrAliasCandidates: ['SAN值', 'SAN', '理智', 'sanity', 'Sanity', 'san'],
            fallbackAttrName: 'SAN值',
          },
        },
        {
          id: 'to_skill_growth',
          kind: 'workflow_shortcut',
          icon: 'fa-seedling',
          tooltip: '技能成长检定',
          config: {
            presetId: 'coc7_growth_check',
            carryInitiator: true,
            carryAttrName: true,
            carryAttrValue: true,
          },
        },
      ],
      outcomes: [
        {
          id: 'crit_success',
          name: '大成功',
          condition: '$roll.total === 1',
          priority: 1,
          rank: 4,
          contestRank: 100, // 对抗等级
          outputText: '',
        },
        {
          id: 'extreme_success',
          name: '极难成功',
          condition: '$roll.total <= $attr / 5',
          priority: 10,
          rank: 3,
          contestRank: 100, // 对抗等级
          outputText: '',
        },
        {
          id: 'hard_success',
          name: '困难成功',
          condition: '$roll.total <= $attr / 2',
          priority: 20,
          rank: 2,
          contestRank: 80, // 对抗等级
          outputText: '',
        },
        {
          id: 'success',
          name: '成功',
          condition: '$roll.total <= $attr',
          priority: 30,
          rank: 1,
          contestRank: 60, // 对抗等级
          outputText: '',
          effects: [
            {
              id: 'san_loss_success',
              target: 'SAN',
              operation: 'subtract',
              value: '1',
              outputText: 'SAN 减少 $effectDelta (成功)',
            },
          ],
        },
        {
          id: 'failure',
          name: '失败',
          condition: '$roll.total > $attr',
          displayExpr: '$roll.total <= $attr', // 显示成功条件，失败时显示"不成立"
          priority: 50,
          rank: 0,
          contestRank: 40, // 对抗等级
          outputText: '',
          effects: [
            {
              id: 'san_loss_fail',
              target: 'SAN',
              operation: 'subtract',
              value: '1d6',
              outputText: 'SAN 减少 $effectDelta',
            },
          ],
        },
        {
          id: 'crit_failure',
          name: '大失败',
          condition: '($attr < 50 && $roll.total >= 96) || ($attr >= 50 && $roll.total === 100)',
          priority: 5,
          rank: -1,
          contestRank: 20, // 对抗等级
          outputText: '',
          effects: [
            {
              id: 'san_loss_fumble',
              target: 'SAN',
              operation: 'subtract',
              value: '1d10',
              outputText: 'SAN 减少 $effectDelta (大失败)',
            },
          ],
        },
        {
          id: 'unmet',
          name: '失败',
          condition: 'false',
          priority: 999,
          rank: -2,
        },
      ],
      outcomePolicy: {
        kind: 'minRank',
        requiredRankVarId: 'requiredRank',
        unmetOutcomeId: 'unmet',
        keepActualOutcome: true,
      },
      // CoC7 SAN疯狂判定：基于SAN损失量和SAN阈值触发
      secondaryEffects: [
        {
          id: 'coc7_temp_insanity',
          trigger: { type: 'delta', attribute: 'SAN', operator: 'gte', value: '5' },
          outputText: '⚠ 单次SAN损失$delta点(≥5)，触发临时疯狂流程，自动进行INT检定。',
          subCheck: {
            label: 'INT检定',
            attribute: 'INT',
            attributeCandidates: ['智力', '灵感', '灵感值'],
            dice: '1d100',
            operator: 'lte',
            success: {
              outputText:
                '🧠 $subCheckLabel：$subCheckDice=$subCheckRoll，判定 $subCheckRoll <= $subCheckTarget？$subCheckJudge，$initiator 陷入临时疯狂。\n症状：$symptomResult\n持续时间：即时发作约$durationImmediateRoll轮，整体影响约$durationSummaryRoll小时。',
              randomTables: {
                durationImmediate: { dice: '1d10' },
                durationSummary: { dice: '1d10' },
                symptom: {
                  dice: '1d10',
                  entries: {
                    1: '失忆——$initiator 回过神来，发现自己身处陌生之处，不记得这段时间发生了什么',
                    2: '假性残疾——$initiator 陷入心因性失明、失聪或肢体瘫痪',
                    3: '暴力倾向——$initiator 陷入暴怒，不分敌我地攻击周围一切',
                    4: '偏执——$initiator 产生严重的被害妄想，不信任任何人',
                    5: '重要之人——$initiator 把在场某人当作了自己生命中的重要之人',
                    6: '昏厥——$initiator 当场昏倒，不省人事',
                    7: '惊慌逃跑——$initiator 不顾一切地逃离此地',
                    8: '歇斯底里——$initiator 情绪彻底崩溃，无法控制地大笑、大哭或尖叫',
                    9: '恐惧症——$initiator 获得一个新的恐惧症（由KP根据场景决定具体内容）',
                    10: '狂躁症——$initiator 获得一个新的狂躁症（由KP根据场景决定具体内容）',
                  },
                },
              },
            },
            failure: {
              outputText:
                '🧠 $subCheckLabel：$subCheckDice=$subCheckRoll，判定 $subCheckRoll <= $subCheckTarget？$subCheckJudge，$initiator 未陷入临时疯狂。',
            },
          },
          enabled: true,
          maxTriggerCount: 1,
        },
        {
          id: 'coc7_permanent_insanity',
          trigger: { type: 'threshold', attribute: 'SAN', operator: 'lte', value: '0' },
          outputText: '💀 永久疯狂！SAN值降至$new，该角色永久疯狂，由KP接管成为NPC。',
          enabled: true,
          maxTriggerCount: 1,
        },
      ],
      contestRule: {
        mode: 'rank', // 对抗模式：按成功等级
        tieBreakers: ['higher_attr', 'initiator_wins'], // 平局处理：先比属性，再判发起方胜
      },
      outputTemplate:
        '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 发起了 $attrName 检定，$formula=$roll，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】\n</meta:检定结果>',
    },
    {
      kind: 'advanced',
      id: 'coc7_growth_check',
      name: 'CoC7-成长',
      description: '幕间技能成长快捷模式（检定成功可成长）',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      visible: false,
      diceExpression: '1d100',
      attribute: {
        label: '技能值',
        placeholder: '留空=50',
        defaultValue: 50,
        key: '技能值',
      },
      dc: {
        hidden: true,
        defaultValue: 0,
      },
      mod: {
        hidden: true,
        defaultValue: 0,
      },
      customFields: [
        {
          id: 'growthGain',
          type: 'text',
          label: '成长值',
          defaultValue: '1d10',
          placeholder: '如 1d10',
        },
      ],
      outcomes: [
        {
          id: 'growth_success',
          name: '成功',
          condition: '$roll.total > $attr',
          priority: 30,
          rank: 1,
          outputText: '',
        },
        {
          id: 'growth_failure',
          name: '失败',
          condition: '$roll.total <= $attr',
          displayExpr: '$roll.total > $attr',
          priority: 60,
          rank: 0,
          outputText: '',
        },
      ],
      currentAttrAutoUpdate: {
        enabled: true,
        when: 'success',
        operation: 'add',
        valueExpr: '$growthGain',
        min: 0,
        changeLabel: '成长',
        outputTextTemplate: '已填表：$attr成长$expr=$rolled，$attrPlain从$old变为$new',
      },
      outputTemplate:
        '<meta:检定结果>\n元叙事：$initiator 发起了$attrName成长检定，$formula=$roll，判定 $conditionExpr？$judgeResult，结果为【$outcomeName】\n</meta:检定结果>',
    },
    // DND5e 规则: 1d20 + 调整值 >= DC (调整值 = floor((属性值-10)/2))
    {
      kind: 'advanced',
      id: 'dnd5e_check',
      name: 'DND5e',
      description: 'D&D第五版: 1d20 + 调整值 >= DC (调整值自动从属性值计算)',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      diceExpression: '1d20',
      attribute: {
        label: '属性值',
        placeholder: '留空=10',
        defaultValue: 10,
        key: '属性值',
        // DND特有：从属性值计算调整值
        computeModifier: 'floor(($attr - 10) / 2)',
      },
      dc: {
        label: '难度等级(DC)',
        placeholder: '留空=10',
        defaultValue: 10,
      },
      mod: {
        label: '额外加值',
        placeholder: '留空=0',
        defaultValue: 0,
      },
      // 技能加值（DND5e 技能检定使用）
      skillMod: {
        label: '技能加值',
        placeholder: '留空=0',
        defaultValue: 0,
      },
      // 属性填入目标映射：技能类属性填入 skillMod，基础属性填入 attribute
      attrTargetMapping: {
        skillMod: [
          // DND5e 18个技能
          '运动', // 力量
          '体操',
          '巧手',
          '隐匿', // 敏捷
          '奥秘',
          '历史',
          '调查',
          '自然',
          '宗教', // 智力
          '驯兽',
          '洞悉',
          '医药',
          '察觉',
          '求生', // 感知
          '欺瞒',
          '威吓',
          '表演',
          '游说', // 魅力
        ],
      },
      customFields: [
        {
          id: 'advantage',
          type: 'select',
          label: '优势/劣势',
          defaultValue: 0,
          options: [
            { label: '正常', value: 0 },
            { label: '优势', value: 1 },
            { label: '劣势', value: -1 },
          ],
        },
      ],
      dicePatches: [
        { when: '$advantage > 0', op: 'replace', template: '2d20kh1' }, // 优势
        { when: '$advantage < 0', op: 'replace', template: '2d20kl1' }, // 劣势
      ],
      outcomes: [
        {
          id: 'crit_success',
          name: '大成功',
          condition: "$roll.hasTag('nat20')",
          priority: 1,
          outputText: '',
        },
        {
          id: 'success',
          name: '成功',
          // $attrMod 是从属性值计算的调整值，$skillMod 是技能加值
          condition: '$roll.total + $attrMod + $skillMod + $mod >= $dc',
          priority: 30,
          outputText: '',
        },
        {
          id: 'failure',
          name: '失败',
          condition: 'true',
          displayExpr: '$roll.total + $attrMod + $skillMod + $mod >= $dc', // 显示成功条件，失败时显示"不成立"
          priority: 50,
          outputText: '',
        },
        {
          id: 'crit_failure',
          name: '大失败',
          condition: "$roll.hasTag('nat1')",
          priority: 2,
          outputText: '',
        },
      ],
      contestRule: {
        mode: 'value', // 对抗模式：按总值比较
        tieBreakers: ['status_quo'], // 平局维持现状
        hideDc: true, // 对抗检定时隐藏DC（双方直接比较总值，不需要固定难度）
        // hideMod: false - 对抗检定时显示额外加值字段
      },
      // DND对抗检定专用模板：双方总值直接比较，不使用固定DC
      contestOutputTemplate: `<meta:检定结果>
 元叙事：进行了一次【$initiator $initAttrName vs $opponent $oppAttrName】的对抗检定。
 $initiator $initAttrName：$formula=$initRoll$initAttrModText$initSkillModText$initModText，总值=$initTotal；
 $opponent $oppAttrName：$formula=$oppRoll$oppAttrModText$oppSkillModText$oppModText，总值=$oppTotal。
 最终结果：【$winner】
 </meta:检定结果>`,
      outputTemplate:
        '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 发起了 $attrName 检定，属性值$attrValue$attrModText$skillModText，$formula=$roll，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】\n</meta:检定结果>',
    },
    {
      kind: 'advanced',
      id: 'fate',
      name: 'Fate',
      description: 'Fate规则: 4dF + 技能值 + 修正值 >= 难度',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      diceExpression: '4dF',
      attributeName: {
        label: '技能/风格',
        placeholder: '自由检定',
      },
      attribute: {
        label: '技能值',
        placeholder: '留空=0',
        defaultValue: 0,
        key: '技能值',
      },
      dc: {
        label: '难度',
        placeholder: '留空=0',
        defaultValue: 0,
      },
      mod: {
        label: '修正值',
        placeholder: '留空=0',
        defaultValue: 0,
      },
      outcomes: [
        {
          id: 'succeed_with_style',
          name: '大成功',
          condition: '$roll.total + $attr + $mod >= $dc + 3',
          priority: 1,
          outputText: 'Fate: 大成功！超出难度3级或更多，可获得额外好处。',
        },
        {
          id: 'success',
          name: '成功',
          condition: '$roll.total + $attr + $mod >= $dc',
          priority: 10,
          outputText: 'Fate: 成功，达成目标。',
        },
        {
          id: 'tie',
          name: '平手',
          condition: '$roll.total + $attr + $mod === $dc - 1',
          priority: 20,
          outputText: 'Fate: 平手，勉强达成但可能有小代价。',
        },
        {
          id: 'failure',
          name: '失败',
          condition: '$roll.total + $attr + $mod < $dc',
          priority: 99,
          outputText: 'Fate: 失败，未能达成目标。',
        },
      ],
      contestRule: {
        mode: 'margin', // 对抗模式：按总值差值裁决
        hideDc: true, // 对抗检定时隐藏难度字段（双方直接比较）
      },
      outputTemplate:
        '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 发起了 $attrName 检定，技能等级$attrValue，修正值$mod，$formula=$roll，总值=$roll+$attr+$mod，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】\n</meta:检定结果>',
      contestOutputTemplate: `<meta:检定结果>
 元叙事：进行了一次【$initiator $initAttrName vs $opponent $oppAttrName】的Fate对抗检定。
 $initiator $initAttrName：$formula=$initRoll，技能等级$initAttr+修正值$initMod，总值=$initTotal；
 $opponent $oppAttrName：$formula=$oppRoll，技能等级$oppAttr+修正值$oppMod，总值=$oppTotal。
 差值(Shifts)：$margin（正数表示$initiator领先，负数表示$opponent领先）
 最终结果：【$winner】
 </meta:检定结果>`,
    },
    // PbtA 规则: 2d6 + 属性值, 6-失败/7-9部分成功/10+完全成功
    {
      kind: 'advanced',
      id: 'pbta_move',
      name: 'PbtA',
      description: 'Powered by the Apocalypse: 2d6+属性, 6-失败/7-9部分成功/10+完全成功',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      diceExpression: '2d6',
      attribute: {
        label: '属性值',
        placeholder: '留空=0',
        defaultValue: 0,
        key: '属性',
      },
      dc: {
        hidden: true,
        defaultValue: 0,
      },
      mod: {
        label: '临时加值',
        placeholder: '留空=0',
        defaultValue: 0,
      },
      outcomes: [
        {
          id: 'strong_hit',
          name: '完全成功',
          condition: '$roll.total + $attr + $mod >= 10',
          priority: 1,
          outputText: 'PbtA:完全成功!',
        },
        {
          id: 'weak_hit',
          name: '部分成功',
          condition: '$roll.total + $attr + $mod >= 7',
          priority: 20,
          outputText: 'PbtA:部分成功。',
        },
        {
          id: 'miss',
          name: '失败',
          condition: '$roll.total + $attr + $mod < 7',
          priority: 99,
          outputText: 'PbtA:失败...',
        },
      ],
      contestRule: {
        disabled: true, // PbtA 规则不支持传统对抗检定
      },
      outputTemplate:
        '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 发起了 $attrName 检定，属性值$attrValue，临时加值$mod，$formula=$roll，总值=$roll+$attr+$mod，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】\n</meta:检定结果>',
    },
    // 三角机构规则: 6d4统计3的个数
    {
      kind: 'advanced',
      id: 'triangle_agency',
      name: '三角机构',
      description: '6d4统计3的个数；至少一个3成功，三个3为三重升华；无3失败',
      version: PRESET_FORMAT_VERSION,
      builtin: true,
      diceExpression: '6d4=3',
      attribute: {
        hidden: true,
        defaultValue: 0,
      },
      dc: {
        hidden: true,
        defaultValue: 0,
      },
      mod: {
        hidden: true,
        defaultValue: 0,
      },
      derivedVars: [{ id: 'chaos', expr: '6 - $roll.total' }],
      outcomes: [
        {
          id: 'triple_success',
          name: '三重升华',
          condition: '$roll.total === 3',
          priority: 1,
          rank: 3,
          outputText: '三角机构：三重升华！命中三个3，完美共鸣达成。',
        },
        {
          id: 'success',
          name: '成功',
          condition: '$roll.total >= 1',
          priority: 10,
          rank: 1,
          outputText: '三角机构：成功。至少命中一个3，行动达成。',
        },
        {
          id: 'failure',
          name: '失败',
          condition: '$roll.total === 0',
          priority: 50,
          rank: 0,
          outputText: '三角机构：失败。未能命中任何3，行动受阻。',
        },
      ],
      contestRule: {
        disabled: true, // 三角机构不支持对抗检定
      },
      outputTemplate:
        '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 的三角机构检定，$formula=$roll，命中3的个数：$roll.total，GM获得混沌：$chaos，判定为【$outcomeName】\n</meta:检定结果>',
    },
  ];

  // ========================================
  // 属性规则预设系统
  // ========================================

  // 内置属性规则预设
  const BUILTIN_ATTRIBUTE_PRESETS = [
    {
      format: 'acu_attr_preset_v1',
      version: PRESET_FORMAT_VERSION,
      id: 'coc7',
      name: '简化COC规则',
      builtin: true,
      description: '基于克苏鲁的呼唤第7版规则的属性预设。包含9条基本属性和18条特殊属性。',
      baseAttributes: [
        { name: '力量', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '体质', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '体型', formula: '2d6*5+30', range: [40, 90], modifier: '1d10-5' },
        { name: '敏捷', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '外貌', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '意志', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '幸运', formula: '3d6*5', range: [15, 90], modifier: '1d10-5' },
        { name: '智力', formula: '2d6*5+30', range: [40, 90], modifier: '1d10-5' },
        { name: '教育', formula: '2d6*5+30', range: [40, 90], modifier: '1d10-5' },
      ],
      specialAttributes: [
        // 高频核心技能（范围 15-110，限制到95，平均60）
        { name: '侦查', formula: '10+5d20', range: [15, 95] },
        { name: '聆听', formula: '10+5d20', range: [15, 95] },
        { name: '心理学', formula: '10+5d20', range: [15, 95] },
        // 中频常用技能（范围 9-85，平均47）
        { name: '说服', formula: '5+4d20', range: [9, 85] },
        { name: '话术', formula: '5+4d20', range: [9, 85] },
        { name: '潜行', formula: '5+4d20', range: [9, 85] },
        { name: '格斗', formula: '5+4d20', range: [9, 85] },
        { name: '射击', formula: '5+4d20', range: [9, 85] },
        { name: '信用评级', formula: '5+4d20', range: [9, 85] },
        // 低频辅助技能（范围 8-65，平均36）
        { name: '魅惑', formula: '5+3d20', range: [8, 65] },
        { name: '恐吓', formula: '5+3d20', range: [8, 65] },
        { name: '图书馆使用', formula: '5+3d20', range: [8, 65] },
        { name: '急救', formula: '5+3d20', range: [8, 65] },
        { name: '驾驶', formula: '5+3d20', range: [8, 65] },
        // 极低稀有技能（范围 3-41，平均22）
        { name: '神秘学', formula: '1+2d20', range: [3, 41] },
        // 公式计算
        { name: '闪避', formula: '敏捷/2', range: [1, 99] },
        // COC 特色
        { name: 'SAN值', formula: '意志', range: [1, 99] },
        { name: '克苏鲁神话', formula: '1d5', range: [1, 5] },
      ],
    },
    {
      format: 'acu_attr_preset_v1',
      version: PRESET_FORMAT_VERSION,
      id: 'dnd5e',
      name: '简化DND规则',
      builtin: true,
      description:
        '基于龙与地下城第5版规则的属性预设。包含6条基本属性和19条技能/派生属性。技能使用长尾分布：多数人为0或负值，少数专家可达+10以上。',
      baseAttributes: [
        { name: '力量', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
        { name: '敏捷', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
        { name: '体质', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
        { name: '智力', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
        { name: '感知', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
        { name: '魅力', formula: '4d6dl1', range: [3, 18], modifier: '1d4-2' },
      ],
      specialAttributes: [
        // DND5e 18个技能 - 使用 NdMkl1-X 公式实现长尾分布
        // 原理：取多个骰子的最低值，低值常见、高值稀有
        // 例如 4d8kl1-3: 范围 -2 到 +5，大部分人在 -2~+1，少数专家能到 +5

        // 力量系技能
        { name: '运动', formula: '4d8kl1-3', range: [-2, 5] }, // 范围 -2 到 +5
        // 敏捷系技能
        { name: '杂技', formula: '4d8kl1-3', range: [-2, 5] },
        { name: '巧手', formula: '4d8kl1-3', range: [-2, 5] },
        { name: '隐匿', formula: '5d10kl1-4', range: [-3, 6] }, // 高频，长尾更长
        // 智力系技能
        { name: '奥秘', formula: '3d6kl1-2', range: [-1, 4] }, // 稀有技能，范围小
        { name: '历史', formula: '3d6kl1-2', range: [-1, 4] },
        { name: '调查', formula: '4d8kl1-3', range: [-2, 5] },
        { name: '自然', formula: '3d6kl1-2', range: [-1, 4] },
        { name: '宗教', formula: '3d6kl1-2', range: [-1, 4] },
        // 感知系技能
        { name: '驯兽', formula: '3d6kl1-2', range: [-1, 4] },
        { name: '洞悉', formula: '5d10kl1-4', range: [-3, 6] }, // 高频
        { name: '医药', formula: '3d6kl1-2', range: [-1, 4] },
        { name: '察觉', formula: '5d10kl1-4', range: [-3, 6] }, // 高频，长尾更长
        { name: '求生', formula: '3d6kl1-2', range: [-1, 4] },
        // 魅力系技能
        { name: '欺瞒', formula: '4d8kl1-3', range: [-2, 5] },
        { name: '威吓', formula: '4d8kl1-3', range: [-2, 5] },
        { name: '表演', formula: '3d6kl1-2', range: [-1, 4] },
        { name: '游说', formula: '4d8kl1-3', range: [-2, 5] },
        // 派生属性
        { name: '先攻', formula: 'floor((敏捷-10)/2)', range: [-4, 4] },
      ],
    },
  ];

  // 属性预设管理器
  const AttributePresetManager = (() => {
    let _cache = null;

    return {
      // 获取所有预设（内置 + 自定义，自动检测并更新版本）
      getAllPresets() {
        const stored = Store.get(STORAGE_KEY_ATTRIBUTE_PRESETS, []);
        // 自动检测并更新所有自定义预设的版本（每次调用都检测，不依赖缓存）
        let needsSave = false;
        stored.forEach(preset => {
          const presetVersion = preset.version || '0.0.0';
          if (compareVersion(presetVersion, PRESET_FORMAT_VERSION) < 0) {
            console.log(
              `[DICE]AttributePresetManager 检测到预设 "${preset.name}" 版本较旧 (${presetVersion})，自动更新到 ${PRESET_FORMAT_VERSION}`,
            );
            preset.version = PRESET_FORMAT_VERSION;
            needsSave = true;
          }
        });
        if (needsSave) {
          Store.set(STORAGE_KEY_ATTRIBUTE_PRESETS, stored);
          // 清除缓存，确保下次获取时使用更新后的数据
          _cache = null;
        }
        // 只有在没有更新时才使用缓存
        if (!needsSave && _cache) {
          return _cache;
        }
        _cache = [...BUILTIN_ATTRIBUTE_PRESETS, ...stored];
        return _cache;
      },

      // 获取当前激活的预设（null = 使用默认逻辑）
      getActivePreset() {
        const activeId = Store.get(STORAGE_KEY_ACTIVE_ATTR_PRESET, null);
        if (!activeId) return null;
        return this.getAllPresets().find(p => p.id === activeId) || null;
      },

      // 设置激活的预设
      setActivePreset(id) {
        try {
          // 如果id是空字符串，设置为null
          const finalId = id === '' || id === undefined ? null : id;
          Store.set(STORAGE_KEY_ACTIVE_ATTR_PRESET, finalId);
          // 清除缓存，确保下次获取时是最新的
          _cache = null;
          console.log('[DICE]AttributePresetManager 切换预设:', finalId);
          // 延迟调用以确保函数已定义（函数在 AttributePresetManager 之后定义）
          setTimeout(() => {
            if (typeof updateTemplateForActivePreset === 'function') {
              updateTemplateForActivePreset(finalId);
            }
          }, 0);
          return true;
        } catch (err) {
          console.error('[DICE]AttributePresetManager 设置预设失败:', err);
          return false;
        }
      },

      // 创建自定义预设
      createPreset(preset) {
        const stored = Store.get(STORAGE_KEY_ATTRIBUTE_PRESETS, []);
        const newPreset = {
          ...preset,
          id: preset.id || 'custom_' + Date.now(),
          builtin: false,
          version: preset.version || PRESET_FORMAT_VERSION,
          createdAt: new Date().toISOString(),
        };
        stored.push(newPreset);
        Store.set(STORAGE_KEY_ATTRIBUTE_PRESETS, stored);
        _cache = null;
        console.log('[DICE]AttributePresetManager 创建预设:', newPreset.name);
        return newPreset;
      },

      // 更新自定义预设
      updatePreset(id, updates) {
        const stored = Store.get(STORAGE_KEY_ATTRIBUTE_PRESETS, []);
        const index = stored.findIndex(p => p.id === id);
        if (index < 0) return false;
        stored[index] = { ...stored[index], ...updates };
        Store.set(STORAGE_KEY_ATTRIBUTE_PRESETS, stored);
        _cache = null;
        console.log('[DICE]AttributePresetManager 更新预设:', id);
        return true;
      },

      // 删除自定义预设
      deletePreset(id) {
        const stored = Store.get(STORAGE_KEY_ATTRIBUTE_PRESETS, []);
        const filtered = stored.filter(p => p.id !== id);
        if (filtered.length === stored.length) return false;
        Store.set(STORAGE_KEY_ATTRIBUTE_PRESETS, filtered);
        _cache = null;
        // 如果删除的是激活预设，清除激活状态
        if (Store.get(STORAGE_KEY_ACTIVE_ATTR_PRESET) === id) {
          Store.set(STORAGE_KEY_ACTIVE_ATTR_PRESET, null);
        }
        console.log('[DICE]AttributePresetManager 删除预设:', id);
        return true;
      },

      // 导出预设为 JSON
      exportPreset(id) {
        const preset = this.getAllPresets().find(p => p.id === id);
        if (!preset) return null;
        const exported = {
          format: 'acu_attr_preset_v1',
          version: PRESET_FORMAT_VERSION,
          ...preset,
        };
        delete exported.builtin; // 导出时移除内置标记
        return JSON.stringify(exported, null, 2);
      },

      // 从 JSON 导入预设
      importPreset(jsonStr, autoUpdate = false) {
        try {
          const data = JSON.parse(jsonStr);

          // 校验格式
          if (data.format !== 'acu_attr_preset_v1') {
            throw new Error('不支持的预设格式');
          }

          // 基本校验
          if (!data.name || !data.baseAttributes || !Array.isArray(data.baseAttributes)) {
            throw new Error('预设数据不完整');
          }

          const importedVersion = data.version || '0.0.0';
          const needsUpdate = compareVersion(importedVersion, PRESET_FORMAT_VERSION) < 0;

          // 生成新ID避免冲突
          const imported = {
            ...data,
            id: 'imported_' + Date.now(),
            builtin: false,
            version: autoUpdate && needsUpdate ? PRESET_FORMAT_VERSION : importedVersion,
            createdAt: new Date().toISOString(),
          };

          const result = this.createPreset(imported);
          if (result && needsUpdate && !autoUpdate) {
            console.warn(
              `[DICE]AttributePresetManager 导入的预设 "${result.name}" 版本较旧 (${importedVersion})，建议更新到 ${PRESET_FORMAT_VERSION}`,
            );
          }
          return result;
        } catch (e) {
          console.error('[DICE]AttributePresetManager 导入失败:', e);
          return null;
        }
      },

      // 清除缓存
      clearCache() {
        _cache = null;
      },
    };
  })();

  // ========================================
  // 高级骰子预设管理器
  // ========================================

  const STORAGE_KEY_ACTIVE_ADVANCED_PRESET = 'acu_active_advanced_preset';

  // 高级骰子预设管理器
  const AdvancedDicePresetManager = (() => {
    let _cache = null;

    const getBuiltinPresetVisibilityMap = (): Record<string, boolean> => {
      const stored = Store.get(STORAGE_KEY_BUILTIN_PRESET_VISIBILITY, {});
      if (!stored || typeof stored !== 'object') return {};
      return stored as Record<string, boolean>;
    };

    const getBuiltinPresetOrderMap = (): Record<string, number> => {
      const stored = Store.get(STORAGE_KEY_BUILTIN_PRESET_ORDER, {});
      if (!stored || typeof stored !== 'object') return {};
      return stored as Record<string, number>;
    };

    return {
      // 获取所有预设（内置 + 自定义）
      getAllPresets() {
        const stored = Store.get(STORAGE_KEY_ADVANCED_PRESETS, []);
        // 自动检测并更新所有自定义预设的版本
        let needsSave = false;
        stored.forEach(preset => {
          const presetVersion = preset.version || '0.0.0';
          if (compareVersion(presetVersion, PRESET_FORMAT_VERSION) < 0) {
            console.log(
              `[DICE]AdvancedDicePresetManager 检测到预设 "${preset.name}" 版本较旧 (${presetVersion})，自动更新到 ${PRESET_FORMAT_VERSION}`,
            );
            preset.version = PRESET_FORMAT_VERSION;
            needsSave = true;
          }
        });
        if (needsSave) {
          Store.set(STORAGE_KEY_ADVANCED_PRESETS, stored);
          _cache = null;
        }
        // 只有在没有更新时才使用缓存
        if (!needsSave && _cache) {
          return _cache;
        }

        // 填充默认值并合并
        const builtinVisibilityMap = getBuiltinPresetVisibilityMap();
        const builtinOrderMap = getBuiltinPresetOrderMap();
        const processedBuiltin = BUILTIN_ADVANCED_PRESETS.map((p, index) => ({
          ...p,
          visible: builtinVisibilityMap[p.id] ?? p.visible ?? true,
          order: builtinOrderMap[p.id] ?? p.order ?? index,
        }));

        const processedCustom = stored.map(p => ({
          ...p,
          visible: p.visible ?? false,
          order: p.order ?? 999,
        }));

        _cache = [...processedBuiltin, ...processedCustom];
        return _cache;
      },

      // 获取当前激活的预设（null = 未激活）
      getActivePreset() {
        const activeId = Store.get(STORAGE_KEY_ACTIVE_ADVANCED_PRESET, null);
        if (!activeId) return null;
        return this.getAllPresets().find(p => p.id === activeId) || null;
      },

      // 设置激活的预设
      setActivePreset(id) {
        try {
          const finalId = id === '' || id === undefined ? null : id;
          Store.set(STORAGE_KEY_ACTIVE_ADVANCED_PRESET, finalId);
          _cache = null;
          console.log('[DICE]AdvancedDicePresetManager 切换预设:', finalId);
          return true;
        } catch (err) {
          console.error('[DICE]AdvancedDicePresetManager 设置预设失败:', err);
          return false;
        }
      },

      setBuiltinPresetVisibility(id, visible) {
        try {
          const map = getBuiltinPresetVisibilityMap();
          map[id] = visible;
          Store.set(STORAGE_KEY_BUILTIN_PRESET_VISIBILITY, map);
          _cache = null;
          return true;
        } catch (err) {
          console.error('[DICE]AdvancedDicePresetManager 设置内置预设显示状态失败:', err);
          return false;
        }
      },

      setPresetOrder(id, order) {
        try {
          if (BUILTIN_ADVANCED_PRESETS.some(p => p.id === id)) {
            const map = getBuiltinPresetOrderMap();
            map[id] = order;
            Store.set(STORAGE_KEY_BUILTIN_PRESET_ORDER, map);
            _cache = null;
            return true;
          }
          return this.updatePreset(id, { order });
        } catch (err) {
          console.error('[DICE]AdvancedDicePresetManager 设置预设排序失败:', err);
          return false;
        }
      },

      // 创建自定义预设
      createPreset(preset) {
        const stored = Store.get(STORAGE_KEY_ADVANCED_PRESETS, []);
        const newPreset = {
          ...preset,
          id: preset.id || 'custom_' + Date.now(),
          kind: 'advanced',
          builtin: false,
          version: preset.version || PRESET_FORMAT_VERSION,
          createdAt: new Date().toISOString(),
        };
        stored.push(newPreset);
        Store.set(STORAGE_KEY_ADVANCED_PRESETS, stored);
        _cache = null;
        console.log('[DICE]AdvancedDicePresetManager 创建预设:', newPreset.name);
        return newPreset;
      },

      // 更新自定义预设
      updatePreset(id, updates) {
        // 禁止修改内置预设
        if (BUILTIN_ADVANCED_PRESETS.some(p => p.id === id)) {
          console.error('[DICE]AdvancedDicePresetManager 不能修改内置预设:', id);
          throw new Error('不能修改内置预设');
        }
        const stored = Store.get(STORAGE_KEY_ADVANCED_PRESETS, []);
        const index = stored.findIndex(p => p.id === id);
        if (index < 0) return false;
        stored[index] = { ...stored[index], ...updates, id }; // 保持ID不变
        Store.set(STORAGE_KEY_ADVANCED_PRESETS, stored);
        _cache = null;
        console.log('[DICE]AdvancedDicePresetManager 更新预设:', id);
        return true;
      },

      // 删除自定义预设
      deletePreset(id) {
        // 禁止删除内置预设
        if (BUILTIN_ADVANCED_PRESETS.some(p => p.id === id)) {
          console.error('[DICE]AdvancedDicePresetManager 不能删除内置预设:', id);
          throw new Error('不能删除内置预设');
        }
        const stored = Store.get(STORAGE_KEY_ADVANCED_PRESETS, []);
        const filtered = stored.filter(p => p.id !== id);
        if (filtered.length === stored.length) return false;
        Store.set(STORAGE_KEY_ADVANCED_PRESETS, filtered);
        _cache = null;
        // 如果删除的是激活预设，清除激活状态
        if (Store.get(STORAGE_KEY_ACTIVE_ADVANCED_PRESET) === id) {
          Store.set(STORAGE_KEY_ACTIVE_ADVANCED_PRESET, null);
        }
        console.log('[DICE]AdvancedDicePresetManager 删除预设:', id);
        return true;
      },

      // 导出预设为 JSON
      exportPreset(id) {
        const preset = this.getAllPresets().find(p => p.id === id);
        if (!preset) return null;
        const exported = {
          kind: 'advanced',
          version: PRESET_FORMAT_VERSION,
          ...preset,
        };
        delete exported.builtin; // 导出时移除内置标记
        return JSON.stringify(exported, null, 2);
      },

      // 从 JSON 导入预设
      importPreset(jsonStr) {
        try {
          const data = JSON.parse(jsonStr);

          // 校验格式
          if (data.kind !== 'advanced') {
            throw new Error('不支持的预设格式');
          }

          // 基本校验
          if (!data.name || !data.diceExpression) {
            throw new Error('预设数据不完整: 缺少名称或骰子表达式');
          }

          // 校验判定条件：必须有 outcomes
          if (!Array.isArray(data.outcomes) || data.outcomes.length === 0) {
            throw new Error('预设数据不完整: 缺少 outcomes 判定条件');
          }

          const importedVersion = data.version || '0.0.0';
          const needsUpdate = compareVersion(importedVersion, PRESET_FORMAT_VERSION) < 0;

          // 数据迁移：合并旧版 UI 字段
          if (data.ui) {
            if (data.ui.attributeLabel && data.attribute) data.attribute.label = data.ui.attributeLabel;
            if (data.ui.dcLabel && data.dc) data.dc.label = data.ui.dcLabel;
            delete data.ui;
          }

          // 生成新ID避免冲突
          const imported = {
            ...data,
            id: 'imported_' + Date.now(),
            kind: 'advanced',
            builtin: false,
            version: PRESET_FORMAT_VERSION,
            createdAt: new Date().toISOString(),
          };

          const result = this.createPreset(imported);
          if (result && needsUpdate) {
            console.warn(
              `[DICE]AdvancedDicePresetManager 导入的预设 "${result.name}" 版本较旧 (${importedVersion})，已自动更新到 ${PRESET_FORMAT_VERSION}`,
            );
          }
          return result;
        } catch (e) {
          console.error('[DICE]AdvancedDicePresetManager 导入失败:', e);
          return null;
        }
      },

      // 清除缓存
      clearCache() {
        _cache = null;
      },

      /**
       * 检查预设是否支持对抗检定
       * @param preset 预设对象或预设ID
       * @returns true 表示支持对抗检定，false 表示不支持
       */
      supportsContest(preset: AdvancedDicePreset | string | null | undefined): boolean {
        if (!preset) return true; // 无预设时（自定义模式）默认支持

        const presetObj = typeof preset === 'string' ? this.getAllPresets().find(p => p.id === preset) : preset;
        if (!presetObj) return true; // 找不到预设时默认支持

        // 检查 contestRule.disabled 标志
        return !(presetObj.contestRule?.disabled === true);
      },
    };
  })();

  // ========================================
  // 预设切换时更新表格模板
  // ========================================

  /**
   * 根据数值范围动态生成属性标尺描述（包含基准说明）
   * 将范围按比例划分为6个区间：能力缺失/弱项/平均/精英/极限/破格
   * @param min 范围最小值
   * @param max 范围最大值
   * @returns 完整的属性标尺描述字符串（包含标尺和基准说明）
   */
  const generateAttributeScale = (min: number, max: number): string => {
    const range = max - min;

    // 计算各区间的边界值（向下取整）
    const threshold1 = Math.floor(min + range * 0.1); // 能力缺失上限
    const threshold2 = Math.floor(min + range * 0.4); // 弱项上限
    const threshold3 = Math.floor(min + range * 0.6); // 平均上限
    const threshold4 = Math.floor(min + range * 0.8); // 精英上限
    const threshold5 = Math.floor(min + range * 0.9); // 极限上限

    // 生成标尺字符串，处理边界情况（避免出现 "3-3" 这样的区间）
    const formatRange = (start: number, end: number): string => {
      if (start === end) return `${start}`;
      return `${start}-${end}`;
    };

    const scales = [
      `${formatRange(min, threshold1)}:能力缺失`,
      `${formatRange(threshold1 + 1, threshold2)}:弱项`,
      `${formatRange(threshold2 + 1, threshold3)}:平均`,
      `${formatRange(threshold3 + 1, threshold4)}:精英`,
      `${formatRange(threshold4 + 1, threshold5)}:极限`,
      `${formatRange(threshold5 + 1, max)}:破格`,
    ];

    const scaleStr = scales.join(' | ');

    // 计算基准说明中的动态数值
    // "聚集在40-60" → 平均区间
    // "90+呈断崖式稀缺" → 极限区间起点
    // "重伤→0-10" → 能力缺失区间
    // "肾上腺素→80" → 精英区间的高端值
    const avgStart = threshold2 + 1;
    const avgEnd = threshold3;
    const rareThreshold = threshold5 + 1; // 破格区间起点
    const debuffRange = formatRange(min, threshold1); // 能力缺失区间
    const buffRange = formatRange(threshold4 + 1, threshold5); // 精英区间上限

    const baseDescription = `基准: 数值呈指数增长；分布呈长尾状(绝大多数聚集在${avgStart}-${avgEnd}，${rareThreshold}+呈断崖式稀缺)，依角色[身份背景]生成，当前值受[当前状态]修正。如:重伤→${debuffRange}; 肾上腺素→${buffRange}`;

    return `${scaleStr}。${baseDescription}`;
  };

  // 默认规则的特有属性模板内容（用于恢复）
  const DEFAULT_SPECIAL_ATTR_TEMPLATE = {
    // 主角信息表和重要人物表统一的默认内容
    range: [0, 100] as [number, number],
    // 默认示例（分号分隔格式）
    example: '爆裂魔法:85; 时间回溯:70; 超电磁炮:90',
  };

  // 默认规则的虚拟预设定义（六维属性百分制）
  const DEFAULT_VIRTUAL_PRESET = {
    id: '__default__',
    name: '六维属性百分制',
    baseAttributes: ['力量', '敏捷', '体质', '智力', '感知', '魅力'].map(name => ({
      name,
      formula: '3d6*5',
      range: [5, 95] as [number, number],
      modifier: '1d10-5',
    })),
    specialAttributes: [] as { name: string; formula: string; range: [number, number]; modifier: string }[],
  };

  /**
   * 替换标签内容的通用函数（支持多行内容）
   * @param text 原始文本
   * @param tag 标签名（中文标签如 "属性规则"）
   * @param content 新内容
   */
  const replaceTag = (text: string, tag: string, content: string): string => {
    // 使用 [\s\S]* 匹配任意字符（包括换行）
    const regex = new RegExp(`<${tag}>[\\s\\S]*?</${tag}>`, 'g');
    return text.replace(regex, `<${tag}>\n${content}\n</${tag}>`);
  };

  /**
   * 根据激活的属性预设更新表格模板中的示例和范围
   * @param presetId 预设ID，null 表示使用默认逻辑
   */
  const updateTemplateForActivePreset = (presetId: string | null): void => {
    // 1. 获取预设对象（默认规则使用虚拟预设，确保统一处理路径）
    type AttributePreset = (typeof BUILTIN_ATTRIBUTE_PRESETS)[number];
    let preset: AttributePreset;
    if (presetId === null || presetId === '__default__') {
      // 使用虚拟默认预设
      preset = DEFAULT_VIRTUAL_PRESET as AttributePreset;
    } else {
      const found = AttributePresetManager.getAllPresets().find((p: AttributePreset) => p.id === presetId);
      preset = found || (DEFAULT_VIRTUAL_PRESET as AttributePreset);
    }

    // 2. 生成随机属性值
    // 注意：对于默认规则，传入 null 以使用 generateRPGAttributes 的内置默认逻辑
    const attrs = generateRPGAttributes(presetId === null || presetId === '__default__' ? null : preset);
    // attrs = { base: {...}, special: {...} }

    // 3. 计算数值范围（统一从 preset 对象读取）
    let baseRangeMin = 0;
    let baseRangeMax = 100;
    let specialRangeMin = 0;
    let specialRangeMax = 100;

    // 基础属性范围：取所有 baseAttributes.range 的 min/max
    if (preset.baseAttributes && preset.baseAttributes.length > 0) {
      const baseRanges = preset.baseAttributes.map(attr => attr.range);
      baseRangeMin = Math.min(...baseRanges.map(r => r[0]));
      baseRangeMax = Math.max(...baseRanges.map(r => r[1]));
    }
    // 特有属性范围：取所有 specialAttributes.range 的 min/max
    if (preset.specialAttributes && preset.specialAttributes.length > 0) {
      const specialRanges = preset.specialAttributes.map(attr => attr.range);
      specialRangeMin = Math.min(...specialRanges.map(r => r[0]));
      specialRangeMax = Math.max(...specialRanges.map(r => r[1]));
    }

    // 4. 获取生成的属性数据
    const baseEntries = Object.entries(attrs.base as Record<string, number>);
    const specialEntries = Object.entries(attrs.special as Record<string, number>);

    // 5. 获取数据库 API 并读取模板
    const dbApi = getCore().getDB();
    if (!dbApi || typeof dbApi.getTableTemplate !== 'function') {
      console.warn('[DICE] updateTemplateForActivePreset: 数据库 API 不可用，跳过更新');
      return;
    }

    const template = dbApi.getTableTemplate();
    if (!template) {
      console.warn('[DICE] updateTemplateForActivePreset: 无法获取表格模板，跳过更新');
      return;
    }

    // 6. 生成属性标尺（基于基础属性范围，不含重复的基准说明）
    const attributeScaleStr = generateAttributeScale(baseRangeMin, baseRangeMax);

    // 7. 构建完整的 <属性规则> 内容块
    const baseRangeStr = `[${baseRangeMin},${baseRangeMax}]`;
    const specialRangeStr =
      specialEntries.length > 0
        ? `[${specialRangeMin},${specialRangeMax}]`
        : `[${DEFAULT_SPECIAL_ATTR_TEMPLATE.range[0]},${DEFAULT_SPECIAL_ATTR_TEMPLATE.range[1]}]`;

    // 基础属性示例（分号分隔格式）
    const baseExampleStr =
      baseEntries.length > 0
        ? baseEntries.map(([name, value]) => `${name}:${value}`).join('; ')
        : '力量:35; 敏捷:50; 体质:52; 智力:35; 感知:40; 魅力:64';

    // 特有属性示例（分号分隔格式）
    const specialExampleStr =
      specialEntries.length > 0
        ? specialEntries.map(([name, value]) => `${name}:${value}`).join('; ')
        : DEFAULT_SPECIAL_ATTR_TEMPLATE.example;

    // 构建完整的属性规则内容
    const attributeRulesContent = `基础属性: "{基础属性}:{数值}"，数值范围${baseRangeStr}
示例: "${baseExampleStr}"

特有属性: 角色的特殊能力与技能，体现世界观特色与个体差异。
格式: "{特有属性}:{数值}"，数值范围${specialRangeStr}，数值代表成功概率
示例: "${specialExampleStr}"

【属性标尺】
${attributeScaleStr}`;

    let modified = false;

    // 7.5 检测旧版模板格式（缺少 <属性规则> 标签）
    const checkTemplateFormat = (note: string | undefined, sheetName: string): void => {
      if (!note) return;
      if (!note.includes('<属性规则>')) {
        console.warn(
          `[DICE] ${sheetName} 使用旧版模板格式，缺少 <属性规则> 标签。` +
            `属性预设切换功能无法正常工作。请手动更新模板以添加 <属性规则>...</属性规则> 标签。`,
        );
      }
    };
    checkTemplateFormat(template.sheet_protagonist?.sourceData?.note as string, '主角信息表');
    checkTemplateFormat(template.sheet_important_npc?.sourceData?.note as string, '重要人物表');

    // 8. 替换 sheet_protagonist 的 note（使用 <属性规则> 标签）
    const protagonistSheet = template.sheet_protagonist;
    if (protagonistSheet?.sourceData?.note) {
      let note = protagonistSheet.sourceData.note as string;
      const originalNote = note;

      note = replaceTag(note, '属性规则', attributeRulesContent);

      if (note !== originalNote) {
        protagonistSheet.sourceData.note = note;
        modified = true;
      }
    }

    // 9. 替换 sheet_important_npc 的 note（使用 <属性规则> 标签）
    const npcSheet = template.sheet_important_npc;
    if (npcSheet?.sourceData?.note) {
      let note = npcSheet.sourceData.note as string;
      const originalNote = note;

      note = replaceTag(note, '属性规则', attributeRulesContent);

      if (note !== originalNote) {
        npcSheet.sourceData.note = note;
        modified = true;
      }
    }

    // 10. 使用数据库 API 保存模板
    if (modified && typeof dbApi.importTemplateFromData === 'function') {
      dbApi
        .importTemplateFromData(template)
        .then((result: { success: boolean; message: string }) => {
          if (result.success) {
            console.log('[DICE] updateTemplateForActivePreset 已更新表格模板，预设:', presetId);
          } else {
            console.error('[DICE] updateTemplateForActivePreset 保存模板失败:', result.message);
          }
        })
        .catch((err: Error) => {
          console.error('[DICE] updateTemplateForActivePreset 保存模板失败:', err);
        });
    } else if (!modified) {
      console.log('[DICE] updateTemplateForActivePreset 无需更新（模板内容未变化），预设:', presetId);
    } else {
      console.warn('[DICE] updateTemplateForActivePreset: importTemplateFromData 不可用，跳过保存');
    }
  };

  // ========================================
  // 自定义交互规则预设系统
  // ========================================

  // ActionPresetManager 类型定义（仅用于文档，实际是 JS 对象）
  // interface ActionGroupPreset {
  //   format: 'acu_action_preset_v1';
  //   version: string;
  //   id: string;
  //   name: string;
  //   builtin: boolean;
  //   description?: string;
  //   rules: ActionRule[];
  // }
  // interface ActionRule {
  //   table_keywords: string[];
  //   actions: ActionItem[];
  // }
  // interface ActionItem {
  //   label: string;
  //   icon?: string;
  //   template?: string;
  // }

  // 内置默认交互规则预设
  const BUILTIN_ACTION_PRESETS = [
    {
      format: 'acu_action_preset_v1',
      version: PRESET_FORMAT_VERSION,
      id: '__builtin_default__',
      name: '默认交互规则',
      builtin: true,
      description: '基于表格类型的默认交互选项，包含地点、人物、物品、装备、技能、任务、势力等常用规则',
      rules: [
        {
          table_keywords: ['地点', '地图', 'Location', 'Map', '世界', '场所'],
          actions: [
            { label: '前往', template: '<user>前往{Name}。' },
            { label: '探索', template: '<user>探索{Name}。' },
            { label: '停留', template: '<user>在{Name}停留。' },
          ],
        },
        {
          table_keywords: ['人物', 'NPC', '重要人物', '角色', '女主'],
          actions: [
            { label: '交谈', template: '<user>与{Name}交谈。' },
            { label: '观察', template: '<user>观察{Name}。' },
            { label: '战斗', template: '<user>与{Name}战斗。' },
          ],
        },
        {
          table_keywords: ['物品', '背包', '道具'],
          actions: [
            { label: '使用', template: '<user>使用了{Name}。' },
            { label: '查看', template: '<user>查看了{Name}。' },
            { label: '丢弃', template: '<user>丢弃了{Name}。' },
          ],
        },
        {
          table_keywords: ['装备', '武器', '防具'],
          actions: [
            { label: '装备', template: '<user>装备了{Name}。' },
            { label: '卸下', template: '<user>卸下了{Name}。' },
            { label: '卖出', template: '<user>卖出了{Name}。' },
          ],
        },
        {
          table_keywords: ['技能', '能力'],
          actions: [
            { label: '使用', template: '<user>使用{Name}。' },
            { label: '练习', template: '<user>练习{Name}。' },
          ],
        },
        {
          table_keywords: ['备忘', '任务', '事项'],
          actions: [
            { label: '追踪', template: '<user>将{Name}设为当前追踪目标。' },
            { label: '整理', template: '<user>整理关于{Name}的信息。' },
            { label: '放弃', template: '<user>放弃了{Name}。' },
          ],
        },
        {
          table_keywords: ['势力', '组织', '阵营'],
          actions: [
            { label: '打探', template: '<user>打探{Name}的情报。' },
            { label: '加入', template: '<user>申请加入{Name}。' },
            { label: '合作', template: '<user>向{Name}请求合作。' },
          ],
        },
      ],
    },
  ];

  const ActionPresetManager = (() => {
    let _cache = null;

    return {
      // 获取所有预设（内置 + 用户自定义）
      getAllPresets() {
        if (_cache) return _cache;
        const stored = Store.get(STORAGE_KEY_ACTION_PRESETS, []);
        _cache = [...BUILTIN_ACTION_PRESETS, ...stored];
        return _cache;
      },

      // 根据ID获取单个预设
      getPresetById(id) {
        return this.getAllPresets().find(p => p.id === id) || null;
      },

      // 获取当前激活的预设ID（默认为内置预设）
      getActivePresetId() {
        const stored = Store.get(STORAGE_KEY_ACTIVE_ACTION_PRESET, '__builtin_default__');
        return stored === null ? '__builtin_default__' : stored;
      },

      // 获取当前激活的预设
      getActivePreset() {
        const activeId = this.getActivePresetId();
        if (!activeId || activeId === '__none__') return null;
        return this.getPresetById(activeId);
      },

      // 设置激活的预设（'__none__' 表示全部关闭）
      setActivePresetId(id) {
        try {
          const finalId = id === '' || id === undefined || id === null ? '__none__' : id;
          Store.set(STORAGE_KEY_ACTIVE_ACTION_PRESET, finalId);
          _cache = null;
          console.log('[DICE]ActionPresetManager 切换预设:', finalId);
          return true;
        } catch (err) {
          console.error('[DICE]ActionPresetManager 设置预设失败:', err);
          return false;
        }
      },

      // 创建自定义预设
      createPreset(preset) {
        const stored = Store.get(STORAGE_KEY_ACTION_PRESETS, []);
        const newPreset = {
          format: 'acu_action_preset_v1',
          version: PRESET_FORMAT_VERSION,
          ...preset,
          id: preset.id || 'custom_' + Date.now(),
          builtin: false,
          createdAt: new Date().toISOString(),
        };
        stored.push(newPreset);
        Store.set(STORAGE_KEY_ACTION_PRESETS, stored);
        _cache = null;
        console.log('[DICE]ActionPresetManager 创建预设:', newPreset.name);
        return newPreset;
      },

      // 更新自定义预设
      updatePreset(id, updates) {
        const stored = Store.get(STORAGE_KEY_ACTION_PRESETS, []);
        const index = stored.findIndex(p => p.id === id);
        if (index < 0) return false;
        stored[index] = { ...stored[index], ...updates, version: PRESET_FORMAT_VERSION };
        Store.set(STORAGE_KEY_ACTION_PRESETS, stored);
        _cache = null;
        console.log('[DICE]ActionPresetManager 更新预设:', id);
        return true;
      },

      // 删除自定义预设
      deletePreset(id) {
        const stored = Store.get(STORAGE_KEY_ACTION_PRESETS, []);
        const filtered = stored.filter(p => p.id !== id);
        if (filtered.length === stored.length) return false;
        Store.set(STORAGE_KEY_ACTION_PRESETS, filtered);
        _cache = null;
        // 如果删除的是激活预设，清除激活状态
        if (Store.get(STORAGE_KEY_ACTIVE_ACTION_PRESET) === id) {
          Store.set(STORAGE_KEY_ACTIVE_ACTION_PRESET, null);
        }
        console.log('[DICE]ActionPresetManager 删除预设:', id);
        return true;
      },

      // 导出预设为 JSON
      exportPreset(id) {
        const preset = this.getPresetById(id);
        if (!preset) return null;
        const exported = {
          format: 'acu_action_preset_v1',
          version: PRESET_FORMAT_VERSION,
          ...preset,
        };
        delete exported.builtin;
        delete exported.createdAt;
        return JSON.stringify(exported, null, 2);
      },

      // 从 JSON 导入预设
      importPreset(jsonStr) {
        try {
          const data = JSON.parse(jsonStr);

          // 校验格式
          if (data.format !== 'acu_action_preset_v1') {
            throw new Error('不支持的预设格式，需要 acu_action_preset_v1');
          }

          // 基本校验
          if (!data.name || !data.rules || !Array.isArray(data.rules)) {
            throw new Error('预设数据不完整，需要 name 和 rules 字段');
          }

          // 生成新ID避免冲突
          const imported = {
            ...data,
            id: 'imported_' + Date.now(),
            builtin: false,
            version: PRESET_FORMAT_VERSION,
            createdAt: new Date().toISOString(),
          };

          const result = this.createPreset(imported);
          return result;
        } catch (e) {
          console.error('[DICE]ActionPresetManager 导入失败:', e);
          return null;
        }
      },

      // 清除缓存
      clearCache() {
        _cache = null;
      },
    };
  })();

  // ========================================
  // 疯狂模式系统
  // ========================================

  // 获取疯狂模式配置
  const getCrazyModeConfig = () => {
    const stored = Store.get(STORAGE_KEY_CRAZY_MODE, null);
    if (!stored) return { ...DEFAULT_CRAZY_MODE_CONFIG };
    return { ...DEFAULT_CRAZY_MODE_CONFIG, ...stored };
  };

  // 保存疯狂模式配置
  const saveCrazyModeConfig = config => {
    Store.set(STORAGE_KEY_CRAZY_MODE, config);
  };

  // 判断是否触发疯狂模式
  const shouldTriggerCrazyMode = () => {
    const config = getCrazyModeConfig();
    if (!config.enabled) return false;
    // crazyLevel 作为触发概率百分比
    const roll = Math.random() * 100;
    return roll < config.crazyLevel;
  };

  // 选择投骰类型
  const selectCrazyRollType = crazyLevel => {
    // crazyLevel < 50: 100% 普通检定
    // crazyLevel 50-75: 70% 普通 / 30% 对抗
    // crazyLevel > 75: 50% 普通 / 50% 对抗
    if (crazyLevel < 50) return 'normal';
    const contestChance = crazyLevel <= 75 ? 0.3 : 0.5;
    return Math.random() < contestChance ? 'contest' : 'normal';
  };

  // 根据权重随机选择
  const weightedRandomSelect = items => {
    if (!items || items.length === 0) return null;
    const totalWeight = items.reduce((sum, item) => sum + (item.weight || 1), 0);
    let random = Math.random() * totalWeight;
    for (const item of items) {
      random -= item.weight || 1;
      if (random <= 0) return item;
    }
    return items[items.length - 1];
  };

  // 选择参与者
  const selectCrazyParticipant = () => {
    const config = getCrazyModeConfig();
    const rawData = cachedRawData || getTableData();
    if (!rawData) return null;

    const allTables = processJsonData(rawData || {});
    const playerResult = DashboardDataParser.findTable(allTables, 'player');
    const npcResult = DashboardDataParser.findTable(allTables, 'npc');

    // 构建候选列表
    const candidates = [];

    // 主角
    if (playerResult?.data?.rows?.length > 0) {
      const playerName = getDisplayPlayerName() || '主角';
      const playerAttrs = getFullAttributesForCharacter('<user>');
      candidates.push({
        name: playerName,
        attrs: playerAttrs,
        isPlayer: true,
        inScene: true,
        weight: config.playerWeight,
      });
    }

    // NPC
    if (npcResult) {
      const npcParsed = DashboardDataParser.parseRows(npcResult, 'npc');
      npcParsed.forEach(npc => {
        if (!npc.name) return;
        const inSceneVal = String(npc.inScene || '').toLowerCase();
        const isInScene = inSceneVal === 'true' || inSceneVal === '在场';
        const npcAttrs = getFullAttributesForCharacter(npc.name);
        candidates.push({
          name: npc.name,
          attrs: npcAttrs,
          isPlayer: false,
          inScene: isInScene,
          weight: isInScene ? config.inSceneNpcWeight : config.offSceneNpcWeight,
        });
      });
    }

    if (candidates.length === 0) return null;
    return weightedRandomSelect(candidates);
  };

  // 选择检定属性
  const selectCrazyAttribute = participant => {
    if (!participant) return { name: '幸运', value: 50 };

    // 1. 优先使用角色已有属性
    if (participant.attrs && participant.attrs.length > 0) {
      const randomAttr = participant.attrs[Math.floor(Math.random() * participant.attrs.length)];
      return { name: randomAttr.name, value: randomAttr.value };
    }

    // 2. 使用当前属性规则定义的属性
    const activePreset = AttributePresetManager.getActivePreset();
    if (activePreset) {
      const allPresetAttrs = [...(activePreset.baseAttributes || []), ...(activePreset.specialAttributes || [])];
      if (allPresetAttrs.length > 0) {
        const randomPresetAttr = allPresetAttrs[Math.floor(Math.random() * allPresetAttrs.length)];
        // 使用 range 的 50% 作为默认值
        const range = randomPresetAttr.range || [0, 100];
        const defaultValue = Math.floor((range[0] + range[1]) / 2);
        return { name: randomPresetAttr.name, value: defaultValue };
      }
    }

    // 3. 使用随机技能池
    const skillPool = getRandomSkillPool();
    if (skillPool && skillPool.length > 0) {
      const randomSkill = skillPool[Math.floor(Math.random() * skillPool.length)];
      return { name: randomSkill, value: 50 };
    }

    return { name: '幸运', value: 50 };
  };

  // 根据预设执行疯狂模式投骰
  const crazyRollWithPreset = (preset: AdvancedDicePreset | null, attrValue: number) => {
    if (!preset) {
      // 没有激活预设时，使用默认 d100 规则
      const roll = Math.floor(Math.random() * 100) + 1;
      let result = '失败';
      if (roll <= 5) result = '大成功';
      else if (roll >= 96) result = '大失败';
      else if (roll <= attrValue) result = '成功';
      return { roll, result, formula: '1d100' };
    }

    // 使用预设的骰子表达式
    const diceExpr = preset.diceExpression || '1d100';
    const rollResult = rollComplexDiceExpression(diceExpr);
    const rollTotal = rollResult.total;

    // 根据预设的 outcomes 判定结果
    if (preset.outcomes && preset.outcomes.length > 0) {
      // 简化的条件判断：根据预设类型进行基本判定
      const presetId = preset.id;

      if (presetId === 'dnd5e_check') {
        // DND5e: 1d20 + 调整值 >= DC
        // 调整值 = floor((属性值-10)/2)
        const attrMod = Math.floor((attrValue - 10) / 2);
        const dc = 10; // 默认DC
        const total = rollTotal + attrMod;

        if (rollResult.rawDice && rollResult.rawDice[0] === 20) {
          return { roll: rollTotal, result: '大成功', formula: diceExpr, total, dc, attrMod };
        } else if (rollResult.rawDice && rollResult.rawDice[0] === 1) {
          return { roll: rollTotal, result: '大失败', formula: diceExpr, total, dc, attrMod };
        } else if (total >= dc) {
          return { roll: rollTotal, result: '成功', formula: diceExpr, total, dc, attrMod };
        } else {
          return { roll: rollTotal, result: '失败', formula: diceExpr, total, dc, attrMod };
        }
      } else if (presetId === 'coc7_check') {
        // CoC7: 1d100 <= 属性值
        if (rollTotal === 1) {
          return { roll: rollTotal, result: '大成功', formula: diceExpr };
        } else if ((attrValue < 50 && rollTotal >= 96) || (attrValue >= 50 && rollTotal === 100)) {
          return { roll: rollTotal, result: '大失败', formula: diceExpr };
        } else if (rollTotal <= Math.floor(attrValue / 5)) {
          return { roll: rollTotal, result: '极难成功', formula: diceExpr };
        } else if (rollTotal <= Math.floor(attrValue / 2)) {
          return { roll: rollTotal, result: '困难成功', formula: diceExpr };
        } else if (rollTotal <= attrValue) {
          return { roll: rollTotal, result: '成功', formula: diceExpr };
        } else {
          return { roll: rollTotal, result: '失败', formula: diceExpr };
        }
      } else if (presetId === 'fate_check') {
        // 命运骰: 4dF + 属性值
        const total = rollTotal + attrValue;
        const dc = 0; // 默认DC
        if (total >= dc + 3) {
          return { roll: rollTotal, result: '大成功', formula: diceExpr, total };
        } else if (total >= dc) {
          return { roll: rollTotal, result: '成功', formula: diceExpr, total };
        } else if (total >= dc - 2) {
          return { roll: rollTotal, result: '失败', formula: diceExpr, total };
        } else {
          return { roll: rollTotal, result: '大失败', formula: diceExpr, total };
        }
      } else if (presetId === 'pbta_check') {
        // PbtA: 2d6 + 属性值
        const total = rollTotal + attrValue;
        if (total >= 10) {
          return { roll: rollTotal, result: '完全成功', formula: diceExpr, total };
        } else if (total >= 7) {
          return { roll: rollTotal, result: '部分成功', formula: diceExpr, total };
        } else {
          return { roll: rollTotal, result: '失败', formula: diceExpr, total };
        }
      }
    }

    // 通用判定逻辑：根据骰子类型自动选择成功条件
    if (diceExpr.includes('d100') || diceExpr.includes('D100')) {
      // d100 系统: 投骰结果 <= 目标值 为成功
      if (rollTotal <= 5) return { roll: rollTotal, result: '大成功', formula: diceExpr };
      if (rollTotal >= 96) return { roll: rollTotal, result: '大失败', formula: diceExpr };
      if (rollTotal <= attrValue) return { roll: rollTotal, result: '成功', formula: diceExpr };
      return { roll: rollTotal, result: '失败', formula: diceExpr };
    } else if (diceExpr.includes('d20') || diceExpr.includes('D20')) {
      // d20 系统: 投骰结果 + 修正 >= DC 为成功
      const dc = 10;
      if (rollTotal === 20) return { roll: rollTotal, result: '大成功', formula: diceExpr };
      if (rollTotal === 1) return { roll: rollTotal, result: '大失败', formula: diceExpr };
      if (rollTotal + attrValue >= dc) return { roll: rollTotal, result: '成功', formula: diceExpr };
      return { roll: rollTotal, result: '失败', formula: diceExpr };
    } else {
      // 其他骰子: 简单判断高低
      const midValue = attrValue;
      if (rollTotal >= midValue) return { roll: rollTotal, result: '成功', formula: diceExpr };
      return { roll: rollTotal, result: '失败', formula: diceExpr };
    }
  };

  // 判断检定结果 (保留用于无预设时的兼容)
  const judgeCrazyRollResult = (roll, target) => {
    if (roll <= 5) return '大成功';
    if (roll >= 96) return '大失败';
    if (roll <= target) return '成功';
    return '失败';
  };

  // 生成疯狂骰子结果
  const generateCrazyRoll = () => {
    const config = getCrazyModeConfig();
    const rollType = selectCrazyRollType(config.crazyLevel);

    // 获取当前激活的检定预设
    const activePreset = AdvancedDicePresetManager.getActivePreset();

    if (rollType === 'normal') {
      // 普通检定
      const participant = selectCrazyParticipant();
      if (!participant) return null;

      const attr = selectCrazyAttribute(participant);
      const rollData = crazyRollWithPreset(activePreset, attr.value);

      // 根据预设类型格式化输出
      if (activePreset) {
        const presetName = activePreset.name;
        if (activePreset.id === 'dnd5e_check' && rollData.attrMod !== undefined) {
          return `<meta:检定结果>\n元叙事：${participant.name}发起了【${attr.name}】检定(${presetName})，${rollData.formula}=${rollData.roll}，调整值${rollData.attrMod >= 0 ? '+' : ''}${rollData.attrMod}，总计${rollData.total}，DC${rollData.dc}，【${rollData.result}】\n</meta:检定结果>`;
        } else if (rollData.total !== undefined) {
          return `<meta:检定结果>\n元叙事：${participant.name}发起了【${attr.name}】检定(${presetName})，${rollData.formula}=${rollData.roll}，总计${rollData.total}，【${rollData.result}】\n</meta:检定结果>`;
        } else {
          return `<meta:检定结果>\n元叙事：${participant.name}发起了【${attr.name}】检定(${presetName})，${rollData.formula}=${rollData.roll}，目标${attr.value}，【${rollData.result}】\n</meta:检定结果>`;
        }
      }

      // 无预设时使用默认格式
      return `<meta:检定结果>\n元叙事：${participant.name}发起了【${attr.name}】检定，掷出${rollData.roll}，目标${attr.value}，【${rollData.result}】\n</meta:检定结果>`;
    } else {
      // 对抗检定
      const participant1 = selectCrazyParticipant();
      if (!participant1) return null;

      // 选择第二个参与者（排除第一个）
      let participant2 = null;
      for (let i = 0; i < 5; i++) {
        const candidate = selectCrazyParticipant();
        if (candidate && candidate.name !== participant1.name) {
          participant2 = candidate;
          break;
        }
      }

      // 如果找不到第二个参与者，降级为普通检定
      if (!participant2) {
        const attr = selectCrazyAttribute(participant1);
        const rollData = crazyRollWithPreset(activePreset, attr.value);
        if (activePreset) {
          return `<meta:检定结果>\n元叙事：${participant1.name}发起了【${attr.name}】检定(${activePreset.name})，${rollData.formula}=${rollData.roll}，目标${attr.value}，【${rollData.result}】\n</meta:检定结果>`;
        }
        return `<meta:检定结果>\n元叙事：${participant1.name}发起了【${attr.name}】检定，掷出${rollData.roll}，目标${attr.value}，【${rollData.result}】\n</meta:检定结果>`;
      }

      const attr1 = selectCrazyAttribute(participant1);
      const attr2 = selectCrazyAttribute(participant2);
      const rollData1 = crazyRollWithPreset(activePreset, attr1.value);
      const rollData2 = crazyRollWithPreset(activePreset, attr2.value);

      // 计算成功度和判定结果
      const result1 = rollData1.result;
      const result2 = rollData2.result;

      // 根据预设类型计算胜负
      let winner;
      if (
        activePreset &&
        (activePreset.id === 'dnd5e_check' || activePreset.id === 'pbta_check' || activePreset.id === 'fate_check')
      ) {
        // 加值系统: 比较总值
        const total1 = rollData1.total !== undefined ? rollData1.total : rollData1.roll + attr1.value;
        const total2 = rollData2.total !== undefined ? rollData2.total : rollData2.roll + attr2.value;
        if (total1 > total2) {
          winner = `${participant1.name}胜出`;
        } else if (total2 > total1) {
          winner = `${participant2.name}胜出`;
        } else {
          winner = '平局';
        }
      } else {
        // d100系统: 比较成功余量 (目标值 - 投骰结果)
        const margin1 = attr1.value - rollData1.roll;
        const margin2 = attr2.value - rollData2.roll;
        if (margin1 > margin2) {
          winner = `${participant1.name}胜出`;
        } else if (margin2 > margin1) {
          winner = `${participant2.name}胜出`;
        } else {
          winner = '平局';
        }
      }

      // 格式与现有对抗检定保持一致
      const presetLabel = activePreset ? `(${activePreset.name})` : '';
      return (
        `<meta:检定结果>\n` +
        `元叙事：进行了一次【${participant1.name} ${attr1.name} vs ${participant2.name} ${attr2.name}】的对抗检定${presetLabel}。` +
        `${participant1.name} ${attr1.name} (目标${attr1.value}) ${rollData1.formula}=${rollData1.roll}，判定为【${result1}】；` +
        `${participant2.name} ${attr2.name} (目标${attr2.value}) ${rollData2.formula}=${rollData2.roll}，判定为【${result2}】。` +
        `最终结果：【${winner}】\n` +
        `</meta:检定结果>`
      );
    }
  };

  // ========================================
  // 公式解析器系统（支持骰子表达式和变量引用）
  // ========================================

  /**
   * 投单个骰子表达式
   * 支持: 3d6, 4d6kh3, 4d6dl1, 4d6dh1
   * @returns 标准化 RollResult，解析失败 total 为 NaN
   */
  const rollDiceExpression = (expr: string): RollResult => {
    const formula = String(expr);
    const rollDice = (sides: number) => Math.floor(Math.random() * sides) + 1;

    // 匹配 XdY 或 XdF 语法，支持重掷、爆炸、保留/舍弃和成功计数
    const match = formula.match(
      /^(\d*)d(\d+|F)([bp]\d+)?(r[o]?(?:[><!=]+)?\d*)?(!!?(?:[><!=]+\d+)?)?(kh\d+|kl\d+|dh\d+|dl\d+)?((?:[><!=]+)\d+)?$/i,
    );
    if (!match) {
      return {
        total: Number.NaN,
        rawDice: [],
        keptDice: [],
        formula,
        breakdown: formula ? `${formula}=NaN` : 'NaN',
        tags: [],
      };
    }

    const [, countStr, sidesOrF, cocPart, rerollPart, explodePart, keepDrop, successPart] = match;
    const count = countStr ? parseInt(countStr, 10) : 1;
    const isFate = sidesOrF.toUpperCase() === 'F';
    const sides = isFate ? 0 : parseInt(sidesOrF, 10);

    let rolls: number[] = [];
    if (isFate) {
      // FATE 骰子: 取值 [-1, 0, 1]
      rolls = Array.from({ length: count }, () => Math.floor(Math.random() * 3) - 1);
    } else {
      // 普通骰子

      // 解析重掷修饰符
      let rerollType = null;
      let rerollCompare = '=';
      let rerollValue = 1;

      if (rerollPart) {
        const m = rerollPart.match(/^(r[o]?)([><!=]+)?(\d+)?$/i);
        if (m) {
          rerollType = m[1].toLowerCase();
          if (m[2]) rerollCompare = m[2];
          if (m[3]) rerollValue = parseInt(m[3], 10);
          else if (!m[2]) rerollValue = 1; // 仅 r 或 ro 默认为 1
        }
      }

      const checkReroll = (val: number) => {
        if (!rerollType) return false;
        switch (rerollCompare) {
          case '>=':
            return val >= rerollValue;
          case '<=':
            return val <= rerollValue;
          case '=':
          case '==':
            return val === rerollValue;
          case '>':
            return val > rerollValue;
          case '<':
            return val < rerollValue;
          case '!=':
          case '<>':
            return val !== rerollValue;
          default:
            return val === rerollValue;
        }
      };

      // 解析爆炸修饰符
      let explodeType = null;
      let explodeCompare = '=';
      let explodeValue = sides;

      if (explodePart) {
        const m = explodePart.match(/^(!!?)([><=!]+)?(\d+)?$/);
        if (m) {
          explodeType = m[1];
          if (m[2]) explodeCompare = m[2];
          if (m[3]) explodeValue = parseInt(m[3], 10);
        }
      }

      const checkExplode = (val: number) => {
        if (!explodeType) return false;
        switch (explodeCompare) {
          case '>=':
            return val >= explodeValue;
          case '<=':
            return val <= explodeValue;
          case '=':
          case '==':
            return val === explodeValue;
          case '>':
            return val > explodeValue;
          case '<':
            return val < explodeValue;
          case '!=':
          case '<>':
            return val !== explodeValue;
          default:
            return val === sides;
        }
      };

      // 解析 CoC 奖励/惩罚骰 (仅对 d100 生效)
      let cocType = null;
      let cocCount = 0;
      if (cocPart && sides === 100) {
        const m = cocPart.match(/^([bp])(\d+)$/i);
        if (m) {
          cocType = m[1].toLowerCase();
          cocCount = parseInt(m[2], 10);
        }
      }

      for (let i = 0; i < count; i++) {
        let val = rollDice(sides);

        // CoC 奖励/惩罚骰逻辑
        if (cocType) {
          const tens = Math.floor((val === 100 ? 0 : val) / 10);
          const units = val % 10;
          const additionalTens = Array.from({ length: cocCount }, () => Math.floor(Math.random() * 10));
          const allTens = [tens, ...additionalTens];
          let finalTens;
          if (cocType === 'b') {
            finalTens = Math.min(...allTens);
          } else {
            finalTens = Math.max(...allTens);
          }
          const result = finalTens * 10 + units;
          val = result === 0 ? 100 : result;
        }

        // 重掷逻辑 (在爆炸之前执行)
        if (rerollType) {
          let rerollCount = 0;
          while (checkReroll(val) && rerollCount < 100) {
            rerollCount++;
            val = rollDice(sides);
            if (rerollType === 'ro') break; // ro 只重掷一次
          }
        }

        if (explodeType) {
          let currentVal = val;
          let nextToCheck = val;
          let explodeCount = 0;
          while (checkExplode(nextToCheck) && explodeCount < 100) {
            explodeCount++;
            nextToCheck = rollDice(sides);
            if (explodeType === '!') {
              rolls.push(currentVal);
              currentVal = nextToCheck;
            } else {
              currentVal += nextToCheck;
            }
          }
          rolls.push(currentVal);
        } else {
          rolls.push(val);
        }
      }
    }

    const rawDice = [...rolls];
    let keptDice = [...rolls];

    // 处理 keep/drop
    if (keepDrop) {
      const kd = keepDrop.toLowerCase();
      const n = parseInt(kd.slice(2), 10);
      const sorted = [...keptDice].sort((a, b) => b - a); // 降序排列

      if (kd.startsWith('kh'))
        keptDice = sorted.slice(0, n); // 保留最高n个
      else if (kd.startsWith('kl'))
        keptDice = sorted.slice(-n); // 保留最低n个
      else if (kd.startsWith('dh'))
        keptDice = sorted.slice(n); // 去掉最高n个
      else if (kd.startsWith('dl')) keptDice = sorted.slice(0, -n); // 去掉最低n个
    }

    let total = keptDice.reduce((a, b) => a + b, 0);

    // 处理成功计数 (骰池)
    if (successPart) {
      const sm = successPart.match(/^([><!=]+)(\d+)$/);
      if (sm) {
        const op = sm[1];
        const val = parseInt(sm[2], 10);
        const isSuccess = (roll: number) => {
          switch (op) {
            case '>=':
              return roll >= val;
            case '<=':
              return roll <= val;
            case '=':
            case '==':
              return roll === val;
            case '>':
              return roll > val;
            case '<':
              return roll < val;
            case '!=':
            case '<>':
              return roll !== val;
            default:
              return false;
          }
        };
        total = keptDice.filter(isSuccess).length;
      }
    }

    const tags: string[] = [];
    if (!isFate && sides === 20) {
      const diceToCheck = keptDice.length > 0 ? keptDice : rawDice;
      if (diceToCheck.some(roll => roll === 20)) tags.push('nat20');
      if (diceToCheck.some(roll => roll === 1)) tags.push('nat1');
    }

    const totalText = Number.isNaN(total) ? 'NaN' : String(total);
    const diceList = rawDice.length > 0 ? `[${rawDice.join(',')}]` : '[]';
    const showList = rawDice.length !== 1 || Boolean(keepDrop) || Boolean(successPart);
    const breakdown = showList ? `${formula}=${diceList}→${totalText}` : `${formula}=${totalText}`;

    return {
      total,
      rawDice,
      keptDice,
      formula,
      breakdown,
      tags,
    };
  };

  // 计算骰子表达式的期望值（用于默认目标值）
  const calculateDiceExpectedValue = (diceExpr: string): number => {
    const formula = String(diceExpr).replace(/\s+/g, '');
    if (!formula) return Number.NaN;

    const parts = formula.match(/[+-]?[^+-]+/g);
    if (!parts) return Number.NaN;

    let total = 0;
    for (const part of parts) {
      if (!part) continue;
      const sign = part.startsWith('-') ? -1 : 1;
      const body = part.replace(/^[+-]/, '');
      if (!body) continue;

      const diceMatch = body.match(
        /^(\d*)d(\d+|F)([bp]\d+)?(r[o]?(?:[><!=]+)?\d*)?(!!?(?:[><!=]+\d+)?)?(kh\d+|kl\d+|dh\d+|dl\d+)?((?:[><!=]+)\d+)?$/i,
      );

      if (diceMatch) {
        const [, countStr, sidesOrF, , , , keepDrop] = diceMatch;
        const count = countStr ? parseInt(countStr, 10) : 1;
        const isFate = sidesOrF.toUpperCase() === 'F';
        const sides = isFate ? 0 : parseInt(sidesOrF, 10);
        const expectedPerDie = isFate ? 0 : (1 + sides) / 2;

        let keptCount = count;
        if (keepDrop) {
          const keepDropType = keepDrop.slice(0, 2);
          const keepDropValue = parseInt(keepDrop.slice(2), 10);
          if (!Number.isNaN(keepDropValue)) {
            if (keepDropType === 'kh' || keepDropType === 'kl') {
              keptCount = Math.min(count, keepDropValue);
            } else if (keepDropType === 'dh' || keepDropType === 'dl') {
              keptCount = Math.max(0, count - keepDropValue);
            }
          }
        }

        total += sign * keptCount * expectedPerDie;
        continue;
      }

      const numericValue = Number(body);
      if (Number.isNaN(numericValue)) {
        return Number.NaN;
      }
      total += sign * numericValue;
    }

    return total;
  };

  // 复合骰子表达式掷骰（支持 2d6+33 等算术修饰符）
  const rollComplexDiceExpression = (expr: string): RollResult => {
    const formula = String(expr).replace(/\s+/g, '');
    if (!formula) {
      return { total: Number.NaN, rawDice: [], keptDice: [], formula: '', breakdown: 'NaN', tags: [] };
    }

    // 先尝试简单表达式
    const simpleResult = rollDiceExpression(formula);
    if (!Number.isNaN(simpleResult.total)) {
      return simpleResult;
    }

    // 解析复合表达式（如 2d6+33, d20-5）
    const parts = formula.match(/[+-]?[^+-]+/g);
    if (!parts) {
      return { total: Number.NaN, rawDice: [], keptDice: [], formula, breakdown: `${formula}=NaN`, tags: [] };
    }

    let total = 0;
    const allRawDice: number[] = [];
    const allKeptDice: number[] = [];
    const breakdownParts: string[] = [];
    const allTags: string[] = [];

    for (const part of parts) {
      if (!part) continue;
      const sign = part.startsWith('-') ? -1 : 1;
      const body = part.replace(/^[+-]/, '');
      if (!body) continue;

      // 尝试作为骰子表达式解析
      const diceResult = rollDiceExpression(body);
      if (!Number.isNaN(diceResult.total)) {
        total += sign * diceResult.total;
        allRawDice.push(...diceResult.rawDice);
        allKeptDice.push(...diceResult.keptDice);
        breakdownParts.push(
          sign === -1
            ? `-${diceResult.breakdown}`
            : breakdownParts.length > 0
              ? `+${diceResult.breakdown}`
              : diceResult.breakdown,
        );
        allTags.push(...diceResult.tags);
        continue;
      }

      // 尝试作为数字解析
      const numericValue = Number(body);
      if (!Number.isNaN(numericValue)) {
        total += sign * numericValue;
        const signedValue = sign * numericValue;
        breakdownParts.push(signedValue >= 0 && breakdownParts.length > 0 ? `+${signedValue}` : String(signedValue));
        continue;
      }

      // 无法解析
      return { total: Number.NaN, rawDice: [], keptDice: [], formula, breakdown: `${formula}=NaN`, tags: [] };
    }

    return {
      total,
      rawDice: allRawDice,
      keptDice: allKeptDice,
      formula,
      breakdown: `${breakdownParts.join('')}=${total}`,
      tags: allTags,
    };
  };

  /**
   * 解析并计算公式（支持变量引用）
   * @param formula 公式字符串，如 "力量/2+1d10" 或 "3d6*5"
   * @param context 变量上下文，如 { 力量: 50, 敏捷: 40 }
   * @returns 计算结果（整数）
   */
  const evaluateFormula = (formula, context = {}) => {
    if (!formula) return 0;

    let expr = String(formula).trim();

    // 1. 替换变量为数值（按长度降序替换，避免部分匹配）
    const varNames = Object.keys(context).sort((a, b) => b.length - a.length);
    for (const name of varNames) {
      const value = context[name];
      if (typeof value === 'number' && !isNaN(value)) {
        // 用括号包裹避免运算优先级问题
        expr = expr.split(name).join(`(${value})`);
      }
    }

    // 2. 替换骰子表达式为数值
    expr = expr.replace(
      /\d*d(?:\d+|F)(?:[bp]\d+)?(?:r[o]?(?:[><!=]+)?\d*)?(?:!!?(?:[><!=]+\d+)?)?(?:kh\d+|kl\d+|dh\d+|dl\d+)?(?:(?:[><!=]+)\d+)?/gi,
      match => {
        const result = rollDiceExpression(match);
        return Number.isNaN(result.total) ? '0' : String(result.total);
      },
    );

    // 3. 安全性检查：只允许数字和基本运算符
    if (!/^[\d\s+\-*/().]+$/.test(expr)) {
      console.warn('[DICE]evaluateFormula 公式包含非法字符:', formula, '→', expr);
      return 0;
    }

    // 4. 计算数学表达式
    try {
      // eslint-disable-next-line no-new-func
      const result = new Function(`return (${expr})`)();
      return Math.round(result); // 四舍五入为整数
    } catch (e) {
      console.error('[DICE]evaluateFormula 公式计算失败:', formula, '→', expr, e);
      return 0;
    }
  };

  /**
   * 评估条件表达式（支持比较运算和逻辑运算）
   * @param {string} formula 表达式字符串
   * @param {Record<string, number>} context 变量上下文
   * @returns {{success: boolean, value?: number | boolean, error?: string}}
   */
  const evaluateCondition = (formula, context = {}) => {
    if (!formula || typeof formula !== 'string') return { success: true, value: 0 };

    const functionHandlers: Record<string, { minArgs: number; maxArgs: number; apply: (args: number[]) => number }> = {
      abs: { minArgs: 1, maxArgs: 1, apply: args => Math.abs(args[0]) },
      floor: { minArgs: 1, maxArgs: 1, apply: args => Math.floor(args[0]) },
      min: { minArgs: 2, maxArgs: Number.POSITIVE_INFINITY, apply: args => Math.min(...args) },
      max: { minArgs: 2, maxArgs: Number.POSITIVE_INFINITY, apply: args => Math.max(...args) },
    };

    // 支持 $roll.hasTag("tag")
    if (context && context.$roll && typeof context.$roll === 'object') {
      const roll = context.$roll as RollResult;
      functionHandlers['$roll.hastag'] = {
        minArgs: 1,
        maxArgs: 1,
        apply: (args: any[]) => {
          const tag = String(args[0]);
          return (roll.tags ?? []).includes(tag) ? 1 : 0;
        },
      };
    }

    function evaluateExpression(expression: string): { success: boolean; value?: number | boolean; error?: string } {
      // 2. 安全检查
      // 检查是否包含非法字符
      const illegal = expression.match(/[^0-9+\-*/()><=!&| .]/g);
      if (illegal) {
        return { success: false, error: `包含非法字符: ${illegal.join('')}` };
      }

      // 3. 分词 (Tokenization)
      // 需要处理多字符运算符: >=, <=, ==, !=, &&, ||
      const tokens = [];
      let i = 0;
      while (i < expression.length) {
        const char = expression[i];
        if (/\s/.test(char)) {
          i++;
          continue;
        }
        if (/\d/.test(char)) {
          let num = '';
          while (i < expression.length && /[\d.]/.test(expression[i])) {
            num += expression[i++];
          }
          tokens.push({ type: 'NUMBER', value: parseFloat(num) });
          continue;
        }

        // 处理三字符操作符 (===, !==)
        const threeChar = expression.substring(i, i + 3);
        if (['===', '!=='].includes(threeChar)) {
          tokens.push({ type: 'OPERATOR', value: threeChar });
          i += 3;
          continue;
        }

        // 处理双字符操作符
        const twoChar = expression.substring(i, i + 2);
        if (['>=', '<=', '==', '!=', '&&', '||'].includes(twoChar)) {
          tokens.push({ type: 'OPERATOR', value: twoChar });
          i += 2;
          continue;
        }

        // 处理单字符操作符
        if (['+', '-', '*', '/', '%', '>', '<', '(', ')'].includes(char)) {
          // 处理一元负号：如果 '-' 出现在开头或紧跟在操作符/左括号后面，则是负号
          if (char === '-' || char === '+') {
            const lastToken = tokens[tokens.length - 1];
            const isUnary = !lastToken || lastToken.type === 'OPERATOR' || lastToken.value === '(';
            if (isUnary) {
              // 读取后面的数字
              let num = char;
              i++;
              while (i < expression.length && /[\d.]/.test(expression[i])) {
                num += expression[i++];
              }
              if (num.length > 1) {
                tokens.push({ type: 'NUMBER', value: parseFloat(num) });
                continue;
              }
              // 如果只有 '-' 没有数字，回退并作为操作符处理
              i--;
            }
          }
          if (char === '>' || char === '<') {
            const nextChar = expression[i + 1];
            if (nextChar === char) {
              // 处理 >> 或 <<
              return { success: false, error: `语法错误: 无法解析操作符 "${char}${char}"` };
            }
          }
          tokens.push({ type: 'OPERATOR', value: char });
          i++;
          continue;
        }

        // 捕获未处理的字符
        if (['=', '!', '&', '|'].includes(char)) {
          return { success: false, error: `语法错误: 孤立的操作符 "${char}"` };
        }
        return { success: false, error: `语法错误: 无法解析或孤立的字符 "${char}"` };
      }

      // 4. Shunting-yard 算法
      const ops = {
        '||': { prec: 1, assoc: 'L' },
        '&&': { prec: 2, assoc: 'L' },
        '==': { prec: 3, assoc: 'L' },
        '!=': { prec: 3, assoc: 'L' },
        '===': { prec: 3, assoc: 'L' },
        '!==': { prec: 3, assoc: 'L' },
        '>': { prec: 4, assoc: 'L' },
        '<': { prec: 4, assoc: 'L' },
        '>=': { prec: 4, assoc: 'L' },
        '<=': { prec: 4, assoc: 'L' },
        '+': { prec: 5, assoc: 'L' },
        '-': { prec: 5, assoc: 'L' },
        '*': { prec: 6, assoc: 'L' },
        '/': { prec: 6, assoc: 'L' },
        '%': { prec: 6, assoc: 'L' },
      };

      const outputQueue = [];
      const operatorStack = [];

      for (const token of tokens) {
        if (token.type === 'NUMBER') {
          outputQueue.push(token);
        } else if (token.value === '(') {
          operatorStack.push(token);
        } else if (token.value === ')') {
          while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1].value !== '(') {
            outputQueue.push(operatorStack.pop());
          }
          if (operatorStack.length === 0) return { success: false, error: '括号不匹配' };
          operatorStack.pop(); // 弹出 '('
        } else {
          const o1 = token.value;
          while (operatorStack.length > 0) {
            const o2 = operatorStack[operatorStack.length - 1].value;
            if (o2 === '(') break;
            if (ops[o2].prec > ops[o1].prec || (ops[o2].prec === ops[o1].prec && ops[o1].assoc === 'L')) {
              outputQueue.push(operatorStack.pop());
            } else {
              break;
            }
          }
          operatorStack.push(token);
        }
      }

      while (operatorStack.length > 0) {
        const op = operatorStack.pop();
        if (op.value === '(') return { success: false, error: '括号不匹配' };
        outputQueue.push(op);
      }

      // 5. 栈求值
      const evalStack = [];
      for (const token of outputQueue) {
        if (token.type === 'NUMBER') {
          evalStack.push(token.value);
        } else {
          const b = evalStack.pop();
          const a = evalStack.pop();
          let res;
          switch (token.value) {
            case '+':
              res = a + b;
              break;
            case '-':
              res = a - b;
              break;
            case '*':
              res = a * b;
              break;
            case '/':
              res = a / b;
              break;
            case '%':
              res = a % b;
              break;
            case '>':
              res = a > b;
              break;
            case '<':
              res = a < b;
              break;
            case '>=':
              res = a >= b;
              break;
            case '<=':
              res = a <= b;
              break;
            case '==':
              res = a == b;
              break;
            case '!=':
              res = a != b;
              break;
            case '===':
              res = a === b;
              break;
            case '!==':
              res = a !== b;
              break;
            case '&&':
              res = a && b ? 1 : 0;
              break;
            case '||':
              res = a || b ? 1 : 0;
              break;
            default:
              return { success: false, error: `未知操作符: ${token.value}` };
          }
          evalStack.push(res);
        }
      }

      if (evalStack.length !== 1) return { success: false, error: '无效的表达式' };
      return { success: true, value: evalStack[0] };
    }

    function normalizeNumberLiteral(value: number): string {
      const text = String(value);
      if (value < 0) return `(0${text})`;
      return `(${text})`;
    }

    function splitArguments(argsText: string): string[] {
      const args: string[] = [];
      let depth = 0;
      let start = 0;
      let inQuote = false;
      for (let index = 0; index < argsText.length; index++) {
        const char = argsText[index];
        if (char === '"' || char === "'") {
          inQuote = !inQuote;
        }
        if (inQuote) continue;

        if (char === '(') {
          depth++;
        } else if (char === ')') {
          depth--;
        } else if (char === ',' && depth === 0) {
          args.push(argsText.slice(start, index).trim());
          start = index + 1;
        }
      }
      args.push(argsText.slice(start).trim());
      return args;
    }

    function findMatchingParen(source: string, startIndex: number): number {
      let depth = 0;
      for (let index = startIndex; index < source.length; index++) {
        const char = source[index];
        if (char === '(') depth++;
        if (char === ')') {
          depth--;
          if (depth === 0) return index;
        }
      }
      return -1;
    }

    function evaluateArgumentValue(argExpr: string): { success: boolean; value?: any; error?: string } {
      const trimmed = argExpr.trim();
      if (!trimmed) return { success: false, error: '函数参数不能为空' };

      // 处理字符串字面量
      if ((trimmed.startsWith('"') && trimmed.endsWith('"')) || trimmed.startsWith("'")) {
        return { success: true, value: trimmed.slice(1, -1) };
      }

      // [修复] 先替换变量，再处理函数
      let exprWithVars = trimmed;
      const varPattern = /\$[a-zA-Z_]\w*/g;
      exprWithVars = exprWithVars.replace(varPattern, match => {
        const val = context[match];
        return typeof val === 'number' && !isNaN(val) ? String(val) : '0';
      });

      const resolved = resolveFunctions(exprWithVars);
      if (!resolved.success || resolved.expr === undefined) {
        return { success: false, error: resolved.error ?? '函数参数解析失败' };
      }

      const dicePattern = /\d*d(?:\d+|F)/i;
      if (dicePattern.test(resolved.expr)) {
        const formulaValue = evaluateFormula(resolved.expr, context);
        if (typeof formulaValue === 'number' && Number.isFinite(formulaValue)) {
          return { success: true, value: formulaValue };
        }
      }

      const evalResult = evaluateExpression(resolved.expr);
      if (!evalResult.success || evalResult.value === undefined) {
        return { success: false, error: evalResult.error ?? '函数参数计算失败' };
      }
      const value = typeof evalResult.value === 'boolean' ? (evalResult.value ? 1 : 0) : evalResult.value;
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return { success: false, error: '函数参数不是有效数字' };
      }
      return { success: true, value };
    }

    function resolveFunctions(source: string): { success: boolean; expr?: string; error?: string } {
      let result = '';
      let index = 0;
      const isIdentifierStart = (char: string): boolean => /[a-zA-Z_]/.test(char);
      const isIdentifierChar = (char: string): boolean => /[a-zA-Z0-9_]/.test(char);

      while (index < source.length) {
        const char = source[index];
        if (isIdentifierStart(char)) {
          let name = char;
          index++;
          while (index < source.length && (isIdentifierChar(source[index]) || source[index] === '.')) {
            name += source[index];
            index++;
          }

          // 处理 true/false 布尔字面量
          const nameLower = name.toLowerCase();
          if (nameLower === 'true') {
            result += '1';
            continue;
          }
          if (nameLower === 'false') {
            result += '0';
            continue;
          }

          let nextIndex = index;
          while (nextIndex < source.length && /\s/.test(source[nextIndex])) {
            nextIndex++;
          }

          if (source[nextIndex] !== '(') {
            return { success: false, error: `未知函数或标识符: ${name}` };
          }

          const closeIndex = findMatchingParen(source, nextIndex);
          if (closeIndex === -1) return { success: false, error: '括号不匹配' };

          const argsText = source.slice(nextIndex + 1, closeIndex);
          const args = splitArguments(argsText);
          const key = name.toLowerCase();
          const handler = functionHandlers[key];
          if (!handler) return { success: false, error: `不支持的函数: ${name}` };
          if (args.length < handler.minArgs || args.length > handler.maxArgs) {
            return { success: false, error: `函数 ${name} 参数数量不合法` };
          }

          const values: number[] = [];
          for (const arg of args) {
            if (!arg) return { success: false, error: `函数 ${name} 参数不能为空` };
            const valueResult = evaluateArgumentValue(arg);
            if (!valueResult.success || valueResult.value === undefined) {
              return { success: false, error: valueResult.error ?? `函数 ${name} 参数计算失败` };
            }
            values.push(valueResult.value);
          }

          const fnResult = handler.apply(values);
          if (!Number.isFinite(fnResult)) {
            return { success: false, error: `函数 ${name} 结果无效` };
          }
          result += normalizeNumberLiteral(fnResult);
          index = closeIndex + 1;
          continue;
        }

        result += char;
        index++;
      }

      return { success: true, expr: result };
    }

    // 1. 替换变量
    // 支持变量: $roll.total, $attr, $dc, $mod 等,未定义视为0
    // 特殊处理 $roll 对象
    if (context && context.$roll && typeof context.$roll === 'object') {
      const roll = context.$roll as RollResult;
      formula = formula.replace(/\$roll\.total/g, String(roll.total));
      // 预处理 $roll.hasTag('tagName') 调用，在变量替换前完成
      formula = formula.replace(/\$roll\.hasTag\s*\(\s*['"]([^'"]+)['"]\s*\)/gi, (_match, tag) => {
        return (roll.tags ?? []).includes(tag) ? '1' : '0';
      });
    }

    const varPattern = /\$[a-zA-Z_]\w*/g;
    let expr = formula.trim().replace(varPattern, match => {
      const val = context[match];
      return typeof val === 'number' && !isNaN(val) ? String(val) : '0';
    });

    const resolved = resolveFunctions(expr);
    if (!resolved.success || resolved.expr === undefined) {
      return { success: false, error: resolved.error ?? '函数解析失败' };
    }
    expr = resolved.expr;

    return evaluateExpression(expr);
  };

  /**
   * 判断条件表达式是否为复杂条件 (包含 && 或 ||)
   * @param expr - 条件表达式字符串
   * @returns 如果包含 && 或 || 返回 true, 否则返回 false
   */
  const isComplexCondition = (expr: string): boolean => {
    return /(\&\&|\|\|)/.test(expr);
  };

  /**
   * 评估多级结果
   * @param outcomes - outcomes 数组 (会被排序)
   * @param context - 上下文对象 {$roll, $attr, $dc, $mod, ...}
   * @returns 匹配的 outcome (如果所有条件都不满足,返回最低优先级的兜底 outcome)
   */
  const evaluateOutcomes = (outcomes: OutcomeLevel[], context: Record<string, number>) => {
    if (!outcomes || outcomes.length === 0) {
      console.warn('[DICE] outcomes 数组为空,使用默认判定');
      return { id: 'default', name: '判定结果', condition: 'true', priority: 99 };
    }
    const sorted = [...outcomes].sort((a, b) => a.priority - b.priority);

    for (const outcome of sorted) {
      try {
        const conditionResult: { success: boolean; value?: number | boolean; error?: string } = evaluateCondition(
          outcome.condition,
          context,
        );
        if (!conditionResult.success) {
          if (conditionResult.error) {
            console.warn(`[DICE] outcome "${outcome.name}" 条件评估失败:`, conditionResult.error);
          }
          continue;
        }
        const isMatch =
          typeof conditionResult.value === 'number' ? conditionResult.value !== 0 : Boolean(conditionResult.value);
        if (isMatch) {
          return outcome;
        }
      } catch (error) {
        console.warn(`[DICE] outcome "${outcome.name}" 条件评估失败:`, error);
        continue;
      }
    }

    return sorted[sorted.length - 1];
  };

  // 默认输出模板
  const DEFAULT_OUTPUT_TEMPLATE = `<meta:检定结果>
$outcomeText
元叙事：$initiator 发起了 $attrName 检定，$formula=$roll，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】
</meta:检定结果>`;

  // 默认对抗检定输出模板
  const DEFAULT_CONTEST_OUTPUT_TEMPLATE = `<meta:检定结果>
元叙事：进行了一次【$initiator $initAttrName vs $opponent $oppAttrName】的对抗检定。
$initiator $initAttrName：$formula=$initRoll，判定 $initConditionExpr？$initJudgeResult，判定为【$initSuccessName】；
$opponent $oppAttrName：$formula=$oppRoll，判定 $oppConditionExpr？$oppJudgeResult，判定为【$oppSuccessName】。
最终结果：【$winner】
</meta:检定结果>`;

  /**
   * 格式化输出模板
   * @param template - 模板字符串
   * @param context - 变量上下文
   * @returns 格式化后的文本
   */
  const formatOutputTemplate = (template: string, context: Record<string, string | number | undefined>): string => {
    const missingKeys = new Set<string>();

    // [修复] 先替换带点的变量（如 $roll.total），再替换普通变量（如 $roll）
    // 这样可以避免 $roll.total 被错误地替换为 "3.total"
    let result = template.replace(/\$([a-zA-Z_]\w*\.[a-zA-Z_]\w*)/g, match => {
      const key = match.slice(1); // 去掉 $ 前缀，得到 "roll.total"
      const value = context[key];
      if (value === undefined || value === null) {
        if (!missingKeys.has(key)) {
          missingKeys.add(key);
          console.warn(`[DICE] formatOutputTemplate: 未定义变量 $${key}`);
        }
        return '';
      }
      return String(value);
    });

    // 再替换普通变量
    result = result.replace(/\$([a-zA-Z_]\w*)(?=\W|$)/g, match => {
      const key = match.slice(1);
      const value = context[key];
      if (value === undefined || value === null) {
        if (!missingKeys.has(key)) {
          missingKeys.add(key);
          console.warn(`[DICE] formatOutputTemplate: 未定义变量 $${key}`);
        }
        return '';
      }
      return String(value);
    });
    // 清理空行：将连续多个换行符替换为单个换行符
    return result.replace(/\n\s*\n/g, '\n');
  };

  /**
   * 生成单个属性值，应用范围限制
   * @param formula 公式字符串
   * @param range 可选范围 [min, max]
   * @param context 变量上下文
   * @returns 属性值
   */
  const generateAttributeValue = (formula, range, context) => {
    let value = evaluateFormula(formula, context);

    if (range && Array.isArray(range) && range.length === 2) {
      value = Math.max(range[0], Math.min(range[1], value));
    }

    return value;
  };

  // ========================================
  // 仪表盘统一配置中心
  // ========================================
  const DASHBOARD_TABLE_CONFIG = {
    global: {
      tableKeywords: ['全局数据表', '全局数据', '全局'],
      columns: {
        detailLocation: { keywords: ['当前详细地点', '详细地点', '具体位置', '当前位置'], fallbackIndex: null },
        currentLocation: { keywords: ['当前次要地区', '当前所在地点', '当前地点', '所在地点'], fallbackIndex: 2 },
      },
    },
    player: {
      // 新增: user, <user>
      tableKeywords: ['主角信息', '主角', '玩家', '角色信息', 'player', '用户', 'user', '<user>'],
      columns: {
        name: { keywords: ['姓名', '名称', '人物名称', 'name'], fallbackIndex: 1 },
        status: { keywords: ['状态关键词', '状态关键字', '状态标签', '状态'], fallbackIndex: null },
        position: { keywords: ['具体位置', '位置', '所在地'], fallbackIndex: null },
        attrs: { keywords: ['基础属性', '属性'], fallbackIndex: null, isMultiple: true },
        // 新增: 灵石, 积分, 代币, 信用点
        money: {
          keywords: ['金钱', '资金', '金币', '货币', '余额', '灵石', '积分', '代币', '信用点'],
          fallbackIndex: null,
        },
        resources: { keywords: ['资源数据', '资源', 'resources'], fallbackIndex: null },
      },
    },
    location: {
      // 新增: 秘境, 副本, 洞府, 空间, 位面, 界域
      tableKeywords: [
        '世界地图点',
        '地图点',
        '地图',
        '地点',
        '地点表',
        '地图表',
        '场景',
        '区域',
        '秘境',
        '副本',
        '洞府',
        '空间',
        '位面',
        '界域',
      ],
      columns: {
        name: {
          keywords: ['详细地点', '具体位置', '当前地点', '次要地区', '主要地区', '地区', '地点名', '名称'],
          fallbackIndex: 1,
        },
        description: { keywords: ['环境描述', '描述', '说明', '介绍', '氛围描述'], fallbackIndex: null },
      },
    },
    npc: {
      // 新增: 弟子, 成员, 队友, 伙伴, 宠物, 灵宠
      tableKeywords: [
        '重要人物表',
        '重要角色表',
        '重要人物',
        'NPC',
        '人物表',
        '人物',
        '角色表',
        '角色',
        'character',
        '弟子',
        '成员',
        '队友',
        '伙伴',
        '宠物',
        '灵宠',
      ],
      columns: {
        name: { keywords: ['姓名', '名称'], fallbackIndex: 1 },
        status: { keywords: ['自身状态', '状态'], fallbackIndex: null },
        position: { keywords: ['具体位置', '位置', '所在地点', '所在'], fallbackIndex: null },
        inScene: { keywords: ['在场状态', '在场', '是否离场', '离场'], fallbackIndex: null },
      },
    },
    quest: {
      // 新增: 委托, 悬赏
      tableKeywords: ['任务表', '备忘事项', '任务', '事项', '目标', '待办', '主线', '支线', '委托', '悬赏'],
      columns: {
        name: { keywords: ['事项名称', '任务名', '名称'], fallbackIndex: 1 },
        type: { keywords: ['类型', '分类', '事项类型'], fallbackIndex: 2 },
        progress: { keywords: ['进度', '完成度', '进度/结果'], fallbackIndex: 5 },
        status: { keywords: ['状态'], fallbackIndex: 6 },
      },
      filters: {
        active: { column: 'status', includes: ['活跃', '进行中', '进行'], excludeColumn: 'type', excludes: ['规则'] },
      },
    },
    bag: {
      // 新增: 储物袋, 空间戒指
      tableKeywords: ['背包物品', '背包', '物品', '道具', '库存', '储物袋', '空间戒指', '持有物品表'],
      columns: {
        name: { keywords: ['物品名称', '名称', '物品名'], fallbackIndex: 1 },
        type: { keywords: ['类型', '分类', '物品类型'], fallbackIndex: 2 },
        count: { keywords: ['数量', '个数', '持有数'], fallbackIndex: 3 },
      },
    },
    skill: {
      // 新增: 神通, 道法, 功法, 血脉, 天赋, 义体改造, 超凡能力, 词条
      tableKeywords: [
        '主角技能',
        '技能表',
        '技能',
        '能力',
        '魔法',
        '超能力',
        '异能',
        '神通',
        '道法',
        '功法',
        '血脉',
        '天赋',
        '义体改造',
        '超凡能力',
        '词条',
      ],
      columns: {
        name: { keywords: ['技能名称', '名称', '技能名'], fallbackIndex: 1 },
        type: { keywords: ['类型', '分类'], fallbackIndex: 2 },
        level: { keywords: ['等级', '级别', '熟练度', 'lv'], fallbackIndex: 3 },
      },
    },
    equip: {
      // 新增: 法宝, 灵器, 仙器, 神器, 义体, 神装
      tableKeywords: ['装备表', '装备', '武器', '防具', '法宝', '灵器', '仙器', '神器', '义体', '神装'],
      columns: {
        name: { keywords: ['装备名称', '名称', '装备名'], fallbackIndex: 1 },
        type: { keywords: ['类型', '分类'], fallbackIndex: 2 },
        part: { keywords: ['部位', '装备部位', '位置'], fallbackIndex: 3 },
        isEquipped: { keywords: ['状态', '是否装备', '装备状态', '装备中'], fallbackIndex: 4 },
      },
      filters: {
        equipped: { column: 'isEquipped', includes: ['已装备', '装备中', 'true', '是', 'yes', 'equipped'] },
      },
    },
  };

  // 仪表盘数据解析器
  const DashboardDataParser = {
    // 根据配置查找表
    findTable(allTables, moduleKey) {
      const config = DASHBOARD_TABLE_CONFIG[moduleKey];
      if (!config) {
        console.info(`[DICE]仪表盘查找表格: 模块"${moduleKey}"配置不存在`);
        return null;
      }

      for (const keyword of config.tableKeywords) {
        for (const tableName in allTables) {
          if (tableName.includes(keyword)) {
            console.info(`[DICE]仪表盘查找表格: 模块"${moduleKey}"找到表格"${tableName}" (关键词: "${keyword}")`);
            return {
              data: allTables[tableName],
              name: tableName,
              key: allTables[tableName].key,
              config: config,
            };
          }
        }
      }
      console.info(
        `[DICE]仪表盘查找表格: 模块"${moduleKey}"未找到匹配表格 (关键词: ${config.tableKeywords.join(', ')})`,
      );
      return null;
    },

    // 根据配置查找列索引
    findColumnIndex(headers, columnKey, moduleConfig) {
      const colConfig = moduleConfig.columns[columnKey];
      if (!colConfig) return -1;

      // 先尝试关键词匹配
      for (let i = 0; i < headers.length; i++) {
        const h = String(headers[i] || '').toLowerCase();
        if (colConfig.keywords.some(kw => h.includes(kw.toLowerCase()))) {
          return i;
        }
      }

      // 回退到默认索引
      return colConfig.fallbackIndex ?? -1;
    },

    // 从行中提取指定列的值
    getValue(row, headers, columnKey, moduleConfig) {
      const idx = this.findColumnIndex(headers, columnKey, moduleConfig);
      if (idx < 0 || idx >= row.length) return null;
      return row[idx];
    },

    // 获取模块的所有列索引映射
    getColumnMap(headers, moduleKey) {
      const config = DASHBOARD_TABLE_CONFIG[moduleKey];
      if (!config) return {};

      const map = {};
      for (const colKey in config.columns) {
        map[colKey] = this.findColumnIndex(headers, colKey, config);
      }
      return map;
    },

    // 解析表格数据为结构化对象数组
    parseRows(tableResult, moduleKey) {
      if (!tableResult || !tableResult.data) {
        console.info(`[DICE]仪表盘解析数据: 模块"${moduleKey}"无数据，跳过解析`);
        return [];
      }

      const { data, config } = tableResult;
      const headers = data.headers || [];
      const rows = data.rows || [];
      const colMap = this.getColumnMap(headers, moduleKey);

      const parsed = rows.map((row, idx) => {
        const obj = { _rowIndex: idx, _raw: row };
        for (const colKey in colMap) {
          const colIdx = colMap[colKey];
          obj[colKey] = colIdx >= 0 && colIdx < row.length ? row[colIdx] : null;
        }
        return obj;
      });

      console.info(`[DICE]仪表盘解析数据: 模块"${moduleKey}"解析完成，共${parsed.length}行`);
      return parsed;
    },

    // 应用过滤器（容错：当目标列不存在时返回全部数据）
    applyFilter(parsedRows, filterKey, moduleKey) {
      const config = DASHBOARD_TABLE_CONFIG[moduleKey];
      if (!config || !config.filters || !config.filters[filterKey]) return parsedRows;

      const filter = config.filters[filterKey];

      // 容错：检查过滤列是否存在（即parsedRows中是否有该字段的有效值）
      const hasFilterColumn = parsedRows.some(row => row[filter.column] !== null && row[filter.column] !== undefined);
      if (!hasFilterColumn) {
        // 过滤列不存在，返回全部数据
        return parsedRows;
      }

      return parsedRows.filter(row => {
        const value = String(row[filter.column] || '').toLowerCase();
        const matchInclude = filter.includes.some(inc => value.includes(inc.toLowerCase()));

        if (filter.excludeColumn && filter.excludes) {
          const excludeValue = String(row[filter.excludeColumn] || '').toLowerCase();
          const matchExclude = filter.excludes.some(exc => excludeValue.includes(exc.toLowerCase()));
          return matchInclude && !matchExclude;
        }

        return matchInclude;
      });
    },
  };

  const DEFAULT_GM_CONFIG = {
    enabled: true,
    diceSystem: '1d100',
    showDiceIcon: true,
    autoSendPrompt: true,
    action_groups: [
      {
        table_keywords: ['地点', '地图', 'Location', 'Map', '世界', '场所'],
        actions: [
          { label: '前往', icon: 'fa-walking', type: 'prompt', template: '<user>前往{Name}。', auto_send: true },
          { label: '探索', icon: 'fa-search', type: 'prompt', template: '<user>探索{Name}。', auto_send: true },
          { label: '停留', icon: 'fa-clock', type: 'prompt', template: '<user>在{Name}停留。', auto_send: true },
        ],
      },
      {
        table_keywords: ['人物', 'NPC', '重要人物', '角色', '女主'],
        actions: [
          { label: '交谈', icon: 'fa-comments', type: 'prompt', template: '<user>与{Name}交谈。', auto_send: true },
          { label: '观察', icon: 'fa-eye', type: 'prompt', template: '<user>观察{Name}。', auto_send: true },
          { label: '战斗', icon: 'fa-hand-fist', type: 'prompt', template: '<user>与{Name}战斗。', auto_send: true },
        ],
      },
      {
        table_keywords: ['物品', '背包', '道具'],
        actions: [
          { label: '使用', icon: 'fa-hand-pointer', type: 'prompt', template: '<user>使用了{Name}。', auto_send: true },
          { label: '查看', icon: 'fa-eye', type: 'prompt', template: '<user>查看了{Name}。', auto_send: true },
          { label: '丢弃', icon: 'fa-trash', type: 'prompt', template: '<user>丢弃了{Name}。', auto_send: true },
        ],
      },
      {
        table_keywords: ['装备', '武器', '防具'],
        actions: [
          {
            label: '装备',
            icon: 'fa-shield-halved',
            type: 'prompt',
            template: '<user>装备了{Name}。',
            auto_send: true,
          },
          { label: '卸下', icon: 'fa-circle-xmark', type: 'prompt', template: '<user>卸下了{Name}。', auto_send: true },
          { label: '卖出', icon: 'fa-coins', type: 'prompt', template: '<user>卖出了{Name}。', auto_send: true },
        ],
      },
      {
        table_keywords: ['技能', '能力'],
        actions: [
          {
            label: '使用',
            icon: 'fa-wand-magic-sparkles',
            type: 'skill_check',
            template: '<user>使用{Name}。',
            auto_send: true,
          },
          { label: '练习', icon: 'fa-dumbbell', type: 'prompt', template: '<user>练习{Name}。', auto_send: true },
        ],
      },
      {
        table_keywords: ['备忘', '任务', '事项'],
        actions: [
          {
            label: '追踪',
            icon: 'fa-crosshairs',
            type: 'prompt',
            template: '<user>将{Name}设为当前追踪目标。',
            auto_send: true,
          },
          {
            label: '整理',
            icon: 'fa-list-check',
            type: 'prompt',
            template: '<user>整理关于{Name}的信息。',
            auto_send: true,
          },
          { label: '放弃', icon: 'fa-circle-xmark', type: 'prompt', template: '<user>放弃了{Name}。', auto_send: true },
        ],
      },
      {
        table_keywords: ['势力', '组织', '阵营'],
        actions: [
          {
            label: '打探',
            icon: 'fa-ear-listen',
            type: 'prompt',
            template: '<user>打探{Name}的情报。',
            auto_send: true,
          },
          { label: '加入', icon: 'fa-user-plus', type: 'prompt', template: '<user>申请加入{Name}。', auto_send: true },
          {
            label: '合作',
            icon: 'fa-handshake',
            type: 'prompt',
            template: '<user>向{Name}请求合作。',
            auto_send: true,
          },
        ],
      },
    ],
  };
  const getGMConfig = () => {
    const baseConfig = Store.get(STORAGE_KEY_GM_CONFIG, DEFAULT_GM_CONFIG);

    // 检查用户是否明确禁用了所有交互规则
    const activePresetId = ActionPresetManager.getActivePresetId();
    if (activePresetId === '__none__') {
      return {
        ...baseConfig,
        action_rules_disabled: true, // 标记：用户明确禁用了所有规则
      };
    }

    // 注入用户自定义交互规则
    const activePreset = ActionPresetManager.getActivePreset();
    if (activePreset && activePreset.rules && activePreset.rules.length > 0) {
      // 转换预设格式为 custom_action_groups 格式
      const customActionGroups = activePreset.rules.map(rule => ({
        table_keywords: rule.table_keywords || [],
        actions: (rule.actions || []).map(action => ({
          label: action.label,
          icon: action.icon || ACTION_ICON_MAP[action.label] || 'fa-circle',
          type: 'prompt',
          template: action.template || `<user>对{Name}执行互动:${action.label}。`,
          auto_send: false,
        })),
      }));

      return {
        ...baseConfig,
        custom_action_groups: customActionGroups,
      };
    }

    return baseConfig;
  };

  // 统一的结果标签样式生成函数 - 返回 CSS 类名
  const getResultBadgeClass = resultType => {
    // resultType: 'critSuccess' | 'extremeSuccess' | 'success' | 'warning' | 'failure' | 'critFailure'
    const classMap = {
      critSuccess: 'acu-result-badge acu-result-badge-crit-success',
      extremeSuccess: 'acu-result-badge acu-result-badge-extreme-success',
      success: 'acu-result-badge acu-result-badge-success',
      warning: 'acu-result-badge acu-result-badge-warning',
      failure: 'acu-result-badge acu-result-badge-failure',
      critFailure: 'acu-result-badge acu-result-badge-crit-failure',
    };
    return classMap[resultType] || classMap.failure;
  };

  // [统一] 交互选项的图标映射表，供所有渲染位置共享使用
  const ACTION_ICON_MAP: Record<string, string> = {
    // 战斗类
    战斗: 'fa-hand-fist',
    攻击: 'fa-hand-fist',
    防御: 'fa-shield',
    逃跑: 'fa-person-running',
    // 社交类
    交谈: 'fa-comments',
    对话: 'fa-comments',
    告别: 'fa-hand',
    求爱: 'fa-heart',
    邀约: 'fa-calendar-check',
    赠送: 'fa-gift',
    送礼: 'fa-gift',
    // 观察类
    观察: 'fa-eye',
    查看: 'fa-eye',
    检查: 'fa-magnifying-glass',
    // 物品操作
    使用: 'fa-hand-pointer',
    丢弃: 'fa-trash',
    装备: 'fa-shield-halved',
    卸下: 'fa-circle-xmark',
    卖出: 'fa-coins',
    购买: 'fa-shopping-cart',
    // 移动类
    前往: 'fa-walking',
    探索: 'fa-search',
    停留: 'fa-clock',
    离开: 'fa-door-open',
    // 技能类
    练习: 'fa-dumbbell',
    施展: 'fa-wand-magic-sparkles',
    凝练: 'fa-fire',
    // 任务类
    追踪: 'fa-crosshairs',
    整理: 'fa-list-check',
    放弃: 'fa-circle-xmark',
    完成: 'fa-check',
    // 组织类
    打探: 'fa-ear-listen',
    加入: 'fa-user-plus',
    合作: 'fa-handshake',
    // 表演类
    表演: 'fa-music',
    演奏: 'fa-guitar',
    唱歌: 'fa-microphone',
  };

  /**
   * 获取指定表格的默认交互动作
   *
   * [扩展点] 支持用户自定义规则，优先级：用户自定义规则 > 内置默认规则
   * 将来可通过 config.custom_action_groups 添加用户定义的表格规则
   * 例如用户可以为"神通表"定义固有选项"凝练"、"施展"
   *
   * @param tableName 表格名称（用于匹配动作组）
   * @returns 匹配的动作列表（返回副本，避免变异原配置）
   */
  const getActionsForTable = (tableName: string) => {
    const config = getGMConfig();
    if (!config.enabled) return [];

    // 如果用户明确禁用了所有规则，返回空数组
    if ((config as any).action_rules_disabled) return [];

    const lowerName = tableName.toLowerCase();

    // [扩展点] 优先检查用户自定义规则
    const customRules = (config as any).custom_action_groups || [];
    for (const group of customRules) {
      const matched = group.table_keywords.some((keyword: string) => lowerName.includes(keyword.toLowerCase()));
      if (matched) return [...(group.actions || [])]; // 返回副本
    }

    // 回退到内置默认规则
    const builtinRules = config.action_groups || [];
    for (const group of builtinRules) {
      const matched = group.table_keywords.some((keyword: string) => lowerName.includes(keyword.toLowerCase()));
      if (matched) return [...(group.actions || [])]; // 返回副本
    }

    return [];
  };

  /**
   * 获取指定行的完整交互选项列表
   * 合并逻辑：默认动作 + AI生成的自定义动作（去重）
   *
   * @param tableName 表格名称（用于匹配默认动作）
   * @param headers 表头数组
   * @param rowData 行数据数组
   * @returns 完整的动作列表（默认动作在前，自定义动作在后）
   */
  const getInteractOptionsForRow = (tableName: string, headers: any[], rowData: any[]) => {
    // 1. 获取基于表格类型的默认动作（返回副本避免变异）
    const defaultActions = [...getActionsForTable(tableName)];

    // 2. 查找"交互选项"列索引
    const interactColIdx = headers.findIndex(h => h && String(h).includes('交互'));
    if (interactColIdx < 0 || !rowData[interactColIdx]) {
      return defaultActions;
    }

    // 3. 过滤无效值
    const invalidValues = ['-', 'null', 'none', '无', '空', 'n/a', 'undefined', '/'];
    const cellValue = String(rowData[interactColIdx]).trim();
    if (!cellValue || invalidValues.includes(cellValue.toLowerCase())) {
      return defaultActions;
    }

    // 4. 解析分隔的选项
    const interactOptions = cellValue
      .split(/[,，、;；]/)
      .map(s => s.trim())
      .filter(s => s && !invalidValues.includes(s.toLowerCase()));

    if (interactOptions.length === 0) {
      return defaultActions;
    }

    // 5. 获取默认动作的标签列表，用于去重
    const existingLabels = defaultActions.map(a => a.label.toLowerCase());

    // 6. 只追加不在默认动作中的自定义选项
    const newActions = interactOptions
      .filter(opt => !existingLabels.includes(opt.toLowerCase()))
      .map(opt => ({
        label: opt,
        icon: ACTION_ICON_MAP[opt] || 'fa-hand-pointer',
        type: 'prompt',
        template: `<user>对{Name}执行互动:${opt}。`,
        auto_send: true,
      }));

    // 7. 返回合并后的数组：默认动作 + 自定义动作
    return [...defaultActions, ...newActions];
  };

  const isNumericCell = value => {
    if (value === null || value === undefined || value === '') return false;
    const str = String(value).trim();
    // 匹配: 纯数字、百分比、分数(50/100)、任意中文/英文标签:数字 格式
    return (
      /^-?\d+(\.\d+)?%?$/.test(str) ||
      /^\d+\/\d+$/.test(str) ||
      /^[\u4e00-\u9fa5a-zA-Z]+[:\s：]\s*\d+/i.test(str) ||
      /\d+/.test(str)
    );
  };

  const extractNumericValue = value => {
    if (!value) return 0;
    const str = String(value).trim();
    // 处理分数形式 (50/100 -> 取第一个数)
    if (/^\d+\/\d+$/.test(str)) return parseInt(str.split('/')[0], 10);
    // 处理百分比
    if (str.endsWith('%')) return parseInt(str.replace('%', ''), 10);
    // 处理 "标签:数值" 格式，提取最后一个数字
    const matches = str.match(/\d+/g);
    if (matches && matches.length > 0) {
      return parseInt(matches[matches.length - 1], 10);
    }
    return 0;
  };

  const parseAttributeString = str => {
    if (!str) return [];
    const results = [];
    const rawStr = String(str).trim();

    // 尝试解析 JSON 格式 {"属性名":数值, ...}
    if (rawStr.startsWith('{') && rawStr.endsWith('}')) {
      try {
        const jsonObj = JSON.parse(rawStr);
        for (const key in jsonObj) {
          const val = jsonObj[key];
          if (typeof val === 'number') {
            results.push({ name: key, value: val });
          } else if (typeof val === 'string' && /^\d+$/.test(val)) {
            results.push({ name: key, value: parseInt(val, 10) });
          }
        }
        if (results.length > 0) return results;
      } catch (e) {
        // JSON 解析失败，继续用原有逻辑
      }
    }

    // 原有逻辑：解析 "属性名:数值; 属性名:数值" 格式
    const parts = rawStr.split(/[,;，；\s]+/);
    for (const part of parts) {
      const match = part.match(/^"?([\u4e00-\u9fa5a-zA-Z_]+)"?[:\s：]\s*"?(-?\d+)"?/);
      if (match) {
        results.push({ name: match[1], value: parseInt(match[2], 10) });
      }
    }
    return results;
  };
  // [新增] 解析人际关系字符串，支持多种格式:
  // 格式1: "人名(关系标签);人名(关系)"
  // 格式2: "与人名:关系描述;与人名:关系描述"
  // 格式3: "与人名:关系描述,细节;与人名:关系"
  const parseRelationshipString = str => {
    if (!str) return [];
    const results = [];
    const rawStr = String(str).trim();

    // 按分号分割
    const parts = rawStr.split(/[;；]/);
    for (const part of parts) {
      const trimmed = part.trim();
      if (!trimmed) continue;

      // 格式2/3: "与人名:关系" 或 "与人名：关系"
      const colonMatch = trimmed.match(/^与?(.+?)[:\：](.+)$/);
      if (colonMatch) {
        const name = colonMatch[1].trim();
        const relation = colonMatch[2].trim();
        if (name && relation) {
          results.push({ name: name, relation: relation });
          continue;
        }
      }

      // 格式1: "人名(关系)" 或 "人名（关系）"
      const parenMatch = trimmed.match(/^([^(（]+)[(（]([^)）]+)[)）]$/);
      if (parenMatch) {
        results.push({ name: parenMatch[1].trim(), relation: parenMatch[2].trim() });
        continue;
      }

      // 都不匹配，整个作为人名
      if (trimmed.length > 0) {
        results.push({ name: trimmed, relation: '' });
      }
    }
    return results;
  };

  // [新增] 检测是否是人际关系格式
  const isRelationshipCell = (value, headerName) => {
    if (!value) return false;
    const str = String(value).trim();
    const lowerHeader = (headerName || '').toLowerCase();
    // 表头包含"关系"关键词
    if (lowerHeader.includes('关系') || lowerHeader.includes('人际')) {
      return true;
    }
    // 或者内容匹配 "名字(关系);名字(关系)" 格式
    return /^[^(（;；]+[(（][^)）]+[)）]([;；][^(（;；]+[(（][^)）]+[)）])*$/.test(str);
  };

  const processTemplate = (template, cardData, headers) => {
    if (!template || !cardData) return template;
    let result = template;
    const name = cardData[1] || '未知';
    result = result.replace(/\{Name\}/gi, name);
    result = result.replace(/\{RowIndex\}/gi, cardData[0] || '0');
    if (headers && headers.length > 0) {
      headers.forEach((header, idx) => {
        if (header && idx < cardData.length) {
          const value = cardData[idx] || '未知';
          const regex = new RegExp(`\\{${header}\\}`, 'gi');
          result = result.replace(regex, value);
        }
      });
    }
    result = result.replace(/\{[^}]+\}/g, '未知');
    return result;
  };

  // 固定显示的功能按钮
  // 注意：保存按钮已移除，系统现在使用即时保存模式（每次编辑/删除后自动保存）
  const ACTION_BUTTONS = [
    // { id: 'acu-btn-save-global', icon: 'fa-save', title: '保存所有修改' }, // 已废弃：使用即时保存
    { id: 'acu-btn-open-editor', icon: 'fa-database', title: '打开神-数据库' },
    { id: 'acu-btn-open-visualizer', icon: 'fa-table-columns', title: '打开可视化表格编辑' },
    { id: 'acu-btn-collapse', icon: 'fa-chevron-down', title: '收起面板' },
    { id: 'acu-btn-refill', icon: 'fa-bolt', title: '重新填表' },
    { id: 'acu-btn-settings', icon: 'fa-cog', title: '全能设置' },
  ];

  let isInitialized = false;
  let isSaving = false;
  let saveQueue: Promise<void> = Promise.resolve(); // 保存队列，确保并发保存按顺序执行
  let isEditingOrder = false;
  let isSettingsOpen = false;

  // === 弹窗栈管理 ===
  // 用于追踪弹窗打开顺序，关闭时自动返回上一个弹窗
  type ModalEntry = {
    name: string;
    show: () => void;
  };
  const modalStack: ModalEntry[] = [];

  /**
   * 将弹窗推入栈中
   * @param name 弹窗名称（用于调试）
   * @param show 重新打开该弹窗的函数
   */
  const pushModal = (name: string, show: () => void) => {
    modalStack.push({ name, show });
  };

  /**
   * 从栈中弹出当前弹窗并返回上一个弹窗
   * @returns 是否成功返回上一个弹窗
   */
  const popModal = (): boolean => {
    modalStack.pop(); // 移除当前弹窗
    const prev = modalStack.pop(); // 获取上一个弹窗
    if (prev) {
      prev.show(); // 重新打开上一个弹窗
      return true;
    }
    return false;
  };

  /**
   * 清空弹窗栈（用于关闭所有弹窗或从根弹窗关闭）
   */
  const clearModalStack = () => {
    modalStack.length = 0;
  };

  let currentDiffMap = new Set();
  let observer = null;
  let _boundRenderHandler = null;

  // --- 全局状态变量 ---
  let cachedRawData = null;
  let hasUnsavedChanges = false;
  // [修复] 存储待删除行的索引（按表格分组）
  let pendingDeletions: Record<string, number[]> = {};
  const getPendingDeletions = () => pendingDeletions;
  const clearPendingDeletions = () => {
    pendingDeletions = {};
  };
  let isAutoTransforming = false; // 防止自动转换循环触发
  let tablePageStates = {};
  let tableSearchStates = {};
  let lastOptionHash = null;
  let optionPanelVisible = false; // [新增] 选项面板可见性控制
  // [修改] 初始化时从硬盘读取记忆
  const STORAGE_KEY_SCROLL = 'acu_scroll_v19_fixed';
  let tableScrollStates = {};
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SCROLL);
    if (saved) tableScrollStates = JSON.parse(saved);
  } catch (e) {
    console.warn('[DICE]ACU Error:', e);
  }
  // [优化] 智能更新控制器：后端数据变动时，自动更新快照
  const UpdateController = {
    _lastValidationCount: 0,
    _isRollingBack: false, // 防止回滚时触发递归

    handleUpdate: () => {
      // 防止回滚操作触发递归
      if (UpdateController._isRollingBack) return;

      // === 更新拦截逻辑（检查启用了 intercept 的规则） ===
      try {
        const snapshot = loadSnapshot();
        const newData = getTableData();
        if (snapshot && newData) {
          const rules = ValidationRuleManager.getEnabledRules();
          const violations = ValidationEngine.checkTableRules(snapshot, newData, rules);

          if (violations.length > 0) {
            console.warn('[DICE]ACU 规则拦截触发，执行回滚:', violations);
            UpdateController._isRollingBack = true;

            // 获取 API 并回滚
            const api = getCore().getDB();
            if (api?.fillTable) {
              try {
                api.fillTable(snapshot);
                if (window.toastr) {
                  window.toastr.error(violations[0].message, '已回滚', {
                    timeOut: 5000,
                    positionClass: 'toast-bottom-right',
                  });
                }
              } catch (fillError) {
                console.error('[DICE]ACU fillTable 回滚失败:', fillError);
                // 回滚失败时仍然显示规则拦截提示
                if (window.toastr) {
                  window.toastr.error(`规则拦截: ${violations[0].message}（回滚操作失败，请手动刷新）`, '错误', {
                    timeOut: 7000,
                    positionClass: 'toast-bottom-right',
                  });
                }
              }
            }

            setTimeout(() => {
              UpdateController._isRollingBack = false;
            }, 500);
            return;
          }
        }
      } catch (e) {
        console.error('[DICE]ACU 拦截检查失败:', e);
      }

      // 直接触发渲染，让 renderInterface 内部处理数据获取和差异计算
      // 注意：不要在这里更新快照！快照只在用户主动保存时更新
      renderInterface();

      // 执行实时验证
      setTimeout(() => {
        try {
          const rawData = cachedRawData || getTableData();
          if (rawData) {
            const errors = ValidationEngine.validateAllData(rawData);
            const newCount = errors.length;

            // 只有当错误数量增加时才弹出提示
            if (newCount > UpdateController._lastValidationCount && newCount > 0) {
              // 错误数量已增加
            }

            UpdateController._lastValidationCount = newCount;

            // 更新导航栏指示器
            updateValidationIndicator(newCount);
          }
        } catch (e) {
          console.error('[DICE]ACU 验证执行失败:', e);
        }
      }, 100);
    },
  };

  // 更新导航栏验证指示器
  const updateValidationIndicator = count => {
    const { $ } = getCore();
    const $indicator = $('.acu-validation-indicator');

    if (count > 0) {
      if ($indicator.length) {
        $indicator.find('.acu-validation-count').text(count);
        $indicator.show();
      }
    } else {
      $indicator.hide();
    }
  };

  // --- [重构] 上下文指纹工具 ---
  const getCurrentContextFingerprint = () => {
    try {
      // 方式1: 酒馆标准 API
      if (typeof SillyTavern !== 'undefined' && SillyTavern.getCurrentChatId) {
        return SillyTavern.getCurrentChatId();
      }
      // 方式2: 直接访问属性
      if (typeof SillyTavern !== 'undefined' && SillyTavern.chatId) {
        return SillyTavern.chatId;
      }
      // 方式3: 父窗口 (iframe 场景)
      if (window.parent?.SillyTavern?.getCurrentChatId) {
        return window.parent.SillyTavern.getCurrentChatId();
      }
    } catch (e) {
      console.warn('[DICE]ACU getCurrentContextFingerprint error:', e);
    }
    return 'unknown_context';
  };

  // 全局状态追踪 (已清理死代码)

  const DEFAULT_CONFIG = {
    layout: 'horizontal',
    collapseStyle: 'bar',
    collapseAlign: 'right',
    fontFamily: 'default',
    theme: 'retro',
    cardWidth: 260,
    fontSize: 13,
    highlightNew: true,
    itemsPerPage: 50,
    actionsPosition: 'bottom',
    gridColumns: 'auto', // [修改] 默认为智能自动列数
    positionMode: 'fixed', // fixed=悬浮底部, embedded=跟随消息
    showOptionPanel: true, // [新增] 显示选项面板
    clickOptionToAutoSend: true, // [新增] 点击选项自动发送
    optionFontSize: 12, // [新增] 行动选项独立字体大小
    muteDatabaseToasts: false,
  };

  const FONTS = [
    { id: 'default', name: '系统默认 (Modern)', val: `'Segoe UI', 'Microsoft YaHei', sans-serif` },
    { id: 'hanchan', name: '寒蝉全圆体', val: `"寒蝉全圆体", sans-serif` },
    { id: 'maple', name: 'Maple Mono (代码风)', val: `"Maple Mono NF CN", monospace` },
    { id: 'huiwen', name: '汇文明朝体 (Huiwen)', val: `"Huiwen-mincho", serif` },
    { id: 'cooper', name: 'Cooper正楷', val: `"CooperZhengKai", serif` },
    { id: 'yffyt', name: 'YFFYT (艺术体)', val: `"YFFYT", sans-serif` },
    { id: 'fusion', name: 'Fusion Pixel (像素风)', val: `"Fusion Pixel 12px M latin", monospace` },
    { id: 'wenkai', name: '霞鹜文楷 (WenKai)', val: `"LXGW WenKai", serif` },
    { id: 'notosans', name: '思源黑体 (Noto Sans)', val: `"Noto Sans CJK", sans-serif` },
    { id: 'zhuque', name: '朱雀仿宋 (Zhuque)', val: `"Zhuque Fangsong (technical preview)", serif` },
  ];

  const THEMES = [
    { id: 'retro', name: '复古羊皮 (Retro)', icon: 'fa-scroll' },
    { id: 'dark', name: '极夜深空 (Dark)', icon: 'fa-moon' },
    { id: 'modern', name: '现代清爽 (Modern)', icon: 'fa-sun' },
    { id: 'forest', name: '森之物语 (Forest)', icon: 'fa-tree' },
    { id: 'ocean', name: '深海幽蓝 (Ocean)', icon: 'fa-water' },
    { id: 'cyber', name: '赛博霓虹 (Cyber)', icon: 'fa-bolt' },
    { id: 'nightowl', name: '深蓝磨砂 (Night Owl)', icon: 'fa-feather' },
    { id: 'sakura', name: '暖粉手账 (Warm Pink)', icon: 'fa-heart' },
    { id: 'minepink', name: '量产地雷 (Mine Pink)', icon: 'fa-skull' },
    { id: 'galgame', name: '粉梦物语 (Galgame Pink)', icon: 'fa-heart' },
    { id: 'purple', name: '紫罗兰梦 (Purple)', icon: 'fa-gem' },
    { id: 'wechat', name: '绿色泡泡 (Green Bubble)', icon: 'fa-weixin' },
    { id: 'educational', name: '学习资料 (Educational)', icon: 'fa-book' },
    { id: 'vaporwave', name: '霓虹怀旧 (Vaporwave)', icon: 'fa-palette' },
    { id: 'classicpackaging', name: '经典包装 (Classic Packaging)', icon: 'fa-box' },
    { id: 'terminal', name: '终端绿屏 (Terminal)', icon: 'fa-terminal' },
    { id: 'dreamcore', name: '梦核迷离 (Dreamcore)', icon: 'fa-cloud-moon' },
    { id: 'aurora', name: '极光幻境 (Aurora)', icon: 'fa-snowflake' },
    { id: 'chouten', name: '幻夜霓虹 (Cyber Kawaii)', icon: 'fa-star' },
  ];

  // [优化] 缓存 core 对象 (修复竞态条件 + 增强 ST 穿透查找)
  let _coreCache = null;
  const getCore = () => {
    const w = window.parent || window;
    // 动态获取 jQuery
    const $ = window.jQuery || w.jQuery;

    // 只有当缓存存在且有效($存在)时，才直接返回
    if (_coreCache && _coreCache.$) return _coreCache;

    const core = {
      $: $,
      getDB: () => w.AutoCardUpdaterAPI || window.AutoCardUpdaterAPI,
      clipboard: w.navigator.clipboard,
      // 增强查找：依次尝试 当前窗口 -> 父窗口 -> 顶层窗口 (带跨域保护)
      ST:
        window.SillyTavern ||
        w.SillyTavern ||
        (() => {
          try {
            return window.top ? window.top.SillyTavern : null;
          } catch (e) {
            return null;
          }
        })(),
    };

    // 只有成功获取到 jQuery 后才锁定缓存，防止初始化过早导致永久失效
    if ($) _coreCache = core;
    return core;
  };

  const updateSaveButtonState = () => {
    const { $ } = getCore();
    const $btn = $('#acu-btn-save-global');
    const $icon = $btn.find('i');
    const deletions = getPendingDeletions();
    let hasDeletions = false;
    if (deletions) {
      for (const key in deletions) {
        if (deletions[key] && deletions[key].length > 0) {
          hasDeletions = true;
          break;
        }
      }
    }
    if (hasUnsavedChanges || hasDeletions) {
      $icon.addClass('acu-icon-breathe');
      $btn.attr('title', '你有未保存的手动修改或删除操作');
    } else {
      $icon.removeClass('acu-icon-breathe');
      $btn.attr('title', '保存');
      $btn.css('color', '');
    }
  };

  const getIconForTableName = name => {
    if (!name) return 'fa-table';
    const n = name.toLowerCase();
    if (n.includes('主角') || n.includes('角色')) return 'fa-user-circle';
    if (n.includes('通用') || n.includes('全局')) return 'fa-globe-asia';
    if (n.includes('装备') || n.includes('背包')) return 'fa-briefcase';
    if (n.includes('技能') || n.includes('武魂')) return 'fa-dragon';
    if (n.includes('关系') || n.includes('周边')) return 'fa-user-friends';
    if (n.includes('任务') || n.includes('日志')) return 'fa-scroll';
    if (n.includes('人物') || n.includes('关键人物')) return 'fa-address-book';
    if (n.includes('总结') || n.includes('大纲')) return 'fa-book-reader';
    if (n.includes('地图点') || n.includes('世界地图')) return 'fa-map-location-dot';
    if (n.includes('地图元素') || n.includes('机关') || n.includes('线索')) return 'fa-bullseye';
    if (n.includes('势力') || n.includes('阵营')) return 'fa-shield-halved';
    if (n.includes('物品')) return 'fa-gem';
    if (n.includes('情报') || n.includes('信息')) return 'fa-file-lines';
    if (n.includes('选项')) return 'fa-list-check';
    return 'fa-table';
  };

  const getBadgeStyle = text => {
    if (!text) return '';
    const str = String(text).trim();
    if (/^[0-9]+%?$/.test(str) || /^Lv\.\d+$/.test(str)) return 'acu-badge-green';
    if (str.length <= 6 && !str.includes('http')) return 'acu-badge-neutral';
    if (['是', '否', '有', '无', '死亡', '存活'].includes(str)) return 'acu-badge-neutral';
    return '';
  };

  // [优化] 统一存储封装 (带静默自动清理)
  const Store = {
    get: (key, def = null) => {
      try {
        return JSON.parse(localStorage.getItem(key)) ?? def;
      } catch {
        return def;
      }
    },
    set: (key, val) => {
      try {
        localStorage.setItem(key, JSON.stringify(val));
      } catch (e) {
        // 捕获存储空间已满错误
        if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
          console.warn('[DICE]ACU 存储空间已满，触发静默清理策略...');
          try {
            // 1. 优先删除最占空间的“数据快照” (不影响功能，只会导致下次刷新暂时没有蓝色高亮)
            localStorage.removeItem(STORAGE_KEY_LAST_SNAPSHOT);

            // 2. 再次尝试保存
            localStorage.setItem(key, JSON.stringify(val));
          } catch (retryErr) {
            // 如果清理后还是存不下，才弹窗打扰用户
            console.error('[DICE]ACU Store 清理后依然失败', retryErr);
            if (window.toastr && !window._acuQuotaAlerted) {
              window.toastr.warning('⚠️ 浏览器存储空间严重不足，配置保存失败');
              window._acuQuotaAlerted = true;
              setTimeout(() => (window._acuQuotaAlerted = false), 10000);
            }
          }
        } else {
          console.error('[DICE]ACU Store', e);
        }
      }
    },
  };

  const getActiveTabState = () => Store.get(STORAGE_KEY_ACTIVE_TAB);
  const saveActiveTabState = v => Store.set(STORAGE_KEY_ACTIVE_TAB, v);

  // [修复] 统一清理所有面板状态，避免状态残留导致内容错乱
  const clearAllPanelStates = () => {
    Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, false);
    Store.set('acu_changes_panel_active', false);
    Store.set('acu_favorites_panel_active', false);
    saveActiveTabState(null);
  };

  // [修复] MVU 面板异步回调防竞态：只有当前仍处于 MVU 标签且无更高优先级面板激活时才允许写入
  function canWriteMvuPanel() {
    if (getActiveTabState() !== MvuModule.MODULE_ID) return false;
    if (Store.get('acu_changes_panel_active', false)) return false;
    if (Store.get('acu_favorites_panel_active', false)) return false;
    if (Store.get(STORAGE_KEY_DASHBOARD_ACTIVE, false)) return false;
    return true;
  }

  const getSavedTableOrder = () => Store.get(STORAGE_KEY_TABLE_ORDER);
  const saveTableOrder = v => Store.set(STORAGE_KEY_TABLE_ORDER, v);
  const getCollapsedState = () => Store.get(STORAGE_KEY_IS_COLLAPSED, false);
  const saveCollapsedState = v => Store.set(STORAGE_KEY_IS_COLLAPSED, v);
  // [新增] 选项面板独立折叠状态管理
  const getOptionsCollapsedState = () => Store.get(STORAGE_KEY_OPTIONS_COLLAPSED, false);
  const saveOptionsCollapsedState = v => Store.set(STORAGE_KEY_OPTIONS_COLLAPSED, v);
  // [修改] 读取快照时，严格核对身份证 (Chat ID)
  const loadSnapshot = () => {
    const data = Store.get(STORAGE_KEY_LAST_SNAPSHOT);
    if (!data) return null;
    // 获取当前环境指纹
    const currentCtx = getCurrentContextFingerprint();
    // 如果快照里的指纹存在，但和当前不一致，说明是上个角色的数据，必须作废
    if (data._contextId && data._contextId !== currentCtx) {
      return null;
    }
    return data;
  };

  // [修改] 保存快照时，自动注入当前的身份证
  const saveSnapshot = v => {
    if (!v) return;
    // 确保数据对象里带有当前 ChatID
    if (typeof v === 'object') {
      v._contextId = getCurrentContextFingerprint();
    }
    Store.set(STORAGE_KEY_LAST_SNAPSHOT, v);
  };

  // --- [新增] 移植的辅助函数 ---
  const getTableHeights = () => Store.get(STORAGE_KEY_TABLE_HEIGHTS, {});
  const saveTableHeights = v => Store.set(STORAGE_KEY_TABLE_HEIGHTS, v);
  const getTableStyles = () => Store.get(STORAGE_KEY_TABLE_STYLES, {});
  const saveTableStyles = v => Store.set(STORAGE_KEY_TABLE_STYLES, v);
  const getHiddenTables = () => Store.get(STORAGE_KEY_HIDDEN_TABLES, []);
  const saveHiddenTables = v => Store.set(STORAGE_KEY_HIDDEN_TABLES, v);
  const getReverseTables = () => Store.get(STORAGE_KEY_REVERSE_TABLES, []);
  const saveReverseTables = v => Store.set(STORAGE_KEY_REVERSE_TABLES, v);

  // 判断表格是否需要显示倒序按钮
  const shouldShowReverseButton = tableName => {
    if (!tableName) return false;
    const keywords = ['总结', '大纲', '日志', '记录', '历史'];
    return keywords.some(kw => tableName.includes(kw));
  };

  // 判断表格当前是否为倒序
  const isTableReversed = tableName => {
    return getReverseTables().includes(tableName);
  };

  // 切换表格倒序状态
  const toggleTableReverse = tableName => {
    const list = getReverseTables();
    const idx = list.indexOf(tableName);
    if (idx >= 0) {
      list.splice(idx, 1);
    } else {
      list.push(tableName);
    }
    saveReverseTables(list);
    console.log('[DICE]ACU toggleTableReverse:', tableName, 'reversed:', idx < 0);
  };
  // [新增] 根据角色名获取属性列表
  const getAttributesForCharacter = characterName => {
    const rawData = cachedRawData || getTableData();
    if (!rawData) return [];

    const isUser = !characterName || characterName === '<user>' || characterName.trim() === '';

    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;

      // 主角信息表 -> <user> 或通过真名匹配
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与characterName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(characterName)) continue;
          }
          const headers = sheet.content[0] || [];
          const row = sheet.content[1];
          let attrs = [];
          headers.forEach((h, idx) => {
            if (h && h.includes('属性')) {
              const parsed = parseAttributeString(row[idx] || '');
              parsed.forEach(attr => {
                if (!attrs.includes(attr.name)) attrs.push(attr.name);
              });
            }
          });
          if (attrs.length > 0) return attrs;
        }
      }

      // 重要人物表 -> 其他角色 (模糊匹配)
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        const headers = sheet.content[0] || [];
        // 动态查找姓名列
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (headers[h].includes('姓名') || headers[h].includes('名称') || headers[h].toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(characterName)) {
            let attrs = [];
            headers.forEach((h, idx) => {
              if (h && h.includes('属性')) {
                const parsed = parseAttributeString(row[idx] || '');
                parsed.forEach(attr => {
                  if (!attrs.includes(attr.name)) attrs.push(attr.name);
                });
              }
            });
            return attrs;
          }
        }
      }
    }

    return [];
  };
  const normalizeAttributeName = (name: string): string => {
    if (!name) return '';
    return String(name)
      .trim()
      .toLowerCase()
      .replace(/[\s_:\-：]/g, '')
      .replace(/值$/u, '');
  };

  const resolveAttributeAliasName = (
    characterName: string,
    targetName: string,
    aliasCandidates: string[] = [],
  ): { name: string | null; reason?: string } => {
    const allAttrs = getFullAttributesForCharacter(characterName)
      .map(attr => attr.name)
      .filter(Boolean);
    if (allAttrs.length === 0) {
      return { name: targetName || null };
    }

    const orderedCandidates = [targetName, ...aliasCandidates]
      .map(n => String(n || '').trim())
      .filter(Boolean)
      .filter((n, idx, arr) => arr.indexOf(n) === idx);
    if (orderedCandidates.length === 0) {
      return { name: null, reason: '目标属性名为空' };
    }

    for (const candidate of orderedCandidates) {
      if (allAttrs.includes(candidate)) {
        return { name: candidate };
      }
    }

    const lowerMap = new Map<string, string>();
    allAttrs.forEach(name => {
      const lower = name.toLowerCase();
      if (!lowerMap.has(lower)) lowerMap.set(lower, name);
    });
    for (const candidate of orderedCandidates) {
      const matched = lowerMap.get(candidate.toLowerCase());
      if (matched) {
        return { name: matched };
      }
    }

    const normalizedGroups = new Map<string, string[]>();
    allAttrs.forEach(name => {
      const key = normalizeAttributeName(name);
      if (!key) return;
      const list = normalizedGroups.get(key) || [];
      list.push(name);
      normalizedGroups.set(key, list);
    });

    for (const candidate of orderedCandidates) {
      const normalized = normalizeAttributeName(candidate);
      if (!normalized) continue;
      const matched = normalizedGroups.get(normalized) || [];
      if (matched.length === 1) {
        return { name: matched[0] };
      }
      if (matched.length > 1) {
        return {
          name: null,
          reason: `属性别名冲突: ${candidate} 可匹配 ${matched.join(', ')}`,
        };
      }
    }

    return {
      name: null,
      reason: `找不到属性: ${targetName}`,
    };
  };

  const isSameAttributeAlias = (left: string, right: string): boolean => {
    const a = normalizeAttributeName(left);
    const b = normalizeAttributeName(right);
    return Boolean(a) && Boolean(b) && a === b;
  };

  // [新增] 根据角色名和属性名获取属性值
  const getAttributeValue = (characterName, attrName, aliasCandidates: string[] = []) => {
    const rawData = cachedRawData || getTableData();
    if (!rawData || !attrName) return null;

    const isUser = !characterName || characterName === '<user>' || characterName.trim() === '';
    const resolved = resolveAttributeAliasName(characterName, attrName, aliasCandidates);
    if (!resolved.name) return null;
    const resolvedAttrName = resolved.name;

    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;

      // 主角信息表 -> <user> 或通过真名匹配
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与characterName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(characterName)) continue;
          }
          const headers = sheet.content[0] || [];
          const row = sheet.content[1];
          for (let idx = 0; idx < headers.length; idx++) {
            const h = headers[idx];
            if (h && h.includes('属性')) {
              const parsed = parseAttributeString(row[idx] || '');
              const found = parsed.find(attr => attr.name === resolvedAttrName);
              if (found) return found.value;
            }
          }
        }
      }

      // 重要人物表 -> 其他角色 (模糊匹配)
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        const headers = sheet.content[0] || [];
        // 动态查找姓名列
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (headers[h].includes('姓名') || headers[h].includes('名称') || headers[h].toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(characterName)) {
            for (let idx = 0; idx < headers.length; idx++) {
              const h = headers[idx];
              if (h && h.includes('属性')) {
                const parsed = parseAttributeString(row[idx] || '');
                const found = parsed.find(attr => attr.name === resolvedAttrName);
                if (found) return found.value;
              }
            }
          }
        }
      }
    }

    return null;
  };
  // [新增] 标准6维属性名
  const STANDARD_ATTRS = ['力量', '敏捷', '体质', '智力', '感知', '魅力'];

  /**
   * 获取当前规则的标准属性名列表
   */
  const getStandardAttrs = () => {
    const preset = AttributePresetManager.getActivePreset();
    if (preset && preset.baseAttributes) {
      return preset.baseAttributes.map(attr => attr.name);
    }
    return STANDARD_ATTRS;
  };

  /**
   * 获取当前规则的随机属性池（包含基本属性和特殊属性）
   * 默认状态：返回所有规则预设的属性合并（超级大杂烩）
   * 选中特定规则时：返回该规则的基本属性 + 特殊属性
   */
  const getRandomSkillPool = () => {
    try {
      const preset = AttributePresetManager.getActivePreset();
      if (preset) {
        // 选中特定规则：返回该规则的基本属性 + 特殊属性
        const allAttrs = new Set();

        // 添加基本属性
        if (preset.baseAttributes && Array.isArray(preset.baseAttributes)) {
          preset.baseAttributes.forEach(attr => {
            const attrName = typeof attr === 'string' ? attr : attr && attr.name;
            if (attrName) {
              allAttrs.add(attrName);
            }
          });
        }

        // 添加特殊属性
        if (preset.specialAttributes && Array.isArray(preset.specialAttributes)) {
          preset.specialAttributes.forEach(attr => {
            const attrName = typeof attr === 'string' ? attr : attr && attr.name;
            if (attrName) {
              allAttrs.add(attrName);
            }
          });
        }

        return Array.from(allAttrs);
      }

      // 默认状态（没有激活预设）：返回所有规则预设的属性合并（超级大杂烩）
      const allPresets = AttributePresetManager.getAllPresets() || [];
      const allAttrs = new Set(RANDOM_SKILL_POOL || []); // 先添加默认池

      // 合并所有预设的基本属性和特殊属性
      if (Array.isArray(allPresets)) {
        allPresets.forEach(p => {
          if (!p) return;

          // 添加基本属性
          if (p.baseAttributes && Array.isArray(p.baseAttributes)) {
            p.baseAttributes.forEach(attr => {
              const attrName = typeof attr === 'string' ? attr : attr && attr.name;
              if (attrName) {
                allAttrs.add(attrName);
              }
            });
          }

          // 添加特殊属性
          if (p.specialAttributes && Array.isArray(p.specialAttributes)) {
            p.specialAttributes.forEach(attr => {
              const attrName = typeof attr === 'string' ? attr : attr && attr.name;
              if (attrName) {
                allAttrs.add(attrName);
              }
            });
          }
        });
      }

      return Array.from(allAttrs);
    } catch (err) {
      console.error('[DICE]ACU getRandomSkillPool 错误:', err);
      return RANDOM_SKILL_POOL || [];
    }
  };

  // [新增] 随机技能池（用于属性名随机生成，可自由增减）
  const RANDOM_SKILL_POOL = [
    // --- 身体与移动类 (Physical & Movement) ---
    '杂技',
    '特技',
    '运动',
    '格斗',
    '斗殴',
    '攀爬',
    '健康',
    '闪避',
    '身法',
    '驾驶',
    '耐力',
    '灵巧',
    '巧手',
    '戏法',
    '跑酷',
    '飞行',
    '潜行',
    '渗透',
    '骑术',
    '游泳',
    '投掷',
    '跳跃',
    '体操',
    '功夫',
    '武术',

    // --- 社交与心理类 (Social & Psychological) ---
    '行政',
    '官僚',
    '权威',
    '命令',
    '交易',
    '掮客',
    '欺诈',
    '诱骗',
    '谎言侦测',
    '狂欢',
    '交际',
    '摆布',
    '镇定',
    '黑话',
    '行话',
    '礼节',
    '礼仪',
    '信誉',
    '财力',
    '戏剧',
    '表演',
    '共情',
    '洞察',
    '情感',
    '团队精神',
    '话术',
    '博弈',
    '赌博',
    '阅人',
    '小透明',
    '审讯',
    '恐吓',
    '挑衅',
    '领导',
    '谈判',
    '演说',
    '精神分析',
    '街头智慧',
    '边缘知识',
    '残酷真相',
    '意志',
    '决心',
    '说服',
    '魅惑',
    '威吓',
    '游说',
    '交涉',
    '察言观色',
    '欺骗',
    '洞悉',
    '欺瞒',
    // 网络/现代用语
    '标新立异',
    '脑内剧场',
    '神游太虚',
    '踩地雷',
    '顾左右而言他',
    '主角光环',
    '厚颜无耻',
    '甩锅',
    '造假',
    '废话文学',
    '上头',
    '破防',
    '种草',
    '社死',
    '点子',
    '惊世智慧',
    '奶龙之力',
    '狗屎运',
    '天意',
    '桃花运',

    // --- 技术与技艺类 (Technical & Crafting) ---
    '建筑学',
    '军械',
    '枪械制造',
    '工匠',
    '技艺',
    '生物科技',
    '露营',
    '化学',
    '药理',
    '创作',
    '电脑',
    '黑客',
    '赛博技术',
    '爆破',
    '电子学',
    '工程学',
    '急救',
    '伪造',
    '信息安全',
    '修补',
    '捣鼓',
    '开锁',
    '机械',
    '修理',
    '医学',
    '摄影',
    '编程',
    '锻造',
    '编译',
    '科技使用',
    '机械维修',
    '电气维修',
    '锁匠',
    '操作重型机械',
    '药学',
    '艺术',

    // --- 知识与调查类 (Knowledge & Investigation) ---
    '会计',
    '人类学',
    '智慧生物学',
    '考古学',
    '灵视',
    '导航',
    '方向',
    '天文学',
    '生物学',
    '犯罪学',
    '神话',
    '禁忌知识',
    '文化',
    '习俗',
    '法医',
    '搜证',
    '历史',
    '人力情报',
    '调查',
    '搜索',
    '语言',
    '语言学',
    '法律',
    '图书馆使用',
    '研究',
    '学识',
    '侦察',
    '神秘学',
    '物理',
    '有备无患',
    '信号情报',
    '生存',
    '战术',
    '神学',
    '通识',
    '侦查',
    '聆听',
    '心理学',
    '追踪',
    '博物学',
    '克苏鲁神话',
    '地质学',
    '气象学',
    '奥秘',
    '自然',
    '宗教',
    '察觉',
    '求生',
    '情报收集',
    '估价',
    '密语',
    '读唇',
    '手语',

    // --- 战斗与特殊类 (Combat & Special) ---
    '弓术',
    '炮术',
    '引导',
    '召唤',
    '信仰',
    '奇迹',
    '击剑',
    '枪械',
    '射击',
    '重武器',
    '先攻',
    '神射',
    '狙击',
    '武艺',
    '近战',
    '兵器',
    '预兆',
    '运气',
    '格挡',
    '灵能',
    '巫术',
    '施法',
    '茶道',
    '破坏',
    '剑术',
    '斧术',
    '鞭术',
    '躲藏',
    '乔装',
    '隐匿',
    '驯兽',
    '医疗',
    '催眠',
    '伪装',
    '时髦值',
  ];

  // [新增] 生成 COC/DND 风格的6维属性（支持预设）
  /**
   * 生成角色属性
   * @param isDNDOrPreset 布尔值(旧版兼容) 或 预设对象 或 null(自动获取激活预设)
   * @returns { base: {...}, special: {...} } 或旧格式 {...}（向后兼容）
   */
  const generateRPGAttributes = (isDNDOrPreset = undefined) => {
    // 兼容旧版：如果传入布尔值，使用传统逻辑
    if (typeof isDNDOrPreset === 'boolean') {
      const isDND = isDNDOrPreset;
      const rollDice = sides => Math.floor(Math.random() * sides) + 1;
      const generate3d6 = () => rollDice(6) + rollDice(6) + rollDice(6);

      const generateValue = () => {
        if (isDND) {
          const base = generate3d6();
          const adjust = rollDice(4) - 2;
          return Math.max(3, Math.min(18, base + adjust));
        } else {
          const base = generate3d6() * 5;
          const adjust = rollDice(10) - 5;
          return Math.max(5, Math.min(95, base + adjust));
        }
      };

      const result = {};
      STANDARD_ATTRS.forEach(attr => {
        result[attr] = generateValue();
      });
      return result; // 旧格式
    }

    // 新版：使用预设系统
    const preset = isDNDOrPreset || AttributePresetManager.getActivePreset();

    // 如果没有激活预设，使用默认逻辑（百分制六维）
    if (!preset) {
      const rollDice = sides => Math.floor(Math.random() * sides) + 1;
      const generate3d6 = () => rollDice(6) + rollDice(6) + rollDice(6);
      const result = {};
      STANDARD_ATTRS.forEach(attr => {
        const base = generate3d6() * 5;
        const adjust = rollDice(10) - 5;
        result[attr] = Math.max(5, Math.min(95, base + adjust));
      });
      return { base: result, special: {} };
    }

    // 第一阶段：生成基本属性
    const baseResult = {};
    preset.baseAttributes.forEach(attr => {
      const formula = attr.modifier ? `${attr.formula}+${attr.modifier}` : attr.formula;
      baseResult[attr.name] = generateAttributeValue(formula, attr.range, {});
    });

    // 第二阶段：生成特别属性（可引用基本属性）
    const specialResult = {};
    if (preset.specialAttributes && Array.isArray(preset.specialAttributes)) {
      preset.specialAttributes.forEach(attr => {
        specialResult[attr.name] = generateAttributeValue(attr.formula, attr.range, baseResult);
      });
    }

    return { base: baseResult, special: specialResult };
  };

  // [简化] 清空角色的属性（直接清空基础属性列和特有属性列）
  const clearPresetAttributesForCharacter = async charName => {
    const rawData = cachedRawData || getTableData();
    if (!rawData) {
      console.error('[DICE]ACU clearPresetAttributesForCharacter: 无法获取表格数据');
      if (window.toastr) window.toastr.error('无法获取表格数据');
      return { success: false };
    }

    const isUser = !charName || charName === '<user>' || charName.trim() === '';
    let targetSheet = null;
    let targetRowIndex = -1;
    let baseColIndex = -1; // 基础属性列
    let specialColIndex = -1; // 特有属性列
    let sheetKey = null;

    // 查找目标表和行
    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;
      const headers = sheet.content[0] || [];

      // 主角信息表
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与charName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(charName)) continue;
          }
          targetSheet = sheet;
          targetRowIndex = 1;
          sheetKey = key;

          // 查找基础属性列和特有属性列
          for (let h = 0; h < headers.length; h++) {
            if (headers[h] && headers[h].includes('基础属性')) {
              baseColIndex = h;
            } else if (headers[h] && headers[h].includes('特有属性')) {
              specialColIndex = h;
            }
          }
          // 如果没有找到基础属性列，尝试查找通用属性列
          if (baseColIndex < 0) {
            for (let h = 0; h < headers.length; h++) {
              if (headers[h] && headers[h].includes('属性') && !headers[h].includes('特有')) {
                baseColIndex = h;
                break;
              }
            }
          }
          break;
        }
      }

      // NPC/角色/人物表
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (headers[h].includes('姓名') || headers[h].includes('名称') || headers[h].toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        // 查找目标行
        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(charName)) {
            targetSheet = sheet;
            targetRowIndex = i;
            sheetKey = key;

            // 查找基础属性列和特有属性列
            for (let h = 0; h < headers.length; h++) {
              if (headers[h] && headers[h].includes('基础属性')) {
                baseColIndex = h;
              } else if (headers[h] && headers[h].includes('特有属性')) {
                specialColIndex = h;
              }
            }
            // 如果没有找到基础属性列，尝试查找通用属性列
            if (baseColIndex < 0) {
              for (let h = 0; h < headers.length; h++) {
                if (headers[h] && headers[h].includes('属性') && !headers[h].includes('特有')) {
                  baseColIndex = h;
                  break;
                }
              }
            }
            break;
          }
        }
        if (targetRowIndex > 0) break;
      }
    }

    // 验证是否找到目标
    if (!targetSheet || targetRowIndex < 0) {
      console.error('[DICE]ACU clearPresetAttributesForCharacter: 找不到角色', charName);
      if (window.toastr) window.toastr.error(`找不到角色「${charName || '<user>'}」`);
      return { success: false };
    }

    if (baseColIndex < 0) {
      console.error('[DICE]ACU clearPresetAttributesForCharacter: 找不到属性列');
      if (window.toastr) window.toastr.error('找不到属性列');
      return { success: false };
    }

    // 直接清空基础属性列
    targetSheet.content[targetRowIndex][baseColIndex] = '';

    // 如果存在特有属性列，也清空
    if (specialColIndex >= 0) {
      targetSheet.content[targetRowIndex][specialColIndex] = '';
    }

    cachedRawData = rawData;

    // 保存
    await saveDataOnly(rawData, [sheetKey]);

    return {
      success: true,
    };
  };

  // [新增] 将属性写入角色表格
  // [修复] 支持分别写入基础属性列和特有属性列
  const writeAttributesToCharacter = async (
    charName,
    newAttrs,
    isDND = false,
    specialAttrs: Record<string, number> | null = null,
  ) => {
    const rawData = cachedRawData || getTableData();
    if (!rawData) {
      console.error('[DICE]ACU writeAttributesToCharacter: 无法获取表格数据');
      if (window.toastr) window.toastr.error('无法获取表格数据');
      return { success: false };
    }

    const isUser = !charName || charName === '<user>' || charName.trim() === '';
    let targetSheet = null;
    let targetRowIndex = -1;
    let baseColIndex = -1; // 基础属性列
    let specialColIndex = -1; // 特有属性列
    let sheetKey = null;

    // 查找目标表和行
    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;
      const headers = sheet.content[0] || [];

      // 主角信息表
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与charName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(charName)) continue;
          }
          targetSheet = sheet;
          targetRowIndex = 1;
          sheetKey = key;

          // 查找基础属性列和特有属性列
          for (let h = 0; h < headers.length; h++) {
            if (headers[h] && headers[h].includes('基础属性')) {
              baseColIndex = h;
            } else if (headers[h] && headers[h].includes('特有属性')) {
              specialColIndex = h;
            }
          }
          // 如果没有找到基础属性列，尝试查找通用属性列
          if (baseColIndex < 0) {
            for (let h = 0; h < headers.length; h++) {
              if (headers[h] && headers[h].includes('属性') && !headers[h].includes('特有')) {
                baseColIndex = h;
                break;
              }
            }
          }
          break;
        }
      }

      // 重要人物表
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        // 查找姓名列
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (headers[h].includes('姓名') || headers[h].includes('名称') || headers[h].toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        // 查找目标行
        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(charName)) {
            targetSheet = sheet;
            targetRowIndex = i;
            sheetKey = key;

            // 查找基础属性列和特有属性列
            for (let h = 0; h < headers.length; h++) {
              if (headers[h] && headers[h].includes('基础属性')) {
                baseColIndex = h;
              } else if (headers[h] && headers[h].includes('特有属性')) {
                specialColIndex = h;
              }
            }
            // 如果没有找到基础属性列，尝试查找通用属性列
            if (baseColIndex < 0) {
              for (let h = 0; h < headers.length; h++) {
                if (headers[h] && headers[h].includes('属性') && !headers[h].includes('特有')) {
                  baseColIndex = h;
                  break;
                }
              }
            }
            break;
          }
        }
        if (targetRowIndex > 0) break;
      }
    }

    // 验证是否找到目标
    if (!targetSheet || targetRowIndex < 0) {
      console.error('[DICE]ACU writeAttributesToCharacter: 找不到角色', charName);
      if (window.toastr) window.toastr.error(`找不到角色「${charName || '<user>'}」`);
      return { success: false };
    }

    if (baseColIndex < 0) {
      console.error('[DICE]ACU writeAttributesToCharacter: 找不到属性列');
      if (window.toastr) window.toastr.error('找不到属性列（需要包含"属性"关键词的列）');
      return { success: false };
    }

    // 获取当前规则的属性列表
    const standardAttrs = getStandardAttrs();
    const preset = AttributePresetManager.getActivePreset();
    const presetSpecialAttrNames = new Set<string>();
    if (preset && preset.specialAttributes) {
      preset.specialAttributes.forEach(attr => presetSpecialAttrNames.add(attr.name));
    }

    // ========== 处理基础属性列 ==========
    const existingBaseStr = targetSheet.content[targetRowIndex][baseColIndex] || '';
    const existingBaseAttrs = parseAttributeString(existingBaseStr);

    // 构建现有基础属性的映射
    const existingBaseMap = {};
    existingBaseAttrs.forEach(attr => {
      existingBaseMap[attr.name] = attr.value;
    });

    // 检查标准属性（基本属性）是否完整
    let standardCount = 0;
    standardAttrs.forEach(attrName => {
      if (existingBaseMap[attrName] !== undefined) {
        standardCount++;
      }
    });
    const isComplete = standardCount === standardAttrs.length;

    // 收集基础属性列中的用户自定义属性（不属于当前规则预设的属性）
    const customBaseAttrs: Array<{ name: string; value: number }> = [];
    existingBaseAttrs.forEach(attr => {
      if (!standardAttrs.includes(attr.name) && !presetSpecialAttrNames.has(attr.name)) {
        customBaseAttrs.push({ name: attr.name, value: attr.value });
      }
    });

    // 按标准顺序构建基础属性结果
    const baseResultParts: string[] = [];

    // 写入基本属性
    standardAttrs.forEach(attrName => {
      if (isComplete) {
        // 完整 → 全部用新值覆盖
        const newValue = newAttrs[attrName] !== undefined ? newAttrs[attrName] : existingBaseMap[attrName];
        if (newValue !== undefined) {
          baseResultParts.push(`${attrName}:${newValue}`);
        }
      } else {
        // 不完整 → 有则保留，无则用新值
        if (existingBaseMap[attrName] !== undefined) {
          baseResultParts.push(`${attrName}:${existingBaseMap[attrName]}`);
        } else if (newAttrs[attrName] !== undefined) {
          baseResultParts.push(`${attrName}:${newAttrs[attrName]}`);
        }
      }
    });

    // 如果没有独立的特有属性列，则把特有属性也写入基础属性列（兼容旧格式）
    if (specialColIndex < 0 && specialAttrs) {
      Object.keys(specialAttrs).forEach(attrName => {
        if (isComplete || !existingBaseMap[attrName]) {
          baseResultParts.push(`${attrName}:${specialAttrs[attrName]}`);
        } else {
          baseResultParts.push(`${attrName}:${existingBaseMap[attrName]}`);
        }
      });
    }

    // 追加用户自定义属性
    customBaseAttrs.forEach(attr => {
      baseResultParts.push(`${attr.name}:${attr.value}`);
    });

    const newBaseAttrString = baseResultParts.join(';');

    // 写入基础属性数据
    targetSheet.content[targetRowIndex][baseColIndex] = newBaseAttrString;

    // ========== 处理特有属性列（如果存在且有特有属性需要写入） ==========
    let newSpecialAttrString = '';
    if (specialColIndex >= 0 && specialAttrs && Object.keys(specialAttrs).length > 0) {
      const existingSpecialStr = targetSheet.content[targetRowIndex][specialColIndex] || '';
      const existingSpecialAttrs = parseAttributeString(existingSpecialStr);

      // 构建现有特有属性的映射
      const existingSpecialMap = {};
      existingSpecialAttrs.forEach(attr => {
        existingSpecialMap[attr.name] = attr.value;
      });

      // 收集特有属性列中的用户自定义属性
      const customSpecialAttrs: Array<{ name: string; value: number }> = [];
      existingSpecialAttrs.forEach(attr => {
        if (!presetSpecialAttrNames.has(attr.name)) {
          customSpecialAttrs.push({ name: attr.name, value: attr.value });
        }
      });

      // 构建特有属性结果
      const specialResultParts: string[] = [];

      // 按预设顺序写入特有属性
      if (preset && preset.specialAttributes) {
        preset.specialAttributes.forEach(attrDef => {
          const attrName = attrDef.name;
          if (specialAttrs[attrName] !== undefined) {
            if (isComplete || !existingSpecialMap[attrName]) {
              specialResultParts.push(`${attrName}:${specialAttrs[attrName]}`);
            } else {
              specialResultParts.push(`${attrName}:${existingSpecialMap[attrName]}`);
            }
          } else if (existingSpecialMap[attrName] !== undefined) {
            specialResultParts.push(`${attrName}:${existingSpecialMap[attrName]}`);
          }
        });
      }

      // 追加用户自定义属性
      customSpecialAttrs.forEach(attr => {
        specialResultParts.push(`${attr.name}:${attr.value}`);
      });

      newSpecialAttrString = specialResultParts.join(';');

      // 写入特有属性数据
      targetSheet.content[targetRowIndex][specialColIndex] = newSpecialAttrString;
    }

    cachedRawData = rawData;

    // 保存（不更新快照，保留审核面板状态）
    await saveDataOnly(rawData, [sheetKey]);

    // 返回写入的属性供UI更新
    const writtenAttrs: Array<{ name: string; value: number }> = [];
    standardAttrs.forEach(attrName => {
      writtenAttrs.push({ name: attrName, value: newAttrs[attrName] });
    });

    return {
      success: true,
      attrs: writtenAttrs,
      attrString: newBaseAttrString,
      specialAttrString: newSpecialAttrString,
      wasComplete: isComplete,
    };
  };

  // [新增] 更新属性字符串中的单个属性值（用于燃运等功能）
  const updateSingleAttribute = async (
    charName: string,
    attrName: string,
    operation: 'add' | 'subtract' | 'set',
    value: number,
    options?: {
      initValue?: number;
      min?: number;
      max?: number;
      aliasCandidates?: string[];
      skipSave?: boolean;
      dataOverride?: Record<string, { name: string; content: (string | number | null)[][] }>;
    },
  ): Promise<{
    success: boolean;
    oldValue: number;
    newValue: number;
    error?: string;
    resolvedAttrName?: string;
    modifiedSheetKey?: string;
  }> => {
    const rawData = options?.dataOverride || cachedRawData || getTableData();
    if (!rawData) {
      const error = '无法获取表格数据';
      console.error(`[DICE] updateSingleAttribute: ${error}`);
      return { success: false, oldValue: 0, newValue: 0, error };
    }

    const isUser = !charName || charName === '<user>' || charName.trim() === '';
    let targetSheet: { name: string; content: (string | number | null)[][] } | null = null;
    let targetRowIndex = -1;
    let targetColIndex = -1;
    let fallbackAttrColIndex = -1;
    let attrColIndices: number[] = [];
    let sheetKey: string | null = null;

    // 查找目标表和行
    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;
      const headers = sheet.content[0] || [];
      const collectAttrCols = (): number[] => {
        const cols: number[] = [];
        for (let h = 0; h < headers.length; h++) {
          if (headers[h] && String(headers[h]).includes('属性')) {
            cols.push(h);
          }
        }
        return cols;
      };
      const pickFallbackAttrCol = (cols: number[]): number => {
        if (cols.length === 0) return -1;
        for (const col of cols) {
          if (String(headers[col]).includes('基础属性')) return col;
        }
        for (const col of cols) {
          if (String(headers[col]).includes('特有属性')) return col;
        }
        return cols[0];
      };

      // 主角信息表
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与charName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(charName)) continue;
          }
          targetSheet = sheet;
          targetRowIndex = 1;
          sheetKey = key;
          attrColIndices = collectAttrCols();
          fallbackAttrColIndex = pickFallbackAttrCol(attrColIndices);
          targetColIndex = fallbackAttrColIndex;
          break;
        }
      }

      // 重要人物表
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        // 查找姓名列
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (String(headers[h]).includes('姓名') ||
              String(headers[h]).includes('名称') ||
              String(headers[h]).toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        // 查找目标行
        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(charName)) {
            targetSheet = sheet;
            targetRowIndex = i;
            sheetKey = key;
            attrColIndices = collectAttrCols();
            fallbackAttrColIndex = pickFallbackAttrCol(attrColIndices);
            targetColIndex = fallbackAttrColIndex;
            break;
          }
        }
        if (targetRowIndex > 0) break;
      }
    }

    // 验证是否找到目标
    if (!targetSheet || targetRowIndex < 0) {
      const error = `找不到角色: ${charName || '<user>'}`;
      console.error(`[DICE] updateSingleAttribute: ${error}`);
      return { success: false, oldValue: 0, newValue: 0, error };
    }

    if (targetColIndex < 0) {
      const error = '找不到属性列（需要包含"属性"关键词的列）';
      console.error(`[DICE] updateSingleAttribute: ${error}`);
      return { success: false, oldValue: 0, newValue: 0, error };
    }

    const resolved = resolveAttributeAliasName(charName, attrName, options?.aliasCandidates || []);
    if (!resolved.name) {
      const error = resolved.reason || `属性 ${attrName} 不存在`;
      console.warn(`[DICE] updateSingleAttribute: ${error}`);
      return { success: false, oldValue: 0, newValue: 0, error };
    }
    const targetAttrName = resolved.name;

    // 在所有属性列中，优先选择实际包含目标属性的列
    for (const colIdx of attrColIndices) {
      const cellStr = String(targetSheet.content[targetRowIndex][colIdx] || '');
      const parsed = parseAttributeString(cellStr);
      if (parsed.some(attr => attr.name === targetAttrName)) {
        targetColIndex = colIdx;
        break;
      }
    }
    if (targetColIndex < 0) {
      targetColIndex = fallbackAttrColIndex;
    }

    // 读取目标列现有属性并解析
    const existingStr = String(targetSheet.content[targetRowIndex][targetColIndex] || '');
    const existingAttrs = parseAttributeString(existingStr);
    const existingMap: Record<string, number> = {};
    existingAttrs.forEach(attr => {
      existingMap[attr.name] = attr.value;
    });

    // 获取旧值或使用初始值
    let oldValue: number;
    if (existingMap[targetAttrName] !== undefined) {
      oldValue = existingMap[targetAttrName];
    } else if (options?.initValue !== undefined) {
      oldValue = options.initValue;
      console.info(`[DICE] updateSingleAttribute: 属性 ${targetAttrName} 不存在，初始化为 ${oldValue}`);
    } else {
      const error = `属性 ${targetAttrName} 不存在且未提供初始值`;
      console.warn(`[DICE] updateSingleAttribute: ${error}`);
      return { success: false, oldValue: 0, newValue: 0, error };
    }

    // 执行操作
    let newValue: number;
    switch (operation) {
      case 'add':
        newValue = oldValue + value;
        break;
      case 'subtract':
        newValue = oldValue - value;
        break;
      case 'set':
        newValue = value;
        break;
      default:
        const error = `不支持的操作类型: ${operation}`;
        console.error(`[DICE] updateSingleAttribute: ${error}`);
        return { success: false, oldValue, newValue: oldValue, error };
    }

    // 应用 min/max 约束
    const min = options?.min ?? 0; // 默认最小为0
    const max = options?.max ?? Infinity;
    newValue = Math.max(min, Math.min(max, newValue));

    console.info(
      `[DICE] updateSingleAttribute: ${charName}.${targetAttrName} ${oldValue} → ${newValue} (${operation} ${value})`,
    );

    // 更新属性映射
    existingMap[targetAttrName] = newValue;

    // 重建属性字符串（保持原有顺序，新属性追加到末尾）
    const resultParts: string[] = [];
    const processedNames = new Set<string>();

    // 先按原有顺序处理
    existingAttrs.forEach(attr => {
      const val = existingMap[attr.name];
      if (val !== undefined) {
        resultParts.push(`${attr.name}:${val}`);
        processedNames.add(attr.name);
      }
    });

    // 添加新属性（如果是初始化的情况）
    if (!processedNames.has(targetAttrName)) {
      resultParts.push(`${targetAttrName}:${newValue}`);
    }

    const newAttrString = resultParts.join(';');

    // 写入数据
    targetSheet.content[targetRowIndex][targetColIndex] = newAttrString;
    if (!options?.skipSave) {
      cachedRawData = rawData;
      await saveDataOnly(rawData, [sheetKey!]);
    }

    console.info(`[DICE] updateSingleAttribute: 成功修改 ${charName}.${targetAttrName}`);
    return { success: true, oldValue, newValue, resolvedAttrName: targetAttrName, modifiedSheetKey: sheetKey! };
  };

  // [修复] 获取角色的完整属性列表（包括基础属性和特有属性等所有包含"属性"的列）
  const getFullAttributesForCharacter = (
    characterName,
    dataOverride?: Record<string, { name: string; content: (string | number | null)[][] }>,
  ) => {
    const rawData = dataOverride || cachedRawData || getTableData();
    if (!rawData) return [];

    const isUser = !characterName || characterName === '<user>' || characterName.trim() === '';
    let attrs = [];

    for (const key in rawData) {
      const sheet = rawData[key];
      if (!sheet || !sheet.name || !sheet.content) continue;
      const sheetName = sheet.name;

      // 主角信息表 -> <user> 或通过真名匹配
      if (sheetName.includes('主角') || sheetName.includes('玩家') || sheetName.toLowerCase().includes('player')) {
        if (sheet.content[1]) {
          // 通过真名匹配：非<user>时检查主角表中的姓名是否与characterName一致
          if (!isUser) {
            const protagonistName = getDisplayName(String(sheet.content[1][1] || ''));
            if (protagonistName !== getDisplayName(characterName)) continue;
          }
          const headers = sheet.content[0] || [];
          const row = sheet.content[1];
          headers.forEach((h, idx) => {
            if (h && h.includes('属性')) {
              const parsed = parseAttributeString(row[idx] || '');
              parsed.forEach(attr => {
                if (!attrs.some(a => a.name === attr.name)) {
                  attrs.push(attr);
                }
              });
            }
          });
          if (attrs.length > 0) break;
        }
      }

      // 重要人物表 -> 其他角色 (模糊匹配)
      if (
        !isUser &&
        (sheetName.includes('人物') ||
          sheetName.includes('NPC') ||
          sheetName.includes('角色') ||
          sheetName.toLowerCase().includes('character'))
      ) {
        const headers = sheet.content[0] || [];
        // 动态查找姓名列
        let nameColIdx = 1;
        for (let h = 0; h < headers.length; h++) {
          if (
            headers[h] &&
            (headers[h].includes('姓名') || headers[h].includes('名称') || headers[h].toLowerCase().includes('name'))
          ) {
            nameColIdx = h;
            break;
          }
        }

        for (let i = 1; i < sheet.content.length; i++) {
          const row = sheet.content[i];
          if (row && getDisplayName(String(row[nameColIdx] || '')) === getDisplayName(characterName)) {
            headers.forEach((h, idx) => {
              if (h && h.includes('属性')) {
                const parsed = parseAttributeString(row[idx] || '');
                parsed.forEach(attr => {
                  if (!attrs.some(a => a.name === attr.name)) {
                    attrs.push(attr);
                  }
                });
              }
            });
            break;
          }
        }
        if (attrs.length > 0) break;
      }
    }

    return attrs;
  };
  // [新增] 自定义下拉菜单初始化函数
  const initCustomDropdown = ($input, options) => {
    const { $ } = getCore();
    const inputId = $input.attr('id') || 'dd_' + Math.random().toString(36).substr(2, 9);
    $input.attr('id', inputId);

    // 移除已存在的下拉
    $input.parent().find('.acu-dropdown-list').remove();

    // 包裹成 wrapper
    if (!$input.parent().hasClass('acu-dropdown-wrapper')) {
      $input.wrap('<div class="acu-dropdown-wrapper"></div>');
    }

    // 创建下拉列表 - 样式通过 CSS 类控制
    const $dropdown = $(`<div class="acu-dropdown-list" data-for="${inputId}"></div>`);
    $input.after($dropdown);

    const renderItems = (filter = '') => {
      const lowerFilter = filter.toLowerCase();
      const filtered = options.filter(opt => opt.toLowerCase().includes(lowerFilter));

      if (filtered.length === 0) {
        $dropdown.html(`<div class="acu-dropdown-empty">无匹配项</div>`);
      } else {
        $dropdown.html(
          filtered
            .map(opt => `<div class="acu-dropdown-item" data-value="${escapeHtml(opt)}">${escapeHtml(opt)}</div>`)
            .join(''),
        );
      }
    };

    const showDropdown = () => {
      $('.acu-dropdown-list').removeClass('visible');
      renderItems($input.val());
      $dropdown.addClass('visible');
    };

    const hideDropdown = () => {
      $dropdown.removeClass('visible');
    };

    // 点击输入框显示下拉
    $input.off('.acudd').on('focus.acudd click.acudd', function (e) {
      e.stopPropagation();
      showDropdown();
    });

    // 输入筛选
    $input.on('input.acudd', function () {
      renderItems($(this).val());
    });

    // hover 效果已通过 CSS :hover 处理，无需 JS

    // 选择项目
    $dropdown.on('click', '.acu-dropdown-item', function (e) {
      e.stopPropagation();
      e.preventDefault();
      const val = $(this).data('value');
      $input.val(val).trigger('change');
      hideDropdown();
    });

    // 点击下拉列表本身不关闭
    $dropdown.on('click', function (e) {
      e.stopPropagation();
    });

    // 点击面板其他区域关闭
    $input
      .closest('.acu-dice-panel, .acu-contest-panel')
      .off('click.acudd_' + inputId)
      .on('click.acudd_' + inputId, function (e) {
        if (!$(e.target).closest('.acu-dropdown-wrapper').length) {
          hideDropdown();
        }
      });
  };
  // [新增] 给输入框添加清除按钮
  const addClearButton = ($panel, inputSelector) => {
    const { $ } = getCore();
    $panel.find(inputSelector).each(function () {
      const $input = $(this);
      // 避免重复添加
      if ($input.parent().hasClass('acu-input-wrapper')) return;
      // 包装输入框
      $input.wrap('<div class="acu-input-wrapper"></div>');
      // 添加清除按钮 - 样式通过 CSS 类控制
      const $clearBtn = $(
        `<button type="button" class="acu-clear-btn" title="清除"><i class="fa-solid fa-times"></i></button>`,
      );
      $input.after($clearBtn);
      // 点击清除
      $clearBtn.on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        $input.val('').trigger('input').trigger('change').focus();
      });
      // hover 效果已通过 CSS :hover 处理，无需 JS
    });
  };
  // [新增] 统一的骰子规则设置面板
  /**
   * @deprecated 请使用 showAdvancedPresetManager() 替代。此函数仅保留函数体以供回退。
   */
  const showDiceSettingsPanel = (isDND = false) => {
    const { $ } = getCore();
    $('.acu-dice-config-overlay').remove();

    const config = getConfig();
    const diceCfg = getDiceConfig();

    const ruleTitle = isDND ? 'DND 规则设置' : 'COC 规则设置';
    const resetText = isDND ? '恢复 DND 默认' : '恢复 COC 默认';

    // 默认值定义
    const defaults = isDND
      ? { critSuccess: 20, critFail: 1 }
      : { critSuccess: 5, critFail: 96, hardDiv: 2, extremeDiv: 5 };

    // 当前值：只有用户明确设置过才显示，否则留空用 placeholder
    const currentCritSuccess = isDND
      ? diceCfg.dndCritSuccess !== undefined && diceCfg.dndCritSuccess !== defaults.critSuccess
        ? diceCfg.dndCritSuccess
        : ''
      : diceCfg.critSuccessMax !== undefined && diceCfg.critSuccessMax !== defaults.critSuccess
        ? diceCfg.critSuccessMax
        : '';
    const currentCritFail = isDND
      ? diceCfg.dndCritFail !== undefined && diceCfg.dndCritFail !== defaults.critFail
        ? diceCfg.dndCritFail
        : ''
      : diceCfg.critFailMin !== undefined && diceCfg.critFailMin !== defaults.critFail
        ? diceCfg.critFailMin
        : '';
    const currentHardDiv =
      !isDND && diceCfg.difficultSuccessDiv !== undefined && diceCfg.difficultSuccessDiv !== defaults.hardDiv
        ? diceCfg.difficultSuccessDiv
        : '';
    const currentExtremeDiv =
      !isDND && diceCfg.hardSuccessDiv !== undefined && diceCfg.hardSuccessDiv !== defaults.extremeDiv
        ? diceCfg.hardSuccessDiv
        : '';

    const tieRule = diceCfg.contestTieRule || 'initiator_lose';
    const hideDiceResultFromUser =
      diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
    const hideDiceResultInChat = diceCfg.hideDiceResultInChat !== undefined ? diceCfg.hideDiceResultInChat : false;

    const cocExtraHtml = isDND
      ? ''
      : `
            <div class="acu-dice-cfg-row">
                <div class="acu-dice-cfg-item">
                    <label>困难 (÷)</label>
                    <div class="acu-stepper" data-id="cfg-hard-div" data-min="2" data-max="5" data-step="1">
                        <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                        <span class="acu-stepper-value">${currentHardDiv || defaults.hardDiv}</span>
                        <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                    </div>
                </div>
                <div class="acu-dice-cfg-item">
                    <label>极难 (÷)</label>
                    <div class="acu-stepper" data-id="cfg-extreme-div" data-min="3" data-max="10" data-step="1">
                        <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                        <span class="acu-stepper-value">${currentExtremeDiv || defaults.extremeDiv}</span>
                        <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                    </div>
                </div>
            </div>
        `;

    const panelHtml = `
            <div class="acu-dice-config-overlay">
                <div class="acu-dice-config-dialog acu-theme-${config.theme}">
                    <div class="acu-dice-cfg-header">
                        <span><i class="fa-solid fa-cog"></i> ${ruleTitle}</span>
                        <button class="acu-config-close"><i class="fa-solid fa-times"></i></button>
                    </div>
                    <div class="acu-dice-cfg-body">
                        <div class="acu-dice-cfg-row">
                            <div class="acu-dice-cfg-item">
                                <label>大成功阈值</label>
                                <div class="acu-stepper" data-id="cfg-crit-success" data-min="1" data-max="100" data-step="1">
                                    <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                    <span class="acu-stepper-value">${currentCritSuccess || defaults.critSuccess}</span>
                                    <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="acu-dice-cfg-item">
                                <label>大失败阈值</label>
                                <div class="acu-stepper" data-id="cfg-crit-fail" data-min="1" data-max="100" data-step="1">
                                    <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                    <span class="acu-stepper-value">${currentCritFail || defaults.critFail}</span>
                                    <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                                </div>
                            </div>
                        </div>
                        ${cocExtraHtml}
                        <div class="acu-dice-cfg-row acu-cfg-full-row">
                            <div class="acu-dice-cfg-item">
                                <label>对抗平手规则</label>
                                <select id="cfg-tie-rule">
                                    <option value="initiator_lose" ${tieRule === 'initiator_lose' ? 'selected' : ''}>发起方判负 (默认)</option>
                                    <option value="tie" ${tieRule === 'tie' ? 'selected' : ''}>双方平手</option>
                                    <option value="initiator_win" ${tieRule === 'initiator_win' ? 'selected' : ''}>发起方判胜</option>
                                </select>
                            </div>
                        </div>
                        <div class="acu-dice-cfg-row acu-cfg-full-row">
                            <div class="acu-dice-cfg-item acu-cfg-toggle-item">
                                <label>隐藏输入栏中的检定结果</label>
                                <label class="acu-toggle">
                                    <input type="checkbox" id="cfg-hide-dice-result" ${hideDiceResultFromUser ? 'checked' : ''}>
                                    <span class="acu-toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="acu-dice-cfg-row acu-cfg-full-row">
                            <div class="acu-dice-cfg-item acu-cfg-toggle-item">
                                <label>隐藏聊天记录中的检定结果</label>
                                <label class="acu-toggle">
                                    <input type="checkbox" id="cfg-hide-dice-result-chat" ${hideDiceResultInChat ? 'checked' : ''}>
                                    <span class="acu-toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="acu-dice-cfg-actions">
                            <button id="cfg-reset-dice">${resetText}</button>
                            <button id="cfg-save-dice">保存</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

    const $panel = $(panelHtml);
    $('body').append($panel);

    $panel.css({
      position: 'fixed',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      width: '100vw',
      height: '100vh',
      background: 'rgba(0,0,0,0.6)',
      'z-index': '31300',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center',
      padding: '20px',
      'box-sizing': 'border-box',
    });

    const closePanel = () => $panel.remove();
    $panel.find('.acu-config-close').click(closePanel);
    setupOverlayClose($panel, 'acu-dice-config-overlay', closePanel);

    // === Stepper 步进器事件 ===
    $panel.find('.acu-stepper').each(function () {
      const $stepper = $(this);
      const id = $stepper.data('id');
      const min = parseInt($stepper.data('min'));
      const max = parseInt($stepper.data('max'));
      const step = parseInt($stepper.data('step'));
      const $value = $stepper.find('.acu-stepper-value');

      const updateValue = newVal => {
        newVal = Math.max(min, Math.min(max, newVal));
        $value.text(newVal);
      };

      const getCurrentValue = () => {
        const text = $value.text().replace(/[^\d]/g, '');
        return parseInt(text) || min;
      };

      $stepper.find('.acu-stepper-dec').on('click', function () {
        updateValue(getCurrentValue() - step);
      });

      $stepper.find('.acu-stepper-inc').on('click', function () {
        updateValue(getCurrentValue() + step);
      });
    });

    $panel.find('#cfg-save-dice').click(function () {
      const newCfg = { contestTieRule: $('#cfg-tie-rule').val() };

      // 从stepper读取值
      const getStepperValue = id => {
        const $stepper = $panel.find(`.acu-stepper[data-id="${id}"]`);
        if ($stepper.length) {
          const text = $stepper.find('.acu-stepper-value').text().replace(/[^\d]/g, '');
          return text !== '' ? parseInt(text, 10) : null;
        }
        return null;
      };

      const critSuccessVal = getStepperValue('cfg-crit-success');
      const critFailVal = getStepperValue('cfg-crit-fail');

      if (isDND) {
        newCfg.dndCritSuccess = critSuccessVal !== null ? critSuccessVal : defaults.critSuccess;
        newCfg.dndCritFail = critFailVal !== null ? critFailVal : defaults.critFail;
      } else {
        newCfg.critSuccessMax = critSuccessVal !== null ? critSuccessVal : defaults.critSuccess;
        newCfg.critFailMin = critFailVal !== null ? critFailVal : defaults.critFail;

        const hardDivVal = getStepperValue('cfg-hard-div');
        const extremeDivVal = getStepperValue('cfg-extreme-div');
        newCfg.difficultSuccessDiv = hardDivVal !== null ? hardDivVal : defaults.hardDiv;
        newCfg.hardSuccessDiv = extremeDivVal !== null ? extremeDivVal : defaults.extremeDiv;
      }

      // 保存"隐藏输入栏中的检定结果"设置
      newCfg.hideDiceResultFromUser = $('#cfg-hide-dice-result').is(':checked');
      // 保存"隐藏聊天记录中的检定结果"设置
      newCfg.hideDiceResultInChat = $('#cfg-hide-dice-result-chat').is(':checked');

      saveDiceConfig(newCfg);
      // 保存后立即应用隐藏逻辑
      console.info('[DICE]应用投骰结果隐藏/显示设置...');
      hideDiceResultsInUserMessages();
      closePanel();
    });

    $panel.find('#cfg-reset-dice').click(function () {
      // 重置stepper到默认值
      const resetStepper = (id, defaultValue) => {
        const $stepper = $panel.find(`.acu-stepper[data-id="${id}"]`);
        if ($stepper.length) {
          $stepper.find('.acu-stepper-value').text(defaultValue);
        }
      };

      resetStepper('cfg-crit-success', defaults.critSuccess);
      resetStepper('cfg-crit-fail', defaults.critFail);
      if (!isDND) {
        resetStepper('cfg-hard-div', defaults.hardDiv);
        resetStepper('cfg-extreme-div', defaults.extremeDiv);
      }
    });
  };
  // [新增] 显示掷骰面板
  const showDicePanel = (options = {}) => {
    const { $ } = getCore();
    $('.acu-dice-panel, .acu-dice-overlay').remove();

    const config = getConfig();
    const diceCfg = getDiceConfig();
    // 读取上次保存的骰子类型，必须是有效公式，否则默认1d100
    let savedDiceType = diceCfg.lastDiceType || '1d100';
    // 验证是否是有效公式，无效则回退到1d100
    if (Number.isNaN(rollComplexDiceExpression(savedDiceType).total)) {
      savedDiceType = '1d100';
    }
    // [新增] 构建角色和属性下拉列表
    const rawDataForList = cachedRawData || getTableData();
    let diceCharacterList: string[] = [];
    let diceAttrList = [];

    if (rawDataForList) {
      for (const key in rawDataForList) {
        const sheet = rawDataForList[key];
        if (!sheet || !sheet.name || !sheet.content) continue;

        if (isNpcTableName(sheet.name)) {
          for (let i = 1; i < sheet.content.length; i++) {
            const row = sheet.content[i];
            if (row && row[1]) diceCharacterList.push(row[1]);
          }
        }

        if (sheet.name?.includes('主角') && sheet.content[1]) {
          const row = sheet.content[1];
          // 主角真名加入角色列表（作为第一个）
          if (row[1]) diceCharacterList.unshift(getDisplayName(String(row[1])));
          const headers = sheet.content[0] || [];
          headers.forEach((h, idx) => {
            if (h && h.includes('属性')) {
              const parsed = parseAttributeString(row[idx] || '');
              parsed.forEach(attr => {
                if (!diceAttrList.includes(attr.name)) diceAttrList.push(attr.name);
              });
            }
          });
        }
      }
    }
    const {
      targetValue = null, // [修复] 默认为 null，支持留空自动计算
      targetName = '', // 留空让 placeholder 显示，执行时若仍为空则使用 '自由检定'
      attrValue = null, // [新增] 属性值参数
      diceType = savedDiceType, // 使用上次保存的骰子类型
      successCriteria = 'lte', // [新增] 默认成功标准：小于等于（COC规则）
      onResult = null,
      initiatorName = '', // [修复] 接收发起者名字
      fromMvu = false, // [新增] 是否从MVU面板调用
      mvuPath = null, // [新增] MVU变量路径
      mvuParsedInfo = null, // [新增] 解析后的路径信息
    } = options;

    // [新增] 计算初始属性值和目标值/DC
    const isDND = diceType === '1d20' || successCriteria === 'gte';
    let initialAttrValue = attrValue;
    let initialTargetValue = targetValue;

    // 如果传入了attrValue但没有targetValue，根据模式自动计算
    if (attrValue !== null && targetValue === null) {
      if (isDND) {
        initialTargetValue = Math.max(0, 20 - attrValue);
      } else {
        initialTargetValue = attrValue;
      }
    }

    const overlay = $(`<div class="acu-dice-overlay"></div>`);

    // [精简] 成功标准选项：只保留 COC 和 DND
    const successCriteriaOptions = [
      { id: 'lte', name: '≤ (COC)' },
      { id: 'gte', name: '≥ (DND)' },
    ];

    // [新增] 根据骰子类型智能选择默认成功标准
    let defaultCriteria = successCriteria;
    if (diceType === '1d100') defaultCriteria = 'lte';
    else if (diceType === '1d20') defaultCriteria = 'gte';

    // [新增] 预设快捷按钮区逻辑
    const quickPresetsHtml = (() => {
      const presets = AdvancedDicePresetManager.getAllPresets()
        .filter(p => p.visible !== false) // 默认显示
        .sort((a, b) => (a.order || 0) - (b.order || 0));

      let html = `<div class="acu-dice-quick-section" style="margin-bottom: 8px;">`;
      html += `<div class="acu-dice-section-title"><span><i class="fa-solid fa-sliders"></i> 检定规则<div id="dice-preset-quick-actions" class="acu-dice-preset-quick-actions"></div></span></div>`;

      // 1. 常规预设选择器容器
      html += `<div class="acu-dice-quick-presets" id="dice-normal-presets">`;
      // 自定义按钮（固定在最左）
      html += `<button class="acu-dice-quick-preset-btn" data-id="__custom__">自定义</button>`;

      presets.forEach(p => {
        html += `<button class="acu-dice-quick-preset-btn" data-id="${escapeHtml(p.id)}">${escapeHtml(p.name)}</button>`;
      });
      html += `</div>`;

      // 2. 工作流模式下的“返回”按钮容器（默认隐藏）
      html += `<div id="dice-workflow-return-container" style="display: none;">
        <button class="acu-dice-return-btn" id="dice-return-normal-btn">
            <i class="fa-solid fa-arrow-left"></i> 返回常规检定
        </button>
      </div>`;

      html += `</div>`;
      return html;
    })();

    const panel = $(`
            <div class="acu-dice-panel acu-theme-${config.theme}">
                <div class="acu-dice-panel-header">
                    <div class="acu-dice-panel-title">
                        <i class="fa-solid fa-dice-d20"></i> 普通检定
                    </div>
                    <div class="acu-dice-panel-actions">
                        <button id="dice-switch-contest-top" title="切换到对抗检定"><i class="fa-solid fa-people-arrows"></i></button>
                        <button id="dice-history-btn" title="检定历史"><i class="fa-solid fa-history"></i></button>
                        <button class="acu-dice-config-btn" title="检定设置">
                            <i class="fa-solid fa-cog"></i>
                        </button>
                        <button class="acu-dice-close">
                            <i class="fa-solid fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="acu-dice-panel-body">
                    ${quickPresetsHtml}

                    <!-- 快捷选择角色 -->
                    <div class="acu-dice-quick-section">
                        <div class="acu-dice-section-title"><span><i class="fa-solid fa-user"></i> 快捷选择</span><div id="dice-char-buttons" class="acu-dice-quick-inline"></div></div>
                    </div>

                    <!-- 第1行：名字 + 属性名 -->
                    <div class="acu-dice-form-row cols-2" id="dice-row-1">
                        <div id="dice-name-wrapper">
                            <div class="acu-dice-form-label">名字</div>
                            <input type="text" id="dice-initiator-name" class="acu-dice-input" value="${escapeHtml(initiatorName)}" placeholder="<user>">
                        </div>
                        <div id="dice-attr-name-wrapper">
                            <div class="acu-dice-form-label" id="dice-attr-name-label">
                                <span class="dice-attr-name-text">属性名</span>
                                <button type="button" class="acu-random-skill-btn" id="dice-random-skill" title="随机技能">
                                    <i class="fa-solid fa-dice"></i>
                                </button>
                            </div>
                            <input type="text" id="dice-attr-name" class="acu-dice-input" value="${escapeHtml(targetName || '')}" placeholder="自由检定">
                        </div>
                    </div>

                    <!-- 第2行：属性值 + 技能加值 + 目标值 -->
                    <div class="acu-dice-form-row cols-2" id="dice-row-2">
                        <div id="dice-attr-wrapper">
                            <div class="acu-dice-form-label" id="dice-attr-label">属性值</div>
                            <input type="text" id="dice-attr-value" class="acu-dice-input" value="${initialAttrValue !== null ? initialAttrValue : ''}" placeholder="留空=50%最大值">
                        </div>
                        <div id="dice-skill-mod-wrapper" style="display: none;">
                            <div class="acu-dice-form-label" id="dice-skill-mod-label">技能加值</div>
                            <input type="text" id="dice-skill-mod" class="acu-dice-input" placeholder="留空=0">
                        </div>
                        <div id="dice-target-wrapper">
                            <div class="acu-dice-form-label" id="dice-target-label">目标值</div>
                            <input type="text" id="dice-target" class="acu-dice-input" value="${initialTargetValue !== null ? initialTargetValue : ''}" placeholder="留空=属性值">
                        </div>
                    </div>

                    <!-- 第3行：成功标准 + 难度等级 + 修正值 (基础模式) -->
                    <div class="acu-dice-form-row cols-3" id="dice-row-3">
                        <div>
                            <div class="acu-dice-form-label centered">成功标准</div>
                            <select id="dice-success-criteria" class="acu-dice-select">
                                ${successCriteriaOptions
                                  .map(
                                    opt =>
                                      `<option value="${opt.id}" ${opt.id === defaultCriteria ? 'selected' : ''}>${opt.name}</option>`,
                                  )
                                  .join('')}
                            </select>
                        </div>
                        <div id="dice-difficulty-wrapper">
                            <div class="acu-dice-form-label centered">难度等级</div>
                            <select id="dice-difficulty" class="acu-dice-select">
                                <option value="normal" selected>普通</option>
                                <option value="hard">困难</option>
                                <option value="extreme">极难</option>
                                <option value="critical">大成功</option>
                            </select>
                        </div>
                        <div id="dice-mod-wrapper">
                            <div class="acu-dice-form-label" id="dice-mod-label">修正值</div>
                            <input type="text" id="dice-modifier" class="acu-dice-input" placeholder="留空=0">
                        </div>
                    </div>

                    <!-- [新增] 高级预设自定义字段区域 (在快捷属性上方) -->
                    <div id="dice-custom-fields-area"></div>

                    <!-- [新增] 自定义掷骰模式字段区 -->
                    <div id="acu-dice-custom-mode-fields" style="display: none; margin-top: 8px;">
                        <div class="acu-dice-form-row cols-3">
                            <div>
                                <div class="acu-dice-form-label">骰子语法</div>
                                <input type="text" id="custom-dice-expr" class="acu-dice-input" value="${escapeHtml(diceCfg.customDiceExpr || '')}" placeholder="1d100,2d6+3...">
                            </div>
                            <div>
                                <div class="acu-dice-form-label">成功条件</div>
                                <select id="custom-judge-mode" class="acu-dice-select">
                                    <option value=">=">>=</option>
                                    <option value="<=" selected><=</option>
                                    <option value=">">&gt;</option>
                                    <option value="<">&lt;</option>
                                    <option value="none">无判定</option>
                                </select>
                            </div>
                            <div>
                                <div class="acu-dice-form-label">目标值</div>
                                <input type="text" id="custom-target-value" class="acu-dice-input" placeholder="留空=50%概率">
                            </div>
                        </div>
                    </div>

                    <!-- 快捷选择属性（紧凑型） -->
                    <div id="dice-attr-buttons" class="acu-dice-quick-compact"></div>

                    <!-- 隐藏的骰子公式 -->
                    <input type="hidden" id="dice-formula" value="${diceType}">

                    <button id="dice-roll-btn" class="acu-dice-roll-btn">
                        <i class="fa-solid fa-dice"></i> 掷骰！
                    </button>
                </div>
            </div>
        `);

    overlay.append(panel);
    $('body').append(overlay);
    const effectRunCleanerTimerKey = '__acuEffectRunCleanerTimer';

    const expandedTraceRunIds = new Set<string>();
    let historyFilterStatus = 'all';
    let historyKeyword = '';
    let historyStatsScope: DiceStatsScope = 'chat';

    const renderDiceHistoryItems = (): string => {
      type HistoryItem =
        | (CheckHistoryEntry & { historyType: 'check' })
        | ((AcuDice.ContestResult & { timestamp: number; detailId?: string; detailLines?: string[] }) & {
            historyType: 'contest';
          });

      const mergedItems: HistoryItem[] = [
        ...checkHistory.map(item => ({ ...item, historyType: 'check' as const })),
        ...contestHistory.map(item => ({ ...item, historyType: 'contest' as const })),
      ]
        .sort((a, b) => b.timestamp - a.timestamp)
        .filter(item => {
          if (historyFilterStatus !== 'all') {
            const status = String((item as Record<string, unknown>).effectStatus || '');
            if (!status || status !== historyFilterStatus) return false;
          }
          const keyword = historyKeyword.trim().toLowerCase();
          if (!keyword) return true;
          const raw = item as Record<string, unknown>;
          const haystack = [
            raw.attrName,
            raw.message,
            raw.outcomeText,
            raw.effectStatus,
            raw.initiatorName,
            raw['left'] && typeof raw['left'] === 'object' ? (raw['left'] as Record<string, unknown>).name : undefined,
            raw['right'] && typeof raw['right'] === 'object'
              ? (raw['right'] as Record<string, unknown>).name
              : undefined,
          ]
            .map(text => String(text || '').toLowerCase())
            .join(' ');
          return haystack.includes(keyword);
        })
        .slice(0, 80);

      if (mergedItems.length === 0) {
        return `<div style="padding: 24px 12px; color: var(--acu-text-sub); text-align: center; display:flex; flex-direction:column; align-items:center; gap:8px;"><i class="fa-solid fa-dice-d20" style="font-size:22px; opacity:.35;"></i><span>暂无检定历史</span></div>`;
      }

      const statusTextMap: Record<string, string> = {
        planned: '待执行',
        confirmed: '已确认',
        committed: '已提交',
        failed: '失败',
        cancelled: '已取消',
      };
      const statusColorMap: Record<string, string> = {
        planned: 'var(--acu-text-sub)',
        confirmed: 'var(--acu-accent)',
        committed: 'var(--acu-success-text)',
        failed: 'var(--acu-error-text)',
        cancelled: 'var(--acu-text-sub)',
      };

      return mergedItems
        .map(item => {
          const raw = item as Record<string, unknown>;
          const isContest = item.historyType === 'contest';
          const status = String(raw.effectStatus || '');
          const statusText = status ? statusTextMap[status] || status : '';
          const statusColor = status ? statusColorMap[status] || 'var(--acu-text-sub)' : 'var(--acu-text-sub)';

          const detailId = String(
            raw.detailId ||
              raw.effectRunId ||
              `${item.historyType}-${item.timestamp}-${String(raw.attrName || raw.message || '')}`,
          );
          const traceLines = Array.isArray(raw.effectTrace) ? (raw.effectTrace as string[]) : [];
          const detailLines = Array.isArray(raw.detailLines) ? (raw.detailLines as string[]) : [];
          const canExpand = detailLines.length > 0 || traceLines.length > 0;
          const isExpanded = canExpand && expandedTraceRunIds.has(detailId);

          let title = String(raw.attrName || '检定');
          let subtitle = '';
          let resultColor = raw.success ? 'var(--acu-success-text)' : 'var(--acu-error-text)';
          let rollText = `${String(raw.total ?? '-')}/${String(raw.target ?? '-')}`;
          let metaTag = isContest ? '对抗' : '普通';

          if (isContest) {
            const left = (raw.left || {}) as Record<string, unknown>;
            const right = (raw.right || {}) as Record<string, unknown>;
            title = `${String(left.name || '发起方')} vs ${String(right.name || '对抗方')}`;
            subtitle = String(raw.message || '对抗检定');
            const winner = String(raw.winner || 'tie');
            resultColor = winner === 'tie' ? 'var(--acu-text-sub)' : 'var(--acu-accent)';
            rollText = `${String(left.roll ?? '-')}:${String(right.roll ?? '-')}`;
          } else {
            const initiatorName = String(raw.initiatorName || '').trim();
            if (initiatorName) {
              title = `${initiatorName} · ${title}`;
            }
            subtitle = String(raw.outcomeText || (raw.success ? '成功' : '失败'));
          }

          const pushedBadge = raw.isPushed
            ? '<i class="fa-solid fa-skull" style="font-size:10px;color:var(--acu-text-sub);margin-left:4px;" title="孤注一掷"></i>'
            : '';
          const expandBtn = canExpand
            ? `<button class="acu-history-trace-toggle" data-run-id="${escapeHtml(detailId)}" style="border:none;background:transparent;color:var(--acu-text-sub);cursor:pointer;padding:2px 4px;font-size:13px;" title="${isExpanded ? '收起详情' : '展开详情'}">${isExpanded ? '▼' : '▶'}</button>`
            : '';
          const detailHtml =
            canExpand && isExpanded
              ? `<div style="margin-top:8px; padding:9px 10px; background: color-mix(in srgb, var(--acu-card-bg) 70%, transparent); border:1px solid var(--acu-border); border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:11px; line-height:1.5; color:var(--acu-text-sub); white-space: pre-wrap;">
                   ${detailLines.length > 0 ? `<div style="font-weight:700; color:var(--acu-text-main); margin-bottom:4px;">检定详情</div>${detailLines.map(line => escapeHtml(line)).join('<br>')}` : ''}
                   ${detailLines.length > 0 && traceLines.length > 0 ? '<div style="height:1px; background:var(--acu-border); margin:7px 0;"></div>' : ''}
                   ${traceLines.length > 0 ? `<div style="font-weight:700; color:var(--acu-text-main); margin-bottom:4px;">效果链路</div>${traceLines.map(line => escapeHtml(line)).join('<br>')}` : ''}
                 </div>`
              : '';

          return `
            <div style="padding: 10px 12px; border:1px solid var(--acu-border); border-radius:8px; margin-bottom:8px; background:var(--acu-bg-panel);">
              <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px;">
                <div style="min-width:0; flex:1;">
                  <div style="display:flex; align-items:center; gap:6px;">
                    <span style="font-size:10px; color:var(--acu-text-sub); border:1px solid var(--acu-border); border-radius:999px; padding:1px 6px;">${metaTag}</span>
                    <span style="font-weight:700; color:var(--acu-text-main); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(title)}${pushedBadge}</span>
                  </div>
                  <div style="margin-top:6px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px;">
                    <span style="color:${resultColor}; font-weight:700;">${escapeHtml(subtitle)}</span>
                    <span style="color:var(--acu-text-sub); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;">${escapeHtml(rollText)}</span>
                    ${statusText ? `<span style="color:${statusColor}; border:1px solid color-mix(in srgb, ${statusColor} 40%, transparent); border-radius:999px; padding:1px 7px; font-size:11px;">效果:${statusText}</span>` : ''}
                  </div>
                </div>
                <div style="display:flex; align-items:center; gap:4px; flex-shrink:0;">
                  <span style="font-size:12px; color:var(--acu-text-sub);">${new Date(item.timestamp).toLocaleTimeString('zh-CN', { hour12: false })}</span>
                  ${expandBtn}
                </div>
              </div>
              ${detailHtml}
            </div>
          `;
        })
        .join('');
    };

    const showDiceHistoryDialog = () => {
      $('.acu-dice-history-overlay').remove();
      const currentThemeClass = `acu-theme-${config.theme}`;
      const dialog = $(`
        <div class="acu-edit-overlay acu-dice-history-overlay">
          <div class="acu-edit-dialog ${currentThemeClass}" style="max-width: 600px; width: min(94vw,600px); max-height: 82vh; display:flex; flex-direction:column; padding:14px;">
            <div style="display:flex; justify-content:space-between; align-items:center; padding-bottom:8px; border-bottom:1px solid var(--acu-border);">
              <div style="font-size: 19px; color: var(--acu-text-main); font-weight:700; display:flex; align-items:center; gap:8px;"><i class="fa-solid fa-clock-rotate-left" style="color:var(--acu-accent);"></i> 检定历史</div>
              <button class="acu-close-btn acu-history-close"><i class="fa-solid fa-times"></i></button>
            </div>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:8px; margin-top:10px; align-items:center;">
              <select id="acu-history-scope-filter" class="acu-dice-select" style="width:100%; min-width:0;">
                <option value="chat">本聊天</option>
                <option value="character">本角色卡</option>
                <option value="global">全局</option>
              </select>
              <select id="acu-history-status-filter" class="acu-dice-select" style="width:100%; min-width:0;">
                <option value="all">全部状态</option>
                <option value="planned">待执行</option>
                <option value="confirmed">已确认</option>
                <option value="committed">已提交</option>
                <option value="failed">失败</option>
                <option value="cancelled">已取消</option>
              </select>
              <div style="position:relative; min-width:0;">
                <i class="fa-solid fa-search" style="position:absolute; left:10px; top:50%; transform:translateY(-50%); font-size:12px; color:var(--acu-text-sub);"></i>
                <input id="acu-history-search" class="acu-dice-input" style="width:100%; padding-left:28px;" placeholder="搜索" value="${escapeHtml(historyKeyword)}">
              </div>
            </div>
            <div id="acu-dice-history-stats" style="margin-top:8px; padding:10px; border:1px solid var(--acu-border); border-radius:8px; background:var(--acu-card-bg);">
              <div style="color:var(--acu-text-sub); font-size:12px;">统计加载中...</div>
            </div>
            <div id="acu-dice-history-list" style="margin-top:8px; overflow-y:auto; flex:1; min-height:220px; max-height:52vh; -webkit-overflow-scrolling:touch; overscroll-behavior:contain; touch-action:pan-y;">
              ${renderDiceHistoryItems()}
            </div>
            <div style="display:flex; justify-content:space-between; gap:8px; padding-top:10px; border-top:1px solid var(--acu-border); margin-top:8px;">
              <button class="acu-dialog-btn" id="acu-history-clear" style="background:var(--acu-btn-bg); border-color:var(--acu-border);"><i class="fa-solid fa-trash"></i> 清理历史</button>
              <button class="acu-dialog-btn acu-history-close"><i class="fa-solid fa-times"></i> 关闭</button>
            </div>
          </div>
        </div>
      `);
      $('body').append(dialog);

      const renderHistoryStats = async () => {
        const $stats = dialog.find('#acu-dice-history-stats');
        if ($stats.length === 0) return;

        const allStats = await DiceHistoryStatsDB.getDashboardStats();
        const activeStats = allStats[historyStatsScope];
        const context = getDiceStatsContext();
        const scopeLabelMap: Record<DiceStatsScope, string> = {
          chat: '本聊天',
          character: '本角色卡',
          global: '全局',
        };
        const scopeUnavailable =
          (historyStatsScope === 'chat' && context.chatId === 'unknown_chat') ||
          (historyStatsScope === 'character' && context.characterId === 'unknown_character');

        $stats.html(`
          <div style="display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:8px; margin-bottom:8px;">
            <div style="padding:8px; border:1px solid var(--acu-border); border-radius:6px;">
              <div style="font-size:11px; color:var(--acu-text-sub);">本聊天检定数</div>
              <div style="font-size:18px; font-weight:700; color:var(--acu-text-main);">${allStats.chat.total}</div>
            </div>
            <div style="padding:8px; border:1px solid var(--acu-border); border-radius:6px;">
              <div style="font-size:11px; color:var(--acu-text-sub);">本角色卡检定数</div>
              <div style="font-size:18px; font-weight:700; color:var(--acu-text-main);">${allStats.character.total}</div>
            </div>
            <div style="padding:8px; border:1px solid var(--acu-border); border-radius:6px;">
              <div style="font-size:11px; color:var(--acu-text-sub);">全局检定数</div>
              <div style="font-size:18px; font-weight:700; color:var(--acu-text-main);">${allStats.global.total}</div>
            </div>
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; font-size:12px;">
            <div style="color:var(--acu-text-sub);">当前统计范围：${scopeLabelMap[historyStatsScope]}</div>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <span style="color:var(--acu-text-main);">检定总数：<b>${activeStats.total}</b></span>
              <span style="color:var(--acu-text-main);">普通检定：<b>${activeStats.checks}</b></span>
              <span style="color:var(--acu-text-main);">对抗检定：<b>${activeStats.contests}</b></span>
              <span style="color:var(--acu-text-main);">成功率：<b style="color:var(--acu-success-text);">${activeStats.checkSuccessRate}%</b></span>
            </div>
          </div>
          ${scopeUnavailable ? '<div style="margin-top:6px; font-size:11px; color:var(--acu-text-sub);">当前环境未识别到该范围ID，仅显示已识别范围数据。</div>' : ''}
        `);
      };

      const rerender = () => {
        dialog.find('#acu-dice-history-list').html(renderDiceHistoryItems());
        void renderHistoryStats();
      };
      dialog.find('#acu-history-status-filter').val(historyFilterStatus);
      dialog.find('#acu-history-scope-filter').val(historyStatsScope);

      const refreshByEvent = () => rerender();
      const canListen = Boolean(window.AcuDice && typeof window.AcuDice.on === 'function');
      if (canListen) {
        window.AcuDice.on('check', refreshByEvent);
        window.AcuDice.on('contest', refreshByEvent);
        window.AcuDice.on('effect_run', refreshByEvent);
      }

      void renderHistoryStats();

      dialog.on('change', '#acu-history-scope-filter', function () {
        const val = String($(this).val() || 'chat') as DiceStatsScope;
        historyStatsScope = val === 'character' || val === 'global' ? val : 'chat';
        void renderHistoryStats();
      });

      dialog.on('change', '#acu-history-status-filter', function () {
        historyFilterStatus = String($(this).val() || 'all');
        rerender();
      });

      dialog.on('input', '#acu-history-search', function () {
        historyKeyword = String($(this).val() || '');
        rerender();
      });

      dialog.on('touchstart touchmove', '#acu-dice-history-list', function (e) {
        e.stopPropagation();
      });

      dialog.on('click', '.acu-history-trace-toggle', function (e) {
        e.preventDefault();
        e.stopPropagation();
        const runId = String($(this).data('run-id') || '');
        if (!runId) return;
        if (expandedTraceRunIds.has(runId)) expandedTraceRunIds.delete(runId);
        else expandedTraceRunIds.add(runId);
        rerender();
      });

      dialog.on('click', '#acu-history-clear', async function (e) {
        e.preventDefault();
        e.stopPropagation();
        const ok = window.confirm('确定清理检定历史吗？此操作会清空当前会话内历史和统计库记录。');
        if (!ok) return;

        checkHistory.length = 0;
        contestHistory.length = 0;
        expandedTraceRunIds.clear();
        await DiceHistoryStatsDB.clear();
        rerender();
        if (window.toastr) window.toastr.success('检定历史已清理');
      });

      const closeDialog = () => {
        if (canListen) {
          window.AcuDice.off('check', refreshByEvent);
          window.AcuDice.off('contest', refreshByEvent);
          window.AcuDice.off('effect_run', refreshByEvent);
        }
        dialog.remove();
      };
      dialog.on('click', '.acu-history-close', closeDialog);
      setupOverlayClose(dialog, 'acu-dice-history-overlay', closeDialog);
    };

    // [新增] 构建角色快捷按钮
    const buildCharButtons = () => {
      const $container = panel.find('#dice-char-buttons');
      let html = '';

      // [新增] 如果从MVU面板调用，添加从路径解析的发起者备选
      if (fromMvu && mvuParsedInfo && mvuParsedInfo.initiator) {
        const initiator = mvuParsedInfo.initiator;
        const shortName = initiator.length > 4 ? initiator.substring(0, 4) + '..' : initiator;
        html += `<button class="acu-dice-char-btn acu-dice-char-btn-mvu" data-char="${escapeHtml(initiator)}" title="从变量路径提取: ${escapeHtml(initiator)}">${escapeHtml(shortName)}</button>`;
      }

      // 添加常规角色列表（所有名字统一处理，不再区分 <user>）
      diceCharacterList.forEach(name => {
        const resolvedName = NameAliasRegistry.resolve(String(name));
        const displayName = replaceUserPlaceholders(String(resolvedName));
        const shortName = displayName.length > 4 ? displayName.substring(0, 4) + '..' : displayName;
        html += `<button class="acu-dice-char-btn" data-char="${escapeHtml(String(resolvedName))}" title="${escapeHtml(displayName)}">${escapeHtml(shortName)}</button>`;
      });

      // [新增] 如果从MVU面板调用，添加其他候选（如果有）
      if (fromMvu && mvuParsedInfo && mvuParsedInfo.candidates && mvuParsedInfo.candidates.length > 0) {
        mvuParsedInfo.candidates.forEach(candidate => {
          // 跳过已经添加的发起者
          if (mvuParsedInfo.initiator && candidate === mvuParsedInfo.initiator) return;
          const shortName = candidate.length > 4 ? candidate.substring(0, 4) + '..' : candidate;
          html += `<button class="acu-dice-char-btn acu-dice-char-btn-mvu-candidate" data-char="${escapeHtml(candidate)}" title="从变量路径提取: ${escapeHtml(candidate)}">${escapeHtml(shortName)}</button>`;
        });
      }

      $container.html(html || `<div class="acu-dice-empty-hint">无角色数据</div>`);
      // 绑定点击事件
      $container.find('.acu-dice-char-btn').click(function () {
        const charName = $(this).data('char');
        panel.find('#dice-initiator-name').val(charName).trigger('change');
      });
    };

    // [新增] 构建属性快捷按钮
    const buildAttrButtons = charName => {
      const $container = panel.find('#dice-attr-buttons');
      const $parentSection = $container.parent(); // 获取包含标题的父容器
      const attrs = getFullAttributesForCharacter(charName);

      // 始终显示区域（即使没有属性数据，也要显示生成按钮）
      $parentSection.show();

      let html = '';

      // [新增] 如果从MVU面板调用，添加从路径解析的属性名备选
      if (fromMvu && mvuParsedInfo && mvuParsedInfo.attrName) {
        const attrName = mvuParsedInfo.attrName;
        // 尝试从当前角色获取该属性的值
        const attrValue = getAttributeValue(charName, attrName) || targetValue || '';
        if (attrValue) {
          html += `<button class="acu-dice-attr-btn acu-dice-attr-btn-mvu" data-name="${escapeHtml(attrName)}" data-value="${attrValue}" title="从变量路径提取: ${escapeHtml(attrName)}">${escapeHtml(attrName)}:${attrValue}</button>`;
        } else {
          // 即使没有值也显示，用户可以手动填入
          html += `<button class="acu-dice-attr-btn acu-dice-attr-btn-mvu" data-name="${escapeHtml(attrName)}" data-value="" title="从变量路径提取: ${escapeHtml(attrName)}">${escapeHtml(attrName)}</button>`;
        }
      }

      // 现有属性按钮
      attrs.forEach(attr => {
        html += `<button class="acu-dice-attr-btn" data-name="${escapeHtml(attr.name)}" data-value="${attr.value}">${escapeHtml(attr.name)}:${attr.value}</button>`;
      });

      // 生成属性按钮（始终显示）
      html += `<button class="acu-dice-gen-attr-btn" title="为当前角色生成属性"><i class="fa-solid fa-dice"></i></button>`;

      // 清空属性按钮
      html += `<button class="acu-dice-clear-attr-btn" title="清空当前规则的属性（保留自定义属性）"><i class="fa-solid fa-trash-alt"></i></button>`;

      $container.html(html);

      // 绑定属性按钮点击事件
      $container.find('.acu-dice-attr-btn').click(function () {
        const attrName = $(this).data('name');
        const attrValue = $(this).data('value');

        // 填入属性名
        // 使用 change 触发提交态刷新，避免输入中每字符重绘导致焦点丢失
        const $attrNameInput = panel.find('#dice-attr-name');
        $attrNameInput.val(attrName).trigger('change');

        // [新增] 根据 attrTargetMapping 决定填入哪个字段
        let targetField = '#dice-attr-value'; // 默认填入属性值
        if (currentAdvancedPreset?.attrTargetMapping) {
          for (const [fieldId, names] of Object.entries(currentAdvancedPreset.attrTargetMapping)) {
            if (Array.isArray(names) && names.includes(attrName)) {
              if (fieldId === 'skillMod') {
                targetField = '#dice-skill-mod';
              } else if (fieldId === 'mod') {
                targetField = '#dice-modifier';
              } else if (fieldId === 'attribute') {
                targetField = '#dice-attr-value';
              }
              // 其他 customField.id 可在此扩展
              break;
            }
          }
        }

        panel.find(targetField).val(attrValue);

        // [新增] 如果处于自定义模式,同时填入目标值
        if (panel.find('#acu-dice-custom-mode-fields').is(':visible')) {
          panel.find('#custom-target-value').val(attrValue);
        }

        // [修复] 只填入对应字段，不自动填写DC
        // DC留空时会在检定时根据预设的defaultValue处理
        // - COC模式：DC = 属性值
        // - DND模式：DC = 10（或预设的默认值）

        // 触发change事件以更新相关UI
        panel.find(targetField).trigger('change');
      });

      // 绑定生成属性按钮点击事件
      $container.find('.acu-dice-gen-attr-btn').click(async function (e) {
        e.preventDefault();
        e.stopPropagation();

        const $btn = $(this);
        if ($btn.prop('disabled')) return;

        // 禁用按钮防止重复点击
        $btn.prop('disabled', true).css('opacity', '0.5');
        const originalHtml = $btn.html();
        $btn.html('<i class="fa-solid fa-spinner fa-spin"></i>');

        // [修复] 临时禁用更新处理器，防止闪烁
        const originalHandler = UpdateController.handleUpdate;
        UpdateController.handleUpdate = () => {
          console.log('[DICE]ACU 属性生成中，跳过自动刷新');
        };

        try {
          const charName = panel.find('#dice-initiator-name').val().trim() || '<user>';

          console.log('[DICE]ACU 生成属性 for:', charName);

          // 生成属性（使用激活的预设）
          const generated = generateRPGAttributes();

          // 兼容旧格式和新格式
          const baseAttrs = generated.base || generated;
          const specialAttrs = generated.special || {};

          // [修复] 分别写入基础属性和特有属性到对应的列
          const result = await writeAttributesToCharacter(charName, baseAttrs, false, specialAttrs);

          if (result.success) {
            // 刷新属性按钮
            buildAttrButtons(charName);
          }
        } catch (err) {
          console.error('[DICE]ACU 生成属性失败:', err);
          if (window.toastr) window.toastr.error('生成属性失败');
        } finally {
          // [修复] 恢复更新处理器
          UpdateController.handleUpdate = originalHandler;
          $btn.prop('disabled', false).css('opacity', '1').html(originalHtml);
        }
      });

      // 绑定清空属性按钮点击事件
      $container.find('.acu-dice-clear-attr-btn').click(async function (e) {
        e.preventDefault();
        e.stopPropagation();

        const $btn = $(this);
        if ($btn.prop('disabled')) return;

        const charName = panel.find('#dice-initiator-name').val().trim() || '<user>';

        // 禁用按钮防止重复点击
        $btn.prop('disabled', true).css('opacity', '0.5');
        const originalHtml = $btn.html();
        $btn.html('<i class="fa-solid fa-spinner fa-spin"></i>');

        // 临时禁用更新处理器
        const originalHandler = UpdateController.handleUpdate;
        UpdateController.handleUpdate = () => {
          console.log('[DICE]ACU 清空属性中，跳过自动刷新');
        };

        try {
          console.log('[DICE]ACU 清空属性 for:', charName);

          const result = await clearPresetAttributesForCharacter(charName);

          if (result.success) {
            // 刷新属性按钮
            buildAttrButtons(charName);
          }
        } catch (err) {
          console.error('[DICE]ACU 清空属性失败:', err);
          if (window.toastr) window.toastr.error('清空属性失败');
        } finally {
          // 恢复更新处理器
          UpdateController.handleUpdate = originalHandler;
          $btn.prop('disabled', false).css('opacity', '1').html(originalHtml);
        }
      });
    };

    // 初始化角色按钮
    buildCharButtons();
    // 初始化属性按钮（默认主角）
    buildAttrButtons(diceCharacterList[0] || '<user>');
    // [新增] 随机技能按钮点击事件
    panel.find('#dice-random-skill').click(function (e) {
      e.preventDefault();
      e.stopPropagation();
      const skillPool = getRandomSkillPool();
      const randomSkill = skillPool[Math.floor(Math.random() * skillPool.length)];
      panel.find('#dice-attr-name').val(randomSkill).trigger('change');
    });

    // 初始化自定义下拉菜单
    initCustomDropdown(panel.find('#dice-initiator-name'), diceCharacterList);
    initCustomDropdown(panel.find('#dice-attr-name'), diceAttrList);
    // [新增] 添加清除按钮
    addClearButton(
      panel,
      '#dice-initiator-name, #dice-attr-name, #dice-attr-value, #dice-skill-mod, #dice-target, #dice-modifier, #custom-dice-expr, #custom-target-value',
    );

    // [修复] 角色变化时更新属性列表和快捷按钮
    panel.find('#dice-initiator-name').on('change.acuattr input.acuattr', function () {
      const charName = $(this).val().trim() || '<user>';
      const newAttrList = getAttributesForCharacter(charName);
      initCustomDropdown(panel.find('#dice-attr-name'), newAttrList.length > 0 ? newAttrList : diceAttrList);

      // [新增] 更新属性快捷按钮
      buildAttrButtons(charName);
    });

    // [新增] 属性名变化时自动填入属性值
    panel.find('#dice-attr-name').on('change.acuval', function () {
      const charName = panel.find('#dice-initiator-name').val().trim() || '<user>';
      const attrName = $(this).val().trim();
      const attrValue = getAttributeValue(charName, attrName);
      if (attrValue !== null) {
        panel.find('#dice-attr-value').val(attrValue);
        // [修复] 不自动填写DC，让检定时根据预设的defaultValue处理
      }
    });

    // [修复] 根据骰子类型自动转换目标值
    const convertTargetForDice = (currentTarget, fromDice, toDice) => {
      if (!currentTarget || currentTarget === '') return '';
      const val = parseInt(currentTarget, 10);
      if (isNaN(val)) return currentTarget;

      // 获取骰子最大值
      const getMaxRoll = dice => {
        const match = dice.match(/(\d+)d(\d+)/i);
        if (!match) return 100;
        return parseInt(match[1], 10) * parseInt(match[2], 10);
      };

      const fromMax = getMaxRoll(fromDice);
      const toMax = getMaxRoll(toDice);

      // 按比例转换
      const ratio = val / fromMax;
      const newVal = Math.round(ratio * toMax);
      return Math.max(0, Math.min(newVal, toMax));
    };

    // [重写] 成功标准切换时更新 UI（COC/DND 模式切换）
    const updateRuleMode = () => {
      const criteria = panel.find('#dice-success-criteria').val();
      const isDND = criteria === 'gte';
      const $targetInput = panel.find('#dice-target');
      const $difficultyWrapper = panel.find('#dice-difficulty-wrapper');
      const $row3 = panel.find('#dice-row-3');

      if (isDND) {
        // DND 模式
        $targetInput.attr('placeholder', '留空=10');
        panel.find('#dice-target-label').text('DC');
        $difficultyWrapper.hide();
        $row3.css('grid-template-columns', '1fr 1fr');
      } else {
        // COC 模式
        $targetInput.attr('placeholder', '留空=属性值');
        panel.find('#dice-target-label').text('目标值');
        $difficultyWrapper.show();
        $row3.css('grid-template-columns', '1fr 1fr 1fr');
      }
    };

    panel.find('#dice-success-criteria').on('change', updateRuleMode);

    // 初始化时执行一次
    updateRuleMode();

    // [新增] 高级预设选择器变更事件 (已重构为快捷按钮点击事件)
    let currentAdvancedPreset: AdvancedDicePreset | LegacyAdvancedDicePreset | null = null;
    let lastVisiblePresetId: string | null = null;
    let pendingEffectRuns: PendingEffectContext[] = [];
    let activeConfirmEffectRun: PendingEffectContext | null = null;
    let effectRunRetryTimer: ReturnType<typeof setTimeout> | null = null;
    let effectRunEventSeq = 0;
    const EFFECT_RUN_TTL_MS = 60_000;
    const EFFECT_RUN_FALLBACK_WINDOW_MS = 2_500;
    const messageMutationQueues = new Map<number, Promise<unknown>>();

    const getPresetQuickActions = (
      preset: AdvancedDicePreset | LegacyAdvancedDicePreset | null,
    ): PresetQuickAction[] => {
      if (!preset || !('quickActions' in preset) || !Array.isArray(preset.quickActions)) return [];
      return preset.quickActions.filter((action): action is PresetQuickAction =>
        Boolean(action && typeof action.id === 'string' && typeof action.kind === 'string'),
      );
    };

    const buildQuickActionContext = (): Record<string, number> => {
      const attrRaw = String(panel.find('#dice-attr-value').val() || '').trim();
      const modRaw = String(panel.find('#dice-modifier').val() || '').trim();
      const targetRaw = String(panel.find('#dice-target').val() || '').trim();
      const attr = attrRaw === '' ? 0 : parseFloat(attrRaw) || 0;
      const mod = modRaw === '' ? 0 : parseFloat(modRaw) || 0;
      const dc = targetRaw === '' ? 0 : parseFloat(targetRaw) || 0;
      return {
        $attr: attr,
        $mod: mod,
        $dc: dc,
      };
    };

    const isQuickActionVisible = (action: PresetQuickAction): boolean => {
      if (!action.condition) return true;
      const evalResult = evaluateCondition(action.condition, buildQuickActionContext());
      if (!evalResult.success) return false;
      return typeof evalResult.value === 'number' ? evalResult.value !== 0 : Boolean(evalResult.value);
    };

    const renderPresetQuickActions = (preset: AdvancedDicePreset | LegacyAdvancedDicePreset | null): void => {
      const $container = panel.find('#dice-preset-quick-actions');
      if (!$container.length) return;
      const actions = getPresetQuickActions(preset).filter(isQuickActionVisible);
      if (actions.length === 0) {
        $container.empty().hide();
        return;
      }
      let html = '';
      actions.forEach(action => {
        const icon = action.icon || 'fa-bolt';
        const tooltip = action.tooltip || action.id;
        html += `<button type="button" class="acu-dice-preset-action-btn" data-action-id="${escapeHtml(action.id)}" title="${escapeHtml(tooltip)}"><i class="fa-solid ${escapeHtml(icon)}"></i></button>`;
      });
      $container.html(html).show();
    };

    const waitMs = (ms: number): Promise<void> => {
      return new Promise(resolve => {
        setTimeout(resolve, ms);
      });
    };

    const enqueueMessageMutation = async <T>(messageId: number, task: () => Promise<T>): Promise<T> => {
      const prev = messageMutationQueues.get(messageId) || Promise.resolve();
      const next: Promise<T> = prev.catch(() => undefined).then(task);
      messageMutationQueues.set(messageId, next);
      try {
        return await next;
      } finally {
        if (messageMutationQueues.get(messageId) === next) {
          messageMutationQueues.delete(messageId);
        }
      }
    };

    const injectEffectLinesIntoMeta = async (messageId: number, runId: string, lines: string[]): Promise<boolean> => {
      if (lines.length === 0) return false;
      console.info(`[DICE][META] inject start: run=${runId}, message=${messageId}, lines=${lines.length}`);
      return enqueueMessageMutation(messageId, async () => {
        const retryDelays = [0, 120, 280, 500, 900];
        for (let attempt = 0; attempt < retryDelays.length; attempt++) {
          const delay = retryDelays[attempt];
          if (delay > 0) await waitMs(delay);

          const msgs = getChatMessages(messageId);
          if (msgs.length === 0) {
            console.info(
              `[DICE][META] inject retry=${attempt + 1}/${retryDelays.length}: message not found, run=${runId}, message=${messageId}`,
            );
            continue;
          }

          const msg = msgs[0];
          const msgRole = (msg as { role?: string }).role || 'unknown';
          const extraObj: Record<string, unknown> =
            msg.extra && typeof msg.extra === 'object' ? (msg.extra as Record<string, unknown>) : {};
          const injectedRunsRaw = extraObj.acuEffectInjectedRuns;
          const injectedRuns = Array.isArray(injectedRunsRaw)
            ? injectedRunsRaw.filter((v): v is string => typeof v === 'string')
            : [];
          if (injectedRuns.includes(runId)) {
            console.info(`[DICE][META] inject skipped duplicated run: run=${runId}, message=${messageId}`);
            return true;
          }

          const original = String(msg.message || '');
          const closingCandidates = ['</meta:检定结果>', '&lt;/meta:检定结果&gt;', '&amp;lt;/meta:检定结果&amp;gt;'];
          let closingIdx = -1;
          let closingTag = '';
          for (const candidate of closingCandidates) {
            const idx = original.lastIndexOf(candidate);
            if (idx > closingIdx) {
              closingIdx = idx;
              closingTag = candidate;
            }
          }
          if (closingIdx === -1) {
            const hasRawOpen = original.includes('<meta:检定结果>');
            const hasRawClose = original.includes('</meta:检定结果>');
            const hasEscapedOpen = original.includes('&lt;meta:检定结果&gt;');
            const hasEscapedClose = original.includes('&lt;/meta:检定结果&gt;');
            console.info(
              `[DICE][META] inject retry=${attempt + 1}/${retryDelays.length}: closing tag not found, run=${runId}, message=${messageId}, role=${msgRole}, length=${original.length}, rawOpen=${hasRawOpen}, rawClose=${hasRawClose}, escapedOpen=${hasEscapedOpen}, escapedClose=${hasEscapedClose}`,
            );
            continue;
          }

          const beforeClose = original.slice(0, closingIdx);
          const needsLeadingNewline = beforeClose.length > 0 && !beforeClose.endsWith('\n');
          const effectBlock = `${needsLeadingNewline ? '\n' : ''}${lines.join('\n')}`;
          const updatedMsg = beforeClose + effectBlock + '\n' + original.slice(closingIdx);
          console.info(
            `[DICE][META] inject apply: run=${runId}, message=${messageId}, role=${msgRole}, attempt=${attempt + 1}, oldLen=${original.length}, newLen=${updatedMsg.length}, closingIdx=${closingIdx}, closingTag=${closingTag}`,
          );
          await setChatMessages(
            [
              {
                message_id: messageId,
                message: updatedMsg,
                extra: {
                  ...extraObj,
                  acuEffectInjectedRuns: [...injectedRuns, runId],
                },
              },
            ],
            { refresh: 'affected' },
          );
          const verifyMsg = getChatMessages(messageId)[0];
          const verifyText = String(verifyMsg?.message || '');
          const lineHitCount = lines.filter(line => verifyText.includes(line)).length;
          console.info(
            `[DICE][META] inject done: run=${runId}, message=${messageId}, lineHit=${lineHitCount}/${lines.length}, finalLen=${verifyText.length}`,
          );
          return true;
        }

        console.warn(
          `[DICE][META] inject failed: run=${runId}, message=${messageId}, reason=message_not_ready_or_meta_missing`,
        );
        return false;
      });
    };

    const injectEffectLinesIntoTextarea = (runId: string, lines: string[]): boolean => {
      if (lines.length === 0) return false;
      try {
        const { $ } = getCore();
        const $ta = $('#send_textarea');
        if ($ta.length === 0) return false;
        const raw = String($ta.val() || '');
        if (!raw.includes('meta:检定结果')) return false;
        const missingLines = lines.filter(line => !raw.includes(line));
        if (missingLines.length === 0) {
          console.info(`[DICE][META] textarea inject skipped duplicated run=${runId}`);
          return true;
        }

        const closingCandidates = ['</meta:检定结果>', '&lt;/meta:检定结果&gt;', '&amp;lt;/meta:检定结果&amp;gt;'];
        let closingIdx = -1;
        let closingTag = '';
        for (const candidate of closingCandidates) {
          const idx = raw.lastIndexOf(candidate);
          if (idx > closingIdx) {
            closingIdx = idx;
            closingTag = candidate;
          }
        }
        if (closingIdx === -1) {
          console.warn(`[DICE][META] textarea inject failed: closing tag missing, run=${runId}`);
          return false;
        }

        const beforeClose = raw.slice(0, closingIdx);
        const needsLeadingNewline = beforeClose.length > 0 && !beforeClose.endsWith('\n');
        const effectBlock = `${needsLeadingNewline ? '\n' : ''}${missingLines.join('\n')}`;
        const updated = beforeClose + effectBlock + '\n' + raw.slice(closingIdx);
        $ta.val(updated).trigger('input').trigger('change');
        console.info(
          `[DICE][META] textarea inject done: run=${runId}, lines=${missingLines.length}, closingTag=${closingTag}`,
        );
        return true;
      } catch (e) {
        console.warn(`[DICE][META] textarea inject error: run=${runId}`, e);
        return false;
      }
    };

    const hasMetaInTextarea = (): boolean => {
      try {
        const { $ } = getCore();
        const $ta = $('#send_textarea');
        if ($ta.length === 0) return false;
        const raw = String($ta.val() || '');
        return raw.includes('meta:检定结果');
      } catch {
        return false;
      }
    };

    const normalizeMessageId = (payload: unknown): string | undefined => {
      if (payload === null || payload === undefined) return undefined;
      if (typeof payload === 'string' || typeof payload === 'number') return String(payload);
      if (typeof payload === 'object') {
        const record = payload as Record<string, unknown>;
        const candidates = [record.messageId, record.message_id, record.id, record.mid];
        const hit = candidates.find(v => v !== undefined && v !== null && String(v).trim() !== '');
        if (hit !== undefined && hit !== null) return String(hit);
      }
      return undefined;
    };

    const emitEffectRun = (payload: Omit<EffectRunEventPayload, 'seq'>): number => {
      effectRunEventSeq += 1;
      const fullPayload: EffectRunEventPayload = {
        ...payload,
        seq: effectRunEventSeq,
      };
      emitEvent('effect_run', fullPayload);
      return effectRunEventSeq;
    };

    const getSecondaryTriggerMode = (preset?: AdvancedDicePreset): 'first' | 'all' => {
      return preset?.secondaryTriggerMode === 'all' ? 'all' : 'first';
    };

    const findHistoryIndexByRunId = (runId?: string): number => {
      if (!runId) return -1;
      for (let index = checkHistory.length - 1; index >= 0; index--) {
        const item = checkHistory[index] as CheckHistoryEntry;
        if (item.effectRunId === runId) return index;
      }
      return -1;
    };

    const isValidEffectStatusTransition = (
      fromStatus: CheckHistoryExtension['effectStatus'],
      toStatus: CheckHistoryExtension['effectStatus'],
    ): boolean => {
      if (!fromStatus || !toStatus) return true;
      if (fromStatus === toStatus) return true;
      const transitions: Record<string, string[]> = {
        planned: ['confirmed', 'cancelled', 'failed'],
        confirmed: ['committed', 'failed', 'cancelled'],
        committed: [],
        failed: [],
        cancelled: [],
      };
      const allowed = transitions[fromStatus] || [];
      return allowed.includes(toStatus);
    };

    const setHistoryEffectState = (
      historyIndex: number,
      patch: Partial<CheckHistoryExtension>,
    ): CheckHistoryEntry | null => {
      if (historyIndex < 0 || historyIndex >= checkHistory.length) return null;
      const historyEntry = checkHistory[historyIndex] as CheckHistoryEntry;
      const nextPatch = { ...patch };
      if (
        nextPatch.effectStatus &&
        historyEntry.effectStatus &&
        !isValidEffectStatusTransition(historyEntry.effectStatus, nextPatch.effectStatus)
      ) {
        console.warn(
          `[DICE] Invalid effect status transition blocked: ${historyEntry.effectStatus} -> ${nextPatch.effectStatus}`,
        );
        delete nextPatch.effectStatus;
      }
      Object.assign(historyEntry, nextPatch);
      return historyEntry;
    };

    const setHistoryEffectStateByRun = (
      run: PendingEffectContext,
      patch: Partial<CheckHistoryExtension>,
    ): CheckHistoryEntry | null => {
      const byRunId = findHistoryIndexByRunId(run.runId);
      if (byRunId >= 0) return setHistoryEffectState(byRunId, patch);
      console.warn(`[DICE] setHistoryEffectStateByRun skipped: runId not found (${run.runId})`);
      return null;
    };

    const resolveLatestMetaUserMessageId = (): number | undefined => {
      try {
        const lastId = getLastMessageId();
        if (!Number.isFinite(lastId) || lastId < 0) return undefined;
        const from = Math.max(0, lastId - 12);
        const msgs = getChatMessages(`${from}-${lastId}`, { role: 'user' }) as Array<{
          message_id: number;
          message: string;
        }>;
        for (let i = msgs.length - 1; i >= 0; i--) {
          const text = String(msgs[i].message || '');
          if (text.includes('meta:检定结果')) {
            return msgs[i].message_id;
          }
        }
      } catch {
        // ignore
      }
      return undefined;
    };

    const scheduleEffectRunRetry = (): void => {
      if (effectRunRetryTimer) return;
      effectRunRetryTimer = setTimeout(() => {
        effectRunRetryTimer = null;
        void processPendingEffectRuns();
      }, 220);
    };

    const enqueueEffectRun = (run: PendingEffectContext): void => {
      if (!run.expiresAt) {
        run.expiresAt = Date.now() + EFFECT_RUN_TTL_MS;
      }
      pendingEffectRuns.push(run);
      console.info(
        `[DICE] Effect run queued: ${run.runId}, message=${run.messageId || 'pending'}, expiresAt=${run.expiresAt}, pending=${pendingEffectRuns.length}`,
      );
    };

    const processPendingEffectRuns = async (payload?: unknown): Promise<void> => {
      const incomingMessageId = normalizeMessageId(payload);
      if (incomingMessageId) {
        console.info(`[DICE][META] MESSAGE_SENT captured id=${incomingMessageId}`);
      }

      // 即使队列为空，也将 messageId 捕获到正在等待确认的 run 上
      // （确认弹窗期间 MESSAGE_SENT 可能已触发，run 还没进队列）
      if (incomingMessageId && activeConfirmEffectRun && !activeConfirmEffectRun.messageId) {
        activeConfirmEffectRun.messageId = incomingMessageId;
        console.info(
          `[DICE][META] bind activeConfirm run=${activeConfirmEffectRun.runId} message=${incomingMessageId}`,
        );
      }

      if (pendingEffectRuns.length === 0) return;

      const now = Date.now();
      const nextPending: PendingEffectContext[] = [];
      const executableRuns: PendingEffectContext[] = [];
      let consumedByMessage = false;
      let consumedByFallback = false;

      for (const run of pendingEffectRuns) {
        const expired = Boolean(run.expiresAt && run.expiresAt < now);
        if (expired) {
          const errMsg = '效果执行已过期，已自动取消';
          setHistoryEffectStateByRun(run, {
            effectStatus: 'cancelled',
            effectError: errMsg,
            effectTrace: ['已取消：超时未提交'],
          });
          const seq = emitEffectRun({
            runId: run.runId,
            status: 'cancelled',
            characterName: run.context.characterName,
            attributeName: run.context.attributeName,
            historyIndex: run.historyIndex,
            effectResults: [],
            effectTrace: ['已取消：超时未提交'],
            chainMode: getSecondaryTriggerMode(run.preset),
            error: errMsg,
            timestamp: now,
          });
          setHistoryEffectStateByRun(run, { effectEventSeq: seq });
          continue;
        }

        if (incomingMessageId) {
          if (run.messageId && run.messageId !== incomingMessageId) {
            nextPending.push(run);
            continue;
          }

          if (!consumedByMessage) {
            if (!run.messageId) {
              run.messageId = incomingMessageId;
              console.info(`[DICE][META] bind queued run=${run.runId} message=${incomingMessageId}`);
            }
            executableRuns.push(run);
            consumedByMessage = true;
          } else {
            nextPending.push(run);
          }
          continue;
        }

        // 无 messageId 事件参数时，使用短时间窗降级执行，避免队列永久卡住
        const withinFallbackWindow = now - run.timestamp <= EFFECT_RUN_FALLBACK_WINDOW_MS;
        if (withinFallbackWindow && !consumedByFallback) {
          if (!run.messageId) {
            const guessedMsgId = resolveLatestMetaUserMessageId();
            if (guessedMsgId !== undefined) {
              run.messageId = String(guessedMsgId);
              console.warn(`[DICE][META] fallback guessed messageId: run=${run.runId}, message=${run.messageId}`);
            }
          }
          if (run.messageId) {
            console.warn(`[DICE] Effect run ${run.runId}: fallback commit with bound messageId=${run.messageId}`);
            executableRuns.push(run);
            consumedByFallback = true;
          } else if (hasMetaInTextarea()) {
            console.warn(`[DICE][META] fallback commit by textarea meta presence: run=${run.runId}`);
            executableRuns.push(run);
            consumedByFallback = true;
          } else {
            console.warn(`[DICE][META] fallback skipped: run=${run.runId} has no messageId yet`);
            nextPending.push(run);
          }
        } else if (!withinFallbackWindow && !consumedByFallback) {
          console.warn(`[DICE][META] timeout fallback commit without messageId: run=${run.runId}`);
          executableRuns.push(run);
          consumedByFallback = true;
        } else {
          nextPending.push(run);
        }
      }

      if (executableRuns.length === 0) {
        pendingEffectRuns = nextPending;
        if (pendingEffectRuns.length > 0) {
          scheduleEffectRunRetry();
        }
        return;
      }

      pendingEffectRuns = nextPending;
      for (const run of executableRuns) {
        try {
          const results = await executeEffects(run);
          const hasFailure = results.some(r => !r.success);
          if (!hasFailure) {
            const succeeded = results.filter(r => r.success);
            const latestAttrResult = succeeded
              .slice()
              .reverse()
              .find(r => r.target && isSameAttributeAlias(r.target, run.context.attributeName));
            if (latestAttrResult) {
              panel.find('#dice-attr-value').val(String(latestAttrResult.newValue));
            }
            buildAttrButtons(run.context.characterName);
          }

          setHistoryEffectStateByRun(run, {
            effectStatus: hasFailure ? 'failed' : 'committed',
            effectResults: results,
            effectError: hasFailure ? '部分效果执行失败' : undefined,
            effectTrace: buildEffectTraceLines(results),
          });

          const seq = emitEffectRun({
            runId: run.runId,
            status: hasFailure ? 'failed' : 'committed',
            characterName: run.context.characterName,
            attributeName: run.context.attributeName,
            historyIndex: run.historyIndex,
            effectResults: results,
            effectTrace: buildEffectTraceLines(results),
            chainMode: getSecondaryTriggerMode(run.preset),
            error: hasFailure ? '部分效果执行失败' : undefined,
            timestamp: Date.now(),
          });
          setHistoryEffectStateByRun(run, { effectEventSeq: seq });

          if (hasFailure && window.toastr) {
            window.toastr.warning('效果执行存在失败，已回滚本次全部效果', '效果执行失败');
          }

          console.info(
            `[DICE] Effect run committed: ${run.runId}, total=${results.length}, success=${results.filter(r => r.success).length}`,
          );

          // 效果结果注入：将属性变化和 outputMessage 插入到已有的 <meta:检定结果> 闭合标签前
          if (!hasFailure) {
            const metaLines = buildEffectMetaLines(results, {
              branchReasonText: run.branchReasonText,
            });
            if (metaLines.length > 0) {
              try {
                if (run.messageId) {
                  const msgId = parseInt(run.messageId, 10);
                  if (!isNaN(msgId) && msgId >= 0) {
                    const injected = await injectEffectLinesIntoMeta(msgId, run.runId, metaLines);
                    if (injected) {
                      console.info(
                        `[DICE] Effect results injected into meta: ${metaLines.length} line(s) in message ${msgId}`,
                      );
                    } else {
                      console.warn(
                        `[DICE][META] inject returned false: run=${run.runId}, rawMessageId=${run.messageId}, lines=${metaLines.length}`,
                      );
                    }
                  } else {
                    console.warn(
                      `[DICE][META] invalid messageId for injection: run=${run.runId}, rawMessageId=${run.messageId}`,
                    );
                  }
                } else {
                  const textareaInjected = injectEffectLinesIntoTextarea(run.runId, metaLines);
                  if (!textareaInjected) {
                    console.warn(`[DICE][META] no messageId and textarea inject failed: run=${run.runId}`);
                  }
                }
              } catch (injectErr) {
                console.error('[DICE] Failed to inject effect results into meta:', injectErr);
              }
            }
          }
        } catch (error) {
          const errMsg = error instanceof Error ? error.message : String(error);
          setHistoryEffectStateByRun(run, {
            effectStatus: 'failed',
            effectError: errMsg,
            effectTrace: [`执行失败：${errMsg}`],
          });
          const seq = emitEffectRun({
            runId: run.runId,
            status: 'failed',
            characterName: run.context.characterName,
            attributeName: run.context.attributeName,
            historyIndex: run.historyIndex,
            effectResults: [],
            effectTrace: [`执行失败：${errMsg}`],
            chainMode: getSecondaryTriggerMode(run.preset),
            error: errMsg,
            timestamp: Date.now(),
          });
          setHistoryEffectStateByRun(run, { effectEventSeq: seq });
          console.error(`[DICE] Effect run failed: ${run.runId}`, error);
        }
      }
    };

    const cleanupExpiredEffectRuns = (): void => {
      if (pendingEffectRuns.length === 0) return;
      const now = Date.now();
      const nextPending: PendingEffectContext[] = [];
      for (const run of pendingEffectRuns) {
        const expired = Boolean(run.expiresAt && run.expiresAt < now);
        if (!expired) {
          nextPending.push(run);
          continue;
        }

        const errMsg = '效果执行已过期，已自动取消';
        setHistoryEffectStateByRun(run, {
          effectStatus: 'cancelled',
          effectError: errMsg,
          effectTrace: ['已取消：超时'],
        });
        const seq = emitEffectRun({
          runId: run.runId,
          status: 'cancelled',
          characterName: run.context.characterName,
          attributeName: run.context.attributeName,
          historyIndex: run.historyIndex,
          effectResults: [],
          effectTrace: ['已取消：超时'],
          chainMode: getSecondaryTriggerMode(run.preset),
          error: errMsg,
          timestamp: now,
        });
        setHistoryEffectStateByRun(run, { effectEventSeq: seq });
      }
      pendingEffectRuns = nextPending;
    };
    const existingCleaner = (window as Record<string, unknown>)[effectRunCleanerTimerKey];
    if (typeof existingCleaner === 'number') {
      window.clearInterval(existingCleaner);
    }
    (window as Record<string, unknown>)[effectRunCleanerTimerKey] = window.setInterval(() => {
      cleanupExpiredEffectRuns();
    }, 2000);

    // 辅助函数: 应用字段配置
    const applyFieldConfig = function (
      $input: JQuery,
      $label: JQuery,
      config: FieldConfig | undefined,
      defaults: { label: string; placeholder: string },
    ) {
      // 获取包含label和input的wrapper div
      // 实际DOM结构: <div> <label/> <div.acu-input-wrapper> <input/> </div> </div>
      // 所以需要找到label的父元素（同时也是input-wrapper的父元素）
      const $wrapper = $label.parent();

      if (config?.hidden) {
        $wrapper.hide();
        return;
      }

      $wrapper.show();
      $input.attr('placeholder', config?.placeholder || defaults.placeholder).prop('readonly', false);
      $label.text(config?.label || defaults.label);
    };

    /**
     * [新增] 检查属性名是否匹配 CheckSelector
     * @param attrName - 当前检定的属性名
     * @param selector - 选择器配置
     * @returns 是否匹配（true=可用，false=不可用）
     */
    const matchesCheckSelector = (attrName: string, selector?: CheckSelector): boolean => {
      // 如果没有定义 selector，默认匹配所有
      if (!selector) return true;

      const normalizedName = attrName.trim().toLowerCase();

      // 辅助函数：将通配符模式转换为正则表达式
      const wildcardToRegex = (pattern: string): RegExp => {
        const escaped = pattern
          .replace(/[.+^${}()|[\]\\]/g, '\\$&') // 转义特殊字符
          .replace(/\*/g, '.*') // * -> .*
          .replace(/\?/g, '.'); // ? -> .
        return new RegExp(`^${escaped}$`, 'i');
      };

      // 辅助函数：检查名称是否匹配任一模式
      const matchesAnyPattern = (name: string, patterns: string[]): boolean => {
        return patterns.some(pattern => {
          const regex = wildcardToRegex(pattern);
          return regex.test(name);
        });
      };

      // 1. 检查 namePatterns.exclude（优先于 include）
      if (selector.namePatterns?.exclude && selector.namePatterns.exclude.length > 0) {
        if (matchesAnyPattern(normalizedName, selector.namePatterns.exclude)) {
          return false; // 被排除
        }
      }

      // 2. 检查 namePatterns.include
      if (selector.namePatterns?.include && selector.namePatterns.include.length > 0) {
        // 如果定义了 include 且不为 ['*']，需要匹配
        const isWildcardOnly = selector.namePatterns.include.length === 1 && selector.namePatterns.include[0] === '*';
        if (!isWildcardOnly && !matchesAnyPattern(normalizedName, selector.namePatterns.include)) {
          return false; // 未被包含
        }
      }

      // 3. 检查 tags（暂时跳过，因为当前掷骰上下文可能没有 tags 元数据）
      // 未来可以扩展支持 tags.include/exclude

      return true;
    };

    // [新增] 渲染效果输入区域
    const renderEffectInputs = (preset: AdvancedDicePreset, attrName: string): string[] => {
      if (!preset.effectsConfig) return [];

      // 检查触发模式
      const isMatched = matchesCheckSelector(attrName, {
        namePatterns: { include: preset.effectsConfig.triggerPatterns },
      });

      if (!isMatched) return [];

      const items: string[] = [];

      // 从 preset.outcomes 中查找有效果的结果等级，生成输入框
      // 注意：效果定义在 preset.outcomes[].effects 中，不是 effectsConfig.outcomes
      if (preset.outcomes && Array.isArray(preset.outcomes)) {
        const outcomesWithEffects = preset.outcomes.filter(outcome => outcome.effects && outcome.effects.length > 0);

        outcomesWithEffects.forEach(outcome => {
          // 获取该结果等级的默认值（从 effectsConfig.defaultValues 或 effects[0].value）
          const defaultVal =
            preset.effectsConfig?.defaultValues?.[outcome.name] || (outcome.effects && outcome.effects[0]?.value) || '';
          const label = outcome.name; // 使用结果名作为标签

          items.push(`
            <div class="acu-effect-input-group">
              <div class="acu-effect-input-label">
                <span>${escapeHtml(label)}效果</span>
                <span class="acu-effect-preview-text" id="effect-preview-${escapeHtml(outcome.name)}"></span>
              </div>
              <input type="text"
                     class="acu-dice-input acu-effect-value-input"
                     data-outcome="${escapeHtml(outcome.name)}"
                     value=""
                     placeholder="${escapeHtml(String(defaultVal || '输入效果值 (如 1d6)'))}">
            </div>
          `);
        });
      }

      return items;
    };

    const applyAdvancedPreset = (presetId: string | null) => {
      // 获取关键DOM元素
      const $modWrapper = panel.find('#dice-mod-wrapper');
      const $row1 = panel.find('#dice-row-1');
      const $row2 = panel.find('#dice-row-2');
      const $row3 = panel.find('#dice-row-3');
      const $customArea = panel.find('#dice-custom-fields-area');
      const $attrWrapper = panel.find('#dice-attr-wrapper');
      const $targetWrapper = panel.find('#dice-target-wrapper');
      const $skillModWrapper = panel.find('#dice-skill-mod-wrapper');
      const $nameWrapper = panel.find('#dice-name-wrapper');
      const $attrNameWrapper = panel.find('#dice-attr-name-wrapper');

      // 辅助函数: 恢复 Row 1 的名字和属性名
      const restoreRow1 = () => {
        if ($nameWrapper.parent().attr('id') !== 'dice-row-1') {
          $nameWrapper.detach().prependTo($row1);
        }
        if ($attrNameWrapper.parent().attr('id') !== 'dice-row-1') {
          $attrNameWrapper.detach().appendTo($row1);
        }
        $nameWrapper.show();
        $attrNameWrapper.show();
        $row1.show();
        // 恢复为2列布局
        $row1.removeClass('cols-2 cols-3').addClass('cols-2');
      };

      // 辅助函数: 确保修正值输入框回到原来的位置
      const restoreModifier = () => {
        if ($modWrapper.parent().attr('id') !== 'dice-row-3') {
          $modWrapper.detach().appendTo($row3);
        }
        $modWrapper.show();
        panel.find('#dice-mod-label').text('修正值'); // 恢复默认标签
        panel.find('#dice-modifier').attr('placeholder', '留空=0');
      };

      // 辅助函数: 恢复 Row 2 的属性值、技能加值和目标值
      const restoreRow2 = () => {
        if ($attrWrapper.parent().attr('id') !== 'dice-row-2') {
          $attrWrapper.detach().prependTo($row2);
        }
        if ($skillModWrapper.parent().attr('id') !== 'dice-row-2') {
          $skillModWrapper.detach().insertAfter($attrWrapper);
        }
        if ($targetWrapper.parent().attr('id') !== 'dice-row-2') {
          $targetWrapper.detach().appendTo($row2);
        }
        $attrWrapper.show();
        $skillModWrapper.hide(); // 默认隐藏，由预设控制显示
        $targetWrapper.show();
        $row2.show();
      };

      if (!presetId || presetId === '__custom__') {
        // 恢复默认模式 (自定义或无预设)
        currentAdvancedPreset = null;
        lastVisiblePresetId = null;

        // [新增] 显示自定义模式字段区,隐藏预设相关字段
        panel.find('#acu-dice-custom-mode-fields').show();

        // 恢复 Row 1、Row 2 和 Row 3 但隐藏 Row 2/3 (自定义模式使用专属字段)
        restoreRow1();
        restoreRow2();
        restoreModifier();
        $row2.hide();
        $row3.hide();
        panel.find('#dice-difficulty-wrapper').hide();
        panel.find('#dice-success-criteria').closest('div').hide();

        // 清空自定义区域
        $customArea.empty();

        // 恢复"属性名"标签
        panel.find('.dice-attr-name-text').text('属性名');

        // 恢复属性值和目标值输入框
        applyFieldConfig(panel.find('#dice-attr-value'), panel.find('#dice-attr-label'), undefined, {
          label: '属性值',
          placeholder: '留空=50%最大值',
        });

        applyFieldConfig(panel.find('#dice-target'), panel.find('#dice-target-label'), undefined, {
          label: '目标值',
          placeholder: '留空=属性值',
        });

        // 更新按钮高亮
        panel.find('.acu-dice-quick-preset-btn').removeClass('active');
        panel.find('.acu-dice-quick-preset-btn[data-id="__custom__"]').addClass('active');

        panel.find('#dice-normal-presets').show();
        panel.find('#dice-workflow-return-container').hide();

        updateRuleMode();
        renderPresetQuickActions(null);
        return;
      }

      const preset = AdvancedDicePresetManager.getAllPresets().find(p => p.id === presetId);
      if (!preset) {
        console.warn('[DICE] 未找到预设:', presetId);
        // 回退到自定义模式
        applyAdvancedPreset('__custom__');
        return;
      }

      currentAdvancedPreset = preset;
      if (preset.visible !== false) {
        lastVisiblePresetId = preset.id;
      }

      // 更新按钮高亮
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      panel.find(`.acu-dice-quick-preset-btn[data-id="${escapeHtml(preset.id)}"]`).addClass('active');

      // 隐藏自定义输入框
      // [新增] 隐藏自定义模式字段区
      panel.find('#acu-dice-custom-mode-fields').hide();

      // 更新骰子表达式
      panel.find('#dice-formula').val(preset.diceExpression);

      // 更新"属性名"标签（如Fate使用"技能/风格"）
      panel.find('.dice-attr-name-text').text(preset.attributeName?.label || '属性名');

      // 隐藏原始 Row 1、Row 2 和 Row 3 (所有字段将整合到 customArea 中)
      restoreRow1();
      restoreRow2();
      restoreModifier();
      $row1.hide();
      $row2.hide();
      $row3.hide();

      // 清空自定义区域
      $customArea.empty();

      // [重构] 收集所有可见字段，统一使用智能布局
      const gridItems: (JQuery | string)[] = [];

      // 0. 名字 (始终显示)
      gridItems.push($nameWrapper);

      // 0.5 属性名 (始终显示)
      gridItems.push($attrNameWrapper);

      // 1. 属性值 (如果未隐藏)
      if (!preset.attribute?.hidden) {
        applyFieldConfig(panel.find('#dice-attr-value'), panel.find('#dice-attr-label'), preset.attribute, {
          label: '属性值',
          placeholder: '留空=50%最大值',
        });
        gridItems.push($attrWrapper);
      }

      // 1.5 技能加值 (如果预设定义了 skillMod 且未隐藏)
      if (preset.skillMod && !preset.skillMod.hidden) {
        applyFieldConfig(panel.find('#dice-skill-mod'), panel.find('#dice-skill-mod-label'), preset.skillMod, {
          label: '技能加值',
          placeholder: '留空=0',
        });
        gridItems.push($skillModWrapper);
      }

      // [新增] 效果输入区域
      const attrName = panel.find('#dice-attr-name').val().trim();
      const effectInputItems = renderEffectInputs(preset, attrName);
      if (effectInputItems.length > 0) {
        gridItems.push(...effectInputItems);
      }

      // 2. 目标值/DC (如果未隐藏)
      if (!preset.dc?.hidden) {
        applyFieldConfig(panel.find('#dice-target'), panel.find('#dice-target-label'), preset.dc, {
          label: '目标值',
          placeholder: '留空=属性值',
        });
        gridItems.push($targetWrapper);
      }

      // 3. 修正值 (如果未隐藏)
      if (!preset.mod?.hidden) {
        if (preset.mod?.label) {
          panel.find('#dice-mod-label').text(preset.mod.label);
        }
        // 使用 placeholder 显示默认值
        const modDefault = preset.mod?.defaultValue;
        if (modDefault !== undefined && modDefault !== 0) {
          panel.find('#dice-modifier').attr('placeholder', `留空=${modDefault}`);
        } else {
          panel.find('#dice-modifier').attr('placeholder', '留空=0');
        }
        gridItems.push($modWrapper);
      }

      // 4. 收集自定义字段
      if ('customFields' in preset && Array.isArray(preset.customFields) && preset.customFields.length > 0) {
        const visibleFields = preset.customFields.filter(f => !f.hidden);

        visibleFields.forEach(field => {
          let html = '<div>';

          // 标签
          if (field.type !== 'toggle') {
            html += `<div class="acu-dice-form-label">${escapeHtml(field.label || field.id)}</div>`;
          } else {
            html += '<div class="acu-dice-form-label">&nbsp;</div>'; // 占位
          }

          // 控件
          if (field.type === 'select' && field.options) {
            html += `<select class="acu-dice-select acu-dice-custom-field" data-id="${escapeHtml(field.id)}">`;
            field.options.forEach(opt => {
              const isSelected = opt.value === field.defaultValue ? 'selected' : '';
              html += `<option value="${escapeHtml(String(opt.value))}" ${isSelected}>${escapeHtml(opt.label)}</option>`;
            });
            html += '</select>';
          } else if (field.type === 'toggle') {
            const isChecked = field.defaultValue ? 'checked' : '';
            html += `<label style="display: flex; align-items: center; cursor: pointer; height: 32px;">
              <input type="checkbox" class="acu-dice-custom-field" data-id="${escapeHtml(field.id)}" ${isChecked} style="margin-right: 8px;">
              ${escapeHtml(field.label || field.id)}
            </label>`;
          } else {
            const type = field.type === 'number' ? 'number' : 'text';
            // [修复] 使用 placeholder 而不是 value 显示默认值
            const defaultVal = field.defaultValue;
            const placeholderText =
              field.placeholder || (defaultVal !== undefined && defaultVal !== '' ? `留空=${defaultVal}` : '');
            html += `<input type="${type}" class="acu-dice-input acu-dice-custom-field" data-id="${escapeHtml(field.id)}"
              placeholder="${escapeHtml(placeholderText)}">`;
          }

          html += '</div>';
          gridItems.push(html);
        });
      }

      // 5. 智能排版渲染网格
      // 布局规律：最后一行优先放3个字段，前面的行放2个字段
      // - 4个字段：2+2
      // - 5个字段：2+3
      // - 6个字段：3+3
      // - 7个字段：2+2+3
      // - 8个字段：2+3+3
      // - 9个字段：3+3+3
      const appendItem = ($row: JQuery, item: JQuery | string) => {
        if (typeof item === 'string') {
          $row.append(item);
        } else {
          item.detach().appendTo($row);
          item.show();
        }
      };

      // 计算行分配：从后往前，优先用3列填充
      const computeRowLayout = (total: number): number[] => {
        if (total <= 0) return [];
        if (total <= 2) return [2]; // 最少2列，避免 cols-1
        if (total === 3) return [3];
        if (total === 4) return [2, 2];
        if (total === 5) return [2, 3];
        if (total === 6) return [3, 3];
        // 7+ 字段：递归计算，最后一行放3个，剩余的递归处理
        return [...computeRowLayout(total - 3), 3];
      };

      // 直接计算 gridItems 的行分配
      const gridRowLayout = computeRowLayout(gridItems.length);

      let itemIndex = 0;
      for (const colCount of gridRowLayout) {
        const $row = $(`<div class="acu-dice-form-row cols-${colCount}"></div>`);
        for (let j = 0; j < colCount; j++) {
          if (itemIndex < gridItems.length) {
            appendItem($row, gridItems[itemIndex]);
            itemIndex++;
          } else {
            $row.append('<div></div>');
          }
        }
        $customArea.append($row);
      }

      // [新增] 为动态生成的 customFields 输入框添加清除按钮
      addClearButton($customArea, '.acu-dice-custom-field[type="text"], .acu-dice-custom-field[type="number"]');

      renderPresetQuickActions(preset);

      // [核心修复] 检测是否为“工作流模式”并切换 UI 状态
      // 这里的判定逻辑：如果预设是“非默认可见”的（visible: false），则视为特殊工作流（如技能成长）
      // 此时隐藏常规预设切换按钮，显示“返回常规检定”按钮
      const isWorkMode = preset.visible === false;
      const $normalPresets = panel.find('#dice-normal-presets');
      const $workflowReturn = panel.find('#dice-workflow-return-container');

      if (isWorkMode) {
        $normalPresets.hide();
        $workflowReturn.show();
        $workflowReturn
          .find('button')
          .html(`<i class="fa-solid fa-arrow-left"></i> 返回常规检定（退出${escapeHtml(preset.name)}）`);
      } else {
        $normalPresets.show();
        $workflowReturn.hide();
      }

      console.log('[DICE] 应用高级预设:', preset.name, isWorkMode ? '(工作流模式)' : '');
    };

    // [新增] 动态监听属性名变化，更新效果输入区域
    panel.find('#dice-attr-name').on('change', function () {
      if (!currentAdvancedPreset) return;
      // 重新渲染整个面板内容可能太重，这里只更新效果区域
      // 但由于效果区域是作为 gridItems 动态插入的，直接重新调用 applyAdvancedPreset 最简单
      // 必须防止死循环
      if (panel.data('updating-preset')) return;
      panel.data('updating-preset', true);
      applyAdvancedPreset(currentAdvancedPreset.id);
      panel.data('updating-preset', false);
    });

    // 自定义模式下持久化骰子语法（仅自定义模式使用）
    panel.find('#custom-dice-expr').on('input change', function () {
      if (!panel.find('#acu-dice-custom-mode-fields').is(':visible')) return;
      const customExpr = ($(this).val() || '').toString().trim();
      saveDiceConfig({ customDiceExpr: customExpr });
    });

    // 绑定快捷预设按钮点击事件
    panel.find('.acu-dice-quick-preset-btn').click(function () {
      const presetId = $(this).data('id') as string;

      // 保存到 last preset
      if (presetId === '__custom__') {
        AdvancedDicePresetManager.setActivePreset(null);
        localStorage.setItem(STORAGE_KEY_LAST_PRESET, '__custom__');
      } else {
        AdvancedDicePresetManager.setActivePreset(presetId);
        localStorage.setItem(STORAGE_KEY_LAST_PRESET, presetId);
      }

      applyAdvancedPreset(presetId);
    });

    // [新增] 绑定“返回常规检定”按钮点击事件
    panel.on('click', '#dice-return-normal-btn', function (e) {
      e.preventDefault();
      // 返回到最近一次可见预设；若无则回退到第一个可见预设
      let targetPresetId: string | null = lastVisiblePresetId;

      // 验证 targetPresetId 是否有效且可见
      const allPresets = AdvancedDicePresetManager.getAllPresets();
      const targetPreset = allPresets.find(p => p.id === targetPresetId);
      if (!targetPreset || targetPreset.visible === false) {
        // 如果上次预设无效或不可见，则回退到第一个可见预设
        const firstVisible = allPresets.find(p => p.visible !== false);
        targetPresetId = firstVisible ? firstVisible.id : '__custom__';
      }

      // 执行切换
      if (targetPresetId === '__custom__') {
        AdvancedDicePresetManager.setActivePreset(null);
      } else {
        AdvancedDicePresetManager.setActivePreset(targetPresetId);
      }
      // 更新 localStorage
      localStorage.setItem(STORAGE_KEY_LAST_PRESET, targetPresetId || '__custom__');

      applyAdvancedPreset(targetPresetId);
    });

    panel.on('click', '.acu-dice-preset-action-btn', async function (e) {
      e.preventDefault();
      e.stopPropagation();
      const actionId = String($(this).data('action-id') || '').trim();
      if (!actionId) return;
      const $btn = $(this);
      if ($btn.prop('disabled')) return;
      $btn.prop('disabled', true).addClass('disabled');
      try {
        await executePresetQuickAction(actionId);
      } finally {
        $btn.prop('disabled', false).removeClass('disabled');
        renderPresetQuickActions(currentAdvancedPreset);
      }
    });

    panel.find('#dice-attr-value, #dice-modifier, #dice-target').on('input change', function () {
      renderPresetQuickActions(currentAdvancedPreset);
    });

    // 初始化时应用已保存的预设
    const savedPresetId = localStorage.getItem(STORAGE_KEY_LAST_PRESET);
    // 兼容旧逻辑：如果 ActivePresetManager 里有值，优先使用
    const activePreset = AdvancedDicePresetManager.getActivePreset();

    if (activePreset) {
      applyAdvancedPreset(activePreset.id);
    } else if (savedPresetId && savedPresetId !== '__custom__') {
      applyAdvancedPreset(savedPresetId);
    } else {
      applyAdvancedPreset('__custom__');
    }

    // 掷骰逻辑 - 使用 rollComplexDiceExpression 支持复合表达式
    const rollDice = formula => {
      const rollResult = rollComplexDiceExpression(formula);
      const total = rollResult.total;
      if (Number.isNaN(total)) {
        return { total: 0, rolls: [], formula };
      }
      // 尝试从公式中提取基本信息用于显示
      const basicMatch = formula.match(/^(\d*)d(\d+|F)/i);
      const count = basicMatch && basicMatch[1] ? parseInt(basicMatch[1], 10) : 1;
      const sidesStr = basicMatch ? basicMatch[2] : '100';
      const sides = sidesStr.toUpperCase() === 'F' ? 3 : parseInt(sidesStr, 10);
      // 对于复杂语法，不提供单独的 rolls 数组
      return { total, rolls: [], sides, count, modifier: 0, formula };
    };

    // 解析修正值，支持纯数字和骰子表达式（如1d6, 1d6+2等）
    const parseModifier = function (modStr) {
      if (!modStr || modStr.trim() === '') return 0;
      const trimmed = modStr.trim();

      // 尝试直接解析为数字
      const numValue = parseFloat(trimmed);
      if (!isNaN(numValue) && isFinite(numValue) && trimmed.match(/^-?\d+(\.\d+)?$/)) {
        return numValue;
      }

      // 复合表达式统一走完整解析
      const rollResult = rollComplexDiceExpression(trimmed);
      if (!Number.isNaN(rollResult.total)) return rollResult.total;
      return 0;
    };

    const resolveExpressionWithContext = (expr: string, context: Record<string, string | number | boolean>): string => {
      let resolved = String(expr || '0');
      Object.entries(context).forEach(([key, value]) => {
        const safeKey = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        resolved = resolved.replace(new RegExp(safeKey, 'g'), String(value));
      });
      return resolved;
    };

    const activatePresetQuickAction = (action: WorkflowQuickAction): void => {
      const presetId = String(action.config.presetId || '').trim();
      if (!presetId) {
        if (window.toastr) window.toastr.warning('快捷操作缺少目标预设');
        return;
      }
      const targetPreset = AdvancedDicePresetManager.getAllPresets().find(item => item.id === presetId);
      if (!targetPreset) {
        if (window.toastr) window.toastr.warning(`未找到预设: ${presetId}`);
        return;
      }

      const carryInitiator = action.config.carryInitiator !== false;
      const carryAttrName = action.config.carryAttrName !== false;
      const carryAttrValue = action.config.carryAttrValue !== false;
      const carryTarget = action.config.carryTarget === true;
      const carryModifier = action.config.carryModifier === true;
      const carrySkillMod = action.config.carrySkillMod === true;

      const previousState = {
        initiatorName: String(panel.find('#dice-initiator-name').val() || '').trim(),
        attrName: String(panel.find('#dice-attr-name').val() || '').trim(),
        attrValue: String(panel.find('#dice-attr-value').val() || '').trim(),
        target: String(panel.find('#dice-target').val() || '').trim(),
        modifier: String(panel.find('#dice-modifier').val() || '').trim(),
        skillMod: String(panel.find('#dice-skill-mod').val() || '').trim(),
      };

      AdvancedDicePresetManager.setActivePreset(presetId);
      localStorage.setItem(STORAGE_KEY_LAST_PRESET, presetId);
      applyAdvancedPreset(presetId);

      if (carryInitiator) {
        panel.find('#dice-initiator-name').val(previousState.initiatorName);
      }
      if (carryAttrName) {
        panel.find('#dice-attr-name').val(previousState.attrName);
      } else if (action.config.attrName !== undefined) {
        panel.find('#dice-attr-name').val(action.config.attrName);
      }
      if (carryAttrValue) {
        panel.find('#dice-attr-value').val(previousState.attrValue);
      }
      if (carryTarget) {
        panel.find('#dice-target').val(previousState.target);
      }
      if (carryModifier) {
        panel.find('#dice-modifier').val(previousState.modifier);
      }
      if (carrySkillMod) {
        panel.find('#dice-skill-mod').val(previousState.skillMod);
      }

      if (action.config.customFieldValues) {
        Object.entries(action.config.customFieldValues).forEach(([fieldId, rawValue]) => {
          const $field = panel
            .find('.acu-dice-custom-field')
            .filter((_index, element) => String($(element).data('id') || '') === fieldId);
          if (!$field.length) return;
          if ($field.is(':checkbox')) {
            $field.prop('checked', Boolean(rawValue));
            return;
          }
          $field.val(String(rawValue));
        });
      }

      panel.find('#dice-attr-name').trigger('change');
      panel.find('#dice-attr-value, #dice-target, #dice-modifier, #dice-skill-mod').trigger('change');
    };

    const executeAttrShortcutQuickAction = (action: AttrShortcutQuickAction): void => {
      const presetId = String(action.config.presetId || '').trim();
      if (!presetId) {
        if (window.toastr) window.toastr.warning('属性快捷缺少目标预设');
        return;
      }

      const allPresets = AdvancedDicePresetManager.getAllPresets();
      const configuredTargetPreset = allPresets.find(item => item.id === presetId);
      if (!configuredTargetPreset) {
        if (window.toastr) window.toastr.warning(`属性快捷目标预设不存在: ${presetId}`);
        return;
      }

      // 架构约束：属性快捷只能指向“常规可见预设”，若指向工作流预设则直接中止
      if (configuredTargetPreset.visible === false) {
        if (window.toastr) {
          window.toastr.warning(`属性快捷目标预设不可用（工作流）: ${configuredTargetPreset.name}，已中止执行`);
        }
        return;
      }

      const presetAllowedTargets = Array.isArray(configuredTargetPreset.effectsConfig?.allowedTargets)
        ? configuredTargetPreset.effectsConfig?.allowedTargets
        : [];
      const mergedCandidates = Array.from(
        new Set(
          [...(action.config.attrAliasCandidates || []), ...presetAllowedTargets]
            .map(name => String(name || '').trim())
            .filter(Boolean),
        ),
      );

      const workflowAction: WorkflowQuickAction = {
        id: action.id,
        kind: 'workflow_shortcut',
        icon: action.icon,
        tooltip: action.tooltip,
        condition: action.condition,
        config: {
          presetId,
          carryInitiator: action.config.carryInitiator,
          carryAttrName: false,
          carryAttrValue: action.config.carryAttrValue,
          carryTarget: action.config.carryTarget,
          carryModifier: action.config.carryModifier,
          carrySkillMod: action.config.carrySkillMod,
        },
      };
      activatePresetQuickAction(workflowAction);

      const charName = String(panel.find('#dice-initiator-name').val() || '').trim() || '<user>';
      const candidates = mergedCandidates;
      const fallbackName = String(action.config.fallbackAttrName || '').trim() || candidates[0] || '';
      if (!fallbackName) return;

      const resolved = resolveAttributeAliasName(charName, fallbackName, candidates);
      const resolvedAttrName = resolved.name || fallbackName;
      panel.find('#dice-attr-name').val(resolvedAttrName).trigger('change');
    };

    const executePresetQuickAction = async (actionId: string): Promise<void> => {
      const preset = currentAdvancedPreset;
      if (!preset) {
        if (window.toastr) window.toastr.warning('请先选择一个检定预设');
        return;
      }
      const action = getPresetQuickActions(preset).find(item => item.id === actionId);
      if (!action) {
        if (window.toastr) window.toastr.warning('未找到快捷操作配置');
        return;
      }
      if (action.kind === 'workflow_shortcut') {
        activatePresetQuickAction(action);
        return;
      }
      if (action.kind === 'attr_shortcut') {
        executeAttrShortcutQuickAction(action);
        return;
      }
      if (window.toastr) window.toastr.warning('暂不支持的快捷操作类型');
    };

    // [新增] 资源消耗器按钮渲染辅助函数
    const renderResourceBurnerButtons = (
      preset: AdvancedDicePreset,
      context: Record<string, number>,
      matchedOutcome?: OutcomeLevel,
      attrName?: string,
    ): string => {
      if (!preset.resourceBurners || !Array.isArray(preset.resourceBurners) || preset.resourceBurners.length === 0) {
        return '';
      }

      let html = '';
      preset.resourceBurners.forEach(burner => {
        // 1. 首先检查 selector 过滤（结构性范围控制）
        if (attrName && burner.selector) {
          const selectorMatch = matchesCheckSelector(attrName, burner.selector);
          if (!selectorMatch) {
            return; // 属性名被 selector 排除
          }
        }

        // 2. 然后检查 condition（动态状态控制）
        if (burner.condition) {
          const evalResult = evaluateCondition(burner.condition, context);
          if (
            !evalResult.success ||
            (typeof evalResult.value === 'number' ? evalResult.value === 0 : !evalResult.value)
          ) {
            return;
          }
        }
        const icon = burner.ui?.icon || 'fa-fire';
        const tooltip = burner.ui?.tooltip || `消耗 ${burner.resourceName}`;

        html += `<button class="acu-dice-burner-btn" data-id="${escapeHtml(burner.id)}" title="${escapeHtml(tooltip)}">
          <i class="fa-solid ${escapeHtml(icon)}"></i>
        </button>`;
      });

      return html ? `<div class="acu-dice-burners">${html}</div>` : '';
    };

    // [新增] 资源消耗器点击处理函数
    const handleResourceBurnerClick = (burner: ResourceBurner, context: Record<string, number>) => {
      // 获取角色名：保留原始值用于数据操作，解析后的值用于显示
      const rawInitiatorName = panel.find('#dice-initiator-name').val().trim() || '<user>';
      const displayName = replaceUserPlaceholders(rawInitiatorName);

      // 获取当前资源值（使用原始值，让 getAttributeValue 内部判断是否是主角）
      let currentResource = getAttributeValue(rawInitiatorName, burner.resourceName);

      // 如果资源不存在，尝试初始化（仅限幸运值）
      if (currentResource === undefined || currentResource === null) {
        if (burner.resourceName === '幸运' || burner.resourceName.toLowerCase() === 'luck') {
          // CoC7 幸运值初始化：3D6 × 5
          const d1 = Math.floor(Math.random() * 6) + 1;
          const d2 = Math.floor(Math.random() * 6) + 1;
          const d3 = Math.floor(Math.random() * 6) + 1;
          const initialLuck = (d1 + d2 + d3) * 5;

          if (window.toastr) {
            window.toastr.info(`幸运值未设置，已随机生成: ${d1}+${d2}+${d3}=${d1 + d2 + d3} × 5 = ${initialLuck}`);
          }

          // 尝试写入初始值（使用原始值，让函数内部判断是否是主角）
          updateSingleAttribute(rawInitiatorName, burner.resourceName, 'set', initialLuck, {
            initValue: initialLuck,
          }).then(result => {
            if (result.success) {
              // 递归调用自己，现在资源已存在
              handleResourceBurnerClick(burner, context);
            } else {
              if (window.toastr) window.toastr.error(`初始化幸运值失败: ${result.error}`);
            }
          });
          return;
        } else {
          if (window.toastr) window.toastr.error(`找不到属性: ${burner.resourceName}`);
          return;
        }
      }

      currentResource = currentResource || 0;

      // 创建自定义对话框（传递原始名字用于数据操作）
      showBurnerInputDialog(burner, rawInitiatorName, currentResource, context);
    };

    // [新增] 显示燃运输入对话框
    const showBurnerInputDialog = (
      burner: ResourceBurner,
      rawCharName: string, // 原始角色名（如 <user>），用于数据操作
      currentResource: number,
      context: Record<string, number>,
    ) => {
      const currentThemeClass = `acu-theme-${config.theme}`;

      // 移除已存在的对话框
      $('.acu-burner-overlay').remove();

      // 计算建议消耗量（如果预设定义了 suggestedAmount 表达式）
      let suggestedValue = 1; // 默认为1
      let suggestedHint = '';
      if (burner.suggestedAmount) {
        const evalResult = evaluateCondition(burner.suggestedAmount, context);
        if (evalResult.success && typeof evalResult.value === 'number' && evalResult.value > 0) {
          // 向上取整（需要至少这么多资源才刚好通过），再除以ratio
          const rawNeeded = Math.ceil(evalResult.value / burner.ratio);
          if (burner.resourceOperation === 'add') {
            suggestedValue = Math.max(1, rawNeeded);
            suggestedHint = `建议: ${suggestedValue} (刚好通过)`;
          } else {
            const capped = Math.min(Math.max(1, rawNeeded), currentResource);
            suggestedValue = capped;
            if (rawNeeded > currentResource) {
              suggestedHint = `建议: ${suggestedValue} (已达上限，仍无法通过)`;
            } else {
              suggestedHint = `建议: ${suggestedValue} (刚好通过)`;
            }
          }
        }
      }

      const isAddMode = burner.resourceOperation === 'add';
      const actionVerb = isAddMode ? '增加' : '消耗';
      const maxAttr = isAddMode ? '' : `max="${currentResource}"`;

      // 从 context 提取骰子结果和目标值，用于效果预览
      const rollTotal = (context['$roll.total'] ?? context['$roll'] ?? 0) as number;
      const attrValue = (context['$attr'] ?? 0) as number;

      const dialog = $(`
        <div class="acu-edit-overlay acu-burner-overlay">
          <div class="acu-edit-dialog ${currentThemeClass}" style="max-width:350px;">
            <div class="acu-edit-title">
              <i class="fa-solid ${escapeHtml(burner.ui?.icon || 'fa-fire')}" style="color:${escapeHtml(burner.ui?.color || 'var(--acu-accent)')}"></i>
              ${escapeHtml(actionVerb)} ${escapeHtml(burner.resourceName)}
            </div>
            <div class="acu-settings-content" style="padding:15px;">
              <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
                <div style="flex:1;">
                  <label style="display:block;font-size:11px;color:var(--acu-text-sub);margin-bottom:4px;">${escapeHtml(actionVerb)}数量</label>
                  <input type="number" id="burner-amount" class="acu-input" value="${suggestedValue}" min="1" ${maxAttr} style="width:100%;">
                  ${suggestedHint ? `<div style="font-size:10px;color:var(--acu-accent);margin-top:2px;">${escapeHtml(suggestedHint)}</div>` : ''}
                </div>
                <div style="flex:1;">
                  <label style="display:block;font-size:11px;color:var(--acu-text-sub);margin-bottom:4px;">当前${isAddMode ? '数值' : '可用'}</label>
                  <div style="font-size:18px;font-weight:bold;color:var(--acu-success-text);">${currentResource}</div>
                </div>
              </div>
              <div id="burner-preview" style="padding:10px;background:var(--acu-card-bg);border-radius:6px;font-size:12px;">
                <div id="burner-before" style="color:var(--acu-text-sub);margin-bottom:6px;"></div>
                <div id="burner-after" style="font-weight:bold;"></div>
              </div>
            </div>
            <div class="acu-dialog-btns">
              <button class="acu-dialog-btn" id="burner-cancel"><i class="fa-solid fa-times"></i> 取消</button>
              <button class="acu-dialog-btn acu-btn-confirm" id="burner-confirm"><i class="fa-solid fa-check"></i> 确认${escapeHtml(actionVerb)}</button>
            </div>
          </div>
        </div>
      `);

      $('body').append(dialog);

      // 更新效果预览：显示燃运前后的骰子结果对比
      const updatePreview = () => {
        const amount = parseInt(dialog.find('#burner-amount').val() as string, 10) || 0;
        const effectValue = amount * burner.ratio;
        // 计算燃运后的目标值变化
        let newRoll = rollTotal;
        let newAttr = attrValue;
        if (burner.target === 'roll') {
          newRoll = burner.direction === 'decrease' ? rollTotal - effectValue : rollTotal + effectValue;
        } else if (burner.target === 'attribute') {
          newAttr = burner.direction === 'increase' ? attrValue + effectValue : attrValue - effectValue;
        }
        const beforePass = rollTotal <= attrValue;
        const afterPass = newRoll <= newAttr;
        const beforeColor = beforePass ? 'var(--acu-success-text)' : 'var(--acu-error-text)';
        const afterColor = afterPass ? 'var(--acu-success-text)' : 'var(--acu-error-text)';
        dialog
          .find('#burner-before')
          .html(
            `当前: <span style="color:${beforeColor};font-weight:bold;">${rollTotal} &lt;= ${attrValue} → ${beforePass ? '成功' : '失败'}</span>`,
          );
        dialog
          .find('#burner-after')
          .html(
            `燃运后: <span style="color:${afterColor}">${newRoll} &lt;= ${newAttr} → ${afterPass ? '成功' : '失败'}</span>` +
              `<span style="color:var(--acu-text-sub);font-weight:normal;margin-left:8px;">(${actionVerb} ${amount} 点${burner.resourceName})</span>`,
          );
      };
      updatePreview();

      dialog.find('#burner-amount').on('input', updatePreview);

      // 取消按钮
      dialog.on('click', '#burner-cancel', () => {
        dialog.remove();
      });

      // 点击遮罩关闭
      dialog.on('click', '.acu-burner-overlay', e => {
        if ($(e.target).hasClass('acu-burner-overlay')) {
          dialog.remove();
        }
      });

      // 确认按钮
      dialog.on('click', '#burner-confirm', () => {
        const amount = parseInt(dialog.find('#burner-amount').val() as string, 10);

        if (isNaN(amount) || amount <= 0) {
          if (window.toastr) window.toastr.warning('请输入有效的正整数');
          return;
        }

        // subtract 模式检查资源上限，add 模式不限
        if (!isAddMode && amount > currentResource) {
          if (window.toastr) window.toastr.error(`资源不足: 需要 ${amount}, 当前只有 ${currentResource}`);
          return;
        }

        dialog.remove();

        const op: 'add' | 'subtract' = isAddMode ? 'add' : 'subtract';
        // 执行资源变更（使用原始角色名，让函数内部判断是否是主角）
        updateSingleAttribute(rawCharName, burner.resourceName, op, amount).then(result => {
          if (!result.success) {
            if (window.toastr) window.toastr.error(`${actionVerb}资源失败: ${result.error}`);
            return;
          }

          if (window.toastr) window.toastr.success(`已${actionVerb} ${amount} 点 ${burner.resourceName}`);

          // 刷新属性显示（使用原始角色名）
          buildAttrButtons(rawCharName);

          // 应用效果并重新计算结果
          applyBurnerEffect(burner, amount);
        });
      });

      // 聚焦输入框
      dialog.find('#burner-amount').trigger('focus').trigger('select');
    };

    // [新增] 显示效果确认对话框
    const showEffectConfirmDialog = (options: {
      preset: AdvancedDicePreset;
      outcomeLabel: string;
      branchReasonText?: string;
      effects: ComputedEffect[];
      onConfirm: () => void;
      onCancel: () => void;
    }) => {
      const { preset, outcomeLabel, branchReasonText, effects, onConfirm, onCancel } = options;
      const currentThemeClass = `acu-theme-${config.theme}`;
      const uiCfg = preset.effectConfirmUi || {};
      const dialogTitle = uiCfg.title || '确认效果执行';
      const effectListTitle = uiCfg.effectListTitle || '即将应用以下效果:';
      const branchReasonLabel = uiCfg.branchReasonLabel || '分支依据';

      // 移除已存在的对话框
      $('.acu-confirm-overlay').remove();

      const dialog = $(`
        <div class="acu-edit-overlay acu-confirm-overlay">
          <div class="acu-edit-dialog ${currentThemeClass}" style="max-width:350px;">
            <div class="acu-edit-title">
              <i class="fa-solid fa-clipboard-check" style="color:var(--acu-accent)"></i>
              ${escapeHtml(dialogTitle)}
            </div>
            <div class="acu-settings-content" style="padding:15px;">
              <div style="margin-bottom:12px;font-weight:bold;font-size:14px;text-align:center;color:var(--acu-text-main);">
                ${escapeHtml(outcomeLabel)}
              </div>
              ${
                branchReasonText
                  ? `<div style="margin-bottom:12px;padding:8px 10px;background:var(--acu-card-bg);border-radius:6px;font-size:12px;line-height:1.45;color:var(--acu-text-sub);"><span style="color:var(--acu-text-main);font-weight:bold;">${escapeHtml(branchReasonLabel)}:</span> ${escapeHtml(branchReasonText)}</div>`
                  : ''
              }

              <div style="background:var(--acu-card-bg);border-radius:6px;padding:10px;margin-bottom:15px;max-height:200px;overflow-y:auto;">
                <div style="font-size:12px;color:var(--acu-text-sub);margin-bottom:8px;">${escapeHtml(effectListTitle)}</div>
                ${effects
                  .map(
                    e => `
                  <div style="padding:8px 0;border-bottom:1px solid var(--acu-border);font-size:13px;display:grid;grid-template-columns:1fr auto;gap:6px 10px;align-items:start;">
                    <div style="font-weight:bold;color:var(--acu-text-main);min-width:0;">${escapeHtml(e.resolvedTarget || e.target)}</div>
                    <div style="color:${e.computedValue >= 0 ? 'var(--acu-success-text)' : 'var(--acu-error-text)'};font-weight:bold;text-align:right;white-space:nowrap;">
                      ${e.computedValue > 0 ? '+' : ''}${e.computedValue}
                    </div>
                    <div style="grid-column:1 / -1;font-size:11px;color:var(--acu-text-sub);line-height:1.45;">
                      算式: ${escapeHtml(e.formula)} ｜ 掷值: ${escapeHtml(String(e.rolledValue))}<br>
                      数值: ${e.beforeValue === null || e.beforeValue === undefined ? '未知' : escapeHtml(String(e.beforeValue))}
                      →
                      ${e.afterValue === null || e.afterValue === undefined ? '未知' : escapeHtml(String(e.afterValue))}
                      ${e.conditionSummary ? `<br>条件: ${escapeHtml(e.conditionSummary)}` : ''}
                    </div>
                  </div>
                `,
                  )
                  .join('')}
              </div>
            </div>
            <div class="acu-dialog-btns">
              <button class="acu-dialog-btn" id="confirm-cancel"><i class="fa-solid fa-times"></i> 取消</button>
              <button class="acu-dialog-btn acu-btn-confirm" id="confirm-ok"><i class="fa-solid fa-check"></i> 确认执行</button>
            </div>
          </div>
        </div>
      `);

      $('body').append(dialog);

      // 取消按钮
      dialog.on('click', '#confirm-cancel', () => {
        dialog.remove();
        onCancel();
      });

      // 点击遮罩关闭 (视为取消)
      dialog.on('click', '.acu-confirm-overlay', e => {
        if ($(e.target).hasClass('acu-confirm-overlay')) {
          dialog.remove();
          onCancel();
        }
      });

      // 确认按钮
      dialog.on('click', '#confirm-ok', () => {
        dialog.remove();
        onConfirm();
      });

      // 自动聚焦确认按钮,方便键盘操作
      dialog.find('#confirm-ok').focus();
    };

    /**
     * [新增] 从效果输入框读取并计算效果值
     * @param outcomeName 结果等级名称 (用于匹配输入框)
     * @param defaultFormula 默认公式
     * @returns ComputedEffect 数组
     */
    const resolveEffectConditionPreview = (
      effect: Effect,
      effectContext: PendingEffectContext['context'],
      outcomeName: string,
    ): Pick<ComputedEffect, 'conditionExpr' | 'resolvedConditionExpr' | 'conditionPassed' | 'conditionSummary'> => {
      if (!effect.condition || effect.condition.trim() === '') {
        return {
          conditionExpr: '',
          resolvedConditionExpr: '',
          conditionPassed: true,
          conditionSummary: `命中【${outcomeName}】分支后直接生效`,
        };
      }

      const rawExpr = effect.condition.trim();
      const condContext: Record<string, number> = {
        $roll: effectContext.roll,
        '$roll.total': effectContext.roll,
        $attr: effectContext.attributeValue,
        $mod: effectContext.modifier,
        $dc: effectContext.dc,
      };
      const condResult = evaluateCondition(rawExpr, condContext);
      const passed =
        condResult.success &&
        (typeof condResult.value === 'number' ? condResult.value !== 0 : Boolean(condResult.value));

      const resolvedExpr = rawExpr
        .replace(/\$roll\.total/g, String(effectContext.roll))
        .replace(/\$roll/g, String(effectContext.roll))
        .replace(/\$attr/g, String(effectContext.attributeValue))
        .replace(/\$mod/g, String(effectContext.modifier))
        .replace(/\$dc/g, String(effectContext.dc));

      const summary = `命中【${outcomeName}】分支，条件 ${resolvedExpr}（原式:${rawExpr}）${passed ? '成立' : '不成立'}`;
      return {
        conditionExpr: rawExpr,
        resolvedConditionExpr: resolvedExpr,
        conditionPassed: passed,
        conditionSummary: summary,
      };
    };

    const computeEffectsFromInputs = (
      outcomeName: string,
      effects: Effect[],
      effectContext: PendingEffectContext['context'],
    ): ComputedEffect[] => {
      const results: ComputedEffect[] = [];

      // 查找对应结果等级的效果输入框
      const $inputGroup = panel.find(`.acu-effect-value-input[data-outcome="${outcomeName}"]`);
      const inputValue = $inputGroup.val()?.toString().trim() || '';

      for (const effect of effects) {
        // 如果用户输入了值,使用用户输入;否则使用效果定义的默认值
        const formula = inputValue || String(effect.value || '0');
        const parsedValue = parseEffectValueInput(formula, `Confirm ${outcomeName}/${effect.id}`);
        let computedValue = parsedValue.finalValue;
        const rolledValue = parsedValue.rolledValue;
        const displayText = parsedValue.valid
          ? `${parsedValue.formulaText} → ${rolledValue}`
          : `${parsedValue.formulaText} → 解析失败(按0处理)`;

        // 根据操作类型调整符号
        if (effect.operation === 'subtract') {
          computedValue = -Math.abs(computedValue);
        }

        const conditionPreview = resolveEffectConditionPreview(effect, effectContext, outcomeName);

        results.push({
          effectId: effect.id,
          target: effect.target,
          computedValue,
          rolledValue,
          formula: parsedValue.formulaText,
          displayText,
          ...conditionPreview,
        });
      }

      return results;
    };

    /**
     * [新增] 处理效果确认流程
     * 检查是否有需要确认的效果,显示弹窗并在确认后执行
     */
    const handleEffectConfirmation = async (pendingCtx: PendingEffectContext): Promise<void> => {
      const { preset, matchedOutcome, context: effectContext } = pendingCtx;
      if (!matchedOutcome.effects || matchedOutcome.effects.length === 0) {
        return;
      }

      if (activeConfirmEffectRun && activeConfirmEffectRun.runId !== pendingCtx.runId) {
        const staleRun = activeConfirmEffectRun;
        setHistoryEffectStateByRun(staleRun, {
          effectStatus: 'cancelled',
          effectError: '确认弹窗被新的检定覆盖，自动取消',
          effectTrace: ['已取消：被新操作覆盖'],
        });
        const seq = emitEffectRun({
          runId: staleRun.runId,
          status: 'cancelled',
          characterName: staleRun.context.characterName,
          attributeName: staleRun.context.attributeName,
          historyIndex: staleRun.historyIndex,
          effectResults: [],
          effectTrace: ['已取消：被新操作覆盖'],
          chainMode: getSecondaryTriggerMode(staleRun.preset),
          error: '确认弹窗被新的检定覆盖，自动取消',
          timestamp: Date.now(),
        });
        setHistoryEffectStateByRun(staleRun, { effectEventSeq: seq });
      }
      activeConfirmEffectRun = pendingCtx;

      // 检查是否有需要确认的效果 (默认 needsConfirm=true)
      const needsConfirmEffects = matchedOutcome.effects.filter(e => e.needsConfirm !== false);
      if (needsConfirmEffects.length === 0) {
        // 所有效果都不需要确认,直接暂存等待 MESSAGE_SENT 执行
        return;
      }

      // 计算效果值
      const aliasCandidates = [...(preset.effectsConfig?.allowedTargets || []), effectContext.attributeName].filter(
        (name, idx, arr) => Boolean(name) && arr.indexOf(name) === idx,
      );
      const computedEffects = computeEffectsFromInputs(matchedOutcome.name, needsConfirmEffects, effectContext).map(
        eff => {
          const resolvedTarget = resolveAttributeAliasName(
            effectContext.characterName,
            eff.target,
            aliasCandidates,
          ).name;
          const beforeValue = getAttributeValue(effectContext.characterName, eff.target, aliasCandidates);
          const afterValue = beforeValue === null || beforeValue === undefined ? null : beforeValue + eff.computedValue;
          return {
            ...eff,
            resolvedTarget: resolvedTarget || undefined,
            beforeValue,
            afterValue,
          };
        },
      );
      if (computedEffects.length === 0) {
        return;
      }

      // 显示确认弹窗
      showEffectConfirmDialog({
        preset,
        outcomeLabel: `${effectContext.attributeName} 检定: ${matchedOutcome.name}`,
        branchReasonText: pendingCtx.branchReasonText,
        effects: computedEffects,
        onConfirm: async () => {
          const confirmedRun: PendingEffectContext = {
            ...pendingCtx,
            effectOverrides: computedEffects,
            timestamp: Date.now(),
          };

          enqueueEffectRun(confirmedRun);
          setHistoryEffectStateByRun(pendingCtx, {
            effectStatus: 'confirmed',
          });
          const seq = emitEffectRun({
            runId: pendingCtx.runId,
            status: 'confirmed',
            characterName: effectContext.characterName,
            attributeName: effectContext.attributeName,
            historyIndex: pendingCtx.historyIndex,
            effectResults: [],
            effectTrace: ['已确认，等待提交'],
            chainMode: getSecondaryTriggerMode(pendingCtx.preset),
            timestamp: Date.now(),
          });
          setHistoryEffectStateByRun(pendingCtx, { effectEventSeq: seq });
          if (activeConfirmEffectRun?.runId === pendingCtx.runId) {
            activeConfirmEffectRun = null;
          }
          console.info(`[DICE] Effect run confirmed: ${pendingCtx.runId}`);

          // 确认后立即尝试执行（MESSAGE_SENT 可能已在弹窗显示前触发过，不会再次触发）
          if (confirmedRun.messageId) {
            await processPendingEffectRuns(confirmedRun.messageId);
          } else {
            console.info(`[DICE][META] confirm waiting MESSAGE_SENT for run=${confirmedRun.runId}`);
            await processPendingEffectRuns();
          }
        },
        onCancel: () => {
          setHistoryEffectStateByRun(pendingCtx, { effectStatus: 'cancelled' });
          const seq = emitEffectRun({
            runId: pendingCtx.runId,
            status: 'cancelled',
            characterName: effectContext.characterName,
            attributeName: effectContext.attributeName,
            historyIndex: pendingCtx.historyIndex,
            effectResults: [],
            effectTrace: ['已取消'],
            chainMode: getSecondaryTriggerMode(pendingCtx.preset),
            timestamp: Date.now(),
          });
          setHistoryEffectStateByRun(pendingCtx, { effectEventSeq: seq });
          if (activeConfirmEffectRun?.runId === pendingCtx.runId) {
            activeConfirmEffectRun = null;
          }
          console.info('[DICE] Effect execution cancelled by user');
        },
      });
    };

    /**
     * [新增] 二级效果触发点检测
     * 在效果执行完成后检查是否触发二级效果
     */
    const checkSecondaryEffects = async (
      preset: AdvancedDicePreset,
      effectResults: EffectResult[],
      context: { characterName: string; attributeName: string; attributeValue: number },
    ): Promise<EffectResult[]> => {
      return executeSecondaryEffectsChain(preset, effectResults, context);
    };

    // [新增] 应用消耗效果并更新 UI
    const applyBurnerEffect = (burner: ResourceBurner, amount: number) => {
      const effectValue = amount * burner.ratio;
      const sign = burner.direction === 'increase' ? 1 : -1;
      const totalChange = effectValue * sign;

      // 修改相应的输入框值或预设值
      // 注意: 这会改变下一次投骰的基础值，或者如果是 roll 修正则需要特殊处理
      // 这里我们选择直接修改输入框的值，并触发重新计算
      // 对于 target (roll), 我们无法直接修改已投出的结果，除非重新 evaluateOutcomes
      // 但 evaluateOutcomes 接受的是 outcomes 数组，不直接接受 rollTotal
      // 简单的做法是：修改 modifier 输入框 (对于 mod 修正) 或 target 输入框 (对于 dc 修正)
      // 对于 roll 修正，我们可以添加一个临时的 modifier

      // 为了简单可靠，我们先支持 mod 和 dc 的修改，因为它们对应输入框
      if (burner.target === 'mod') {
        const $modInput = panel.find('#dice-modifier');
        const currentMod = parseModifier($modInput.val().trim());
        const newMod = currentMod + totalChange;
        $modInput.val(newMod >= 0 ? `+${newMod}` : String(newMod));
        // 重新执行高级检定 (会重新投骰吗? 是的，performAdvancedCheck 会重新投骰)
        // 如果不想重新投骰，我们需要拆分 performAdvancedCheck
        // 但目前的架构是整体执行的。
        // 为了"改变结果"而不"重投"，我们需要一种机制来只更新结果判定逻辑
        // 这是一个架构限制。
        // 妥协方案: 消耗资源后，自动触发一次带修正的"重投" (即改变了修正值后的投骰)
        // 这符合"燃运"通常的逻辑：付出代价来获得更有利的结果
        performAdvancedCheck();
      } else if (burner.target === 'dc') {
        const $dcInput = panel.find('#dice-target');
        const currentDc = parseInt($dcInput.val().trim() || '0', 10);
        const newDc = currentDc + totalChange;
        $dcInput.val(newDc);
        performAdvancedCheck();
      } else if (burner.target === 'attribute') {
        // 修改属性值输入框
        const $attrInput = panel.find('#dice-attr-value');
        const currentAttr = parseInt($attrInput.val().trim() || '0', 10);
        const newAttr = currentAttr + totalChange;
        $attrInput.val(newAttr);
        performAdvancedCheck();
      } else if (burner.target === 'roll') {
        // 修改 roll 值通常意味着作为 modifier 加在最终结果上
        // 因为我们不能修改骰子本身的随机结果
        const $modInput = panel.find('#dice-modifier');
        const currentMod = parseModifier($modInput.val().trim());
        const newMod = currentMod + totalChange;
        $modInput.val(newMod >= 0 ? `+${newMod}` : String(newMod));
        performAdvancedCheck();
      }
    };

    // [新增] 高级检定执行函数
    const performAdvancedCheck = async function (options?: { isPushed?: boolean }) {
      if (!currentAdvancedPreset) return;

      const preset = currentAdvancedPreset;
      const initiatorName = panel.find('#dice-initiator-name').val().trim() || '<user>';
      const attrName = panel.find('#dice-attr-name').val().trim() || '自由检定';

      // [辅助函数] 解析 defaultValue (支持表达式)
      const resolveDefaultValue = function (
        defaultValue: number | string | undefined,
        context: Record<string, number>,
      ): number {
        if (defaultValue === undefined) return 0;
        if (typeof defaultValue === 'number') return defaultValue;
        // 字符串表达式,使用 evaluateFormula 解析
        const result = evaluateFormula(defaultValue, context);
        if (result === 0 && defaultValue !== '0' && String(defaultValue) !== '0') {
          if (window.toastr) {
            window.toastr.warning(`表达式 "${defaultValue}" 求值失败,使用默认值 0`);
          }
        }
        return result || 0;
      };

      // 1. 解析属性值 (用户输入优先,留空用 defaultValue)
      let attrValue = 0;
      const attrInputVal = panel.find('#dice-attr-value').val().trim();
      if (attrInputVal !== '') {
        attrValue = parseInt(attrInputVal, 10) || 0;
      } else if (preset.attribute?.mode === 'fixed' && preset.attribute?.key) {
        // 从表格读取
        attrValue = getAttributeValue(initiatorName, preset.attribute.key) || 0;
      } else {
        attrValue = resolveDefaultValue(preset.attribute?.defaultValue, {});
      }

      // 2. 解析DC (hidden 时跳过, 用户输入优先, 留空用 defaultValue)
      let dc = 0;
      if (!preset.dc?.hidden) {
        const dcInputVal = panel.find('#dice-target').val().trim();
        if (dcInputVal !== '') {
          dc = parseInt(dcInputVal, 10) || 0;
        } else if (preset.dc?.mode === 'fixed' && preset.dc?.value !== undefined) {
          dc = preset.dc.value;
        } else {
          dc = resolveDefaultValue(preset.dc?.defaultValue, { $attr: attrValue });
        }
      }

      // 3. 解析修正值 (hidden 时跳过, 用户输入优先, 留空用 defaultValue)
      let mod = 0;
      if (!preset.mod?.hidden) {
        const modStr = panel.find('#dice-modifier').val().trim();
        if (modStr !== '') {
          mod = parseModifier(modStr);
        } else {
          mod = resolveDefaultValue(preset.mod?.defaultValue, { $attr: attrValue });
        }
      }

      // 3.3 解析技能加值 (hidden 时跳过或预设未定义时跳过)
      let skillMod = 0;
      if (preset.skillMod && !preset.skillMod.hidden) {
        const skillModStr = panel.find('#dice-skill-mod').val().trim();
        if (skillModStr !== '') {
          skillMod = parseModifier(skillModStr);
        } else {
          skillMod = resolveDefaultValue(preset.skillMod?.defaultValue, { $attr: attrValue });
        }
      }

      // 3.5 计算属性调整值 (DND5e等规则使用)
      let attrMod = 0;
      if ('attribute' in preset && preset.attribute?.computeModifier) {
        // 使用 computeModifier 公式计算调整值
        const modFormula = preset.attribute.computeModifier;
        // 特殊处理 DND5e 调整值公式: floor(($attr - 10) / 2)
        if (modFormula.includes('floor') && modFormula.includes('$attr')) {
          attrMod = Math.floor((attrValue - 10) / 2);
        } else {
          attrMod = resolveDefaultValue(modFormula, { $attr: attrValue });
        }
      }

      // [新增] 收集自定义字段值
      const customValues: Record<string, number | string | boolean> = {};
      if ('customFields' in preset && Array.isArray(preset.customFields) && preset.customFields.length > 0) {
        const $customFields = panel.find('.acu-dice-custom-field');
        $customFields.each(function () {
          const $el = $(this);
          const id = $el.data('id');
          // 找到配置
          const fieldConfig = preset.customFields.find(f => f.id === id);
          if (!fieldConfig) return;

          let val: string | number | boolean;
          if (fieldConfig.type === 'toggle') {
            val = $el.prop('checked');
          } else if (fieldConfig.type === 'number') {
            const num = parseFloat($el.val() as string);
            val = isNaN(num) ? (fieldConfig.defaultValue as number) : num;
          } else if (fieldConfig.type === 'select') {
            // [修复] select 类型的值需要转换为数字（如果是数字字符串）
            const rawVal = $el.val() as string;
            const num = parseFloat(rawVal);
            val = isNaN(num) ? rawVal : num;
          } else {
            const rawVal = String($el.val() ?? '').trim();
            if (rawVal === '' && fieldConfig.defaultValue !== undefined && fieldConfig.defaultValue !== '') {
              val = fieldConfig.defaultValue as string | number | boolean;
            } else {
              val = rawVal;
            }
          }
          customValues['$' + id] = val; // 添加 $ 前缀以便在表达式中使用
        });
      }

      // [新增] 计算派生变量 (投骰前)
      const baseContext = {
        $attr: attrValue,
        $attrMod: attrMod,
        $skillMod: skillMod,
        $dc: dc,
        $mod: mod,
        ...customValues,
      };
      const derivedValues: Record<string, number> = {};
      if ('derivedVars' in preset && Array.isArray(preset.derivedVars) && preset.derivedVars.length > 0) {
        preset.derivedVars.forEach(spec => {
          const id = spec?.id?.trim();
          if (!id) return;
          const varName = id.startsWith('$') ? id : `$${id}`;
          const evalResult = evaluateCondition(spec.expr, { ...baseContext, ...derivedValues });
          if (!evalResult.success) {
            console.warn(`[DICE] 派生变量 ${varName} 计算失败:`, evalResult.error);
            derivedValues[varName] = 0;
            return;
          }
          const rawValue = evalResult.value;
          const numericValue = typeof rawValue === 'number' && Number.isFinite(rawValue) ? rawValue : rawValue ? 1 : 0;
          derivedValues[varName] = numericValue;
        });
      }
      const extraValues = { ...customValues, ...derivedValues };

      let diceExpression = preset.diceExpression;
      if ('dicePatches' in preset && Array.isArray(preset.dicePatches) && preset.dicePatches.length > 0) {
        const patchContext = { ...baseContext, ...derivedValues };
        const replacePatchTemplate = (template: string): string => {
          const varPattern = /\$[a-zA-Z_]\w*/g;
          return template.replace(varPattern, match => {
            const value = patchContext[match];
            return typeof value === 'number' && Number.isFinite(value) ? String(value) : '0';
          });
        };

        preset.dicePatches.forEach(patch => {
          if (!patch) return;
          if (patch.when) {
            const conditionResult = evaluateCondition(patch.when, patchContext);
            if (!conditionResult.success) {
              console.warn('[DICE] dicePatches 条件评估失败:', conditionResult.error);
              return;
            }
            const shouldApply =
              typeof conditionResult.value === 'number' ? conditionResult.value !== 0 : Boolean(conditionResult.value);
            if (!shouldApply) return;
          }

          const resolvedTemplate = replacePatchTemplate(patch.template ?? '');
          switch (patch.op) {
            case 'append':
              diceExpression = `${diceExpression}${resolvedTemplate}`;
              break;
            case 'prepend':
              diceExpression = `${resolvedTemplate}${diceExpression}`;
              break;
            case 'replace':
              diceExpression = resolvedTemplate;
              break;
          }
        });
      }

      // 4. 投骰
      const rollResult = rollComplexDiceExpression(diceExpression);
      const rollTotal = rollResult.total;

      // [新增] 投骰后重新计算派生变量（支持依赖 $roll.total 的派生变量，如 chaos = 6 - $roll.total）
      const postRollDerivedValues: Record<string, number> = {};
      if ('derivedVars' in preset && Array.isArray(preset.derivedVars) && preset.derivedVars.length > 0) {
        const postRollContext = {
          $roll: rollResult,
          '$roll.total': rollTotal, // 显式添加 $roll.total 作为独立变量
          ...baseContext,
          ...customValues,
        };
        preset.derivedVars.forEach(spec => {
          const id = spec?.id?.trim();
          if (!id) return;
          const varName = id.startsWith('$') ? id : `$${id}`;
          const evalResult = evaluateCondition(spec.expr, { ...postRollContext, ...postRollDerivedValues });
          if (!evalResult.success) {
            console.warn(`[DICE] 派生变量 ${varName} (投骰后) 计算失败:`, evalResult.error);
            postRollDerivedValues[varName] = 0;
            return;
          }
          const rawValue = evalResult.value;
          const numericValue = typeof rawValue === 'number' && Number.isFinite(rawValue) ? rawValue : rawValue ? 1 : 0;
          postRollDerivedValues[varName] = numericValue;
        });
      }

      // 5. 判定成功
      const isPushed = options?.isPushed ?? false;
      const context = {
        $roll: rollResult, // 传递整个对象
        '$roll.total': rollTotal, // 显式添加 $roll.total
        $isPushed: isPushed ? 1 : 0, // 孤注一掷标记 (1=是,0=否)
        ...baseContext,
        ...postRollDerivedValues, // 使用投骰后计算的派生变量
      };

      // 判定结果: 使用 outcomes 系统
      let outcomeText: string;
      let resultType: string;
      let isSuccess = false;
      let matchedOutcome: OutcomeLevel | undefined;
      let conditionExpr = '';
      let displayExprResult = true; // displayExpr 的计算结果，用于判断"成立/不成立"
      let branchReasonText = '';

      if ('outcomes' in preset && Array.isArray(preset.outcomes) && preset.outcomes.length > 0) {
        // 新系统: 使用 evaluateOutcomes
        matchedOutcome = evaluateOutcomes(preset.outcomes, context);
        // [修复] 保存原始结果，用于后续判断是否触发了 unmet
        const originalOutcome = matchedOutcome;
        // [修复] 保存用户要求的等级对应的 outcome，用于显示条件
        let requiredOutcome: OutcomeLevel | undefined;

        // 检查 outcomePolicy
        if (preset.outcomePolicy?.kind === 'minRank') {
          const requiredRankVarId = preset.outcomePolicy.requiredRankVarId;
          // [修复] customFields 的值存储在 context 中时带有 $ 前缀
          // 例如 requiredRankVarId='requiredRank'，但 context 中的键是 '$requiredRank'
          const varKey = requiredRankVarId.startsWith('$') ? requiredRankVarId : `$${requiredRankVarId}`;
          const requiredRank = context[varKey] ?? 0;
          // [修复] 使用 rank（成功等级：0-4）而不是 contestRank（对抗等级：20-100）
          // rank: 0=失败, 1=成功, 2=困难成功, 3=极难成功, 4=大成功
          // requiredRank: 0=无要求, 1=成功, 2=困难成功, 3=极难成功
          const actualRank = matchedOutcome.rank ?? 0;

          // [修复] 找到用户要求的等级对应的 outcome（用于显示条件）
          if (requiredRank > 0) {
            requiredOutcome = preset.outcomes.find(o => o.rank === requiredRank);
          }

          // [修复] 只在 rank 1-3（成功/困难成功/极难成功）区间应用最低成功等级判定
          // 大成功(rank=4)、大失败(rank=-1)、普通失败(rank=0) 不受影响
          if (actualRank >= 1 && actualRank < requiredRank) {
            const unmetOutcomeId = preset.outcomePolicy.unmetOutcomeId;
            const fallbackOutcome = preset.outcomes.find(o => o.id === unmetOutcomeId);
            if (fallbackOutcome) {
              matchedOutcome = fallbackOutcome;
            }
          }
        }

        outcomeText = matchedOutcome.name || '判定完成';
        // 使用 displayExpr（如果有）或 condition 作为显示表达式
        // [修复] 当触发 unmet 时，显示用户要求的等级的条件（如"极难成功"的条件）
        // 这样用户能看到"你需要达到这个条件才算成功"
        const isUnmet = matchedOutcome !== originalOutcome;
        const displaySourceOutcome = isUnmet && requiredOutcome ? requiredOutcome : matchedOutcome;
        const displayExpr = displaySourceOutcome.displayExpr ?? displaySourceOutcome.condition;

        // [修改] 替换所有上下文变量 (包括自定义变量)
        conditionExpr = displayExpr;
        // 先替换 $roll.hasTag() 方法调用 (必须在 $roll 之前)
        if (context.$roll && typeof context.$roll === 'object') {
          const roll = context.$roll as RollResult;
          conditionExpr = conditionExpr.replace(/\$roll\.hasTag\s*\(\s*['"]([^'"]+)['"]\s*\)/gi, (_match, tag) => {
            return (roll.tags ?? []).includes(tag) ? '成立' : '不成立';
          });
        }
        // 再替换标准变量 (注意: $roll.total 必须在 $roll 之前替换)
        conditionExpr = conditionExpr
          .replace(/\$roll\.total/g, String(rollTotal))
          .replace(/\$roll/g, String(rollTotal))
          .replace(/\$attrMod/g, String(attrMod))
          .replace(/\$skillMod/g, String(skillMod))
          .replace(/\$attr/g, String(attrValue))
          .replace(/\$dc/g, String(dc))
          .replace(/\$mod/g, String(mod));

        // 再替换自定义变量
        Object.keys(extraValues).forEach(key => {
          // 使用正则替换所有出现的变量 (注意转义 $ 符号)
          const safeKey = key.replace('$', '\\$');
          const regex = new RegExp(safeKey, 'g');
          conditionExpr = conditionExpr.replace(regex, String(extraValues[key]));
        });

        // [新增] 清理零值显示：隐藏 "+ 0" 模式，使公式更简洁
        // 例如 "3 + 2 + 13 + 0 >= 10" -> "3 + 2 + 13 >= 10"
        conditionExpr = conditionExpr
          .replace(/\s*\+\s*0(?=\s*[+\->=<]|\s*$)/g, '') // 移除 "+ 0" (后面跟运算符或结尾)
          .replace(/^\s*0\s*\+\s*/g, ''); // 移除开头的 "0 +"

        // 计算 displayExpr 的布尔值（用于判断"成立/不成立"）
        const displayExprEvalResult = evaluateCondition(displayExpr, context);
        displayExprResult =
          displayExprEvalResult.success &&
          (typeof displayExprEvalResult.value === 'number'
            ? displayExprEvalResult.value !== 0
            : Boolean(displayExprEvalResult.value));
        branchReasonText = `命中【${matchedOutcome.name}】分支，分支判定式 ${conditionExpr || displayExpr}，结果${displayExprResult ? '成立' : '不成立'}`;
        // 根据 priority 推断 resultType 和 isSuccess (用于 CSS 类名兼容)
        if (matchedOutcome.priority <= 10) {
          resultType = 'critSuccess';
          isSuccess = true;
        } else if (matchedOutcome.priority <= 30) {
          resultType = 'extremeSuccess';
          isSuccess = true;
        } else if (matchedOutcome.priority < 50) {
          resultType = 'success';
          isSuccess = true;
        } else if (matchedOutcome.priority === 50) {
          resultType = 'warning';
          isSuccess = false;
        } else if (matchedOutcome.priority < 90) {
          resultType = 'failure';
          isSuccess = false;
        } else {
          resultType = 'critFailure';
          isSuccess = false;
        }
      } else {
        // 兜底: 无法判定
        outcomeText = '未知';
        resultType = 'warning';
        branchReasonText = '未命中可识别分支，按默认路径处理';
        console.warn('[DICE] 预设缺少 outcomes');
      }

      // 5. 格式化输出
      const finalValue = rollTotal + attrValue + skillMod + mod;

      // 生成徽章样式 (优先使用 outcome.style.color,否则使用 CSS 类名)
      const badgeClass = getResultBadgeClass(resultType);
      const diceCfg = getDiceConfig();
      const hideDiceResultFromUser =
        diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
      const displayValue = hideDiceResultFromUser ? '？？' : rollTotal;
      const displayOutcomeText = hideDiceResultFromUser ? '' : outcomeText;

      // 构建显示表达式
      // 简单条件: 显示 conditionExpr (如 21 <= 64)
      // 复杂条件: 显示空字符串
      // 隐藏检定结果时: 显示空字符串
      const exprDisplay = isComplexCondition(conditionExpr) ? '' : conditionExpr;
      const displayExpr = hideDiceResultFromUser ? '' : exprDisplay;

      // 将按钮内容替换为结果显示
      const $rollBtn = panel.find('#dice-roll-btn');
      $rollBtn.html(`
        <div class="acu-dice-result-display">
          <span class="acu-dice-result-value">${displayValue}</span>
          <span class="acu-dice-result-target" style="font-size: 11px;">${escapeHtml(displayExpr)}</span>
          ${displayOutcomeText ? `<span class="${badgeClass}">${displayOutcomeText}</span>` : ''}
          <button class="dice-retry-btn acu-dice-retry-btn" title="重新投骰">
            <i class="fa-solid fa-rotate-right"></i>
          </button>
        </div>
      `);

      // 绑定重投按钮点击事件
      $rollBtn.off('click', '.dice-retry-btn').on('click', '.dice-retry-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        performAdvancedCheck();
      });

      // [新增] 渲染资源消耗器按钮 (燃运等)
      if (preset.resourceBurners && preset.resourceBurners.length > 0) {
        // 构建上下文：包含基础属性、派生变量、投骰结果
        const burnerContext = {
          ...context, // 复用已构建的 context (包含 $roll, $roll.total, $attr 等)
        };

        const burnersHtml = renderResourceBurnerButtons(preset, burnerContext, matchedOutcome, attrName);
        if (burnersHtml) {
          // 插入到结果显示区域
          const $burners = $(burnersHtml);
          $rollBtn.find('.acu-dice-result-display').append($burners);

          // 绑定资源消耗按钮点击事件
          $burners.find('.acu-dice-burner-btn').on('click', function (e) {
            e.stopPropagation();
            e.preventDefault();
            const burnerId = $(this).data('id');
            const burner = preset.resourceBurners?.find(b => b.id === burnerId);
            if (burner) {
              handleResourceBurnerClick(burner, burnerContext);
            }
          });
        }
      }

      // [新增] 渲染孤注一掷按钮 (Pushed Roll) — 基于 outcome ID 而非 isSuccess 二元值
      if (
        preset.pushedRoll?.enabled &&
        !isPushed && // 已经是孤注一掷则不可再push
        matchedOutcome &&
        !matchesCheckSelector(attrName, {
          namePatterns: { include: preset.pushedRoll.excludePatterns ?? [] },
        }) // 排除特定属性名
      ) {
        const outcomeId = matchedOutcome.id;
        // 判定优先级: blockedOutcomes > pushableOutcomes > legacy fallback (!isSuccess)
        const blockedOutcomes =
          preset.pushedRoll.blockedOutcomes ?? (preset.pushedRoll.blockOnCritFailure !== false ? ['crit_failure'] : []);
        const isBlocked = blockedOutcomes.includes(outcomeId);
        const isPushable = preset.pushedRoll.pushableOutcomes
          ? preset.pushedRoll.pushableOutcomes.includes(outcomeId)
          : !isSuccess; // legacy fallback
        if (isPushable && !isBlocked) {
          const $pushBtn = $(`
           <button class="acu-dice-burner-btn" title="孤注一掷：重掷一次，失败后果更严重">
             <i class="fa-solid fa-skull"></i>
           </button>
         `);
          // 优先插入到 burners 容器中（与燃运按钮并排），否则创建一个
          let $burnersContainer = $rollBtn.find('.acu-dice-burners');
          if (!$burnersContainer.length) {
            $burnersContainer = $('<span class="acu-dice-burners"></span>');
            $rollBtn.find('.acu-dice-result-display').append($burnersContainer);
          }
          $burnersContainer.append($pushBtn);
          $pushBtn.on('click', function (e) {
            e.stopPropagation();
            e.preventDefault();
            performAdvancedCheck({ isPushed: true });
          });
        }
      }

      // 生成输出文本 (使用模板系统)
      // judgeResultText 基于 displayExpr 的计算结果，表示显示的算式是否在数学上成立
      const judgeResultText = displayExprResult ? '成立' : '不成立';
      const template =
        'outputTemplate' in preset && preset.outputTemplate ? preset.outputTemplate : DEFAULT_OUTPUT_TEMPLATE;
      // 计算pushed标注: 按 outcome ID 查找 outcomeLabels，fallback 到 '*' 默认值
      const pushedLabel =
        isPushed && matchedOutcome
          ? (preset.pushedRoll?.outcomeLabels?.[matchedOutcome.id] ?? preset.pushedRoll?.outcomeLabels?.['*'] ?? '')
          : '';
      const outcomeTextRaw = (pushedLabel ? pushedLabel + '\n' : '') + (matchedOutcome?.outputText ?? '');
      // 格式化attrMod为带符号字符串 (如 +3 或 -1)
      const attrModStr = attrMod >= 0 ? `+${attrMod}` : String(attrMod);
      // 格式化skillMod为带符号字符串
      const skillModStr = skillMod >= 0 ? `+${skillMod}` : String(skillMod);

      // [新增] 条件文本变量：当值为0时隐藏整个片段（包括标签）
      // skillModText: 当skillMod非0时显示 "+技能加值+N"，否则为空
      const skillModText = skillMod !== 0 ? `+技能加值${skillModStr}` : '';
      // modText: 当mod非0时显示 "+额外加值+N"，否则为空
      const modText = mod !== 0 ? `+额外加值${mod >= 0 ? '+' + mod : mod}` : '';
      // attrModText: 当attrMod非0时显示 "(调整值+N)"，否则为空
      const attrModText = attrMod !== 0 ? `(调整值${attrModStr})` : '';

      // [新增] 将派生变量转换为 outputContext 格式（去掉 $ 前缀）
      const derivedOutputVars: Record<string, number> = {};
      Object.entries(postRollDerivedValues).forEach(([key, value]) => {
        const cleanKey = key.startsWith('$') ? key.slice(1) : key;
        derivedOutputVars[cleanKey] = value;
      });
      const customOutputVars: Record<string, string | number | boolean> = {};
      Object.entries(customValues).forEach(([key, value]) => {
        const cleanKey = key.startsWith('$') ? key.slice(1) : key;
        customOutputVars[cleanKey] = value;
      });

      // [新增] 计算后果效果变量
      const effectVars = computePendingEffectVariables(matchedOutcome?.effects);

      const outputContext = {
        initiator: initiatorName,
        attrName: `【${attrName}】`,
        attrValue: attrValue,
        attrMod: attrModStr,
        skillMod: skillModStr,
        // [新增] 条件文本变量（零值时隐藏整个片段）
        skillModText: skillModText,
        modText: modText,
        attrModText: attrModText,
        formula: diceExpression,
        roll: rollTotal,
        'roll.total': rollTotal, // [新增] 支持 $roll.total 语法
        dc: dc,
        mod: mod,
        attr: attrValue,
        conditionExpr: conditionExpr,
        judgeResult: judgeResultText,
        outcomeName: outcomeText,
        outcomeText: outcomeTextRaw,
        ...customOutputVars,
        ...derivedOutputVars, // [新增] 添加派生变量（如 chaos）
        ...effectVars, // [新增] 添加后果效果变量
      };
      // [修复] 先独立渲染 outcomeText，避免其中变量（如 $growthGain）残留
      outputContext.outcomeText = formatOutputTemplate(String(outputContext.outcomeText || ''), outputContext);
      const diceResultText = formatOutputTemplate(template, outputContext);
      smartInsertToTextarea(diceResultText, 'dice');

      // 构建检定结果对象
      const checkResult: AcuDice.CheckResult = {
        success: isSuccess,
        total: rollTotal,
        target: dc,
        outcomeText,
        attrName,
        criteria: 'advanced',
        isAutoTarget: false,
        formula: diceExpression,
      };

      // 添加到历史记录
      const detailId = `check_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const checkResultWithTimestamp = {
        ...checkResult,
        timestamp: Date.now(),
        detailId,
        initiatorName,
        historyType: 'check' as const,
        detailLines: [
          `发起者: ${initiatorName}`,
          `属性: ${attrName} (值=${attrValue})`,
          `公式: ${diceExpression}`,
          `掷骰: ${rollTotal}`,
          `目标: ${dc}`,
          `修正: attrMod=${attrModStr}, skillMod=${skillModStr}, mod=${mod >= 0 ? '+' + mod : mod}`,
          `判定: ${judgeResultText || outcomeText}`,
          `结果: ${outcomeText}`,
        ],
        ...(isPushed ? { isPushed: true } : {}),
      };
      checkHistory.push(checkResultWithTimestamp);
      if (checkHistory.length > MAX_HISTORY) {
        checkHistory.shift();
      }

      // 触发事件
      emitEvent('check', checkResultWithTimestamp);

      // 暂存后果
      // [修复] 检查属性名是否匹配 effectsConfig.triggerPatterns
      const shouldTriggerEffects =
        preset.effectsConfig &&
        matchedOutcome &&
        matchedOutcome.effects &&
        matchedOutcome.effects.length > 0 &&
        matchesCheckSelector(attrName, {
          namePatterns: { include: preset.effectsConfig.triggerPatterns },
        });

      if (shouldTriggerEffects) {
        const historyIndex = checkHistory.length - 1;
        const runId = `effect_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        const effectContext = {
          characterName: initiatorName,
          attributeName: attrName,
          attributeValue: attrValue,
          roll: rollResult.total,
          modifier: mod,
          dc,
        };

        const pendingCtx: PendingEffectContext = {
          runId,
          historyIndex,
          preset,
          matchedOutcome,
          context: effectContext,
          branchReasonText,
          timestamp: Date.now(),
        };

        setHistoryEffectState(historyIndex, {
          effectStatus: 'planned',
          effectRunId: runId,
          effectResults: [],
          effectError: undefined,
          effectTrace: undefined,
        });
        const plannedSeq = emitEffectRun({
          runId,
          status: 'planned',
          characterName: initiatorName,
          attributeName: attrName,
          historyIndex,
          effectResults: [],
          effectTrace: ['等待确认'],
          chainMode: getSecondaryTriggerMode(preset),
          timestamp: Date.now(),
        });
        setHistoryEffectState(historyIndex, { effectEventSeq: plannedSeq });

        // [新增] 检查是否有需要确认的效果
        const hasConfirmableEffects = matchedOutcome.effects.some(e => e.needsConfirm !== false);

        if (hasConfirmableEffects) {
          // 有需要确认的效果,显示确认弹窗 (异步处理)
          handleEffectConfirmation(pendingCtx);
          console.info(
            `[DICE] ${matchedOutcome.effects.length} effects pending user confirmation for ${initiatorName}`,
          );
        } else {
          // 所有效果都不需要确认,直接进入待执行队列
          enqueueEffectRun(pendingCtx);
          setHistoryEffectState(historyIndex, {
            effectStatus: 'confirmed',
          });
          const confirmedSeq = emitEffectRun({
            runId,
            status: 'confirmed',
            characterName: initiatorName,
            attributeName: attrName,
            historyIndex,
            effectResults: [],
            effectTrace: ['自动确认，等待提交'],
            chainMode: getSecondaryTriggerMode(preset),
            timestamp: Date.now(),
          });
          setHistoryEffectState(historyIndex, { effectEventSeq: confirmedSeq });
          console.info(`[DICE] Queued ${matchedOutcome.effects.length} auto-execute effects for ${initiatorName}`);
        }
      }

      if (preset.currentAttrAutoUpdate && preset.currentAttrAutoUpdate.enabled !== false) {
        const autoUpdate = preset.currentAttrAutoUpdate;
        const when = autoUpdate.when || 'always';
        const shouldApply =
          when === 'always' || (when === 'success' && isSuccess) || (when === 'failure' && !isSuccess);
        if (shouldApply) {
          const autoContext: Record<string, string | number | boolean> = {
            $roll: rollTotal,
            '$roll.total': rollTotal,
            $attr: attrValue,
            $dc: dc,
            $mod: mod,
            $success: isSuccess ? 1 : 0,
            ...customValues,
          };
          const resolvedExpr = resolveExpressionWithContext(autoUpdate.valueExpr, autoContext);
          const changeValue = parseModifier(resolvedExpr);
          const aliasCandidates = autoUpdate.aliasCandidates || [];
          const resolvedAlias = resolveAttributeAliasName(initiatorName, attrName, aliasCandidates).name;
          const targetAttr = resolvedAlias || attrName;
          const beforeValueRaw = getAttributeValue(initiatorName, attrName, aliasCandidates);
          const beforeValue =
            beforeValueRaw === null || beforeValueRaw === undefined ? (autoUpdate.initValue ?? 0) : beforeValueRaw;

          let previewAfterValue = beforeValue;
          if (autoUpdate.operation === 'add') {
            previewAfterValue = beforeValue + changeValue;
          } else if (autoUpdate.operation === 'subtract') {
            previewAfterValue = beforeValue - changeValue;
          } else {
            previewAfterValue = changeValue;
          }
          const minValue = autoUpdate.min ?? 0;
          const maxValue = autoUpdate.max ?? Infinity;
          previewAfterValue = Math.max(minValue, Math.min(maxValue, previewAfterValue));
          const previewDelta = previewAfterValue - beforeValue;

          const computedAutoEffect: ComputedEffect = {
            effectId: `auto_${autoUpdate.operation}`,
            target: attrName,
            resolvedTarget: targetAttr,
            computedValue: previewDelta,
            rolledValue: changeValue,
            formula: resolvedExpr || '0',
            displayText: `${resolvedExpr || '0'} → ${changeValue}`,
            beforeValue,
            afterValue: previewAfterValue,
            conditionSummary: `命中【${matchedOutcome?.name || outcomeText}】分支后触发自动填表`,
          };

          const confirmed = await new Promise<boolean>(resolve => {
            showEffectConfirmDialog({
              preset,
              outcomeLabel: `${attrName} 检定: ${matchedOutcome?.name || outcomeText}`,
              branchReasonText,
              effects: [computedAutoEffect],
              onConfirm: () => resolve(true),
              onCancel: () => resolve(false),
            });
          });

          if (confirmed) {
            const updateResult = await updateSingleAttribute(
              initiatorName,
              attrName,
              autoUpdate.operation,
              changeValue,
              {
                initValue: autoUpdate.initValue,
                min: autoUpdate.min,
                max: autoUpdate.max,
                aliasCandidates,
              },
            );
            if (updateResult.success) {
              const finalAttr = updateResult.resolvedAttrName || attrName;
              const delta = updateResult.newValue - updateResult.oldValue;
              const changeLabel =
                String(autoUpdate.changeLabel || '').trim() ||
                (autoUpdate.operation === 'add' ? '增加' : autoUpdate.operation === 'subtract' ? '减少' : '设为');
              const exprRaw = String(resolvedExpr || '').trim();
              const rolledText = String(changeValue);
              const exprNormalized = exprRaw.replace(/\s+/g, '');
              const exprWithRoll =
                exprRaw && exprNormalized !== rolledText ? `${exprRaw}=${rolledText}` : exprRaw || rolledText;

              const settledContext: Record<string, string | number | undefined> = {
                attr: `【${finalAttr}】`,
                attrPlain: finalAttr,
                old: updateResult.oldValue,
                new: updateResult.newValue,
                delta,
                expr: exprRaw || rolledText,
                rolled: changeValue,
                operation: autoUpdate.operation,
                changeLabel,
              };

              const settledTemplate = String(autoUpdate.outputTextTemplate || '').trim();
              const settledLine =
                settledTemplate !== ''
                  ? formatOutputTemplate(settledTemplate, settledContext).trim()
                  : `已填表：${finalAttr}从${updateResult.oldValue}变为${updateResult.newValue}，变化${changeLabel}${exprWithRoll}`;

              const autoRunId = `autoupdate_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              const injected = injectEffectLinesIntoTextarea(autoRunId, [settledLine]);
              if (!injected) {
                smartInsertToTextarea(settledLine, 'dice');
              }

              // 同步更新当前面板显示（属性输入框 + 快捷属性按钮）
              const currentAttrName = String(panel.find('#dice-attr-name').val() || '').trim();
              if (currentAttrName === attrName || currentAttrName === finalAttr) {
                panel.find('#dice-attr-value').val(String(updateResult.newValue)).trigger('change');
              }
              buildAttrButtons(initiatorName);

              if (window.toastr) {
                window.toastr.success(
                  `已完成填表更新 ${finalAttr}: ${updateResult.oldValue} -> ${updateResult.newValue}`,
                );
              }
            } else if (window.toastr) {
              window.toastr.warning(`自动更新属性失败: ${updateResult.error || '未知错误'}`);
            }
          } else if (window.toastr) {
            window.toastr.info('已取消本次自动填表');
          }
        }
      }

      if (onResult) {
        onResult(checkResult);
      }
    };

    // [新增] 自定义模式掷骰逻辑
    const performCustomRoll = function () {
      const $btn = panel.find('#dice-roll-btn');

      // 读取自定义模式字段
      const diceExpr = panel.find('#custom-dice-expr').val().trim() || '1d100';
      const judgeMode = panel.find('#custom-judge-mode').val() as string;
      const targetValueStr = panel.find('#custom-target-value').val().trim();
      const initiatorName = panel.find('#dice-initiator-name').val().trim() || '<user>';
      const attrName = panel.find('#dice-attr-name').val().trim() || '自由检定';

      // 解析目标值
      const expectedValue = calculateDiceExpectedValue(diceExpr);
      const autoTargetValue = Number.isFinite(expectedValue) ? Math.floor(expectedValue) : null;
      const targetValue = targetValueStr !== '' ? parseInt(targetValueStr, 10) : autoTargetValue;
      const hasJudgement = judgeMode !== 'none' && targetValue !== null && !isNaN(targetValue);

      // 执行掷骰 - 使用 rollComplexDiceExpression 支持复合表达式如 2d6+33
      const rollResult = rollComplexDiceExpression(diceExpr);
      if (isNaN(rollResult.total)) {
        if (window.toastr) window.toastr.error(`骰子语法错误: ${diceExpr}`);
        return;
      }

      const rollTotal = rollResult.total;

      // 判定结果
      let isSuccess = false;
      let judgeResultText = '';

      if (hasJudgement) {
        switch (judgeMode) {
          case '>=':
            isSuccess = rollTotal >= targetValue;
            judgeResultText = isSuccess ? '成功' : '失败';
            break;
          case '<=':
            isSuccess = rollTotal <= targetValue;
            judgeResultText = isSuccess ? '成功' : '失败';
            break;
          case '>':
            isSuccess = rollTotal > targetValue;
            judgeResultText = isSuccess ? '成功' : '失败';
            break;
          case '<':
            isSuccess = rollTotal < targetValue;
            judgeResultText = isSuccess ? '成功' : '失败';
            break;
          default:
            judgeResultText = '';
        }
      }

      // 生成输出文本 - 使用与内置预设一致的 meta 标签格式
      const displayInitiator = replaceUserPlaceholders(initiatorName);
      const displayAttrName = attrName || '自由检定';
      let outputText: string;

      if (hasJudgement) {
        const conditionExpr = `${rollTotal} ${judgeMode} ${targetValue}`;
        const judgeResultCN = isSuccess ? '成立' : '不成立';
        outputText = `<meta:检定结果>\n元叙事：${displayInitiator} 发起了 【${displayAttrName}】 检定，${diceExpr}=${rollTotal}，判定 ${conditionExpr}？${judgeResultCN}，判定为【${judgeResultText}】\n</meta:检定结果>`;
      } else {
        // 无判定模式
        outputText = `<meta:检定结果>\n元叙事：${displayInitiator} 发起了 【${displayAttrName}】 检定，${diceExpr}=${rollTotal}\n</meta:检定结果>`;
      }

      // 插入到输入框
      smartInsertToTextarea(outputText, 'dice');

      // 生成结果显示
      const badgeClass = hasJudgement
        ? isSuccess
          ? 'acu-dice-result-badge success'
          : 'acu-dice-result-badge failure'
        : '';
      const diceCfg = getDiceConfig();
      const hideDiceResultFromUser =
        diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
      const displayValue = hideDiceResultFromUser ? '？？' : rollTotal;
      const displayOutcome = hideDiceResultFromUser ? '' : judgeResultText;

      // 更新按钮显示结果
      $btn.html(`
        <div class="acu-dice-result-display">
          <span class="acu-dice-result-value">${displayValue}</span>
          ${hasJudgement && displayOutcome ? `<span class="${badgeClass}">${displayOutcome}</span>` : ''}
          <button class="dice-retry-btn acu-dice-retry-btn" title="重新投骰">
            <i class="fa-solid fa-rotate-right"></i>
          </button>
        </div>
      `);

      // 绑定重投按钮
      $btn.off('click', '.dice-retry-btn').on('click', '.dice-retry-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        performCustomRoll();
      });

      // 构建检定结果对象
      const checkResult: AcuDice.CheckResult = {
        success: isSuccess,
        total: rollTotal,
        target: targetValue ?? 0,
        outcomeText: judgeResultText,
        attrName,
        criteria: 'custom',
        isAutoTarget: false,
        formula: diceExpr,
      };

      // 添加到历史记录
      const detailId = `check_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const checkResultWithTimestamp = {
        ...checkResult,
        timestamp: Date.now(),
        detailId,
        initiatorName,
        historyType: 'check' as const,
        detailLines: [
          `发起者: ${initiatorName}`,
          `属性: ${attrName}`,
          `公式: ${diceExpr}`,
          `掷骰: ${rollTotal}`,
          hasJudgement ? `判定: ${rollTotal} ${judgeMode} ${targetValue}` : '判定: 无',
          hasJudgement ? `结果: ${judgeResultText}` : '结果: 仅掷骰',
        ],
      };
      checkHistory.push(checkResultWithTimestamp);
      if (checkHistory.length > MAX_HISTORY) {
        checkHistory.shift();
      }

      // 触发事件
      emitEvent('check', checkResultWithTimestamp);

      if (onResult) {
        onResult(checkResult);
      }
    };

    let lastDiceRollAt = 0;
    // 投骰逻辑函数（可被按钮点击和重投按钮调用）
    const performDiceRoll = function () {
      const $btn = panel.find('#dice-roll-btn');
      const now = Date.now();
      if (now - lastDiceRollAt < 100) return;
      lastDiceRollAt = now;
      if ($btn.prop('disabled')) return;

      // 锁定按钮防止连点
      $btn.prop('disabled', true).addClass('disabled');
      setTimeout(() => {
        $btn.prop('disabled', false).removeClass('disabled');
      }, 100);

      // [新增] 如果使用高级预设,调用专用检定函数
      if (currentAdvancedPreset) {
        performAdvancedCheck();
        return;
      }

      // [新增] 如果处于自定义模式,使用自定义掷骰逻辑
      if (panel.find('#acu-dice-custom-mode-fields').is(':visible')) {
        performCustomRoll();
        return;
      }

      const formula = panel.find('#dice-formula').val().trim() || '1d100';
      const modStr = panel.find('#dice-modifier').val().trim() || '0';
      const mod = parseModifier(modStr);
      const attrName = panel.find('#dice-attr-name').val().trim() || '自由检定';
      const criteria = panel.find('#dice-success-criteria').val() || 'lte';
      const difficulty = panel.find('#dice-difficulty').val() || 'normal';

      // 判断规则类型
      const isDND = criteria === 'gte';

      // 获取骰子配置（根据规则类型读取不同配置）
      const diceCfg = getDiceConfig();
      const hardDiv = diceCfg.difficultSuccessDiv || 2;
      const extremeDiv = diceCfg.hardSuccessDiv || 5;
      // COC: 大成功 ≤ critSuccessMax, 大失败 ≥ critFailMin
      // DND: 大成功 ≥ dndCritSuccess, 大失败 ≤ dndCritFail
      const critSuccessMax = isDND ? diceCfg.dndCritFail || 1 : diceCfg.critSuccessMax || 5;
      const critFailMin = isDND ? diceCfg.dndCritSuccess || 20 : diceCfg.critFailMin || 96;

      // 目标值计算（COC 和 DND 不同）
      let targetInputVal = panel.find('#dice-target').val().trim();
      let attrInputVal = panel.find('#dice-attr-value').val().trim();
      let attrValue = attrInputVal !== '' ? parseInt(attrInputVal, 10) : 0;
      let target;
      let isAutoTarget = false;

      // 辅助函数：根据骰子公式计算最大值的一半
      const getDefaultTarget = formulaStr => {
        const match = formulaStr.match(/(\d+)d(\d+)/i);
        if (match) {
          const maxRoll = parseInt(match[1], 10) * parseInt(match[2], 10);
          return Math.round(maxRoll / 2);
        }
        return 50;
      };

      if (targetInputVal !== '') {
        // 用户手动输入了目标值/DC
        const parsedTarget = parseInt(targetInputVal, 10);
        target = !Number.isNaN(parsedTarget) ? parsedTarget : getDefaultTarget(formula);
      } else if (isDND) {
        // DND 模式：留空时 DC = 10（中等难度）
        target = 10;
        isAutoTarget = true;
      } else {
        // COC 模式：留空时目标值 = 属性值，若属性值也空则取骰子最大值的一半
        if (attrValue > 0) {
          target = attrValue;
          isAutoTarget = true;
        } else {
          target = getDefaultTarget(formula);
          isAutoTarget = true;
        }
      }

      const result = rollDice(formula);
      const finalValue = result.total + mod;

      // 根据规则和难度等级计算
      let requiredTarget = target;
      let difficultyLabel = '';
      let difficultyDiv = 1;

      // DND 模式忽略难度等级
      if (!isDND) {
        switch (difficulty) {
          case 'hard':
            requiredTarget = Math.floor(target / hardDiv);
            difficultyLabel = '困难';
            difficultyDiv = hardDiv;
            break;
          case 'extreme':
            requiredTarget = Math.floor(target / extremeDiv);
            difficultyLabel = '极难';
            difficultyDiv = extremeDiv;
            break;
          case 'critical':
            requiredTarget = critSuccessMax;
            difficultyLabel = '大成功';
            break;
          default:
            difficultyLabel = '';
            break;
        }
      }

      // 判定结果
      let isCritSuccess = false;
      let isCritFailure = false;
      let isSuccess = false;
      let outcomeText = '';
      let outcomeClass = '';

      // 大成功/大失败判定（最高优先级）
      if (isDND) {
        // DND: 大成功 ≥ 20，大失败 ≤ 1
        isCritSuccess = finalValue >= critFailMin; // 复用 critFailMin 作为 DND 大成功阈值
        isCritFailure = finalValue <= critSuccessMax; // 复用 critSuccessMax 作为 DND 大失败阈值
      } else {
        // COC: 大成功 ≤ 5，大失败 ≥ 96
        isCritSuccess = finalValue <= critSuccessMax;
        isCritFailure = finalValue >= critFailMin;
      }

      // 根据规则判断成功/失败
      if (isDND) {
        isSuccess = finalValue >= requiredTarget;
      } else {
        isSuccess = finalValue <= requiredTarget;
      }

      // 确定最终结果文本
      if (isCritSuccess) {
        outcomeText = '大成功！';
        outcomeClass = 'success';
        isSuccess = true;
      } else if (isCritFailure) {
        outcomeText = '大失败！';
        outcomeClass = 'failure';
        isSuccess = false;
      } else if (isSuccess) {
        if (isDND) {
          outcomeText = '成功';
        } else if (difficulty === 'hard') {
          outcomeText = '困难成功';
        } else if (difficulty === 'extreme') {
          outcomeText = '极难成功';
        } else {
          // 普通难度下，检查是否达成更高成就
          const extremeTarget = Math.floor(target / extremeDiv);
          const hardTarget = Math.floor(target / hardDiv);
          if (finalValue <= extremeTarget) {
            outcomeText = '极难成功';
          } else if (finalValue <= hardTarget) {
            outcomeText = '困难成功';
          } else {
            outcomeText = '成功';
          }
        }
        outcomeClass = 'success';
      } else {
        outcomeText = '失败';
        outcomeClass = 'failure';
      }

      const criteriaSymbol = isDND ? '≥' : '≤';
      const hideDiceResultFromUser =
        diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
      const displayValue = hideDiceResultFromUser ? '？？' : finalValue;
      const displayOutcomeText = hideDiceResultFromUser ? '' : outcomeText;

      // 确定结果类型和样式
      let resultType;
      if (isCritSuccess) {
        resultType = 'critSuccess';
      } else if (isCritFailure) {
        resultType = 'critFailure';
      } else if (isSuccess) {
        if (difficulty === 'extreme' || (difficulty === 'normal' && finalValue <= Math.floor(target / extremeDiv))) {
          resultType = 'extremeSuccess';
        } else if (difficulty === 'hard' || (difficulty === 'normal' && finalValue <= Math.floor(target / hardDiv))) {
          resultType = 'success';
        } else {
          resultType = 'warning';
        }
      } else {
        resultType = 'failure';
      }

      const badgeClass = getResultBadgeClass(resultType);

      // 构建显示用的条件表达式（隐藏时为空）
      const displayConditionExpr = hideDiceResultFromUser ? '' : conditionExpr;

      // 将按钮内容替换为结果显示（居中布局，旋转箭头在结果后面）
      const $rollBtn = panel.find('#dice-roll-btn');
      $rollBtn.html(`
        <div class="acu-dice-result-display">
          <span class="acu-dice-result-value">${displayValue}</span>
          ${displayConditionExpr ? `<span class="acu-dice-result-target">${displayConditionExpr}</span>` : ''}
          ${displayOutcomeText ? `<span class="${badgeClass}">${displayOutcomeText}</span>` : ''}
          <button class="dice-retry-btn acu-dice-retry-btn" title="重新投骰">
            <i class="fa-solid fa-rotate-right"></i>
          </button>
        </div>
      `);

      // 绑定重投按钮点击事件（使用事件委托，因为按钮内容会动态更新）
      $rollBtn.off('click', '.dice-retry-btn').on('click', '.dice-retry-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        // 直接调用投骰逻辑函数
        performDiceRoll();
      });

      // 生成 Prompt 文本
      const initiatorName = panel.find('#dice-initiator-name').val().trim() || '<user>';

      // 构建简单条件表达式（用于界面显示）
      let conditionExpr = '';
      if (isCritSuccess) {
        if (isDND) {
          conditionExpr = `${finalValue}≥${critFailMin}`;
        } else {
          conditionExpr = `${finalValue}≤${critSuccessMax}`;
        }
      } else if (isCritFailure) {
        if (isDND) {
          conditionExpr = `${finalValue}≤${critSuccessMax}`;
        } else {
          conditionExpr = `${finalValue}≥${critFailMin}`;
        }
      } else if (isDND) {
        conditionExpr = `${finalValue}≥${requiredTarget}`;
      } else {
        conditionExpr = `${finalValue}≤${requiredTarget}`;
      }

      // 构建详细判定表达式（用于输出文本）
      let judgeExpr = '';
      if (isCritSuccess) {
        if (isDND) {
          judgeExpr = `${finalValue}≥${critFailMin}`;
        } else {
          judgeExpr = `${finalValue}≤${critSuccessMax}`;
        }
      } else if (isCritFailure) {
        if (isDND) {
          judgeExpr = `${finalValue}≤${critSuccessMax}`;
        } else {
          judgeExpr = `${finalValue}≥${critFailMin}`;
        }
      } else if (isDND) {
        // DND 模式
        if (isSuccess) {
          judgeExpr = `需${criteriaSymbol}${requiredTarget}，${finalValue}≥${requiredTarget}`;
        } else {
          judgeExpr = `需${criteriaSymbol}${requiredTarget}，${finalValue}<${requiredTarget}`;
        }
      } else if (difficulty === 'critical') {
        // COC 难度设为大成功但没达成
        judgeExpr = `需≤${critSuccessMax}，${finalValue}>${critSuccessMax}`;
      } else if (difficulty !== 'normal') {
        // COC 困难或极难
        if (isSuccess) {
          judgeExpr = `需≤${target}/${difficultyDiv}，${finalValue}≤${requiredTarget}`;
        } else {
          judgeExpr = `需≤${target}/${difficultyDiv}，${finalValue}>${requiredTarget}`;
        }
      } else {
        // COC 普通难度
        if (isSuccess) {
          const extremeTarget = Math.floor(target / extremeDiv);
          const hardTarget = Math.floor(target / hardDiv);
          if (finalValue <= extremeTarget) {
            judgeExpr = `需≤${target}，${finalValue}≤${target}/${extremeDiv}`;
          } else if (finalValue <= hardTarget) {
            judgeExpr = `需≤${target}，${finalValue}≤${target}/${hardDiv}`;
          } else {
            judgeExpr = `需≤${target}，${finalValue}≤${target}`;
          }
        } else {
          judgeExpr = `需≤${target}，${finalValue}>${target}`;
        }
      }

      // 构建统一格式的检定结果文本
      const metaContent = `元叙事：${initiatorName}发起了【${attrName}】检定，掷出${finalValue}，${judgeExpr}，【${outcomeText}】`;
      const diceResultText = `<meta:检定结果>\n${metaContent}\n</meta:检定结果>`;
      smartInsertToTextarea(diceResultText, 'dice');

      // 构建检定结果对象
      const checkResult: AcuDice.CheckResult = {
        success: isSuccess,
        total: finalValue,
        target,
        outcomeText,
        attrName,
        criteria,
        isAutoTarget,
        formula,
      };

      // 添加到历史记录
      const detailId = `check_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const checkResultWithTimestamp = {
        ...checkResult,
        timestamp: Date.now(),
        detailId,
        initiatorName,
        historyType: 'check' as const,
        detailLines: [
          `发起者: ${initiatorName}`,
          `属性: ${attrName}`,
          `公式: ${formula}`,
          `掷骰+修正: ${result.total} ${mod >= 0 ? '+' : ''}${mod} = ${finalValue}`,
          `目标: ${requiredTarget} (${isAutoTarget ? '自动计算' : '手动输入'})`,
          `成功标准: ${criteria === 'gte' ? '>=' : '<='}${requiredTarget}`,
          difficultyLabel ? `难度: ${difficultyLabel}` : '难度: 普通',
          `判定详情: ${judgeExpr}`,
          `结果: ${outcomeText}`,
        ],
      };
      checkHistory.push(checkResultWithTimestamp);
      if (checkHistory.length > MAX_HISTORY) {
        checkHistory.shift();
      }

      // 触发事件
      emitEvent('check', checkResultWithTimestamp);

      if (onResult) {
        onResult(checkResult);
      }
    };

    // 绑定按钮点击事件
    panel.find('#dice-roll-btn').click(function () {
      performDiceRoll();
    });

    // 切换到对抗检定（标题栏图标）
    panel.find('#dice-switch-contest-top').click(function () {
      const targetInput = panel.find('#dice-target').val().trim();
      const attrValueInput = panel.find('#dice-attr-value').val().trim();
      const currentDice = panel.find('#dice-formula').val() || '1d100';
      const initiatorNameVal = panel.find('#dice-initiator-name').val().trim();
      closePanel();
      showContestPanel({
        // 只有用户实际输入了非默认值才传递，否则留空让 placeholder 生效
        initiatorName: initiatorNameVal && initiatorNameVal !== '<user>' ? initiatorNameVal : '',
        initiatorValue: attrValueInput !== '' ? parseInt(attrValueInput, 10) : undefined,
        diceType: currentDice,
      });
    });
    panel.find('#dice-history-btn').click(function (e) {
      e.stopPropagation();
      showGlobalDiceHistoryDialog();
    });
    // 关闭
    const closePanel = () => {
      overlay.remove();
      panel.remove();
    };
    panel.on('click', e => {
      e.stopPropagation();
    });
    overlay.click(closePanel);
    panel.find('.acu-dice-close').click(closePanel);
    // 齿轮设置按钮点击 - 调用高级检定管理
    panel.find('.acu-dice-config-btn').click(function (e) {
      e.stopPropagation();
      showAdvancedPresetManager({ fromDicePanel: true });
    });
  };

  // 判定成功等级（供对抗检定面板和 API contest() 共用）
  const getSuccessLevel = function (roll: number, target: number, sides: number) {
    if (sides === 100) {
      if (roll <= 5) return { level: 3, name: '大成功', color: 'var(--acu-crit-success-text)' };
      if (roll >= 96) return { level: -1, name: '大失败', color: 'var(--acu-crit-failure-text)' };
      if (roll <= Math.floor(target / 5))
        return { level: 2, name: '极难成功', color: 'var(--acu-extreme-success-text)' };
      if (roll <= Math.floor(target / 2)) return { level: 1, name: '困难成功', color: 'var(--acu-success-text)' };
      if (roll <= target) return { level: 0, name: '普通成功', color: 'var(--acu-warning-text)' };
      return { level: -1, name: '失败', color: 'var(--acu-failure-text)' };
    } else {
      if (roll === 20) return { level: 3, name: '大成功', color: 'var(--acu-crit-success-text)' };
      if (roll === 1) return { level: -1, name: '大失败', color: 'var(--acu-crit-failure-text)' };
      if (roll >= target) return { level: 0, name: '成功', color: 'var(--acu-success-text)' };
      return { level: -1, name: '失败', color: 'var(--acu-failure-text)' };
    }
  };

  // [新增] 显示对抗检定面板
  const showContestPanel = (options = {}) => {
    const { $ } = getCore();
    $('.acu-dice-panel, .acu-dice-overlay, .acu-contest-panel, .acu-contest-overlay').remove();

    const config = getConfig();
    const diceCfg = getDiceConfig();

    // 读取保存的骰子类型，必须是有效公式
    let savedDiceType = diceCfg.lastDiceType || '1d100';
    if (Number.isNaN(rollComplexDiceExpression(savedDiceType).total)) {
      savedDiceType = '1d100';
    }

    // 修复：正确接收所有传入参数
    const opponentName = options.opponentName || '';
    const diceType = options.diceType || savedDiceType;
    const passedInitiatorName = options.initiatorName || '';
    const passedInitiatorValue = options.initiatorValue;
    const passedOpponentValue = options.opponentValue;

    const rawData = cachedRawData || getTableData();
    let playerAttrs = [];
    let opponentAttrs = [];

    // [新增] 构建角色下拉列表（主角真名 + 重要角色表）
    let characterList: string[] = [];
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (!sheet || !sheet.name || !sheet.content) continue;
        if (isNpcTableName(sheet.name)) {
          for (let i = 1; i < sheet.content.length; i++) {
            const row = sheet.content[i];
            if (row && row[1]) characterList.push(row[1]);
          }
        }
        if (sheet.name?.includes('主角') && sheet.content[1]) {
          const row = sheet.content[1];
          if (row[1]) characterList.unshift(getDisplayName(String(row[1])));
        }
      }
    }
    // [新增] 构建属性下拉列表
    let contestAttrList = [];
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (sheet && sheet.name?.includes('主角') && sheet.content && sheet.content[1]) {
          const headers = sheet.content[0] || [];
          const row = sheet.content[1];
          headers.forEach((h, idx) => {
            if (h && h.includes('属性')) {
              const parsed = parseAttributeString(row[idx] || '');
              parsed.forEach(attr => {
                if (!contestAttrList.includes(attr.name)) contestAttrList.push(attr.name);
              });
            }
          });
          break;
        }
      }
    }
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (!sheet || !sheet.name || !sheet.content) continue;

        if (sheet.name?.includes('主角') && sheet.content[1]) {
          const attrStr = sheet.content[1][7] || '';
          playerAttrs = parseAttributeString(attrStr);
        }

        if (isNpcTableName(sheet.name) && opponentName) {
          for (let i = 1; i < sheet.content.length; i++) {
            const row = sheet.content[i];
            if (row && row[1] === opponentName) {
              const attrStr = row[9] || '';
              opponentAttrs = parseAttributeString(attrStr);
              break;
            }
          }
        }
      }
    }

    const buildAttrButtons = (attrs, targetType) => {
      let html = '';
      // 现有属性按钮
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        html +=
          '<button class="acu-contest-attr-btn" data-val="' +
          attr.value +
          '" data-aname="' +
          escapeHtml(attr.name) +
          '" data-type="' +
          targetType +
          '">' +
          escapeHtml(attr.name) +
          ': ' +
          attr.value +
          '</button>';
      }
      // 生成属性按钮（始终显示）
      html +=
        '<button class="acu-contest-gen-attr-btn" data-type="' +
        targetType +
        '" title="生成属性"><i class="fa-solid fa-dice"></i></button>';
      // 清空属性按钮
      html +=
        '<button class="acu-contest-clear-attr-btn" data-type="' +
        targetType +
        '" title="清空规则属性"><i class="fa-solid fa-trash-alt"></i></button>';
      return html;
    };

    // [修复] 获取当前活跃预设，用于正确同步按钮状态
    const contestAvailablePresets = AdvancedDicePresetManager.getAllPresets()
      .filter(p => p.visible !== false)
      .filter(p => AdvancedDicePresetManager.supportsContest(p))
      .sort((a, b) => (a.order || 0) - (b.order || 0));
    const currentActivePreset = AdvancedDicePresetManager.getActivePreset();
    const activePresetId =
      currentActivePreset && AdvancedDicePresetManager.supportsContest(currentActivePreset)
        ? currentActivePreset.id
        : null;

    const overlay = $('<div class="acu-contest-overlay"></div>');
    const panelHtml =
      '<div class="acu-contest-panel acu-theme-' +
      config.theme +
      '">' +
      '<div class="acu-dice-panel-header">' +
      '<div class="acu-dice-panel-title"><i class="fa-solid fa-people-arrows"></i> 对抗检定</div>' +
      '<div class="acu-dice-panel-actions">' +
      '<button id="contest-switch-normal" class="acu-dice-panel-action-btn" title="切换到普通检定"><i class="fa-solid fa-dice-d20"></i></button>' +
      '<button id="contest-history-btn" class="acu-dice-panel-action-btn" title="检定历史"><i class="fa-solid fa-history"></i></button>' +
      '<button class="acu-contest-config-btn acu-dice-panel-action-btn" title="掷骰规则设置"><i class="fa-solid fa-cog"></i></button>' +
      '<button class="acu-contest-close acu-dice-panel-action-btn"><i class="fa-solid fa-times"></i></button>' +
      '</div>' +
      '</div>' +
      '<div class="acu-dice-panel-body">' +
      // [修复] 添加"检定规则"标题，与普通检定一致
      '<div class="acu-dice-section-title"><span><i class="fa-solid fa-sliders"></i> 检定规则</span></div>' +
      '<div class="acu-dice-presets">' +
      '<button class="acu-dice-quick-preset-btn" data-dice="custom" style="order: -999;">自定义</button>' +
      contestAvailablePresets
        .map(
          p =>
            '<button class="acu-dice-quick-preset-btn' +
            // [修复] 使用activePresetId而不是diceExpression来判断active状态
            (p.id === activePresetId ? ' active' : '') +
            '" data-dice="' +
            escapeHtml(p.diceExpression || '1d100') +
            '" data-criteria="' +
            escapeHtml(p.successCriteria || 'lte') +
            '" data-preset-id="' +
            escapeHtml(p.id) +
            '">' +
            escapeHtml(p.name) +
            '</button>',
        )
        .join('') +
      '</div>' +
      '<input type="hidden" id="contest-dice-type" value="' +
      diceType +
      '">' +
      '<div class="acu-dice-section-title"><span><i class="fa-solid fa-user"></i> 发起方</span><div id="contest-init-char-buttons" class="acu-dice-quick-inline"></div></div>' +
      '<div id="contest-init-primary-row" class="acu-dice-form-row cols-2">' +
      '<div><div class="acu-dice-form-label">名字</div><input type="text" class="acu-dice-input" id="contest-init-display" value="" placeholder="<user>"></div>' +
      '<div><div class="acu-dice-form-label"><span class="contest-attr-name-text">属性名</span><button type="button" class="acu-random-skill-btn" id="contest-init-random-skill" title="随机技能"><i class="fa-solid fa-dice"></i></button></div><input type="text" class="acu-dice-input" id="contest-init-name" value="" placeholder="自由检定"></div>' +
      '</div>' +
      // [调整] 发起方骰子语法 (自定义模式时显示，半宽)
      '<div id="contest-init-dice-syntax-row" class="acu-dice-form-row cols-2" style="display: none;">' +
      '<div><div class="acu-dice-form-label">骰子语法</div><input type="text" id="contest-custom-dice-init" class="acu-dice-input" value="" placeholder="留空=1d100, 1d20+5..."></div>' +
      '<div></div>' +
      '</div>' +
      '<div id="contest-init-values-row" class="acu-dice-form-row cols-3">' +
      '<div id="contest-init-attr-wrapper"><div class="acu-dice-form-label" id="contest-init-attr-label">属性值</div><input type="text" class="acu-dice-input" id="contest-init-value" value="' +
      (passedInitiatorValue !== undefined ? passedInitiatorValue : '') +
      '" placeholder="留空=50%最大值"></div>' +
      '<div id="contest-init-skill-mod-wrapper" style="display:none;"><div class="acu-dice-form-label" id="contest-init-skill-mod-label">技能加值</div><input type="text" class="acu-dice-input" id="contest-init-skill-mod" placeholder="留空=0"></div>' +
      '<div id="contest-init-mod-wrapper"><div class="acu-dice-form-label" id="contest-init-mod-label">修正值</div><input type="text" class="acu-dice-input" id="contest-init-mod" placeholder="留空=0"></div>' +
      '<div id="contest-init-target-wrapper"><div class="acu-dice-form-label" id="contest-init-target-label">目标值</div><input type="text" class="acu-dice-input" id="contest-init-target" value="" placeholder="自动"></div>' +
      '</div>' +
      '<div id="contest-init-custom-fields"></div>' +
      '<div id="init-attr-buttons" class="acu-dice-quick-compact">' +
      buildAttrButtons(playerAttrs, 'init') +
      '</div>' +
      '<div class="acu-dice-section-title"><span><i class="fa-solid fa-user"></i> 对抗方</span><div id="contest-opp-char-buttons" class="acu-dice-quick-inline"></div></div>' +
      '<div id="contest-opp-primary-row" class="acu-dice-form-row cols-2">' +
      '<div><div class="acu-dice-form-label">名字</div><input type="text" class="acu-dice-input" id="contest-opponent-display" value="' +
      escapeHtml(opponentName) +
      '" placeholder="对手"></div>' +
      '<div><div class="acu-dice-form-label"><span class="contest-attr-name-text">属性名</span><button type="button" class="acu-random-skill-btn" id="contest-opp-random-skill" title="随机技能"><i class="fa-solid fa-dice"></i></button></div><input type="text" class="acu-dice-input" id="contest-opp-name" value="" placeholder="同发起方"></div>' +
      '</div>' +
      // [调整] 对抗方骰子语法 (自定义模式时显示，半宽)
      '<div id="contest-opp-dice-syntax-row" class="acu-dice-form-row cols-2" style="display: none;">' +
      '<div><div class="acu-dice-form-label">骰子语法</div><input type="text" id="contest-custom-dice-opp" class="acu-dice-input" value="" placeholder="留空=同发起方"></div>' +
      '<div></div>' +
      '</div>' +
      '<div id="contest-opp-values-row" class="acu-dice-form-row cols-3">' +
      '<div id="contest-opp-attr-wrapper"><div class="acu-dice-form-label" id="contest-opp-attr-label">属性值</div><input type="text" class="acu-dice-input" id="contest-opp-value" value="' +
      (passedOpponentValue !== undefined ? passedOpponentValue : '') +
      '" placeholder="留空=50%最大值"></div>' +
      '<div id="contest-opp-skill-mod-wrapper" style="display:none;"><div class="acu-dice-form-label" id="contest-opp-skill-mod-label">技能加值</div><input type="text" class="acu-dice-input" id="contest-opp-skill-mod" placeholder="留空=0"></div>' +
      '<div id="contest-opp-mod-wrapper"><div class="acu-dice-form-label" id="contest-opp-mod-label">修正值</div><input type="text" class="acu-dice-input" id="contest-opp-mod" placeholder="留空=0"></div>' +
      '<div id="contest-opp-target-wrapper"><div class="acu-dice-form-label" id="contest-opp-target-label">目标值</div><input type="text" class="acu-dice-input" id="contest-opp-target" value="" placeholder="自动"></div>' +
      '</div>' +
      '<div id="contest-opp-custom-fields"></div>' +
      '<div id="opp-attr-buttons" class="acu-dice-quick-compact">' +
      buildAttrButtons(opponentAttrs, 'opp') +
      '</div>' +
      // [新增] 判定规则 (自定义模式时显示，只占一半宽度)
      '<div id="contest-custom-judge-row" class="acu-dice-form-row cols-2" style="display: none; margin-top: 8px;">' +
      '<div><div class="acu-dice-form-label">判定规则</div><select id="contest-custom-judge-rule" class="acu-dice-select">' +
      '<option value="higher">值大者胜</option>' +
      '<option value="lower">值小者胜</option>' +
      '<option value="rank">成功等级比较</option>' +
      '<option value="none">仅显示结果</option>' +
      '</select></div>' +
      '<div><div class="acu-dice-form-label">平手规则</div><select id="contest-custom-tie-rule" class="acu-dice-select">' +
      '<option value="initiator_lose">发起者失败</option>' +
      '<option value="tie" selected>平手</option>' +
      '<option value="initiator_win">发起者胜利</option>' +
      '</select></div>' +
      '</div>' +
      '<div id="contest-result-display" class="acu-contest-result-display">' +
      '<div class="acu-contest-result-inner">' +
      '<div id="contest-result-init" class="acu-contest-result-side"></div>' +
      '<span class="acu-contest-vs">VS</span>' +
      '<div id="contest-result-opp" class="acu-contest-result-side right"></div>' +
      '</div>' +
      '</div>' +
      '<button id="contest-roll-btn" class="acu-dice-roll-btn"><i class="fa-solid fa-dice"></i> 开始对抗！</button>' +
      '</div>' +
      '</div>';

    const panel = $(panelHtml);
    overlay.append(panel);
    $('body').append(overlay);

    // [新增] 构建角色快捷按钮 - 复用普通检定的样式规格
    const buildCharBtns = targetType => {
      const containerId = targetType === 'init' ? '#contest-init-char-buttons' : '#contest-opp-char-buttons';
      const $container = panel.find(containerId);
      let html = '';
      characterList.forEach(name => {
        const resolvedName = NameAliasRegistry.resolve(String(name));
        const displayName = replaceUserPlaceholders(String(resolvedName));
        const shortName = displayName.length > 4 ? displayName.substring(0, 4) + '..' : displayName;
        html +=
          '<button class="acu-dice-char-btn" data-char="' +
          escapeHtml(String(resolvedName)) +
          '" data-type="' +
          targetType +
          '" title="' +
          escapeHtml(displayName) +
          '">' +
          escapeHtml(shortName) +
          '</button>';
      });
      $container.html(html);
      $container.find('.acu-dice-char-btn').click(function (e) {
        e.preventDefault();
        e.stopPropagation();
        const charName = $(this).data('char');
        const type = $(this).data('type');
        if (type === 'init') {
          panel.find('#contest-init-display').val(charName).trigger('change');
        } else {
          panel.find('#contest-opponent-display').val(charName).trigger('change');
        }
      });
    };

    // [新增] 重建属性快捷按钮
    const rebuildAttrBtns = (attrs, targetType) => {
      const containerId = targetType === 'init' ? '#init-attr-buttons' : '#opp-attr-buttons';
      const $container = panel.find(containerId);

      // 始终显示容器（即使没有属性数据，也要显示生成按钮）
      $container.show();

      let html = '';

      // 现有属性按钮
      if (attrs.length > 0) {
        attrs.forEach(attr => {
          html +=
            '<button class="acu-contest-attr-btn" data-val="' +
            attr.value +
            '" data-aname="' +
            escapeHtml(attr.name) +
            '" data-type="' +
            targetType +
            '">' +
            escapeHtml(attr.name) +
            ':' +
            attr.value +
            '</button>';
        });
      }

      // 生成属性按钮
      html +=
        '<button class="acu-contest-gen-attr-btn" data-type="' +
        targetType +
        '" title="生成属性"><i class="fa-solid fa-dice"></i></button>';

      // 清空属性按钮
      html +=
        '<button class="acu-contest-clear-attr-btn" data-type="' +
        targetType +
        '" title="清空规则属性"><i class="fa-solid fa-trash-alt"></i></button>';

      $container.html(html);

      // 绑定属性按钮点击事件
      $container.find('.acu-contest-attr-btn').click(function () {
        const val = $(this).attr('data-val');
        const aname = $(this).attr('data-aname');
        const type = $(this).attr('data-type');

        if (type === 'init') {
          const targetInput = getContestAttrTargetInput('init', aname || '');
          panel.find(targetInput).val(val);
          panel.find('#contest-init-name').val(aname);
          panel.find(targetInput).trigger('change');
        } else {
          const targetInput = getContestAttrTargetInput('opp', aname || '');
          panel.find(targetInput).val(val);
          panel.find('#contest-opp-name').val(aname);
          panel.find(targetInput).trigger('change');
        }
      });

      // 绑定生成属性按钮点击事件
      $container.find('.acu-contest-gen-attr-btn').click(async function (e) {
        e.preventDefault();
        e.stopPropagation();

        const $btn = $(this);
        if ($btn.prop('disabled')) return;

        const type = $btn.attr('data-type');

        // 禁用按钮防止重复点击
        $btn.prop('disabled', true).css('opacity', '0.5');
        const originalHtml = $btn.html();
        $btn.html('<i class="fa-solid fa-spinner fa-spin"></i>');

        // [修复] 临时禁用更新处理器，防止闪烁
        const originalHandler = UpdateController.handleUpdate;
        UpdateController.handleUpdate = () => {
          console.log('[DICE]ACU 对抗属性生成中，跳过自动刷新');
        };

        try {
          // 获取角色名
          let charName;
          if (type === 'init') {
            charName = panel.find('#contest-init-display').val().trim() || '<user>';
          } else {
            charName = panel.find('#contest-opponent-display').val().trim();
          }

          if (!charName) {
            if (window.toastr) window.toastr.warning('请先选择角色');
            return;
          }

          console.log('[DICE]ACU 对抗面板生成属性 for:', charName, 'type:', type);

          // 生成属性（使用激活的预设）
          const generated = generateRPGAttributes();

          // 兼容旧格式和新格式
          const baseAttrs = generated.base || generated;
          const specialAttrs = generated.special || {};

          // [修复] 分别写入基础属性和特有属性到对应的列
          const result = await writeAttributesToCharacter(charName, baseAttrs, false, specialAttrs);

          if (result.success) {
            // 刷新该方属性按钮
            const refreshedAttrs = getFullAttributesForCharacter(charName);
            rebuildAttrBtns(refreshedAttrs, type);
          }
        } catch (err) {
          console.error('[DICE]ACU 对抗面板生成属性失败:', err);
          if (window.toastr) window.toastr.error('生成属性失败');
        } finally {
          // [修复] 恢复更新处理器
          UpdateController.handleUpdate = originalHandler;
          $btn.prop('disabled', false).css('opacity', '1').html(originalHtml);
        }
      });

      // 绑定清空属性按钮点击事件
      $container.find('.acu-contest-clear-attr-btn').click(async function (e) {
        e.preventDefault();
        e.stopPropagation();

        const $btn = $(this);
        if ($btn.prop('disabled')) return;

        const type = $btn.attr('data-type');

        // 获取角色名
        let charName;
        if (type === 'init') {
          charName = panel.find('#contest-init-display').val().trim() || '<user>';
        } else {
          charName = panel.find('#contest-opponent-display').val().trim();
        }

        if (!charName) {
          if (window.toastr) window.toastr.warning('请先选择角色');
          return;
        }

        // 禁用按钮防止重复点击
        $btn.prop('disabled', true).css('opacity', '0.5');
        const originalHtml = $btn.html();
        $btn.html('<i class="fa-solid fa-spinner fa-spin"></i>');

        // 临时禁用更新处理器
        const originalHandler = UpdateController.handleUpdate;
        UpdateController.handleUpdate = () => {
          console.log('[DICE]ACU 清空属性中，跳过自动刷新');
        };

        try {
          console.log('[DICE]ACU 对抗面板清空属性 for:', charName, 'type:', type);

          const result = await clearPresetAttributesForCharacter(charName);

          if (result.success) {
            // 刷新该方属性按钮
            const refreshedAttrs = getFullAttributesForCharacter(charName);
            rebuildAttrBtns(refreshedAttrs, type);
          }
        } catch (err) {
          console.error('[DICE]ACU 对抗面板清空属性失败:', err);
          if (window.toastr) window.toastr.error('清空属性失败');
        } finally {
          // 恢复更新处理器
          UpdateController.handleUpdate = originalHandler;
          $btn.prop('disabled', false).css('opacity', '1').html(originalHtml);
        }
      });
    };

    // 初始化角色快捷按钮
    buildCharBtns('init');
    buildCharBtns('opp');
    // [新增] 发起方随机技能按钮
    panel.find('#contest-init-random-skill').click(function (e) {
      e.preventDefault();
      e.stopPropagation();
      const skillPool = getRandomSkillPool();
      var randomSkill = skillPool[Math.floor(Math.random() * skillPool.length)];
      panel.find('#contest-init-name').val(randomSkill).trigger('change');
    });

    // [新增] 对抗方随机技能按钮
    panel.find('#contest-opp-random-skill').click(function (e) {
      e.preventDefault();
      e.stopPropagation();
      const skillPool = getRandomSkillPool();
      var randomSkill = skillPool[Math.floor(Math.random() * skillPool.length)];
      panel.find('#contest-opp-name').val(randomSkill).trigger('change');
    });
    // 始终调用 rebuildAttrBtns 来绑定事件（即使属性为空也需要生成/清空按钮可用）
    const initAttrs = getFullAttributesForCharacter(passedInitiatorName || characterList[0] || '<user>');
    rebuildAttrBtns(initAttrs, 'init');
    const oppAttrs = getFullAttributesForCharacter(opponentName || '');
    rebuildAttrBtns(oppAttrs, 'opp');

    // 初始化下拉菜单
    initCustomDropdown(panel.find('#contest-init-display'), characterList);
    initCustomDropdown(panel.find('#contest-opponent-display'), characterList);
    initCustomDropdown(panel.find('#contest-init-name'), contestAttrList);
    initCustomDropdown(panel.find('#contest-opp-name'), contestAttrList);
    addClearButton(
      panel,
      '#contest-init-display, #contest-init-name, #contest-init-value, #contest-init-skill-mod, #contest-init-mod, #contest-init-target, #contest-opponent-display, #contest-opp-name, #contest-opp-value, #contest-opp-skill-mod, #contest-opp-mod, #contest-opp-target, #contest-custom-dice-init, #contest-custom-dice-opp',
    );

    // [新增] 高级预设选择器（对抗检定）
    let currentContestAdvancedPreset: AdvancedDicePreset | LegacyAdvancedDicePreset | null = null;

    const getContestAttrTargetInput = (party: 'init' | 'opp', attrName: string): string => {
      let target = party === 'init' ? '#contest-init-value' : '#contest-opp-value';
      const mapping = currentContestAdvancedPreset?.attrTargetMapping;
      if (!mapping || !attrName) return target;
      for (const [fieldId, names] of Object.entries(mapping)) {
        if (!Array.isArray(names) || !names.includes(attrName)) continue;
        if (fieldId === 'skillMod') {
          target = party === 'init' ? '#contest-init-skill-mod' : '#contest-opp-skill-mod';
        } else if (fieldId === 'mod') {
          target = party === 'init' ? '#contest-init-mod' : '#contest-opp-mod';
        } else if (fieldId === 'attribute') {
          target = party === 'init' ? '#contest-init-value' : '#contest-opp-value';
        }
        break;
      }
      return target;
    };

    const applyContestAdvancedPreset = (presetId: string | null) => {
      // 获取关键DOM元素 - 使用新的wrapper ID
      const $initValuesRow = panel.find('#contest-init-values-row');
      const $oppValuesRow = panel.find('#contest-opp-values-row');
      const $initPrimaryRow = panel.find('#contest-init-primary-row');
      const $oppPrimaryRow = panel.find('#contest-opp-primary-row');
      const $initCustomFields = panel.find('#contest-init-custom-fields');
      const $oppCustomFields = panel.find('#contest-opp-custom-fields');

      const $initAttrWrapper = panel.find('#contest-init-attr-wrapper');
      const $initSkillModWrapper = panel.find('#contest-init-skill-mod-wrapper');
      const $initModWrapper = panel.find('#contest-init-mod-wrapper');
      const $initTargetWrapper = panel.find('#contest-init-target-wrapper');
      const $oppAttrWrapper = panel.find('#contest-opp-attr-wrapper');
      const $oppSkillModWrapper = panel.find('#contest-opp-skill-mod-wrapper');
      const $oppModWrapper = panel.find('#contest-opp-mod-wrapper');
      const $oppTargetWrapper = panel.find('#contest-opp-target-wrapper');

      const $initAttrLabel = panel.find('#contest-init-attr-label');
      const $initSkillModLabel = panel.find('#contest-init-skill-mod-label');
      const $oppAttrLabel = panel.find('#contest-opp-attr-label');
      const $oppSkillModLabel = panel.find('#contest-opp-skill-mod-label');
      const $initTargetLabel = panel.find('#contest-init-target-label');
      const $oppTargetLabel = panel.find('#contest-opp-target-label');
      const $initModLabel = panel.find('#contest-init-mod-label');
      const $oppModLabel = panel.find('#contest-opp-mod-label');

      const $initAttrInput = panel.find('#contest-init-value');
      const $oppAttrInput = panel.find('#contest-opp-value');
      const $initSkillModInput = panel.find('#contest-init-skill-mod');
      const $oppSkillModInput = panel.find('#contest-opp-skill-mod');
      const $initModInput = panel.find('#contest-init-mod');
      const $oppModInput = panel.find('#contest-opp-mod');

      // 辅助函数：更新值行的列数
      const updateRowColumns = ($row: JQuery, visibleCount: number) => {
        $row.removeClass('cols-2 cols-3');
        if (visibleCount <= 2) {
          $row.addClass('cols-2');
        } else {
          $row.addClass('cols-3');
        }
      };

      const buildContestCustomFieldCell = (
        field: Record<string, unknown>,
        party: 'init' | 'opp',
        extraClass = '',
      ): JQuery => {
        const fieldId = String(field.id || '');
        const fieldLabel = String(field.label || fieldId);
        const fieldType = String(field.type || 'text');
        let html = `<div class="${extraClass}">`;

        if (fieldType !== 'toggle') {
          html += `<div class="acu-dice-form-label">${escapeHtml(fieldLabel)}</div>`;
        } else {
          html += '<div class="acu-dice-form-label">&nbsp;</div>';
        }

        if (fieldType === 'select' && Array.isArray(field.options)) {
          html += `<select class="acu-dice-select acu-dice-custom-field-contest" data-id="${escapeHtml(fieldId)}" data-party="${party}">`;
          field.options.forEach(option => {
            const opt = option as Record<string, unknown>;
            const optValue = opt.value;
            const isSelected = optValue === field.defaultValue ? 'selected' : '';
            html += `<option value="${escapeHtml(String(optValue ?? ''))}" ${isSelected}>${escapeHtml(String(opt.label ?? optValue ?? ''))}</option>`;
          });
          html += '</select>';
        } else if (fieldType === 'toggle') {
          const isChecked = field.defaultValue ? 'checked' : '';
          html += `<label style="display: flex; align-items: center; cursor: pointer; height: 32px;">
            <input type="checkbox" class="acu-dice-custom-field-contest" data-id="${escapeHtml(fieldId)}" data-party="${party}" ${isChecked} style="margin-right: 8px;">
            ${escapeHtml(fieldLabel)}
          </label>`;
        } else {
          const inputType = fieldType === 'number' ? 'number' : 'text';
          const defaultVal = field.defaultValue;
          const placeholderText =
            String(field.placeholder || '') ||
            (defaultVal !== undefined && defaultVal !== '' ? `留空=${defaultVal}` : '');
          html += `<input type="${inputType}" class="acu-dice-input acu-dice-custom-field-contest" data-id="${escapeHtml(fieldId)}" data-party="${party}" placeholder="${escapeHtml(placeholderText)}">`;
        }

        html += '</div>';
        return $(html);
      };

      // 辅助函数：渲染customFields
      const renderCustomFields = (
        $container: JQuery,
        party: 'init' | 'opp',
        preset: AdvancedDicePreset | LegacyAdvancedDicePreset,
      ) => {
        $container.empty();

        if (!('customFields' in preset) || !Array.isArray(preset.customFields) || preset.customFields.length === 0) {
          return;
        }

        // 应用 contestOverride 配置，过滤隐藏字段
        const visibleFields = preset.customFields.map(f => ({ ...f, ...f.contestOverride })).filter(f => !f.hidden);
        if (visibleFields.length === 0) return;

        const gridItems: string[] = visibleFields.map(field =>
          buildContestCustomFieldCell(field, party).prop('outerHTML'),
        );

        // 智能排版渲染网格
        // 布局规律：最后一行优先放3个字段，前面的行放2个字段
        // - 4个字段：2+2
        // - 5个字段：2+3
        // - 6个字段：3+3
        // - 7个字段：2+2+3
        // - 8个字段：2+3+3
        // - 9个字段：3+3+3
        const computeRowLayout = (total: number): number[] => {
          if (total <= 0) return [];
          if (total <= 2) return [2]; // 最少2列，避免 cols-1
          if (total === 3) return [3];
          if (total === 4) return [2, 2];
          if (total === 5) return [2, 3];
          if (total === 6) return [3, 3];
          // 7+ 字段：递归计算，最后一行放3个，剩余的递归处理
          return [...computeRowLayout(total - 3), 3];
        };

        const rowLayout = computeRowLayout(gridItems.length);
        let itemIndex = 0;
        for (const colCount of rowLayout) {
          const $row = $(`<div class="acu-dice-form-row cols-${colCount}"></div>`);
          for (let j = 0; j < colCount; j++) {
            if (itemIndex < gridItems.length) {
              $row.append(gridItems[itemIndex]);
              itemIndex++;
            } else {
              $row.append('<div></div>');
            }
          }
          $container.append($row);
        }
      };

      const restoreDefaults = () => {
        // 恢复标签
        $initAttrLabel.text('属性值');
        $oppAttrLabel.text('属性值');
        $initSkillModLabel.text('技能加值');
        $oppSkillModLabel.text('技能加值');
        $initTargetLabel.text('目标值');
        $oppTargetLabel.text('目标值');
        $initModLabel.text('修正值');
        $oppModLabel.text('修正值');

        // 恢复"属性名"标签
        panel.find('.contest-attr-name-text').text('属性名');

        // 恢复所有字段显示
        $initAttrWrapper.show();
        $oppAttrWrapper.show();
        $initSkillModWrapper.hide();
        $oppSkillModWrapper.hide();
        $initTargetWrapper.show();
        $oppTargetWrapper.show();
        $initModWrapper.show();
        $oppModWrapper.show();

        // 恢复默认placeholder
        $initAttrInput.attr('placeholder', '留空=50%最大值');
        $oppAttrInput.attr('placeholder', '留空=50%最大值');
        $initSkillModInput.attr('placeholder', '留空=0');
        $oppSkillModInput.attr('placeholder', '留空=0');
        $initModInput.attr('placeholder', '留空=0');
        $oppModInput.attr('placeholder', '留空=0');

        // 重建值行结构（移除可能嵌入的customFields）
        const rebuildDefaultRow = (
          $row: JQuery,
          $attrWrapper: JQuery,
          $skillWrapper: JQuery,
          $modWrapper: JQuery,
          $targetWrapper: JQuery,
        ) => {
          // 移除所有非原始wrapper的元素
          $row.children().not($attrWrapper).not($skillWrapper).not($modWrapper).not($targetWrapper).remove();
          // 确保原始wrapper在行中且顺序正确
          if ($attrWrapper.parent()[0] !== $row[0]) $attrWrapper.detach().appendTo($row);
          if ($skillWrapper.parent()[0] !== $row[0]) $skillWrapper.detach().appendTo($row);
          if ($modWrapper.parent()[0] !== $row[0]) $modWrapper.detach().appendTo($row);
          if ($targetWrapper.parent()[0] !== $row[0]) $targetWrapper.detach().appendTo($row);
          // 恢复正确顺序
          $row.append($attrWrapper.detach());
          $row.append($skillWrapper.detach());
          $row.append($modWrapper.detach());
          $row.append($targetWrapper.detach());
        };

        rebuildDefaultRow($initValuesRow, $initAttrWrapper, $initSkillModWrapper, $initModWrapper, $initTargetWrapper);
        rebuildDefaultRow($oppValuesRow, $oppAttrWrapper, $oppSkillModWrapper, $oppModWrapper, $oppTargetWrapper);

        // 恢复3列布局
        updateRowColumns($initValuesRow, 3);
        updateRowColumns($oppValuesRow, 3);

        // 清空customFields
        $initPrimaryRow.find('.acu-contest-inline-custom').remove();
        $oppPrimaryRow.find('.acu-contest-inline-custom').remove();
        updateRowColumns($initPrimaryRow, 2);
        updateRowColumns($oppPrimaryRow, 2);
        $initCustomFields.empty();
        $oppCustomFields.empty();
      };

      if (!presetId) {
        currentContestAdvancedPreset = null;
        restoreDefaults();
        return;
      }

      const preset = AdvancedDicePresetManager.getAllPresets().find(p => p.id === presetId);
      if (!preset) {
        console.warn('[DICE] 对抗检定未找到预设:', presetId);
        restoreDefaults();
        return;
      }

      currentContestAdvancedPreset = preset;

      // [修复] 先恢复默认结构，确保从整合布局切换时字段不会丢失
      restoreDefaults();

      // 获取标签和placeholder配置
      const attrLabel = preset.attribute?.label || '属性值';
      const skillModLabel = preset.skillMod?.label || '技能加值';
      const dcLabel = preset.dc?.label || '目标值';
      const modLabel = preset.mod?.label || '修正值';
      const attrPlaceholder = preset.attribute?.placeholder || '留空=50%最大值';
      const skillModPlaceholder = preset.skillMod?.placeholder || '留空=0';
      const modPlaceholder = preset.mod?.placeholder || '留空=0';

      // 更新标签
      $initAttrLabel.text(attrLabel);
      $oppAttrLabel.text(attrLabel);
      $initSkillModLabel.text(skillModLabel);
      $oppSkillModLabel.text(skillModLabel);
      $initTargetLabel.text(dcLabel);
      $oppTargetLabel.text(dcLabel);
      $initModLabel.text(modLabel);
      $oppModLabel.text(modLabel);

      // 更新"属性名"标签（如Fate使用"技能/风格"）
      panel.find('.contest-attr-name-text').text(preset.attributeName?.label || '属性名');

      // 更新placeholder
      $initAttrInput.attr('placeholder', attrPlaceholder);
      $oppAttrInput.attr('placeholder', attrPlaceholder);
      $initSkillModInput.attr('placeholder', skillModPlaceholder);
      $oppSkillModInput.attr('placeholder', skillModPlaceholder);
      $initModInput.attr('placeholder', modPlaceholder);
      $oppModInput.attr('placeholder', modPlaceholder);

      // 计算可见字段数量
      const hideDcInContest = preset.contestRule?.hideDc === true || preset.dc?.hidden === true;
      const hideModInContest = preset.contestRule?.hideMod === true || preset.mod?.hidden === true;
      const hideSkillModInContest =
        !preset.skillMod || preset.contestRule?.hideSkillMod === true || preset.skillMod.hidden === true;

      // 属性值始终显示
      $initAttrWrapper.show();
      $oppAttrWrapper.show();

      // 控制技能加值显隐
      if (hideSkillModInContest) {
        $initSkillModWrapper.hide();
        $oppSkillModWrapper.hide();
      } else {
        $initSkillModWrapper.show();
        $oppSkillModWrapper.show();
      }

      // 控制目标值显隐
      if (hideDcInContest) {
        $initTargetWrapper.hide();
        $oppTargetWrapper.hide();
      } else {
        $initTargetWrapper.show();
        $oppTargetWrapper.show();
      }

      // 控制修正值显隐
      if (hideModInContest) {
        $initModWrapper.hide();
        $oppModWrapper.hide();
      } else {
        $initModWrapper.show();
        $oppModWrapper.show();
      }

      // [优化] 智能布局：将基础字段和customFields整合计算
      // 收集可见的customFields数量（应用 contestOverride）
      const visibleContestFields =
        'customFields' in preset && Array.isArray(preset.customFields)
          ? preset.customFields.map(f => ({ ...f, ...f.contestOverride })).filter(f => !f.hidden)
          : [];
      const customFieldCount = visibleContestFields.length;

      // 计算基础可见字段数
      let baseVisibleCount = 1; // 属性值始终可见
      if (!hideSkillModInContest) baseVisibleCount++;
      if (!hideModInContest) baseVisibleCount++;
      if (!hideDcInContest) baseVisibleCount++;

      // 决定布局策略
      const totalFields = baseVisibleCount + customFieldCount;

      const useThreeByThreeWithPrimaryRow = customFieldCount === 1 && baseVisibleCount === 3;

      if (useThreeByThreeWithPrimaryRow) {
        const customField = visibleContestFields[0];
        const renderPrimaryInlineField = ($row: JQuery, party: 'init' | 'opp') => {
          $row.find('.acu-contest-inline-custom').remove();
          updateRowColumns($row, 3);
          $row.append(buildContestCustomFieldCell(customField, party, 'acu-contest-inline-custom'));
        };

        renderPrimaryInlineField($initPrimaryRow, 'init');
        renderPrimaryInlineField($oppPrimaryRow, 'opp');
        updateRowColumns($initValuesRow, 3);
        updateRowColumns($oppValuesRow, 3);
        $initCustomFields.empty();
        $oppCustomFields.empty();
      } else {
        $initPrimaryRow.find('.acu-contest-inline-custom').remove();
        $oppPrimaryRow.find('.acu-contest-inline-custom').remove();
        updateRowColumns($initPrimaryRow, 2);
        updateRowColumns($oppPrimaryRow, 2);

        // 如果总字段数 <= 4，尝试将所有内容整合布局
        // 对于 COC7: 1 (技能值) + 3 (奖励骰/惩罚骰/最低成功等级) = 4，使用整合布局
        // 对于 FATE: 2 (技能等级/修正值) + 0 = 2，使用整合布局
        // 对于 DND5e: 3 (属性值/修正值/DC) + 1 (优势/劣势) = 4，使用整合布局
        if (totalFields <= 4 && customFieldCount > 0 && baseVisibleCount < 3) {
          // 将 customFields 嵌入到值行中
          // 首先清空单独的 customFields 容器
          $initCustomFields.empty();
          $oppCustomFields.empty();

          // 重建值行内容，包含 customFields
          const buildIntegratedRow = ($row: JQuery, party: 'init' | 'opp') => {
            // 保留属性值 wrapper
            const $attrWrapper = party === 'init' ? $initAttrWrapper : $oppAttrWrapper;
            const $modWrapper = party === 'init' ? $initModWrapper : $oppModWrapper;
            const $targetWrapper = party === 'init' ? $initTargetWrapper : $oppTargetWrapper;

            // 收集当前可见的元素
            const visibleItems: JQuery[] = [];

            // 先从任意父容器中分离基础 wrapper，避免被后续 empty() 误删
            const $skillWrapper = party === 'init' ? $initSkillModWrapper : $oppSkillModWrapper;

            [$attrWrapper, $skillWrapper, $modWrapper, $targetWrapper].forEach($base => {
              if ($base.length > 0 && $base.parent().length > 0) {
                $base.detach();
              }
            });

            // 属性值始终可见
            visibleItems.push($attrWrapper);

            // 技能加值（如果可见）
            if (!hideSkillModInContest) {
              visibleItems.push($skillWrapper);
            }

            // 修正值（如果可见）
            if (!hideModInContest) {
              visibleItems.push($modWrapper);
            }

            // 目标值（如果可见）
            if (!hideDcInContest) {
              visibleItems.push($targetWrapper);
            }

            // 添加 customFields（应用 contestOverride）
            if ('customFields' in preset && Array.isArray(preset.customFields)) {
              const visibleFields = preset.customFields
                .map(f => ({ ...f, ...f.contestOverride }))
                .filter(f => !f.hidden);
              visibleFields.forEach(field => {
                let html = '<div>';

                // 标签
                if (field.type !== 'toggle') {
                  html += `<div class="acu-dice-form-label">${escapeHtml(field.label || field.id)}</div>`;
                } else {
                  html += '<div class="acu-dice-form-label">&nbsp;</div>';
                }

                // 控件
                if (field.type === 'select' && field.options) {
                  html += `<select class="acu-dice-select acu-dice-custom-field-contest" data-id="${escapeHtml(field.id)}" data-party="${party}">`;
                  field.options.forEach(opt => {
                    const isSelected = opt.value === field.defaultValue ? 'selected' : '';
                    html += `<option value="${escapeHtml(String(opt.value))}" ${isSelected}>${escapeHtml(opt.label)}</option>`;
                  });
                  html += '</select>';
                } else if (field.type === 'toggle') {
                  const isChecked = field.defaultValue ? 'checked' : '';
                  html += `<label style="display: flex; align-items: center; cursor: pointer; height: 32px;">
                  <input type="checkbox" class="acu-dice-custom-field-contest" data-id="${escapeHtml(field.id)}" data-party="${party}" ${isChecked} style="margin-right: 8px;">
                  ${escapeHtml(field.label || field.id)}
                </label>`;
                } else {
                  const type = field.type === 'number' ? 'number' : 'text';
                  // [修复] 使用 placeholder 而不是 value 显示默认值
                  const defaultVal = field.defaultValue;
                  const placeholderText =
                    field.placeholder || (defaultVal !== undefined && defaultVal !== '' ? `留空=${defaultVal}` : '');
                  html += `<input type="${type}" class="acu-dice-input acu-dice-custom-field-contest" data-id="${escapeHtml(field.id)}" data-party="${party}"
                  placeholder="${escapeHtml(placeholderText)}">`;
                }

                html += '</div>';
                visibleItems.push($(html) as JQuery);
              });
            }

            // 清空行和 customFields 容器
            $row.empty();
            const $customContainer = party === 'init' ? $initCustomFields : $oppCustomFields;
            $customContainer.empty();

            // 智能排版：根据字段数量决定布局方式
            // 布局规律：最后一行优先放3个字段，前面的行放2个字段
            // - 4个字段：2+2
            // - 5个字段：2+3
            // - 6个字段：3+3
            // - 7个字段：2+2+3
            // - 8个字段：2+3+3
            // - 9个字段：3+3+3
            const computeRowLayout = (total: number): number[] => {
              if (total <= 0) return [];
              if (total <= 2) return [2]; // 最少2列，避免 cols-1
              if (total === 3) return [3];
              if (total === 4) return [2, 2];
              if (total === 5) return [2, 3];
              if (total === 6) return [3, 3];
              // 7+ 字段：递归计算，最后一行放3个，剩余的递归处理
              return [...computeRowLayout(total - 3), 3];
            };

            const appendItemTo = ($target: JQuery, $item: JQuery) => {
              if ($item.parent().length > 0) {
                $item.detach().appendTo($target);
              } else {
                $target.append($item);
              }
            };

            const rowLayout = computeRowLayout(visibleItems.length);
            let itemIndex = 0;

            // 第一行放在 $row 中
            if (rowLayout.length > 0) {
              const firstRowCols = rowLayout[0];
              for (let j = 0; j < firstRowCols; j++) {
                if (itemIndex < visibleItems.length) {
                  appendItemTo($row, visibleItems[itemIndex]);
                  itemIndex++;
                } else {
                  $row.append('<div></div>');
                }
              }
              updateRowColumns($row, firstRowCols);

              // 剩余行放在 $customContainer 中
              for (let rowIdx = 1; rowIdx < rowLayout.length; rowIdx++) {
                const colCount = rowLayout[rowIdx];
                const $gridRow = $(`<div class="acu-dice-form-row cols-${colCount}"></div>`);
                for (let j = 0; j < colCount; j++) {
                  if (itemIndex < visibleItems.length) {
                    appendItemTo($gridRow, visibleItems[itemIndex]);
                    itemIndex++;
                  } else {
                    $gridRow.append('<div></div>');
                  }
                }
                $customContainer.append($gridRow);
              }
            }

            // 不可见基础字段也保留在值行中（隐藏），防止后续切换时 DOM 丢失
            if (hideSkillModInContest) {
              if ($skillWrapper.parent().length === 0 || $skillWrapper.parent()[0] !== $row[0]) {
                $skillWrapper.detach().appendTo($row);
              }
              $skillWrapper.hide();
            }
            if (hideModInContest) {
              if ($modWrapper.parent().length === 0 || $modWrapper.parent()[0] !== $row[0]) {
                $modWrapper.detach().appendTo($row);
              }
              $modWrapper.hide();
            }
            if (hideDcInContest) {
              if ($targetWrapper.parent().length === 0 || $targetWrapper.parent()[0] !== $row[0]) {
                $targetWrapper.detach().appendTo($row);
              }
              $targetWrapper.hide();
            }
          };

          buildIntegratedRow($initValuesRow, 'init');
          buildIntegratedRow($oppValuesRow, 'opp');
        } else {
          // 使用分离布局：基础字段在值行，customFields 在单独区域
          updateRowColumns($initValuesRow, baseVisibleCount);
          updateRowColumns($oppValuesRow, baseVisibleCount);

          // 渲染 customFields 到单独区域
          renderCustomFields($initCustomFields, 'init', preset);
          renderCustomFields($oppCustomFields, 'opp', preset);
        }
      }

      // 防御性兜底：切换预设后确保“修正值”输入框在应显示时不会丢失
      if (!hideSkillModInContest) {
        if ($initSkillModWrapper.parent().length === 0) {
          $initSkillModWrapper.appendTo($initValuesRow);
        }
        if ($oppSkillModWrapper.parent().length === 0) {
          $oppSkillModWrapper.appendTo($oppValuesRow);
        }
        $initSkillModWrapper.show();
        $oppSkillModWrapper.show();
      }

      if (!hideModInContest) {
        if ($initModWrapper.parent().length === 0) {
          $initModWrapper.appendTo($initValuesRow);
        }
        if ($oppModWrapper.parent().length === 0) {
          $oppModWrapper.appendTo($oppValuesRow);
        }
        $initModWrapper.show();
        $oppModWrapper.show();
      }

      // 更新骰子表达式
      panel.find('#contest-dice-type').val(preset.diceExpression);
      panel.find('#contest-custom-dice-init').val(preset.diceExpression);
      panel.find('#contest-custom-dice-opp').val('');
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      // [修复] 根据 presetId 激活正确的按钮，而不是总是激活 custom 按钮
      if (presetId) {
        panel.find(`.acu-dice-quick-preset-btn[data-preset-id="${presetId}"]`).addClass('active');
      }

      // [新增] 为动态生成的 customFields 输入框添加清除按钮
      addClearButton(
        $initCustomFields,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );
      addClearButton(
        $oppCustomFields,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );
      addClearButton(
        $initValuesRow,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );
      addClearButton(
        $oppValuesRow,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );
      addClearButton(
        $initPrimaryRow,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );
      addClearButton(
        $oppPrimaryRow,
        '.acu-dice-custom-field-contest[type="text"], .acu-dice-custom-field-contest[type="number"]',
      );

      console.log(
        '[DICE] 对抗检定应用高级预设:',
        preset.name,
        '总字段数:',
        totalFields,
        '基础字段:',
        baseVisibleCount,
        'customFields:',
        customFieldCount,
      );
    };

    // [统一UI] 初始化时根据活跃预设高亮对应按钮并应用配置
    const savedContestPreset = AdvancedDicePresetManager.getActivePreset();
    const savedSupportedContestPreset =
      savedContestPreset && AdvancedDicePresetManager.supportsContest(savedContestPreset) ? savedContestPreset : null;
    const defaultContestPresetId = contestAvailablePresets.length > 0 ? contestAvailablePresets[0].id : null;
    const savedPresetId = localStorage.getItem(STORAGE_KEY_LAST_PRESET);

    if (savedPresetId === '__custom__') {
      // [修复] 如果保存的是自定义模式，激活自定义按钮并显示自定义UI
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      panel.find('.acu-dice-quick-preset-btn[data-dice="custom"]').addClass('active');
      panel.find('#contest-init-dice-syntax-row').show();
      panel.find('#contest-opp-dice-syntax-row').show();
      panel.find('#contest-custom-judge-row').show();
      panel.find('#contest-init-values-row, #contest-opp-values-row').hide();
      panel.find('#contest-init-custom-fields, #contest-opp-custom-fields').hide();
      // [修复] 进入自定义模式时也重置对抗预设状态，避免后续切换字段丢失
      applyContestAdvancedPreset(null);
    } else if (savedSupportedContestPreset) {
      // 高亮对应的预设按钮
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      const $matchedBtn = panel.find(`.acu-dice-quick-preset-btn[data-preset-id="${savedSupportedContestPreset.id}"]`);
      if ($matchedBtn.length) {
        $matchedBtn.addClass('active');
      }
      applyContestAdvancedPreset(savedSupportedContestPreset.id);
    } else if (defaultContestPresetId) {
      // 当前活跃预设不支持对抗时，自动回退到首个可用对抗预设
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      const $defaultBtn = panel.find(`.acu-dice-quick-preset-btn[data-preset-id="${defaultContestPresetId}"]`);
      if ($defaultBtn.length) {
        $defaultBtn.addClass('active');
        panel.find('#contest-dice-type').val(($defaultBtn.data('dice') as string) || '1d100');
      }
      applyContestAdvancedPreset(defaultContestPresetId);
    }

    // 发起方角色变化时更新属性
    panel.find('#contest-init-display').on('change.acuattr input.acuattr', function () {
      const charName = $(this).val().trim() || '<user>';
      const newAttrList = getAttributesForCharacter(charName);
      initCustomDropdown(panel.find('#contest-init-name'), newAttrList.length > 0 ? newAttrList : contestAttrList);
      const fullAttrs = getFullAttributesForCharacter(charName);
      rebuildAttrBtns(fullAttrs, 'init');
    });

    // 对抗方角色变化时更新属性
    panel.find('#contest-opponent-display').on('change.acuattr input.acuattr', function () {
      const charName = $(this).val().trim();
      const newAttrList = getAttributesForCharacter(charName);
      initCustomDropdown(panel.find('#contest-opp-name'), newAttrList.length > 0 ? newAttrList : contestAttrList);
      const fullAttrs = getFullAttributesForCharacter(charName);
      rebuildAttrBtns(fullAttrs, 'opp');
    });

    // 发起方属性名变化时自动填入属性值
    panel.find('#contest-init-name').on('change.acuval', function () {
      const charName = panel.find('#contest-init-display').val().trim() || '<user>';
      const attrName = $(this).val().trim();
      const attrValue = getAttributeValue(charName, attrName);
      if (attrValue !== null) {
        const targetInput = getContestAttrTargetInput('init', attrName);
        panel.find(targetInput).val(attrValue).trigger('change');
      }
    });

    // 对抗方属性名变化时自动填入属性值
    panel.find('#contest-opp-name').on('change.acuval', function () {
      const charName = panel.find('#contest-opponent-display').val().trim();
      const attrName = $(this).val().trim();
      const attrValue = getAttributeValue(charName, attrName);
      if (attrValue !== null) {
        const targetInput = getContestAttrTargetInput('opp', attrName);
        panel.find(targetInput).val(attrValue).trigger('change');
      }
    });

    // 骰子预设切换
    panel.find('.acu-dice-quick-preset-btn').click(function () {
      const newDice = $(this).data('dice');
      // 自定义按钮有单独处理，这里跳过
      if (newDice === 'custom') return;

      // [新增] 检查预设是否支持对抗检定
      const presetId = $(this).data('preset-id') as string | undefined;
      if (presetId && !AdvancedDicePresetManager.supportsContest(presetId)) {
        const preset = AdvancedDicePresetManager.getAllPresets().find(p => p.id === presetId);
        toastr.warning(`${preset?.name || presetId} 规则不支持对抗检定`);
        return; // 不切换预设，保持当前状态
      }

      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      $(this).addClass('active');
      panel.find('#contest-dice-type').val(newDice);

      // [修复] 隐藏自定义模式字段区（使用新的元素ID）
      panel.find('#contest-init-dice-syntax-row').hide();
      panel.find('#contest-opp-dice-syntax-row').hide();
      panel.find('#contest-custom-judge-row').hide();
      panel.find('#contest-init-values-row, #contest-opp-values-row').show();
      panel.find('#contest-init-custom-fields, #contest-opp-custom-fields').show();

      // [统一UI] 如果按钮有 data-preset-id，直接应用高级预设配置
      if (presetId) {
        AdvancedDicePresetManager.setActivePreset(presetId);
        applyContestAdvancedPreset(presetId);
      } else {
        // 没有预设ID时清除高级预设
        AdvancedDicePresetManager.setActivePreset(null);
        applyContestAdvancedPreset(null);
      }

      // 保存骰子类型
      saveDiceConfig({ lastDiceType: newDice });
    });

    // 自定义骰子按钮点击事件
    panel.find('.acu-dice-quick-preset-btn[data-dice="custom"]').click(function () {
      // 立即高亮自定义按钮，取消其他按钮高亮
      panel.find('.acu-dice-quick-preset-btn').removeClass('active');
      $(this).addClass('active');

      // [修复] 保存自定义模式状态（与普通检定面板保持一致）
      AdvancedDicePresetManager.setActivePreset(null);
      localStorage.setItem(STORAGE_KEY_LAST_PRESET, '__custom__');

      // [修复] 重置对抗检定预设布局（自定义模式会隐藏区域，但不应留下上一次整合布局残留）
      applyContestAdvancedPreset(null);

      // [修复] 显示自定义模式字段区（使用新的元素ID）
      panel.find('#contest-init-dice-syntax-row').show();
      panel.find('#contest-opp-dice-syntax-row').show();
      panel.find('#contest-custom-judge-row').show();
      panel.find('#contest-init-values-row, #contest-opp-values-row').hide();
      panel.find('#contest-init-custom-fields, #contest-opp-custom-fields').hide();
    });

    // 掷骰函数 - 使用 rollComplexDiceExpression 支持复合表达式
    const rollDice = function (formula) {
      const rollResult = rollComplexDiceExpression(formula);
      const total = rollResult.total;
      if (Number.isNaN(total)) return { total: 0, rolls: [], sides: 100 };
      // 尝试从公式中提取基本信息用于显示
      const basicMatch = formula.match(/^(\d*)d(\d+|F)/i);
      const sidesStr = basicMatch ? basicMatch[2] : '100';
      const sides = sidesStr.toUpperCase() === 'F' ? 3 : parseInt(sidesStr, 10);
      return { total, rolls: [], sides };
    };

    const resolveContest = function (
      preset: AdvancedDicePreset,
      initOutcome: OutcomeLevel,
      oppOutcome: OutcomeLevel,
      initValue: number,
      oppValue: number,
      initAttr: number,
      oppAttr: number,
    ): 'initiator' | 'opponent' | 'tie' {
      const contestRule = preset.contestRule;

      if (!contestRule) {
        if (initValue > oppValue) return 'initiator';
        if (oppValue > initValue) return 'opponent';
        return 'tie';
      }

      let winner: 'initiator' | 'opponent' | 'tie' = 'tie';
      const contestMode = contestRule.mode ?? 'custom'; // 默认自定义模式，保持旧行为

      switch (contestMode) {
        case 'rank': {
          const initRank = initOutcome.contestRank ?? 50;
          const oppRank = oppOutcome.contestRank ?? 50;
          if (initRank > oppRank) winner = 'initiator';
          else if (oppRank > initRank) winner = 'opponent';
          break;
        }
        case 'value':
        case 'margin': {
          // 余量模式裁决与 value 相同
          if (initValue > oppValue) winner = 'initiator';
          else if (oppValue > initValue) winner = 'opponent';
          break;
        }
        case 'custom': {
          if (contestRule.customExpr) {
            const context = {
              $initValue: initValue,
              $oppValue: oppValue,
              $initRank: initOutcome.contestRank ?? 50,
              $oppRank: oppOutcome.contestRank ?? 50,
            };
            const conditionResult: { success: boolean; value?: number | boolean; error?: string } = evaluateCondition(
              contestRule.customExpr,
              context,
            );
            if (conditionResult.success) {
              const isMatch =
                typeof conditionResult.value === 'number'
                  ? conditionResult.value !== 0
                  : Boolean(conditionResult.value);
              winner = isMatch ? 'initiator' : 'opponent';
            } else {
              console.warn('[DICE] 对抗判定自定义表达式失败:', conditionResult.error);
            }
          }
          break;
        }
      }

      const tieBreakers =
        Array.isArray(contestRule.tieBreakers) && contestRule.tieBreakers.length > 0
          ? contestRule.tieBreakers
          : contestRule.tieBreaker
            ? [contestRule.tieBreaker]
            : [];

      if (winner === 'tie' && tieBreakers.length > 0) {
        // 链式平局处理：按顺序尝试直到分出胜负
        for (const tieBreaker of tieBreakers) {
          if (winner !== 'tie') break;
          switch (tieBreaker) {
            case 'higher_attr':
              if (initAttr > oppAttr) winner = 'initiator';
              else if (oppAttr > initAttr) winner = 'opponent';
              break;
            case 'initiator_wins':
              winner = 'initiator';
              break;
            case 'reroll':
              // 重投由外层触发，此处保持平局继续后续规则
              break;
          }
        }
      }

      return winner;
    };

    // [新增] 自定义模式对抗掷骰逻辑
    const performCustomContestRoll = function () {
      const $btn = panel.find('#contest-roll-btn');

      // 读取自定义模式字段
      const initDiceExpr = panel.find('#contest-custom-dice-init').val().trim() || '1d100';
      const oppDiceExpr = panel.find('#contest-custom-dice-opp').val().trim() || initDiceExpr;
      const judgeRule = panel.find('#contest-custom-judge-rule').val() as string;
      const tieRule = (panel.find('#contest-custom-tie-rule').val() as string) ?? 'tie';

      // 读取双方信息
      try {
        const rawDataForAlias = cachedRawData || getTableData();
        if (rawDataForAlias) {
          NameAliasRegistry.rebuild(processJsonData(rawDataForAlias || {}));
        }
      } catch (error) {
        console.warn('[DICE] 对抗别名映射刷新失败:', error);
      }
      const initNameRaw = panel.find('#contest-init-display').val().trim() || '<user>';
      const initName = initNameRaw === '<user>' ? initNameRaw : NameAliasRegistry.resolve(initNameRaw);
      const initAttrName = panel.find('#contest-init-name').val().trim() || '自由检定';
      const oppNameRaw = panel.find('#contest-opponent-display').val().trim() || '对手';
      const oppName = oppNameRaw === '<user>' ? oppNameRaw : NameAliasRegistry.resolve(oppNameRaw);
      const oppAttrName = panel.find('#contest-opp-name').val().trim() || initAttrName;

      // 掷骰
      const initRoll = rollComplexDiceExpression(initDiceExpr);
      const oppRoll = rollComplexDiceExpression(oppDiceExpr);

      if (isNaN(initRoll.total) || isNaN(oppRoll.total)) {
        if (window.toastr) {
          const errorExpr = isNaN(initRoll.total) ? initDiceExpr : oppDiceExpr;
          window.toastr.error(`骰子语法错误: ${errorExpr}`);
        }
        return;
      }

      const initTotal = initRoll.total;
      const oppTotal = oppRoll.total;

      // 判定胜负
      let winner: 'initiator' | 'opponent' | 'tie' = 'tie';
      switch (judgeRule) {
        case 'higher':
          if (initTotal > oppTotal) winner = 'initiator';
          else if (oppTotal > initTotal) winner = 'opponent';
          else {
            // 平手情况，使用 tieRule
            if (tieRule === 'initiator_win') winner = 'initiator';
            else if (tieRule === 'initiator_lose') winner = 'opponent';
            // tieRule === 'tie' 时保持 winner = 'tie'
          }
          break;
        case 'lower':
          if (initTotal < oppTotal) winner = 'initiator';
          else if (oppTotal < initTotal) winner = 'opponent';
          else {
            if (tieRule === 'initiator_win') winner = 'initiator';
            else if (tieRule === 'initiator_lose') winner = 'opponent';
          }
          break;
        case 'rank':
          if (initTotal > oppTotal) winner = 'initiator';
          else if (oppTotal > initTotal) winner = 'opponent';
          else {
            if (tieRule === 'initiator_win') winner = 'initiator';
            else if (tieRule === 'initiator_lose') winner = 'opponent';
          }
          break;
        case 'none':
          break;
      }

      const winnerText =
        winner === 'initiator'
          ? `${replaceUserPlaceholders(initName)} 获胜`
          : winner === 'opponent'
            ? `${replaceUserPlaceholders(oppName)} 获胜`
            : judgeRule === 'none'
              ? '无判定'
              : '平局';

      const contestTitle = initAttrName === oppAttrName ? initAttrName : `${initAttrName} vs ${oppAttrName}`;
      const compareSymbol = judgeRule === 'lower' ? '<' : '>';
      let compareExpr = `${initTotal} ${compareSymbol} ${oppTotal}`;
      if (winner === 'tie' || judgeRule === 'none') {
        compareExpr = `${initTotal} = ${oppTotal}`;
      }

      // 生成输出文本（单行，避免冗余换行）
      const outputText = `<meta:检定结果>【${contestTitle}】对抗检定：${replaceUserPlaceholders(initName)}(${initDiceExpr})=${initTotal}，${replaceUserPlaceholders(oppName)}(${oppDiceExpr})=${oppTotal}，判定 ${compareExpr}，${winnerText}</meta:检定结果>`;

      // 插入到输入框
      smartInsertToTextarea(outputText, 'dice');

      // 更新结果显示
      const diceCfg = getDiceConfig();
      const hideDiceResultFromUser =
        diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;

      const initDisplayRoll = hideDiceResultFromUser ? '？？' : initTotal;
      const oppDisplayRoll = hideDiceResultFromUser ? '？？' : oppTotal;
      const showOutcome = judgeRule !== 'none' && !hideDiceResultFromUser;
      const initOutcomeText = showOutcome ? (winner === 'tie' ? '平局' : winner === 'initiator' ? '胜' : '负') : '';
      const oppOutcomeText = showOutcome ? (winner === 'tie' ? '平局' : winner === 'opponent' ? '胜' : '负') : '';

      panel.find('#contest-result-init').html(`
        <div class="acu-contest-result-name">${escapeHtml(replaceUserPlaceholders(initName))}</div>
        <div class="acu-contest-result-roll">${initDisplayRoll}</div>
        ${showOutcome ? `<div class="acu-contest-result-outcome">${initOutcomeText}</div>` : ''}
      `);

      panel.find('#contest-result-opp').html(`
        <div class="acu-contest-result-name">${escapeHtml(replaceUserPlaceholders(oppName))}</div>
        <div class="acu-contest-result-roll">${oppDisplayRoll}</div>
        ${showOutcome ? `<div class="acu-contest-result-outcome">${oppOutcomeText}</div>` : ''}
      `);

      // 高亮胜者
      panel.find('#contest-result-init').removeClass('winner loser');
      panel.find('#contest-result-opp').removeClass('winner loser');
      if (!hideDiceResultFromUser && judgeRule !== 'none') {
        if (winner === 'initiator') {
          panel.find('#contest-result-init').addClass('winner');
          panel.find('#contest-result-opp').addClass('loser');
        } else if (winner === 'opponent') {
          panel.find('#contest-result-init').addClass('loser');
          panel.find('#contest-result-opp').addClass('winner');
        }
      }

      // 显示结果区
      panel.find('#contest-result-display').show();

      // 更新按钮显示重投
      $btn.html(`
        <div class="acu-dice-result-display">
          <span>${hideDiceResultFromUser ? '？？' : winnerText}</span>
          <button class="dice-retry-btn acu-dice-retry-btn" title="重新投骰">
            <i class="fa-solid fa-rotate-right"></i>
          </button>
        </div>
      `);

      // 绑定重投按钮
      $btn.off('click', '.dice-retry-btn').on('click', '.dice-retry-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        performCustomContestRoll();
      });

      const winnerSide: 'left' | 'right' | 'tie' =
        winner === 'initiator' ? 'left' : winner === 'opponent' ? 'right' : 'tie';
      const customContestResult: AcuDice.ContestResult = {
        left: {
          name: initName,
          attribute: initAttrName,
          roll: initTotal,
          target: 0,
          successLevel: winner === 'initiator' ? 1 : winner === 'tie' ? 0 : -1,
        },
        right: {
          name: oppName,
          attribute: oppAttrName,
          roll: oppTotal,
          target: 0,
          successLevel: winner === 'opponent' ? 1 : winner === 'tie' ? 0 : -1,
        },
        winner: winnerSide,
        message: winnerText,
      };

      const customContestWithTimestamp = {
        ...customContestResult,
        timestamp: Date.now(),
        detailId: `contest_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        detailLines: [
          `发起方: ${initName} / 对抗方: ${oppName}`,
          `属性: ${initAttrName} vs ${oppAttrName}`,
          `公式: ${initDiceExpr} vs ${oppDiceExpr}`,
          `掷骰: ${initTotal} vs ${oppTotal}`,
          `判定规则: ${judgeRule}`,
          `平手规则: ${tieRule}`,
          `判定表达式: ${compareExpr}`,
          `结果: ${winnerText}`,
        ],
      };
      contestHistory.push(customContestWithTimestamp);
      if (contestHistory.length > MAX_HISTORY) {
        contestHistory.shift();
      }
      emitEvent('contest', customContestWithTimestamp);
    };

    let lastContestRollAt = 0;
    // 对抗检定投骰逻辑函数（可被按钮点击和重投按钮调用）
    const performContestRoll = function () {
      const $btn = panel.find('#contest-roll-btn');
      const $row = panel.find('.acu-contest-result-row');
      const now = Date.now();
      if (now - lastContestRollAt < 100) return;
      lastContestRollAt = now;

      // 锁定按钮和结果行防止连点
      if ($btn.prop('disabled') || $row.hasClass('disabled')) return;

      const lockUI = () => {
        $btn.prop('disabled', true).addClass('disabled');
        $row.addClass('disabled').css('pointer-events', 'none');
      };
      const unlockUI = () => {
        $btn.prop('disabled', false).removeClass('disabled');
        $row.removeClass('disabled').css('pointer-events', '');
      };

      lockUI();
      setTimeout(unlockUI, 100);

      // [修复] 如果处于自定义模式,使用自定义对抗掷骰逻辑
      // 检查骰子语法行是否可见来判断是否为自定义模式
      if (panel.find('#contest-init-dice-syntax-row').is(':visible')) {
        performCustomContestRoll();
        return;
      }

      var formula = panel.find('#contest-dice-type').val() || '1d100';
      const activePreset = currentContestAdvancedPreset || AdvancedDicePresetManager.getActivePreset();
      const hasAdvancedPreset =
        !!activePreset &&
        'outcomes' in activePreset &&
        Array.isArray(activePreset.outcomes) &&
        activePreset.outcomes.length > 0;

      try {
        const rawDataForAlias = cachedRawData || getTableData();
        if (rawDataForAlias) {
          NameAliasRegistry.rebuild(processJsonData(rawDataForAlias || {}));
        }
      } catch (error) {
        console.warn('[DICE] 对抗别名映射刷新失败:', error);
      }

      var initNameRaw = (panel.find('#contest-init-display').val() || '').toString().trim() || '<user>';
      var initName = initNameRaw === '<user>' ? initNameRaw : NameAliasRegistry.resolve(initNameRaw);
      var initAttrName = (panel.find('#contest-init-name').val() || '').toString().trim() || '自由检定';
      // 辅助函数：根据骰子公式计算最大值的一半
      var getHalfMax = function (formulaStr) {
        var m = formulaStr.match(/(\d+)d(\d+)/i);
        if (m) return Math.round((parseInt(m[1], 10) * parseInt(m[2], 10)) / 2);
        return 50;
      };
      const resolveDefaultValue = function (
        defaultValue: number | string | undefined,
        context: Record<string, number>,
      ): number {
        if (defaultValue === undefined) return 0;
        if (typeof defaultValue === 'number') return defaultValue;
        const result = evaluateFormula(defaultValue, context);
        if (result === 0 && defaultValue !== '0' && String(defaultValue) !== '0') {
          if (window.toastr) {
            window.toastr.warning(`表达式 "${defaultValue}" 求值失败,使用默认值 0`);
          }
        }
        return result || 0;
      };

      // 解析修正值，支持纯数字和骰子表达式
      const parseModifier = function (modStr: string): number {
        if (!modStr || modStr.trim() === '') return 0;
        const trimmed = modStr.trim();

        // 尝试直接解析为数字
        const numValue = parseFloat(trimmed);
        if (!isNaN(numValue) && isFinite(numValue) && trimmed.match(/^-?\d+(\.\d+)?$/)) {
          return numValue;
        }

        const rollResult = rollComplexDiceExpression(trimmed);
        if (!Number.isNaN(rollResult.total)) return rollResult.total;
        return 0;
      };

      var initValueInput = (panel.find('#contest-init-value').val() || '').toString().trim();
      var initValue;
      if (initValueInput === '') {
        // 属性值留空：高级预设使用默认值，否则使用骰子最大值的一半
        if (hasAdvancedPreset && activePreset && 'attribute' in activePreset) {
          initValue = resolveDefaultValue(activePreset.attribute?.defaultValue, {});
        } else {
          initValue = getHalfMax(formula);
        }
      } else {
        initValue = parseInt(initValueInput, 10) || getHalfMax(formula);
      }
      var initTargetInput = (panel.find('#contest-init-target').val() || '').toString().trim();
      var initTarget;
      if (initTargetInput !== '') {
        initTarget = parseInt(initTargetInput, 10);
      } else {
        // 目标值留空：高级预设使用默认值，否则使用属性值（若属性值也是默认的，则两者相等）
        if (hasAdvancedPreset && activePreset && 'dc' in activePreset) {
          initTarget = resolveDefaultValue(activePreset.dc?.defaultValue, { $attr: initValue });
        } else {
          initTarget = initValue;
        }
      }

      var oppNameRaw = (panel.find('#contest-opponent-display').val() || '').toString().trim() || '对手';
      var oppName = oppNameRaw === '<user>' ? oppNameRaw : NameAliasRegistry.resolve(oppNameRaw);
      var oppAttrName = (panel.find('#contest-opp-name').val() || '').toString().trim() || initAttrName;
      var oppValueInput = (panel.find('#contest-opp-value').val() || '').toString().trim();
      var oppValue;
      if (oppValueInput === '') {
        // 属性值留空：高级预设使用默认值，否则使用骰子最大值的一半
        if (hasAdvancedPreset && activePreset && 'attribute' in activePreset) {
          oppValue = resolveDefaultValue(activePreset.attribute?.defaultValue, {});
        } else {
          oppValue = getHalfMax(formula);
        }
      } else {
        oppValue = parseInt(oppValueInput, 10) || getHalfMax(formula);
      }
      var oppTargetInput = (panel.find('#contest-opp-target').val() || '').toString().trim();
      var oppTarget;
      if (oppTargetInput !== '') {
        oppTarget = parseInt(oppTargetInput, 10);
      } else {
        // 目标值留空：高级预设使用默认值，否则使用属性值
        if (hasAdvancedPreset && activePreset && 'dc' in activePreset) {
          oppTarget = resolveDefaultValue(activePreset.dc?.defaultValue, { $attr: oppValue });
        } else {
          oppTarget = oppValue;
        }
      }

      var initModInput = (panel.find('#contest-init-mod').val() || '').toString().trim();
      var oppModInput = (panel.find('#contest-opp-mod').val() || '').toString().trim();
      var initSkillModInput = (panel.find('#contest-init-skill-mod').val() || '').toString().trim();
      var oppSkillModInput = (panel.find('#contest-opp-skill-mod').val() || '').toString().trim();
      var initMod = initModInput !== '' ? parseModifier(initModInput) : 0;
      var oppMod = oppModInput !== '' ? parseModifier(oppModInput) : 0;

      // 解析技能加值（若预设启用 skillMod）
      var initSkillMod = 0;
      var oppSkillMod = 0;

      const allPresets = AdvancedDicePresetManager.getAllPresets();
      const fallbackPresetId = /d100/i.test(formula) ? 'coc7_check' : 'dnd5e_check';
      const fallbackPreset = allPresets.find(p => p.id === fallbackPresetId);
      const preset =
        activePreset &&
        'outcomes' in activePreset &&
        Array.isArray(activePreset.outcomes) &&
        activePreset.outcomes.length > 0
          ? activePreset
          : fallbackPreset;

      if (!preset || !Array.isArray(preset.outcomes) || preset.outcomes.length === 0) {
        console.warn('[DICE] 对抗检定未找到可用预设或 outcomes');
        return;
      }

      if (preset.mod?.hidden) {
        initMod = 0;
        oppMod = 0;
      }

      if (preset.dc?.hidden) {
        initTarget = resolveDefaultValue(preset.dc?.defaultValue, { $attr: initValue });
        oppTarget = resolveDefaultValue(preset.dc?.defaultValue, { $attr: oppValue });
      }

      const hideSkillModInContest =
        !preset.skillMod || preset.contestRule?.hideSkillMod === true || preset.skillMod.hidden === true;
      if (!hideSkillModInContest && preset.skillMod) {
        if (initSkillModInput !== '') {
          initSkillMod = parseModifier(initSkillModInput);
        } else {
          initSkillMod = resolveDefaultValue(preset.skillMod.defaultValue, { $attr: initValue });
        }

        if (oppSkillModInput !== '') {
          oppSkillMod = parseModifier(oppSkillModInput);
        } else {
          oppSkillMod = resolveDefaultValue(preset.skillMod.defaultValue, { $attr: oppValue });
        }
      }

      // [新增] 收集双方的 customFields
      const collectContestCustomFields = (party: 'init' | 'opp'): Record<string, number | string | boolean> => {
        const customValues: Record<string, number | string | boolean> = {};
        if (!('customFields' in preset) || !Array.isArray(preset.customFields) || preset.customFields.length === 0) {
          return customValues;
        }

        const $customFields = panel.find(`.acu-dice-custom-field-contest[data-party="${party}"]`);
        $customFields.each(function () {
          const $el = $(this);
          const id = $el.data('id');
          const fieldConfig = preset.customFields.find(f => f.id === id);
          if (!fieldConfig) return;

          let val: string | number | boolean;
          if (fieldConfig.type === 'toggle') {
            val = $el.prop('checked');
          } else if (fieldConfig.type === 'number') {
            const num = parseFloat($el.val() as string);
            val = isNaN(num) ? (fieldConfig.defaultValue as number) : num;
          } else if (fieldConfig.type === 'select') {
            const rawVal = $el.val() as string;
            const num = parseFloat(rawVal);
            val = isNaN(num) ? rawVal : num;
          } else {
            const rawVal = String($el.val() ?? '').trim();
            if (rawVal === '' && fieldConfig.defaultValue !== undefined && fieldConfig.defaultValue !== '') {
              val = fieldConfig.defaultValue as string | number | boolean;
            } else {
              val = rawVal;
            }
          }
          customValues['$' + id] = val;
        });
        return customValues;
      };

      // [新增] 计算派生变量
      const computeDerivedVars = (
        customValues: Record<string, number | string | boolean>,
        attrValue: number,
        modValue: number,
        dcValue: number,
      ): Record<string, number> => {
        const derivedValues: Record<string, number> = {};
        if (!('derivedVars' in preset) || !Array.isArray(preset.derivedVars) || preset.derivedVars.length === 0) {
          return derivedValues;
        }

        const baseContext = {
          $attr: attrValue,
          $dc: dcValue,
          $mod: modValue,
          ...customValues,
        };

        preset.derivedVars.forEach(spec => {
          const id = spec?.id?.trim();
          if (!id) return;
          const varName = id.startsWith('$') ? id : `$${id}`;
          const evalResult = evaluateCondition(spec.expr, { ...baseContext, ...derivedValues });
          if (!evalResult.success) {
            console.warn(`[DICE] 对抗检定派生变量 ${varName} 计算失败:`, evalResult.error);
            derivedValues[varName] = 0;
            return;
          }
          const rawValue = evalResult.value;
          const numericValue = typeof rawValue === 'number' && Number.isFinite(rawValue) ? rawValue : rawValue ? 1 : 0;
          derivedValues[varName] = numericValue;
        });
        return derivedValues;
      };

      // [新增] 应用 dicePatches
      const applyDicePatches = (
        baseFormula: string,
        customValues: Record<string, number | string | boolean>,
        derivedValues: Record<string, number>,
        attrValue: number,
        modValue: number,
        dcValue: number,
      ): string => {
        if (!('dicePatches' in preset) || !Array.isArray(preset.dicePatches) || preset.dicePatches.length === 0) {
          return baseFormula;
        }

        const patchContext = {
          $attr: attrValue,
          $dc: dcValue,
          $mod: modValue,
          ...customValues,
          ...derivedValues,
        };

        const replacePatchTemplate = (template: string): string => {
          const varPattern = /\$[a-zA-Z_]\w*/g;
          return template.replace(varPattern, match => {
            const value = patchContext[match];
            return typeof value === 'number' && Number.isFinite(value) ? String(value) : '0';
          });
        };

        let diceExpression = baseFormula;
        preset.dicePatches.forEach(patch => {
          if (!patch) return;
          if (patch.when) {
            const conditionResult = evaluateCondition(patch.when, patchContext);
            if (!conditionResult.success) {
              console.warn('[DICE] 对抗检定 dicePatches 条件评估失败:', conditionResult.error);
              return;
            }
            const shouldApply =
              typeof conditionResult.value === 'number' ? conditionResult.value !== 0 : Boolean(conditionResult.value);
            if (!shouldApply) return;
          }

          const resolvedTemplate = replacePatchTemplate(patch.template ?? '');
          switch (patch.op) {
            case 'append':
              diceExpression = `${diceExpression}${resolvedTemplate}`;
              break;
            case 'prepend':
              diceExpression = `${resolvedTemplate}${diceExpression}`;
              break;
            case 'replace':
              diceExpression = resolvedTemplate;
              break;
          }
        });
        return diceExpression;
      };

      // 收集发起方 customFields 并计算公式
      const initCustomValues = collectContestCustomFields('init');
      const initDerivedValues = computeDerivedVars(initCustomValues, initValue, initMod, initTarget);
      const initFormula = applyDicePatches(
        formula,
        initCustomValues,
        initDerivedValues,
        initValue,
        initMod,
        initTarget,
      );

      // 收集对抗方 customFields 并计算公式
      const oppCustomValues = collectContestCustomFields('opp');
      const oppDerivedValues = computeDerivedVars(oppCustomValues, oppValue, oppMod, oppTarget);
      const oppFormula = applyDicePatches(formula, oppCustomValues, oppDerivedValues, oppValue, oppMod, oppTarget);

      // 投骰（使用各自的公式）
      var initResult = rollDice(initFormula);
      var oppResult = rollDice(oppFormula);
      var initRollTotal = initResult.total;
      var oppRollTotal = oppResult.total;

      console.log('[DICE] 对抗检定公式 - 发起方:', initFormula, '对抗方:', oppFormula);

      // 计算 attrMod（如果预设有 computeModifier）
      let initAttrMod = 0;
      let oppAttrMod = 0;
      if ('attribute' in preset && preset.attribute?.computeModifier) {
        const modFormula = preset.attribute.computeModifier;
        if (modFormula === 'floor(($attr - 10) / 2)') {
          // DND5e 特殊处理
          initAttrMod = Math.floor((initValue - 10) / 2);
          oppAttrMod = Math.floor((oppValue - 10) / 2);
        } else {
          initAttrMod = resolveDefaultValue(modFormula, { $attr: initValue });
          oppAttrMod = resolveDefaultValue(modFormula, { $attr: oppValue });
        }
      }

      const initContext = {
        $roll: initResult,
        $attr: initValue,
        $attrMod: initAttrMod,
        $skillMod: initSkillMod,
        $dc: initTarget,
        $mod: initMod,
        ...initCustomValues,
        ...initDerivedValues,
      };
      const oppContext = {
        $roll: oppResult,
        $attr: oppValue,
        $attrMod: oppAttrMod,
        $skillMod: oppSkillMod,
        $dc: oppTarget,
        $mod: oppMod,
        ...oppCustomValues,
        ...oppDerivedValues,
      };

      const initOutcome = evaluateOutcomes(preset.outcomes, initContext);
      const oppOutcome = evaluateOutcomes(preset.outcomes, oppContext);
      const winnerSide = resolveContest(
        preset,
        initOutcome,
        oppOutcome,
        initRollTotal + initAttrMod + initSkillMod + initMod,
        oppRollTotal + oppAttrMod + oppSkillMod + oppMod,
        initValue,
        oppValue,
      );

      let winnerText = '平局';
      let winnerResultType = 'warning';
      if (winnerSide === 'initiator') {
        winnerText = initName + ' 胜利';
        winnerResultType = 'success';
      } else if (winnerSide === 'opponent') {
        winnerText = oppName + ' 胜利';
        winnerResultType = 'failure';
      }

      var diceCfg = getDiceConfig();
      var hideDiceResultFromUser =
        diceCfg.hideDiceResultFromUser !== undefined ? diceCfg.hideDiceResultFromUser : false;
      var displayInitValue = hideDiceResultFromUser ? '？？' : initRollTotal;
      var displayOppValue = hideDiceResultFromUser ? '？？' : oppRollTotal;
      var displayInitSuccessName = hideDiceResultFromUser ? '' : initOutcome.name;
      var displayOppSuccessName = hideDiceResultFromUser ? '' : oppOutcome.name;
      var displayWinner = hideDiceResultFromUser ? '' : winnerText;

      const getResultTypeFromOutcome = (outcome: OutcomeLevel) => {
        if (outcome.priority <= 10) return 'critSuccess';
        if (outcome.priority <= 30) return 'extremeSuccess';
        if (outcome.priority < 50) return 'success';
        if (outcome.priority === 50) return 'warning';
        if (outcome.priority < 90) return 'failure';
        return 'critFailure';
      };

      const initResultType = getResultTypeFromOutcome(initOutcome);
      const oppResultType = getResultTypeFromOutcome(oppOutcome);

      const initBadgeClass = getResultBadgeClass(initResultType);
      const oppBadgeClass = getResultBadgeClass(oppResultType);
      // 胜者文字颜色类名
      const winnerColorClass =
        winnerResultType === 'success'
          ? 'acu-contest-winner-success'
          : winnerResultType === 'warning'
            ? 'acu-contest-winner-warning'
            : 'acu-contest-winner-failure';

      // 显示结果展示区域
      const $resultDisplay = panel.find('#contest-result-display');
      const $resultInit = panel.find('#contest-result-init');
      const $resultOpp = panel.find('#contest-result-opp');

      // 显示发起方结果
      $resultInit.html(
        '<span class="acu-contest-result-name">' +
          escapeHtml(initName) +
          '</span>' +
          '<span class="acu-contest-result-value">' +
          displayInitValue +
          '</span>' +
          (displayInitSuccessName ? '<span class="' + initBadgeClass + '">' + displayInitSuccessName + '</span>' : ''),
      );

      // 显示对抗方结果
      $resultOpp.html(
        (displayOppSuccessName ? '<span class="' + oppBadgeClass + '">' + displayOppSuccessName + '</span>' : '') +
          '<span class="acu-contest-result-value">' +
          displayOppValue +
          '</span>' +
          '<span class="acu-contest-result-name">' +
          escapeHtml(oppName) +
          '</span>',
      );

      // 将结果显示区域改为两行布局：第一行显示双方信息，第二行显示最终结果和重roll按钮
      $resultDisplay.html(
        '<div class="acu-contest-result-container" title="点击重新投骰">' +
          // 第一行：双方名字、点数、检定结果
          '<div class="acu-contest-result-row">' +
          '<div class="acu-contest-result-inner">' +
          '<div id="contest-result-init" class="acu-contest-result-side">' +
          '<span class="acu-contest-result-name">' +
          escapeHtml(initName) +
          '</span>' +
          '<span class="acu-contest-result-value">' +
          displayInitValue +
          '</span>' +
          (displayInitSuccessName ? '<span class="' + initBadgeClass + '">' + displayInitSuccessName + '</span>' : '') +
          '</div>' +
          '<span class="acu-contest-vs">VS</span>' +
          '<div id="contest-result-opp" class="acu-contest-result-side right">' +
          (displayOppSuccessName ? '<span class="' + oppBadgeClass + '">' + displayOppSuccessName + '</span>' : '') +
          '<span class="acu-contest-result-value">' +
          displayOppValue +
          '</span>' +
          '<span class="acu-contest-result-name">' +
          escapeHtml(oppName) +
          '</span>' +
          '</div>' +
          '</div>' +
          '</div>' +
          // 第二行：最终结果 + 重roll箭头
          '<div class="acu-contest-result-winner-row">' +
          '<span class="acu-contest-winner-text ' +
          winnerColorClass +
          '">' +
          displayWinner +
          '</span>' +
          '<i class="fa-solid fa-rotate-right acu-contest-reroll-icon"></i>' +
          '</div>' +
          '</div>',
      );
      $resultDisplay.show();

      // 绑定整行点击事件进行重投
      $resultDisplay.off('click').on('click', function (e) {
        e.stopPropagation();
        e.preventDefault();
        performContestRoll();
      });

      // 隐藏原按钮
      const $contestBtn = panel.find('#contest-roll-btn');
      $contestBtn.hide();

      // 构建对抗检定结果文本 (使用模板系统)
      const template = preset.contestOutputTemplate || DEFAULT_CONTEST_OUTPUT_TEMPLATE;
      // 使用 displayExpr（如果有）或 condition 作为显示表达式
      const initDisplayExpr = initOutcome.displayExpr ?? initOutcome.condition;
      const oppDisplayExpr = oppOutcome.displayExpr ?? oppOutcome.condition;
      // 先处理 $roll.hasTag() 方法调用
      let initConditionExpr = initDisplayExpr.replace(
        /\$roll\.hasTag\s*\(\s*['"]([^'"]+)['"]\s*\)/gi,
        (_match, tag) => {
          return (initResult.tags ?? []).includes(tag) ? '成立' : '不成立';
        },
      );
      initConditionExpr = initConditionExpr
        .replace(/\$roll\.total/g, String(initRollTotal)) // 先替换 $roll.total
        .replace(/\$roll/g, String(initRollTotal))
        .replace(/\$attrMod/g, String(initAttrMod))
        .replace(/\$skillMod/g, String(initSkillMod))
        .replace(/\$attr/g, String(initValue))
        .replace(/\$dc/g, String(initTarget))
        .replace(/\$mod/g, String(initMod));
      let oppConditionExpr = oppDisplayExpr.replace(/\$roll\.hasTag\s*\(\s*['"]([^'"]+)['"]\s*\)/gi, (_match, tag) => {
        return (oppResult.tags ?? []).includes(tag) ? '成立' : '不成立';
      });
      oppConditionExpr = oppConditionExpr
        .replace(/\$roll\.total/g, String(oppRollTotal)) // 先替换 $roll.total
        .replace(/\$roll/g, String(oppRollTotal))
        .replace(/\$attrMod/g, String(oppAttrMod))
        .replace(/\$skillMod/g, String(oppSkillMod))
        .replace(/\$attr/g, String(oppValue))
        .replace(/\$dc/g, String(oppTarget))
        .replace(/\$mod/g, String(oppMod));
      // 计算 displayExpr 的布尔值来决定"成立/不成立"
      // 注意：复用前面已定义的 initContext 和 oppContext
      const initDisplayExprResult = evaluateCondition(initDisplayExpr, initContext);
      const oppDisplayExprResult = evaluateCondition(oppDisplayExpr, oppContext);
      const initJudgeResult =
        initDisplayExprResult.success &&
        (typeof initDisplayExprResult.value === 'number'
          ? initDisplayExprResult.value !== 0
          : Boolean(initDisplayExprResult.value))
          ? '成立'
          : '不成立';
      const oppJudgeResult =
        oppDisplayExprResult.success &&
        (typeof oppDisplayExprResult.value === 'number'
          ? oppDisplayExprResult.value !== 0
          : Boolean(oppDisplayExprResult.value))
          ? '成立'
          : '不成立';
      const initOutcomeText = initOutcome.outputText || initOutcome.name || '判定完成';
      const oppOutcomeText = oppOutcome.outputText || oppOutcome.name || '判定完成';
      // 计算总值（投骰 + 属性调整值 + 技能加值 + 额外修正）和差值
      const initTotal = initRollTotal + initAttrMod + initSkillMod + initMod;
      const oppTotal = oppRollTotal + oppAttrMod + oppSkillMod + oppMod;
      const margin = initTotal - oppTotal;

      // [新增] 条件文本变量：当值为0时隐藏整个片段（包括标签）
      // 发起方
      const initAttrModStr = initAttrMod >= 0 ? `+${initAttrMod}` : String(initAttrMod);
      const initSkillModStr = initSkillMod >= 0 ? `+${initSkillMod}` : String(initSkillMod);
      const initAttrModText = initAttrMod !== 0 ? `，调整值${initAttrModStr}` : '';
      const initSkillModText = initSkillMod !== 0 ? `+技能加值${initSkillModStr}` : '';
      const initModText = initMod !== 0 ? `+额外加值${initMod >= 0 ? '+' + initMod : initMod}` : '';
      // 对抗方
      const oppAttrModStr = oppAttrMod >= 0 ? `+${oppAttrMod}` : String(oppAttrMod);
      const oppSkillModStr = oppSkillMod >= 0 ? `+${oppSkillMod}` : String(oppSkillMod);
      const oppAttrModText = oppAttrMod !== 0 ? `，调整值${oppAttrModStr}` : '';
      const oppSkillModText = oppSkillMod !== 0 ? `+技能加值${oppSkillModStr}` : '';
      const oppModText = oppMod !== 0 ? `+额外加值${oppMod >= 0 ? '+' + oppMod : oppMod}` : '';

      const contestOutputContext = {
        initiator: initName,
        opponent: oppName,
        initAttrName: initAttrName,
        oppAttrName: oppAttrName,
        initRoll: initRollTotal,
        oppRoll: oppRollTotal,
        initTarget: initTarget,
        oppTarget: oppTarget,
        initSuccessName: initOutcome.name,
        oppSuccessName: oppOutcome.name,
        winner: winnerText, // "XXX 胜利" 或 "平局"
        outcomeText: initOutcomeText,
        outcomeName: initOutcome.name,
        conditionExpr: initConditionExpr,
        judgeResult: initJudgeResult,
        formula: formula,
        roll: initRollTotal,
        dc: initTarget,
        mod: initMod,
        attr: initValue,
        attrName: `【${initAttrName}】`,
        initOutcomeText: initOutcomeText,
        oppOutcomeText: oppOutcomeText,
        initConditionExpr: initConditionExpr,
        oppConditionExpr: oppConditionExpr,
        initJudgeResult: initJudgeResult,
        oppJudgeResult: oppJudgeResult,
        // 属性调整值（用于 DND 等系统）
        initAttrMod: initAttrMod,
        oppAttrMod: oppAttrMod,
        // 技能加值（用于 DND 等系统）
        initSkillMod: initSkillMod,
        oppSkillMod: oppSkillMod,
        initMod: initMod,
        oppMod: oppMod,
        // [新增] 条件文本变量（零值时隐藏整个片段）
        initAttrModText: initAttrModText,
        oppAttrModText: oppAttrModText,
        initSkillModText: initSkillModText,
        oppSkillModText: oppSkillModText,
        initModText: initModText,
        oppModText: oppModText,
        // 总值和差值（用于 DND/Fate 等系统）
        initTotal: initTotal,
        oppTotal: oppTotal,
        margin: margin,
        shifts: margin, // Fate 术语别名
        // [新增] 双方原始属性值（技能等级）
        initAttr: initValue,
        oppAttr: oppValue,
      };
      const contestResultText = formatOutputTemplate(template, contestOutputContext);
      smartInsertToTextarea(contestResultText, 'dice');

      // 构建对抗检定结果对象
      const getOutcomeLevel = (outcome: OutcomeLevel) => {
        if (outcome.priority <= 10) return 3;
        if (outcome.priority <= 30) return 2;
        if (outcome.priority < 50) return 1;
        if (outcome.priority === 50) return 0;
        return -1;
      };
      const contestResult: AcuDice.ContestResult = {
        left: {
          name: initName,
          attribute: initAttrName,
          roll: initRollTotal,
          target: initTarget,
          successLevel: getOutcomeLevel(initOutcome),
        },
        right: {
          name: oppName,
          attribute: oppAttrName,
          roll: oppRollTotal,
          target: oppTarget,
          successLevel: getOutcomeLevel(oppOutcome),
        },
        winner: winnerSide === 'initiator' ? 'left' : winnerSide === 'opponent' ? 'right' : 'tie',
        message: winnerText,
      };

      // 添加到历史记录
      const contestDetailId = `contest_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const contestResultWithTimestamp = {
        ...contestResult,
        timestamp: Date.now(),
        detailId: contestDetailId,
        historyType: 'contest' as const,
        detailLines: [
          `发起方: ${initName} / 对抗方: ${oppName}`,
          `属性: ${initAttrName} vs ${oppAttrName}`,
          `公式: ${initFormula} vs ${oppFormula}`,
          `掷骰: ${initRollTotal} vs ${oppRollTotal}`,
          `总值: ${initTotal} vs ${oppTotal}`,
          `判定: ${initConditionExpr} | ${oppConditionExpr}`,
          `结果: ${winnerText}`,
        ],
      };
      contestHistory.push(contestResultWithTimestamp);
      if (contestHistory.length > MAX_HISTORY) {
        contestHistory.shift();
      }

      // 触发事件
      emitEvent('contest', contestResultWithTimestamp);
    };

    // 绑定对抗检定按钮点击事件
    panel.find('#contest-roll-btn').click(function () {
      performContestRoll();
    });

    // [新增] 切换到普通检定
    panel.find('#contest-switch-normal').click(function () {
      var initValueInput = panel.find('#contest-init-value').val().trim();
      var currentInitName = panel.find('#contest-init-name').val() || '';
      var currentDice = panel.find('#contest-dice-type').val() || '1d100';
      var initiatorNameVal = panel.find('#contest-init-display').val().trim();
      closePanel();
      showDicePanel({
        // 只有用户实际输入了值才传递，否则传 null 让普通检定面板显示 placeholder
        attrValue: initValueInput !== '' ? parseInt(initValueInput, 10) : null,
        targetValue: null,
        targetName: currentInitName,
        diceType: currentDice,
        initiatorName: initiatorNameVal,
      });
    });
    panel.find('#contest-history-btn').click(function (e) {
      e.stopPropagation();
      showGlobalDiceHistoryDialog();
    });
    // 齿轮设置按钮点击 - 调用统一设置面板
    // 对抗检定根据当前骰子类型判断规则：1d20 -> DND, 其他 -> COC
    panel.find('.acu-contest-config-btn').click(function (e) {
      e.stopPropagation();
      // [废弃] 旧的规则设置弹窗调用已替换为高级检定管理
      // const currentDice = panel.find('#contest-dice-type').val() || '1d100';
      // const isDND = currentDice === '1d20';
      // showDiceSettingsPanel(isDND);
      showAdvancedPresetManager({ fromDicePanel: true });
    });
    var closePanel = function () {
      overlay.remove();
      panel.remove();
    };
    panel.on('click', function (e) {
      e.stopPropagation();
    });
    overlay.click(closePanel);
    panel.find('.acu-contest-close').click(closePanel);
  };

  const parseInSceneStatus = (value, headerName) => {
    const val = String(value || '')
      .trim()
      .toLowerCase();
    const header = String(headerName || '').toLowerCase();
    if (!val) return false;

    if (header.includes('离场')) {
      return val === '否' || val === 'false' || val === 'no';
    }

    return val.startsWith('在场') || val === 'true' || val === '是' || val === 'yes';
  };

  const buildMapViewModel = async () => {
    const rawData = cachedRawData || getTableData();
    const allTables = processJsonData(rawData || {});
    NameAliasRegistry.rebuild(allTables);
    if (!rawData || Object.keys(allTables).length === 0) return null;

    const globalResult = DashboardDataParser.findTable(allTables, 'global');
    const locationResult = DashboardDataParser.findTable(allTables, 'location');
    const npcResult = DashboardDataParser.findTable(allTables, 'npc');
    const playerResult = DashboardDataParser.findTable(allTables, 'player');
    const elementResult = (() => {
      const keywords = ['地图元素', '元素表', '地图要素', '机关', '线索'];
      for (const tableName in allTables) {
        if (keywords.some(keyword => tableName.includes(keyword))) {
          return {
            data: allTables[tableName],
            name: tableName,
            key: allTables[tableName].key,
          };
        }
      }
      return null;
    })();

    const globalHeaders = globalResult?.data?.headers || [];
    const globalRows = globalResult?.data?.rows || [];
    const globalRow = globalRows[0] || [];
    const globalConfig = DASHBOARD_TABLE_CONFIG.global;
    const detailIdx = DashboardDataParser.findColumnIndex(globalHeaders, 'detailLocation', globalConfig);
    const regionIdx = DashboardDataParser.findColumnIndex(globalHeaders, 'currentLocation', globalConfig);
    const detailLocation = detailIdx >= 0 ? String(globalRow[detailIdx] || '').trim() : '';
    const currentRegion = regionIdx >= 0 ? String(globalRow[regionIdx] || '').trim() : '';

    if (!locationResult?.data) return null;

    const findColumnIndex = (headers, keywords, fallbackIndex = null) => {
      for (let i = 0; i < headers.length; i++) {
        const h = String(headers[i] || '').toLowerCase();
        if (keywords.some(keyword => h.includes(keyword.toLowerCase()))) return i;
      }
      return fallbackIndex ?? -1;
    };

    const locations = new Map();
    const locationHeaders = locationResult.data.headers || [];
    const locationRows = locationResult.data.rows || [];
    const locationNameIdx = findColumnIndex(locationHeaders, ['详细地点', '具体位置', '地点名', '地点', '名称'], 1);
    const locationRegionIdx = findColumnIndex(locationHeaders, ['次要地区', '次要区域', '区域', '地区'], null);
    const locationTypeIdx = findColumnIndex(locationHeaders, ['地点类型', '地点类别', '类型'], null);
    const locationDescIdx = findColumnIndex(locationHeaders, ['环境描述', '描述', '说明', '介绍', '氛围描述'], null);
    const locationImportanceIdx = findColumnIndex(locationHeaders, ['重要度', '重要性'], null);
    const locationExploreIdx = findColumnIndex(locationHeaders, ['探索状态', '探索进度', '状态'], null);

    // 先收集所有地点名，用于批量emoji分配（去重）
    const allLocationNames: string[] = [];
    locationRows.forEach(row => {
      const name = String(row[locationNameIdx] || '')
        .trim()
        .replace(/[\u200B-\u200D\uFEFF]/g, '');
      if (name) allLocationNames.push(name);
    });
    const emojiMap = resolveBatchLocationEmojis(allLocationNames);

    locationRows.forEach((row, idx) => {
      const name = String(row[locationNameIdx] || '')
        .trim()
        .replace(/[\u200B-\u200D\uFEFF]/g, '');
      if (!name) return;
      const region = locationRegionIdx >= 0 ? String(row[locationRegionIdx] || '').trim() : '';

      const location = {
        name,
        region,
        locationType: locationTypeIdx >= 0 ? row[locationTypeIdx] || '' : '',
        description: locationDescIdx >= 0 ? row[locationDescIdx] || '' : '',
        importance: locationImportanceIdx >= 0 ? row[locationImportanceIdx] || '' : '',
        exploreStatus: locationExploreIdx >= 0 ? row[locationExploreIdx] || '' : '',
        emoji: emojiMap.get(name) ?? null,
        tableKey: locationResult.key || '',
        rowIndex: idx,
      };
      locations.set(name, location);
    });

    const elements = new Map();
    const addElement = (locationName, element) => {
      if (!elements.has(locationName)) {
        elements.set(locationName, []);
      }
      elements.get(locationName).push(element);
    };

    if (elementResult?.data) {
      const elementHeaders = elementResult.data.headers || [];
      const elementRows = elementResult.data.rows || [];
      const elementNameIdx = findColumnIndex(elementHeaders, ['元素名称', '名称', '元素名'], 1);
      const elementTypeIdx = findColumnIndex(elementHeaders, ['元素类型', '类型', '元素分类'], 2);
      const elementLocationIdx = findColumnIndex(elementHeaders, ['所在地点', '位置', '地点'], 3);
      const elementDescIdx = findColumnIndex(elementHeaders, ['元素描述', '描述', '说明'], null);
      const elementStatusIdx = findColumnIndex(elementHeaders, ['状态', '交互状态'], null);
      const elementInteractIdx = findColumnIndex(elementHeaders, ['交互选项', '交互', '互动', '可交互'], null);

      elementRows.forEach((row, idx) => {
        const name = String(row[elementNameIdx] || '').trim();
        if (!name) return;
        const locationName = String(row[elementLocationIdx] || '').trim();
        if (!locationName) return;
        if (currentRegion && locations.size > 0 && !locations.has(locationName)) return;

        const rawInteractions = elementInteractIdx >= 0 ? row[elementInteractIdx] : '';
        const interactions = String(rawInteractions || '')
          .split(/[,，、;；]/)
          .map(item => item.trim())
          .filter(Boolean);
        const typeValue = elementTypeIdx >= 0 ? row[elementTypeIdx] || '' : '';
        const element = {
          name,
          type: typeValue,
          location: locationName,
          description: elementDescIdx >= 0 ? row[elementDescIdx] || '' : '',
          status: elementStatusIdx >= 0 ? row[elementStatusIdx] || '' : '',
          interactions,
          emoji: getElementEmoji(name, typeValue),
          tableKey: elementResult.key || '',
          rowIndex: idx,
        };
        addElement(locationName, element);
      });
    }

    const characters = new Map();
    const addCharacter = async character => {
      const avatarUrl = await AvatarManager.getAsync(character.name);
      const full = {
        ...character,
        avatarUrl,
        avatarOffsetX: AvatarManager.getOffsetX(character.name),
        avatarOffsetY: AvatarManager.getOffsetY(character.name),
        avatarScale: AvatarManager.getScale(character.name),
      };
      if (!characters.has(full.location)) {
        characters.set(full.location, []);
      }
      characters.get(full.location).push(full);
    };

    let playerLocation = '';

    if (playerResult?.data) {
      const playerConfig = DASHBOARD_TABLE_CONFIG.player;
      const playerHeaders = playerResult.data.headers || [];
      const playerRows = playerResult.data.rows || [];
      const playerRow = playerRows[0] || [];
      const playerNameIdx = DashboardDataParser.findColumnIndex(playerHeaders, 'name', playerConfig);
      const playerPosIdx = DashboardDataParser.findColumnIndex(playerHeaders, 'position', playerConfig);
      const playerNameRaw = playerNameIdx >= 0 ? playerRow[playerNameIdx] : getPlayerName();
      const playerPosRaw = playerPosIdx >= 0 ? playerRow[playerPosIdx] : '';
      const playerName = getDisplayName(String(playerNameRaw || '').trim());
      playerLocation = String(playerPosRaw || '').trim();

      if (!playerLocation && detailLocation) {
        playerLocation = detailLocation;
      }

      if (playerName && playerLocation) {
        await addCharacter({
          name: playerName,
          location: playerLocation,
          isPlayer: true,
          isInScene: true,
          tableKey: playerResult.key || '',
          rowIndex: 0,
        });
      }
    }

    if (npcResult?.data) {
      const npcConfig = DASHBOARD_TABLE_CONFIG.npc;
      const npcHeaders = npcResult.data.headers || [];
      const npcRows = npcResult.data.rows || [];
      const npcNameIdx = DashboardDataParser.findColumnIndex(npcHeaders, 'name', npcConfig);
      const npcPosIdx = DashboardDataParser.findColumnIndex(npcHeaders, 'position', npcConfig);
      const npcInSceneIdx = DashboardDataParser.findColumnIndex(npcHeaders, 'inScene', npcConfig);

      for (let idx = 0; idx < npcRows.length; idx++) {
        const row = npcRows[idx];
        const npcName = getDisplayName(String(row[npcNameIdx] || '').trim());
        if (!npcName) continue;
        const locationName = String(row[npcPosIdx] || '').trim();
        if (!locationName) continue;
        if (currentRegion && locations.size > 0 && !locations.has(locationName)) continue;
        const inSceneValue = npcInSceneIdx >= 0 ? row[npcInSceneIdx] : '';
        const inSceneHeader = npcHeaders[npcInSceneIdx] || '';
        const isInScene = parseInSceneStatus(inSceneValue, inSceneHeader);

        await addCharacter({
          name: npcName,
          location: locationName,
          isPlayer: false,
          isInScene,
          tableKey: npcResult.key || '',
          rowIndex: idx,
        });
      }
    }

    const locationIterator = locations.values();
    const firstLocation = locationIterator.next().value;

    const allRegions = [...new Set(Array.from(locations.values()).map(l => l.region || '其他'))].sort();
    // 确保"其他"标签页始终在最后
    const otherIndex = allRegions.indexOf('其他');
    if (otherIndex > -1) {
      allRegions.splice(otherIndex, 1);
      allRegions.push('其他');
    }

    const getHotLocationsInRegion = region => {
      const regionName = region || '其他';
      return Array.from(locations.values())
        .filter(l => (l.region || '其他') === regionName)
        .sort((a, b) => {
          const scoreA = (characters.get(a.name)?.length || 0) + (elements.get(a.name)?.length || 0);
          const scoreB = (characters.get(b.name)?.length || 0) + (elements.get(b.name)?.length || 0);
          return scoreB - scoreA;
        });
    };

    const focusLocation = (() => {
      if (detailLocation && locations.has(detailLocation)) return detailLocation;
      if (playerLocation && locations.has(playerLocation)) return playerLocation;
      const fallbackRegion = allRegions[0];
      if (fallbackRegion) {
        const regionLocations = getHotLocationsInRegion(fallbackRegion);
        if (regionLocations.length > 0) return regionLocations[0].name;
      }
      return firstLocation ? firstLocation.name : '';
    })();

    return {
      currentRegion: currentRegion || locations.get(playerLocation)?.region || '其他',
      detailLocation,
      focusLocation,
      playerLocation,
      locations,
      elements,
      characters,
      allRegions,
    };
  };

  // 防止地图弹窗重复打开
  let isMapOpening = false;

  const showMapVisualization = async () => {
    const { $ } = getCore();

    // 防止重复打开
    if (isMapOpening) return;
    isMapOpening = true;

    // 确保移除所有旧的overlay
    $('.acu-map-overlay').remove();

    let viewModel = await buildMapViewModel();
    if (!viewModel) {
      isMapOpening = false;
      if (window.toastr) window.toastr.warning('未找到地图数据');
      return;
    }

    const config = getConfig();

    // 会话级缓存：记录用户在每个地区选中的地点
    const tabSelectionCache = new Map<string, string>();

    // 热度排序辅助函数：返回指定地区按热度降序排列的地点数组
    const getHotLocationsInRegion = (region: string) => {
      const regionName = region || '其他';
      return Array.from(viewModel.locations.values())
        .filter(l => (l.region || '其他') === regionName)
        .sort((a, b) => {
          const scoreA =
            (viewModel.characters.get(a.name)?.length || 0) + (viewModel.elements.get(a.name)?.length || 0);
          const scoreB =
            (viewModel.characters.get(b.name)?.length || 0) + (viewModel.elements.get(b.name)?.length || 0);
          return scoreB - scoreA;
        });
    };

    // 复用"回到当前地点"的逻辑来确定初始焦点和地区
    const detailLocation = viewModel.detailLocation || '';
    const playerLocation = viewModel.playerLocation || '';
    let focusLocation = '';
    let selectedRegion = viewModel.currentRegion;

    // 优先级: 当前详细地点 > 玩家所在地点 > viewModel.focusLocation
    if (detailLocation && viewModel.locations.has(detailLocation)) {
      focusLocation = detailLocation;
      const targetLocation = viewModel.locations.get(detailLocation);
      selectedRegion = targetLocation?.region || viewModel.currentRegion || '其他';
    } else if (playerLocation && viewModel.locations.has(playerLocation)) {
      focusLocation = playerLocation;
      const targetLocation = viewModel.locations.get(playerLocation);
      selectedRegion = targetLocation?.region || viewModel.currentRegion || '其他';
    } else if (viewModel.focusLocation && viewModel.locations.has(viewModel.focusLocation)) {
      focusLocation = viewModel.focusLocation;
      const targetLocation = viewModel.locations.get(focusLocation);
      selectedRegion = targetLocation?.region || viewModel.currentRegion || '其他';
    }

    if (focusLocation) {
      Store.set(STORAGE_KEY_MAP_FOCUS, focusLocation);
      // 将初始地点写入对应地区的缓存，这样用户切走再切回来时能保持选中
      tabSelectionCache.set(selectedRegion, focusLocation);
    }

    const overlay = $(`
            <div class="acu-map-overlay acu-theme-${config.theme}">
                <div class="acu-map-container">
                    <div class="acu-panel-header">
                        <div class="acu-map-title">
                            <i class="fa-solid fa-map-location-dot"></i>
                            <span class="acu-map-region-name">地图</span>
                        </div>
                        <div class="acu-map-region-tabs"></div>
                        <div class="acu-map-actions">
                            <button class="acu-map-back-btn" title="回到当前地点"><i class="fa-solid fa-location-crosshairs"></i></button>
                            <button class="acu-close-btn acu-map-close"><i class="fa-solid fa-times"></i></button>
                        </div>
                    </div>
                    <div class="acu-map-body">
                        <div class="acu-map-focus-area"></div>
                        <div class="acu-map-thumbnails"></div>
                    </div>
                </div>
            </div>
        `);

    $('body').append(overlay);

    const overlayEl = overlay[0];
    overlayEl.style.setProperty('position', 'fixed', 'important');
    overlayEl.style.setProperty('top', '0', 'important');
    overlayEl.style.setProperty('left', '0', 'important');
    overlayEl.style.setProperty('right', '0', 'important');
    overlayEl.style.setProperty('bottom', '0', 'important');
    overlayEl.style.setProperty('width', '100vw', 'important');
    overlayEl.style.setProperty('height', '100vh', 'important');
    overlayEl.style.setProperty('display', 'flex', 'important');
    overlayEl.style.setProperty('justify-content', 'center', 'important');
    overlayEl.style.setProperty('align-items', 'center', 'important');
    overlayEl.style.setProperty('z-index', '31100', 'important');

    // selectedRegion 已在上方确定，无需重新赋值
    const $focusArea = overlay.find('.acu-map-focus-area');
    const $thumbnails = overlay.find('.acu-map-thumbnails');

    // 图标渲染：支持 fa:xxx / ti:xxx 简写和原生emoji
    const renderIconContent = (icon: string): string => {
      if (icon.startsWith('fa:')) {
        const name = icon.slice(3);
        return `<i class="fa-solid fa-${name} acu-theme-icon"></i>`;
      }
      if (icon.startsWith('ti:')) {
        const name = icon.slice(3);
        return `<i class="ti ti-${name} acu-theme-icon"></i>`;
      }
      return icon;
    };

    const renderElementChip = element => {
      const name = element.name || element.type || '元素';
      const emoji = element.emoji ? `<span class="acu-map-chip-emoji">${renderIconContent(element.emoji)}</span>` : '';
      return `
                 <div class="acu-map-element-chip acu-dash-preview-trigger" data-table-key="${escapeHtml(
                   element.tableKey || '',
                 )}" data-row-index="${element.rowIndex}">
                     ${emoji}
                     <span class="acu-map-chip-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span>
                 </div>
             `;
    };

    const renderFocusArea = (model, locationName) => {
      const location = model.locations.get(locationName);
      if (!location) {
        return '<div class="acu-map-loading" style="grid-column: 1 / -1;"><div class="acu-map-spinner"></div></div>';
      }

      const characters = model.characters.get(locationName) || [];
      const elements = model.elements.get(locationName) || [];

      // 分割角色和元素到左右两侧
      const leftChars = characters.slice(0, Math.ceil(characters.length / 2));
      const rightChars = characters.slice(Math.ceil(characters.length / 2));
      const leftElems = elements.slice(0, Math.ceil(elements.length / 2));
      const rightElems = elements.slice(Math.ceil(elements.length / 2));

      const renderAvatarHtml = char => {
        const displayName = replaceUserPlaceholders(char.name);
        const avatarStyle = char.avatarUrl
          ? `background-image:url('${char.avatarUrl}');background-size:${char.avatarScale}%;background-position:${char.avatarOffsetX}% ${char.avatarOffsetY}%;`
          : '';
        return `
            <div class="acu-map-avatar acu-dash-preview-trigger" data-table-key="${escapeHtml(
              char.tableKey || '',
            )}" data-row-index="${char.rowIndex}">
                <div class="acu-map-avatar-circle" style="${avatarStyle}">
                    ${char.avatarUrl ? '' : `<span>${escapeHtml(displayName.charAt(0))}</span>`}
                </div>
                <div class="acu-map-avatar-name" title="${escapeHtml(displayName)}">${escapeHtml(
                  displayName.length > 4 ? displayName.substring(0, 4) + '..' : displayName,
                )}</div>
            </div>
        `;
      };

      const leftAvatarsHtml = leftChars.length ? leftChars.map(renderAvatarHtml).join('') : '';
      const rightAvatarsHtml = rightChars.length ? rightChars.map(renderAvatarHtml).join('') : '';
      const leftElemsHtml = leftElems.length ? leftElems.map(e => renderElementChip(e)).join('') : '';
      const rightElemsHtml = rightElems.length ? rightElems.map(e => renderElementChip(e)).join('') : '';

      const emojiHtml = location.emoji
        ? `<div class="acu-map-location-emoji">${renderIconContent(location.emoji)}</div>`
        : `<div class="acu-map-location-text">${escapeHtml(location.name.charAt(0) || '□')}</div>`;

      return `
        <div class="acu-map-wing left">
            <div class="acu-map-avatar-group acu-group-left">${leftAvatarsHtml || ''}</div>
            <div class="acu-map-element-group acu-group-left">${leftElemsHtml || ''}</div>
        </div>
        <div class="acu-map-stage-center acu-dash-preview-trigger" data-table-key="${escapeHtml(
          location.tableKey,
        )}" data-row-index="${location.rowIndex}">
            ${emojiHtml}
            <div class="acu-map-location-name" title="${escapeHtml(location.name)}">${escapeHtml(location.name)}</div>
        </div>
        <div class="acu-map-wing right">
            <div class="acu-map-avatar-group acu-group-right">${rightAvatarsHtml || ''}</div>
            <div class="acu-map-element-group acu-group-right">${rightElemsHtml || ''}</div>
        </div>
        <div class="acu-map-mobile-stack">
            <div class="acu-map-mobile-avatars">${leftAvatarsHtml || ''}${rightAvatarsHtml || ''}</div>
            <div class="acu-map-mobile-elements">${leftElemsHtml || ''}${rightElemsHtml || ''}</div>
        </div>
    `;
    };

    const renderThumbnailLocation = (model, location, isActive) => {
      const charCount = (model.characters.get(location.name) || []).length;
      const elementCount = (model.elements.get(location.name) || []).length;
      const totalCount = charCount + elementCount;
      const emoji = location.emoji
        ? `<div class="acu-map-thumbnail-emoji">${renderIconContent(location.emoji)}</div>`
        : `<div class="acu-map-thumbnail-placeholder">${escapeHtml(location.name.charAt(0) || '□')}</div>`;
      const badgeHtml = totalCount > 0 ? `<div class="acu-map-thumbnail-badge">${totalCount}</div>` : '';
      return `
        <div class="acu-map-thumbnail ${isActive ? 'active' : ''}" data-location="${escapeHtml(location.name)}">
            ${badgeHtml}
            ${emoji}
            <div class="acu-map-thumbnail-name" title="${escapeHtml(location.name)}">${escapeHtml(
              location.name.length > 6 ? location.name.substring(0, 6) + '..' : location.name,
            )}</div>
        </div>
    `;
    };

    const renderRegionTabs = (regions, currentRegion) => {
      if (regions.length <= 1) return '';
      return regions
        .map(
          r =>
            `<button class="acu-map-region-tab ${r === currentRegion ? 'active' : ''}" data-region="${escapeHtml(
              r,
            )}">${escapeHtml(r)}</button>`,
        )
        .join('');
    };

    const refreshPanel = () => {
      $focusArea.html(renderFocusArea(viewModel, focusLocation));

      const regionLocations = Array.from(viewModel.locations.values())
        .filter(l => (l.region || '其他') === selectedRegion)
        .sort((a, b) => {
          // 按交互热度排序: 角色数 + 元素数（降序）
          const scoreA =
            (viewModel.characters.get(a.name)?.length || 0) + (viewModel.elements.get(a.name)?.length || 0);
          const scoreB =
            (viewModel.characters.get(b.name)?.length || 0) + (viewModel.elements.get(b.name)?.length || 0);
          return scoreB - scoreA;
        });

      const thumbnails = regionLocations
        .map(location => renderThumbnailLocation(viewModel, location, location.name === focusLocation))
        .join('');
      $thumbnails.html(thumbnails || '<div class="acu-map-empty">该地区暂无其他地点</div>');

      overlay.find('.acu-map-region-tabs').html(renderRegionTabs(viewModel.allRegions, selectedRegion));
    };

    const setFocusLocation = name => {
      if (!name) return;
      focusLocation = name;
      Store.set(STORAGE_KEY_MAP_FOCUS, focusLocation);
      // 将用户选择写入当前地区的缓存
      tabSelectionCache.set(selectedRegion, focusLocation);
      refreshPanel();
    };

    refreshPanel();

    // [新增] 存储刷新回调，供外部删除操作调用
    overlay.data('refreshMapData', async () => {
      const newViewModel = await buildMapViewModel();
      if (newViewModel) {
        viewModel = newViewModel;

        // [修复] 检查当前焦点地点是否仍然存在，不存在则回退
        if (!viewModel.locations.has(focusLocation)) {
          // [优化] 优先回退到当前次要地区的第一个详细地点
          const detailLocation = viewModel.detailLocation || '';
          const playerLocation = viewModel.playerLocation || '';

          let newFocus = '';
          let newRegion = selectedRegion;

          // 优先级1: 当前次要地区的第一个可用地点
          const regionLocs = Array.from(viewModel.locations.values()).filter(
            l => (l.region || '其他') === selectedRegion,
          );
          if (regionLocs.length > 0) {
            newFocus = regionLocs[0].name;
          } else if (detailLocation && viewModel.locations.has(detailLocation)) {
            // 优先级2: detailLocation（当前次要地区不存在时）
            newFocus = detailLocation;
            const loc = viewModel.locations.get(detailLocation);
            newRegion = loc?.region || newRegion;
          } else if (playerLocation && viewModel.locations.has(playerLocation)) {
            // 优先级3: playerLocation
            newFocus = playerLocation;
            const loc = viewModel.locations.get(playerLocation);
            newRegion = loc?.region || newRegion;
          } else if (viewModel.focusLocation && viewModel.locations.has(viewModel.focusLocation)) {
            // 优先级4: focusLocation
            newFocus = viewModel.focusLocation;
            const loc = viewModel.locations.get(newFocus);
            newRegion = loc?.region || newRegion;
          } else {
            // 兜底：任意第一个地点
            const firstLoc = Array.from(viewModel.locations.values())[0];
            if (firstLoc) {
              newFocus = firstLoc.name;
              newRegion = firstLoc.region || '其他';
            }
          }

          if (newFocus) {
            focusLocation = newFocus;
            selectedRegion = newRegion;
            // 同步更新Store，防止下次打开地图时跳回已删除地点
            Store.set(STORAGE_KEY_MAP_FOCUS, focusLocation);
            // 更新tab缓存
            tabSelectionCache.set(selectedRegion, focusLocation);
          }
        }

        refreshPanel();
      }
    });

    // [修复] 直接绑定关闭按钮事件（而非事件委托，避免被其他事件干扰）
    const $closeBtn = overlay.find('.acu-map-close');
    $closeBtn.on('click', e => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      overlay.remove();
    });
    overlay.on('click', '.acu-map-region-tab', function () {
      const newRegion = $(this).data('region');
      if (newRegion === selectedRegion) return;
      selectedRegion = newRegion;

      // 检查当前 focusLocation 是否在新地区内
      const regionLocations = Array.from(viewModel.locations.values()).filter(
        l => (l.region || '其他') === selectedRegion,
      );
      const currentInNewRegion = regionLocations.find(l => l.name === focusLocation);

      if (!currentInNewRegion && regionLocations.length > 0) {
        // 优先级: 缓存的选中地点 > 热度最高的地点
        const cachedLocation = tabSelectionCache.get(selectedRegion);
        const cachedInRegion = cachedLocation && regionLocations.find(l => l.name === cachedLocation);

        if (cachedInRegion) {
          // 使用缓存的选中地点
          focusLocation = cachedLocation;
        } else {
          // 使用热度最高的地点（已按热度排序）
          const hotLocations = getHotLocationsInRegion(selectedRegion);
          focusLocation = hotLocations.length > 0 ? hotLocations[0].name : regionLocations[0].name;
        }
        Store.set(STORAGE_KEY_MAP_FOCUS, focusLocation);
      }

      refreshPanel();
    });
    setupOverlayClose(overlay, 'acu-map-overlay', () => {
      overlay.remove();
    });

    overlay.on('click', '.acu-map-thumbnail', function () {
      const locationName = $(this).data('location');
      if (locationName) setFocusLocation(locationName);
    });

    overlay.on('click', '.acu-map-back-btn', () => {
      const fallbackFocus = viewModel.focusLocation;
      const detailLocation = viewModel.detailLocation || '';
      const playerLocation = viewModel.playerLocation || '';

      let target = '';
      if (detailLocation && viewModel.locations.has(detailLocation)) {
        target = detailLocation;
      } else if (playerLocation && viewModel.locations.has(playerLocation)) {
        target = playerLocation;
      } else if (fallbackFocus && viewModel.locations.has(fallbackFocus)) {
        target = fallbackFocus;
      }

      if (!target) return;

      // 找到目标地点所属的地区，同时切换
      const targetLocation = viewModel.locations.get(target);
      const targetRegion = targetLocation?.region || viewModel.currentRegion || '其他';
      if (targetRegion !== selectedRegion) {
        selectedRegion = targetRegion;
      }

      focusLocation = target;
      Store.set(STORAGE_KEY_MAP_FOCUS, focusLocation);
      refreshPanel();
    });

    // 弹窗创建完成，重置锁（允许关闭后重新打开）
    isMapOpening = false;

    // 地图打开时只加载一次数据，不需要持续轮询
    // 用户无法在地图弹窗打开时修改表格数据
  };

  // 人物关系图可视化
  const showRelationshipGraph = npcTable => {
    console.info('[DICE]开始抓取人物关系表数据...');
    const { $ } = getCore();
    $('.acu-relation-graph-overlay').remove();

    const config = getConfig();

    const headers = npcTable.headers || [];
    const rows = npcTable.rows || [];

    const nameIdx = headers.findIndex(h => h && (h.includes('姓名') || h.includes('名称'))) || 1;
    const relationIdx = headers.findIndex(h => h && h.includes('人际关系'));
    const npcTableKey = npcTable.key || '';

    console.info(`[DICE]人物关系表查找: 表格"${npcTableKey || '未知'}"，共${rows.length}行数据`);

    if (relationIdx < 0) {
      console.warn('[DICE]人物关系表查找: 未找到"人际关系"列');
      if (window.toastr) window.toastr.warning('未找到"人际关系"列');
      return;
    }

    const nodes = new Map();
    const edges = [];

    // 统一解析用户占位符为{{user}}主键（仅用于渲染，不自动管理别名）
    const resolveUserPlaceholder = name => {
      if (!name) return name;
      const playerName = getPlayerName();
      const personaName = getPersonaName();

      // 明确的用户占位符变体
      const diceCfg = getDiceConfig();
      const explicitUserVariants = ['<user>', '{{user}}'];
      if (diceCfg.autoMergeProtagonist !== false) {
        explicitUserVariants.push('主角');
      }
      const isExplicitUserVariant = explicitUserVariants.some(
        v => name === v || name.toLowerCase() === v.toLowerCase(),
      );

      // 如果当前persona名匹配，也视为用户占位符
      const isPersonaName = personaName && name === personaName;

      // 检查是否是主角表名称（模糊匹配：表名包含"主角"）
      // 仅在 autoMergeProtagonist 开启时才将主角名映射为 {{user}}
      const isPlayerName = (() => {
        if (!playerName) return false;
        if (diceCfg.autoMergeProtagonist === false) return false;
        // 精确匹配
        if (name === playerName) return true;
        // 或者通过别名系统检查
        const primaryName = AvatarManager.getPrimaryName(name);
        return primaryName === playerName;
      })();

      // 统一映射到{{user}}主键（仅用于渲染）
      if (isExplicitUserVariant || isPersonaName || isPlayerName) {
        return '{{user}}';
      }

      // 其他情况使用别名系统解析
      return AvatarManager.getPrimaryName(name);
    };

    const resolveName = name => resolveUserPlaceholder(getDisplayName(name));

    const rawData = cachedRawData || getTableData();
    // 重建别名注册表
    NameAliasRegistry.rebuild(processJsonData(rawData || {}));
    let playerName = '主角';
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (sheet?.name?.includes('主角') && sheet.content?.[1]) {
          playerName = getDisplayName(sheet.content[1][1] || '主角');
          break;
        }
      }
    }
    const resolvedPlayerName = resolveName(playerName);
    const playerTableKey = (() => {
      for (const k in rawData) {
        if (rawData[k]?.name?.includes('主角')) return k;
      }
      return '';
    })();
    nodes.set(resolvedPlayerName, {
      name: resolvedPlayerName,
      isPlayer: true,
      x: 0,
      y: 0,
      tableKey: playerTableKey,
      rowIndex: 0,
    });

    // 查找"在场状态"列索引（模糊匹配）
    const inSceneColIdx = headers.findIndex(h => h && h.includes('在场'));

    rows.forEach((row, idx) => {
      const rawNpcName = row[nameIdx];
      if (!rawNpcName) return;

      const npcName = resolveName(rawNpcName);

      // 判断是否在场：支持多种格式
      let isInScene = false;
      if (inSceneColIdx > 0) {
        const inSceneVal = String(row[inSceneColIdx] || '')
          .trim()
          .toLowerCase();
        const header = String(headers[inSceneColIdx] || '').toLowerCase();

        if (header.includes('离场')) {
          isInScene = inSceneVal === '否' || inSceneVal === 'false' || inSceneVal === 'no';
        } else {
          isInScene =
            inSceneVal.startsWith('在场') || inSceneVal === 'true' || inSceneVal === '是' || inSceneVal === 'yes';
        }
      }

      if (!nodes.has(npcName)) {
        nodes.set(npcName, {
          name: npcName,
          isPlayer: false,
          x: 0,
          y: 0,
          tableKey: npcTableKey,
          rowIndex: idx,
          isInScene: isInScene,
        });
      }

      const relationStr = row[relationIdx] || '';
      const relations = parseRelationshipString(relationStr);

      relations.forEach(rel => {
        if (!rel.name) return;
        const resolvedRelName = resolveName(rel.name);

        if (resolvedRelName === npcName) return;

        if (!nodes.has(resolvedRelName)) {
          // 查找该人物在NPC表中的行索引
          let relRowIndex = -1;
          let relIsInScene = false;
          for (let ri = 0; ri < rows.length; ri++) {
            if (resolveName(rows[ri][nameIdx]) === resolvedRelName) {
              relRowIndex = ri;
              // 同时读取该角色的在场状态
              if (inSceneColIdx > 0) {
                const inSceneVal = String(rows[ri][inSceneColIdx] || '')
                  .trim()
                  .toLowerCase();
                const header = String(headers[inSceneColIdx] || '').toLowerCase();

                if (header.includes('离场')) {
                  relIsInScene = inSceneVal === '否' || inSceneVal === 'false' || inSceneVal === 'no';
                } else {
                  relIsInScene =
                    inSceneVal.startsWith('在场') ||
                    inSceneVal === 'true' ||
                    inSceneVal === '是' ||
                    inSceneVal === 'yes';
                }
              }
              break;
            }
          }
          nodes.set(resolvedRelName, {
            name: resolvedRelName,
            isPlayer: resolvedRelName === resolvedPlayerName,
            x: 0,
            y: 0,
            tableKey: relRowIndex >= 0 ? npcTableKey : '',
            rowIndex: relRowIndex >= 0 ? relRowIndex : undefined,
            isInScene: relIsInScene,
          });
        }

        // 清洗关系词：移除冗余前缀/后缀，分割多关系词
        const cleanRelation = rawRel => {
          if (!rawRel) return [];
          const parts = String(rawRel)
            .split(/[,，、;；\/\|]+|\s*[和与&]\s*|\s{2,}|\n/)
            .map(s => s.trim())
            .filter(s => s && s.length < 30); // 放宽初筛限制，后续智能提取

          // 常见关系词库（用于从长文本中智能提取）
          const commonRelations = [
            '恋人',
            '情侣',
            '夫妻',
            '伴侣',
            '爱人',
            '男友',
            '女友',
            '前男友',
            '前女友',
            '朋友',
            '好友',
            '挚友',
            '密友',
            '闺蜜',
            '死党',
            '知己',
            '损友',
            '同学',
            '校友',
            '同窗',
            '学长',
            '学姐',
            '学弟',
            '学妹',
            '前辈',
            '后辈',
            '同事',
            '上司',
            '下属',
            '老板',
            '员工',
            '搭档',
            '队友',
            '战友',
            '伙伴',
            '师父',
            '师傅',
            '徒弟',
            '弟子',
            '老师',
            '学生',
            '导师',
            '门生',
            '父亲',
            '母亲',
            '儿子',
            '女儿',
            '兄弟',
            '姐妹',
            '哥哥',
            '姐姐',
            '弟弟',
            '妹妹',
            '爷爷',
            '奶奶',
            '外公',
            '外婆',
            '叔叔',
            '阿姨',
            '舅舅',
            '姑姑',
            '表哥',
            '表姐',
            '表弟',
            '表妹',
            '堂兄',
            '堂弟',
            '堂姐',
            '堂妹',
            '家人',
            '亲人',
            '亲戚',
            '血亲',
            '义父',
            '义母',
            '义兄',
            '义妹',
            '敌人',
            '仇人',
            '对手',
            '劲敌',
            '宿敌',
            '情敌',
            '死敌',
            '冤家',
            '邻居',
            '室友',
            '房东',
            '租客',
            '客户',
            '商人',
            '雇主',
            '雇员',
            '信徒',
            '教徒',
            '追随者',
            '崇拜者',
            '粉丝',
            '陌生人',
            '熟人',
            '路人',
            '过客',
          ];

          return parts
            .map(p => {
              // [新增] 移除所有中英文括号及其内容
              p = p.replace(/[（(][^）)]*[）)]/g, '').trim();
              // === 特殊前缀处理：XX的目标/对象 → 保留XX ===
              const specialSuffixMatch = p.match(/^(.+)的(目标|对象)$/);
              if (specialSuffixMatch) {
                p = specialSuffixMatch[1]; // "执念的目标" → "执念"
              } else {
                // === 普通情况：XX的YY → 保留YY ===
                p = p.replace(/^[\u4e00-\u9fa5]{2,4}的(?=[\u4e00-\u9fa5]{1,4}$)/, '');
              }

              // === 移除冗余前缀 ===
              p = p.replace(/^(?:属于|作为|身为|是其?|为其?|乃)/, '');
              p = p.replace(/^(?:曾经是?|以前是?|原本是?|前)/, '前');
              p = p.replace(/^(?:互为|彼此是?|相互是?)/, '');

              // === 移除冗余后缀 ===
              p = p.replace(/关系$/, '');
              p = p.replace(/对象$/, '');
              p = p.replace(/目标$/, '');

              // === 特殊短语替换 ===
              p = p.replace(/^关系复杂$/, '复杂');
              p = p.replace(/^关系不明$/, '不明');
              p = p.replace(/^关系微妙$/, '微妙');
              p = p.replace(/^关系紧张$/, '紧张');
              p = p.replace(/^关系亲密$/, '亲密');
              p = p.replace(/^关系疏远$/, '疏远');
              p = p.replace(/^(?:不认识|不熟悉|陌生人?)$/, '陌生');
              p = p.replace(/^(?:认识|熟人)$/, '熟人');
              p = p.replace(/^(?:好朋友|挚友|密友|至交)$/, '挚友');
              p = p.replace(/^(?:男朋友|男友)$/, '男友');
              p = p.replace(/^(?:女朋友|女友)$/, '女友');
              p = p.replace(/^(?:前男友|前男朋友)$/, '前男友');
              p = p.replace(/^(?:前女友|前女朋友)$/, '前女友');
              p = p.replace(/^(?:暗恋对象|暗恋)$/, '暗恋');
              p = p.replace(/^(?:单相思|单恋)$/, '单恋');
              p = p.replace(/^(?:青梅竹马|儿时玩伴|发小)$/, '青梅竹马');
              p = p.replace(/^(?:同班同学|同级同学)$/, '同学');
              p = p.replace(/^(?:工作伙伴|合作伙伴|搭档)$/, '搭档');

              p = p.trim();

              // === [新增] 智能提取：如果处理后仍然过长，尝试从末尾提取常见关系词 ===
              if (p.length > 8) {
                // 尝试匹配末尾的常见关系词
                for (const rel of commonRelations) {
                  if (p.endsWith(rel)) {
                    return rel;
                  }
                }
                // 如果没匹配到，尝试提取最后2-4个字
                const lastChars = p.slice(-4);
                for (const rel of commonRelations) {
                  if (lastChars.includes(rel)) {
                    return rel;
                  }
                }
                // 兜底：取最后3个字
                return p.slice(-3);
              }

              return p;
            })
            .filter(s => s && s.length > 0 && s.length <= 8);
        };

        const cleanedLabels = cleanRelation(rel.relation);
        if (cleanedLabels.length === 0) cleanedLabels.push('');

        // 查找已存在的边（无论方向）
        let existingEdge = edges.find(
          e =>
            (e.source === npcName && e.target === resolvedRelName) ||
            (e.source === resolvedRelName && e.target === npcName),
        );

        if (!existingEdge) {
          // 创建新边，使用新的数据结构
          edges.push({
            source: npcName,
            target: resolvedRelName,
            // 新结构：分别存储两个方向的标签
            labelsFromSource: cleanedLabels.slice(0, 2), // source→target 方向，最多2个
            labelsFromTarget: [], // target→source 方向
          });
        } else {
          // 边已存在，追加标签到正确的方向
          if (existingEdge.source === npcName) {
            // 当前npc是source，追加到 labelsFromSource
            const combined = [...(existingEdge.labelsFromSource || []), ...cleanedLabels];
            // 去重并限制最多2个
            existingEdge.labelsFromSource = [...new Set(combined)].slice(0, 2);
          } else {
            // 当前npc是target，追加到 labelsFromTarget
            const combined = [...(existingEdge.labelsFromTarget || []), ...cleanedLabels];
            existingEdge.labelsFromTarget = [...new Set(combined)].slice(0, 2);
          }
        }
      });
    });

    // [新增] 同时抓取主角信息表的人际关系数据
    if (rawData) {
      for (const key in rawData) {
        const sheet = rawData[key];
        if (sheet?.name === '主角信息' && sheet.content?.[1]) {
          const playerHeaders = sheet.content[0] || [];
          const playerRow = sheet.content[1];
          const playerRelIdx = playerHeaders.findIndex(h => h && h.includes('人际关系'));
          if (playerRelIdx > 0 && playerRow[playerRelIdx]) {
            const playerRelations = parseRelationshipString(playerRow[playerRelIdx]);
            console.info(`[DICE]主角信息表人际关系: 发现${playerRelations.length}条关系`);

            playerRelations.forEach(rel => {
              if (!rel.name) return;
              const resolvedRelName = resolveName(rel.name);
              if (resolvedRelName === resolvedPlayerName) return;

              if (!nodes.has(resolvedRelName)) {
                // 尝试在NPC表中查找该人物的额外信息
                let relRowIndex = -1;
                let relIsInScene = false;
                for (let ri = 0; ri < rows.length; ri++) {
                  if (resolveName(rows[ri][nameIdx]) === resolvedRelName) {
                    relRowIndex = ri;
                    if (inSceneColIdx > 0) {
                      const inSceneVal = String(rows[ri][inSceneColIdx] || '')
                        .trim()
                        .toLowerCase();
                      const header = String(headers[inSceneColIdx] || '').toLowerCase();
                      if (header.includes('离场')) {
                        relIsInScene = inSceneVal === '否' || inSceneVal === 'false' || inSceneVal === 'no';
                      } else {
                        relIsInScene =
                          inSceneVal.startsWith('在场') ||
                          inSceneVal === 'true' ||
                          inSceneVal === '是' ||
                          inSceneVal === 'yes';
                      }
                    }
                    break;
                  }
                }
                nodes.set(resolvedRelName, {
                  name: resolvedRelName,
                  isPlayer: false,
                  x: 0,
                  y: 0,
                  tableKey: relRowIndex >= 0 ? npcTableKey : '',
                  rowIndex: relRowIndex >= 0 ? relRowIndex : undefined,
                  isInScene: relIsInScene,
                });
              }

              // 清洗关系标签（主角信息表格式通常已规范）
              const rawLabel = String(rel.relation || '').trim();
              const cleanedLabels = rawLabel
                ? rawLabel
                    .split(/[,，、\/\|]+/)
                    .map(s => s.trim())
                    .filter(s => s && s.length > 0 && s.length <= 8)
                    .slice(0, 2)
                : [''];
              if (cleanedLabels.length === 0) cleanedLabels.push('');

              // 查找已存在的边（与NPC表处理逻辑一致）
              let existingEdge = edges.find(
                e =>
                  (e.source === resolvedPlayerName && e.target === resolvedRelName) ||
                  (e.source === resolvedRelName && e.target === resolvedPlayerName),
              );

              if (!existingEdge) {
                edges.push({
                  source: resolvedPlayerName,
                  target: resolvedRelName,
                  labelsFromSource: cleanedLabels.slice(0, 2),
                  labelsFromTarget: [],
                });
              } else {
                // 边已存在（可能NPC表已创建该边），追加主角视角的标签
                if (existingEdge.source === resolvedPlayerName) {
                  const combined = [...(existingEdge.labelsFromSource || []), ...cleanedLabels];
                  existingEdge.labelsFromSource = [...new Set(combined)].slice(0, 2);
                } else {
                  const combined = [...(existingEdge.labelsFromTarget || []), ...cleanedLabels];
                  existingEdge.labelsFromTarget = [...new Set(combined)].slice(0, 2);
                }
              }
            });
          }
          break;
        }
      }
    }

    const nodeArr = Array.from(nodes.values());
    console.info(`[DICE]人物关系表数据抓取完成，共${nodeArr.length}个节点，${edges.length}条边`);
    const centerX = 400,
      centerY = 300;

    // [新增] 统计每个节点的关系数量
    const connectionCount = new Map();
    nodeArr.forEach(node => connectionCount.set(node.name, 0));
    edges.forEach(edge => {
      connectionCount.set(edge.source, (connectionCount.get(edge.source) || 0) + 1);
      connectionCount.set(edge.target, (connectionCount.get(edge.target) || 0) + 1);
    });

    // [新增] 根据屏幕尺寸和关系数量计算节点半径
    const isMobileView = window.innerWidth <= 768;
    const baseRadius = isMobileView ? 22 : 28;
    const maxRadius = isMobileView ? 38 : 50;
    const playerBaseRadius = isMobileView ? 28 : 35;
    const radiusPerConnection = isMobileView ? 2.5 : 3.5;

    // 新增：节点大小和过滤状态（必须在 getNodeRadius 之前声明）
    let nodeSizeMultiplier = 1.0; // 节点大小倍数，默认1.0
    let filterInScene = false; // 是否只显示主角+在场角色
    let filterDirectOnly = false; // 是否只显示与中心角色直接相关的
    let centerNodeName = resolvedPlayerName; // 当前中心节点（默认为主角）

    const getNodeRadius = (nodeName, isPlayer) => {
      const base = isPlayer ? playerBaseRadius : baseRadius;
      const count = connectionCount.get(nodeName) || 0;
      const calculated = Math.min(maxRadius, base + Math.sqrt(count) * radiusPerConnection);
      // 应用全局大小倍数
      return calculated * nodeSizeMultiplier;
    };

    // 将半径信息存入节点
    nodeArr.forEach(node => {
      node.radius = getNodeRadius(node.name, node.isPlayer);
    });

    // 过滤节点逻辑（支持两个筛选条件的交集）
    const getFilteredNodes = () => {
      // 两个都关闭时显示全部
      if (!filterInScene && !filterDirectOnly) return nodeArr;

      // 计算中心角色直接相关的节点集合（如果需要）
      let directNodes: Set<string> | null = null;
      if (filterDirectOnly) {
        directNodes = new Set([centerNodeName]);
        edges.forEach(edge => {
          if (edge.source === centerNodeName) directNodes!.add(edge.target);
          if (edge.target === centerNodeName) directNodes!.add(edge.source);
        });
      }

      return nodeArr.filter(n => {
        // 检查在场条件
        const passInScene = !filterInScene || n.isInScene || n.isPlayer;
        // 检查主角相关条件
        const passDirectOnly = !filterDirectOnly || directNodes!.has(n.name);
        // 两个条件取交集
        return passInScene && passDirectOnly;
      });
    };

    // [Modified] 力导向布局实现
    // ---------------------------------------------------------
    // 物理参数常量 (已调整以增加间距)
    const kRepulsion = 20000; // 斥力常数 (库仑定律) - 大幅增大以推开节点
    const kSpring = 0.02; // 弹力常数 (胡克定律) - 减小以避免拉得太紧
    const kGravity = 0.01; // 中心引力 - 减小以允许图表扩展遍布画面
    const idealLen = 250; // 理想边长 - 增大以拉开连线距离
    const iterations = 300; // 预计算迭代次数
    const timeStep = 0.5; // 模拟时间步长
    const damping = 0.8; // 速度阻尼 (摩擦力)

    // 布局缓存管理
    const LAYOUT_CACHE_KEY = 'acu-relation-graph-layout-cache';

    // 生成布局缓存键（基于节点名单）
    const getLayoutCacheKey = () => {
      const nodeNames = nodeArr
        .map(n => n.name)
        .sort()
        .join('|');
      return `${LAYOUT_CACHE_KEY}-${nodeNames}`;
    };

    // 保存布局到缓存
    const saveLayoutCache = () => {
      try {
        const cacheKey = getLayoutCacheKey();
        const layoutData = {};
        nodeArr.forEach(node => {
          layoutData[node.name] = { x: node.x, y: node.y };
        });
        localStorage.setItem(cacheKey, JSON.stringify(layoutData));
      } catch (e) {
        console.warn('[DICE]关系图 保存布局缓存失败:', e);
      }
    };

    // 从缓存加载布局
    const loadLayoutCache = () => {
      try {
        const cacheKey = getLayoutCacheKey();
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return false;

        const layoutData = JSON.parse(cached);
        let allNodesFound = true;

        // 验证缓存中是否包含所有节点
        for (const node of nodeArr) {
          if (!layoutData[node.name]) {
            allNodesFound = false;
            break;
          }
        }

        if (allNodesFound) {
          // 应用缓存的位置
          nodeArr.forEach(node => {
            const cached = layoutData[node.name];
            if (cached) {
              node.x = cached.x;
              node.y = cached.y;
              node.vx = 0;
              node.vy = 0;
            }
          });
          return true;
        }
        return false;
      } catch (e) {
        console.warn('[DICE]关系图 加载布局缓存失败:', e);
        return false;
      }
    };

    // 清除布局缓存
    const clearLayoutCache = () => {
      try {
        const cacheKey = getLayoutCacheKey();
        localStorage.removeItem(cacheKey);
      } catch (e) {
        console.warn('[DICE]关系图 清除布局缓存失败:', e);
      }
    };

    // 力导向布局物理模拟函数
    const runForceDirectedLayout = () => {
      // 初始化位置：在中心附近随机散布，开始模拟
      nodeArr.forEach(node => {
        if (node.name === centerNodeName) {
          node.x = centerX;
          node.y = centerY;
          node.vx = 0;
          node.vy = 0;
        } else {
          // 在中心 100px 范围内随机散布
          const angle = Math.random() * 2 * Math.PI;
          const dist = 50 + Math.random() * 100;
          node.x = centerX + Math.cos(angle) * dist;
          node.y = centerY + Math.sin(angle) * dist;
          node.vx = 0;
          node.vy = 0;
        }
      });

      // 建立映射以便 O(1) 查找节点
      const nodeMap = new Map();
      nodeArr.forEach(n => nodeMap.set(n.name, n));

      // 预计算模拟 (迭代运行物理引擎)
      for (let iter = 0; iter < iterations; iter++) {
        // 1. 斥力 (节点 vs 节点)
        for (let i = 0; i < nodeArr.length; i++) {
          const u = nodeArr[i];
          for (let j = i + 1; j < nodeArr.length; j++) {
            const v = nodeArr[j];
            const dx = v.x - u.x;
            const dy = v.y - u.y;
            let distSq = dx * dx + dy * dy;
            if (distSq < 1) distSq = 1; // 防止除以零

            const dist = Math.sqrt(distSq);
            const force = kRepulsion / distSq;

            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;

            if (u.name !== centerNodeName) {
              u.vx -= fx;
              u.vy -= fy;
            }
            if (v.name !== centerNodeName) {
              v.vx += fx;
              v.vy += fy;
            }
          }
        }

        // 2. 引力 (边连接)
        edges.forEach(edge => {
          const u = nodeMap.get(edge.source);
          const v = nodeMap.get(edge.target);
          if (!u || !v) return;

          const dx = v.x - u.x;
          const dy = v.y - u.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          // 弹簧力: F = k * (当前距离 - 理想距离)
          const force = (dist - idealLen) * kSpring;

          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;

          if (u.name !== centerNodeName) {
            u.vx += fx;
            u.vy += fy;
          }
          if (v.name !== centerNodeName) {
            v.vx -= fx;
            v.vy -= fy;
          }
        });

        // 3. 中心重力 (轻微拉向中心)
        nodeArr.forEach(node => {
          if (node.name === centerNodeName) return;
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          node.vx += dx * kGravity;
          node.vy += dy * kGravity;
        });

        // 4. 更新位置
        // 限制最大速度以防爆炸
        const maxSpeed = 50 * (1 - iter / iterations); // 随迭代冷却最大速度

        nodeArr.forEach(node => {
          if (node.name === centerNodeName) return; // 中心节点固定不动 (作为锚点)

          // 阻尼
          node.vx *= damping;
          node.vy *= damping;

          // 限制速度
          const vMag = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
          if (vMag > maxSpeed) {
            node.vx = (node.vx / vMag) * maxSpeed;
            node.vy = (node.vy / vMag) * maxSpeed;
          }

          node.x += node.vx * timeStep;
          node.y += node.vy * timeStep;
        });
      }

      // 物理模拟完成后保存布局
      saveLayoutCache();
    };

    // 运行初始布局（优先使用缓存）
    if (!loadLayoutCache()) {
      // 缓存不存在或不匹配，运行物理模拟
      runForceDirectedLayout();
    }

    // 视图状态
    let scale = 1;
    let panX = 0;
    let panY = 0;
    const minScale = 0.3;
    const maxScale = 4;

    const overlay = $(`
            <div class="acu-relation-graph-overlay acu-theme-${config.theme}">
                <div class="acu-relation-graph-container">
                    <div class="acu-panel-header">
                        <div class="acu-graph-title">
                            <i class="fa-solid fa-project-diagram"></i>
                            <div class="acu-graph-center-dropdown" id="graph-center-dropdown">
                                <button class="acu-graph-center-trigger" type="button" title="选择中心角色">
                                    <span class="acu-center-label">${escapeHtml(replaceUserPlaceholders(centerNodeName))}</span>
                                    <i class="fa-solid fa-caret-down"></i>
                                </button>
                                <div class="acu-graph-center-menu">
                                    ${nodeArr.map(n => `<div class="acu-center-option${n.name === centerNodeName ? ' active' : ''}" data-value="${escapeHtml(n.name)}">${escapeHtml(replaceUserPlaceholders(n.name))}</div>`).join('')}
                                </div>
                            </div>
                            <button class="acu-graph-btn acu-filter-toggle acu-graph-filter-btn" id="filter-in-scene" title="只显示中心角色和在场角色"><i class="fa-solid fa-map-marker-alt"></i></button>
                            <button class="acu-graph-btn acu-filter-toggle acu-graph-filter-btn" id="filter-direct-only" title="只显示与中心角色直接相关"><i class="fa-solid fa-link"></i></button>
                        </div>
                        <div class="acu-graph-actions">
                            <button class="acu-graph-btn" id="graph-relayout" title="重新布局（清除缓存并重新计算节点位置）"><i class="fa-solid fa-sync"></i></button>
                            <button class="acu-graph-btn" id="graph-manage-avatar" title="管理头像"><i class="fa-solid fa-user-circle"></i></button>
                            <button class="acu-graph-btn acu-graph-close" title="关闭"><i class="fa-solid fa-times"></i></button>
                        </div>
                    </div>
                    <div class="acu-graph-canvas-wrapper">
                        <svg class="acu-graph-svg" viewBox="0 0 800 600">
                            <defs>
                                <marker id="arrowhead-end" markerWidth="6" markerHeight="5" refX="5" refY="2.5" orient="auto" markerUnits="strokeWidth">
                                    <polygon points="0 0, 6 2.5, 0 5" />
                                </marker>
                                <marker id="arrowhead-start" markerWidth="6" markerHeight="5" refX="1" refY="2.5" orient="auto" markerUnits="strokeWidth">
                                    <polygon points="6 0, 0 2.5, 6 5" />
                                </marker>
                                <marker id="arrowhead-end-hl" markerWidth="7" markerHeight="6" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <polygon points="0 0, 7 3, 0 6" />
                                </marker>
                                <marker id="arrowhead-start-hl" markerWidth="7" markerHeight="6" refX="1" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <polygon points="7 0, 0 3, 7 6" />
                                </marker>
                            </defs>
                            <g class="acu-graph-transform">
                                <g class="acu-graph-edges"></g>
                                <g class="acu-graph-nodes"></g>
                            </g>
                        </svg>
                        <div class="acu-node-size-slider-container">
                            <div class="acu-slider-header">
                                <span class="acu-slider-label">节点大小</span>
                                <span id="slider-size-display" class="acu-slider-value">${Math.round(nodeSizeMultiplier * 100)}%</span>
                            </div>
                            <input type="range" id="node-size-slider" min="0.5" max="2.0" step="0.1" value="${nodeSizeMultiplier}" class="acu-range-input" />
                        </div>
                    </div>
                    <div class="acu-graph-legend">
                        <button class="acu-graph-btn acu-graph-reset-btn" id="graph-zoom-reset" title="重置视图和节点大小"><i class="fa-solid fa-compress-arrows-alt"></i><span>重置</span></button>
                        <div class="acu-node-size-stepper-wrapper acu-node-size-wrapper">
                            <span style="font-size:11px;color:var(--acu-text-sub);white-space:nowrap;">节点:</span>
                            <div class="acu-stepper acu-stepper-container" data-id="graph-node-size" data-min="50" data-max="200" data-step="10">
                                <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                <span class="acu-stepper-value acu-stepper-value-display" id="node-size-display">${Math.round(nodeSizeMultiplier * 100)}%</span>
                                <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                            </div>
                        </div>
                        <span class="acu-zoom-display acu-zoom-info">
                            <span>视图:</span>
                            <span>${Math.round(scale * 100)}%</span>
                        </span>
                    </div>
                </div>
            </div>
        `);

    $('body').append(overlay);

    const $svg = overlay.find('.acu-graph-svg');
    const $transform = overlay.find('.acu-graph-transform');
    const $edgesGroup = overlay.find('.acu-graph-edges');
    const $nodesGroup = overlay.find('.acu-graph-nodes');
    const $zoomDisplay = overlay.find('.acu-zoom-display span:last-child');
    const $nodeSizeDisplay = overlay.find('#node-size-display');
    const $wrapper = overlay.find('.acu-graph-canvas-wrapper');

    const updateTransform = () => {
      $transform.attr('transform', `translate(${panX}, ${panY}) scale(${scale})`);
      $zoomDisplay.text(`${Math.round(scale * 100)}%`);
    };

    const updateNodeSizeDisplay = () => {
      if ($nodeSizeDisplay.length) {
        $nodeSizeDisplay.text(`${Math.round(nodeSizeMultiplier * 100)}%`);
      }
    };

    const zoomTo = (newScale, centerX = 400, centerY = 300) => {
      const oldScale = scale;
      scale = Math.max(minScale, Math.min(maxScale, newScale));
      const scaleChange = scale / oldScale;
      panX = centerX - (centerX - panX) * scaleChange;
      panY = centerY - (centerY - panY) * scaleChange;
      updateTransform();
    };

    const render = async () => {
      // 获取过滤后的节点
      const filteredNodes = getFilteredNodes();
      const filteredNodeNames = new Set(filteredNodes.map(n => n.name));

      // 过滤边：只保留连接两个可见节点的边
      const filteredEdges = edges.filter(
        edge => filteredNodeNames.has(edge.source) && filteredNodeNames.has(edge.target),
      );

      let edgesHtml = '';
      filteredEdges.forEach((edge, edgeIdx) => {
        const source = nodes.get(edge.source);
        const target = nodes.get(edge.target);
        if (!source || !target) return;

        // 计算方向向量和中点
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const nx = dx / len; // 单位向量
        const ny = dy / len;

        // 垂直于连线的向量（用于标签偏移）
        const px = -ny;
        const py = nx;

        // 判断箭头类型
        const hasFromSource =
          edge.labelsFromSource && edge.labelsFromSource.length > 0 && edge.labelsFromSource.some(l => l);
        const hasFromTarget =
          edge.labelsFromTarget && edge.labelsFromTarget.length > 0 && edge.labelsFromTarget.some(l => l);

        // 缩短线条，避免箭头与节点重叠（增加额外间距）
        const sourceRadius = source.radius || 28;
        const targetRadius = target.radius || 28;
        const arrowGap = 10; // 箭头与节点之间的额外间距（考虑大节点）
        const x1 = source.x + nx * (sourceRadius + arrowGap);
        const y1 = source.y + ny * (sourceRadius + arrowGap);
        const x2 = target.x - nx * (targetRadius + arrowGap);
        const y2 = target.y - ny * (targetRadius + arrowGap);

        // 智能去重：跨方向移除重复标签
        let srcLabels = (edge.labelsFromSource || []).filter(l => l);
        let tgtLabels = (edge.labelsFromTarget || []).filter(l => l);

        // 找出两边都有的标签（共同标签）
        const srcSet = new Set(srcLabels);
        const tgtSet = new Set(tgtLabels);
        const commonLabels = [...srcSet].filter(l => tgtSet.has(l));

        // 从两边移除共同标签，它们将显示在中间
        const srcUnique = srcLabels.filter(l => !commonLabels.includes(l));
        const tgtUnique = tgtLabels.filter(l => !commonLabels.includes(l));

        // 设置箭头标记
        let markerStart = '';
        let markerEnd = '';
        if (hasFromSource) markerEnd = 'url(#arrowhead-end)';
        if (hasFromTarget) markerStart = 'url(#arrowhead-start)';

        edgesHtml += `<line class="acu-graph-edge" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"
                    ${markerEnd ? `marker-end="${markerEnd}"` : ''}
                    ${markerStart ? `marker-start="${markerStart}"` : ''}
                    data-edge-idx="${edgeIdx}" />`;

        // 渲染标签
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2;

        // 计算标签位置（根据连线长度动态调整，更紧凑）
        const lineLen = Math.sqrt(dx * dx + dy * dy);

        // 判断是否是"双向且内容完全一致"的情况
        const isBidirectional = hasFromSource && hasFromTarget;
        const isBidirectionalSame =
          isBidirectional && commonLabels.length > 0 && srcUnique.length === 0 && tgtUnique.length === 0;

        // 只有双向且完全一致时，标签才显示在正中间
        if (isBidirectionalSame) {
          // 双向相同：标签显示在正中间
          // [修复] 移动 renderRelationIcon 和 addRelationIcon 到这里也能使用
          const renderRelationIconInline = (iconStr: string): string => {
            if (iconStr.startsWith('fa:')) {
              return `<i class="fa-solid fa-${iconStr.slice(3)}" style="font-size:10px;margin-left:2px;opacity:0.8;"></i>`;
            } else if (iconStr.startsWith('ti:')) {
              return `<i class="ti ti-${iconStr.slice(3)}" style="font-size:10px;margin-left:2px;opacity:0.8;"></i>`;
            }
            return iconStr;
          };

          const addRelationIconInline = (lbl: string): string => {
            if (!lbl) return '';
            for (const group of RELATION_ICON_MAP) {
              for (const kw of group.keywords) {
                if (lbl.includes(kw)) {
                  return lbl + renderRelationIconInline(group.icon);
                }
              }
            }
            return lbl;
          };

          commonLabels.slice(0, 2).forEach((lbl, i) => {
            if (!lbl) return;
            const offsetDir = i === 0 ? 1 : -1;
            const offsetDist = 6 + i * 10;
            const lx = midX + px * offsetDir * offsetDist;
            const ly = midY + py * offsetDir * offsetDist;
            // [修复] 添加图标支持
            const content = addRelationIconInline(lbl);
            if (content.includes('<i ')) {
              // 使用foreignObject渲染HTML内容
              edgesHtml += `<foreignObject x="${lx - 50}" y="${ly - 10}" width="100" height="20" style="overflow:visible;">
                <div xmlns="http://www.w3.org/1999/xhtml" class="acu-graph-edge-label-html" data-edge-idx="${edgeIdx}" style="
                  display:flex;align-items:center;justify-content:center;
                  font-size:11px;color:var(--acu-text-sub);white-space:nowrap;
                  pointer-events:none;
                ">${content}</div>
              </foreignObject>`;
            } else {
              edgesHtml += `<text class="acu-graph-edge-label" x="${lx}" y="${ly}" data-edge-idx="${edgeIdx}">${escapeHtml(lbl)}</text>`;
            }
          });
        } else {
          // 单向或双向不同：分区域显示
          // 偏移量：从中点向source/target方向偏移，但不要太靠近节点
          // 使用连线长度的25%，但限制在合理范围内
          const safeOffset = Math.max(30, Math.min(lineLen * 0.25, 60));

          // 渲染关系图标为HTML
          const renderRelationIcon = (iconStr: string): string => {
            if (iconStr.startsWith('fa:')) {
              return `<i class="fa-solid fa-${iconStr.slice(3)}" style="font-size:10px;margin-left:2px;opacity:0.8;"></i>`;
            } else if (iconStr.startsWith('ti:')) {
              return `<i class="ti ti-${iconStr.slice(3)}" style="font-size:10px;margin-left:2px;opacity:0.8;"></i>`;
            }
            return iconStr;
          };

          // 给关系词添加图标
          const addRelationIcon = (lbl: string): string => {
            if (!lbl) return '';
            for (const group of RELATION_ICON_MAP) {
              for (const kw of group.keywords) {
                if (lbl.includes(kw)) {
                  return lbl + renderRelationIcon(group.icon);
                }
              }
            }
            return lbl;
          };

          // 截断过长标签的辅助函数（在添加图标之前截断）
          const truncateLabel = (lbl: string, maxLen = 4): string => {
            if (!lbl) return '';
            const truncated = lbl.length > maxLen ? lbl.substring(0, maxLen) + '..' : lbl;
            return addRelationIcon(truncated);
          };

          // 生成带图标的标签HTML（使用foreignObject以支持HTML内容）
          const createLabelHtml = (lbl: string, x: number, y: number, edgeIdx: number, maxLen = 5): string => {
            const content = truncateLabel(lbl, maxLen);
            // 检测是否包含HTML标签（图标）
            if (content.includes('<i ')) {
              // 使用foreignObject渲染HTML内容
              return `<foreignObject x="${x - 50}" y="${y - 10}" width="100" height="20" style="overflow:visible;">
                <div xmlns="http://www.w3.org/1999/xhtml" class="acu-graph-edge-label-html" data-edge-idx="${edgeIdx}" style="
                  display:flex;align-items:center;justify-content:center;
                  font-size:11px;color:var(--acu-text-sub);white-space:nowrap;
                  pointer-events:none;
                ">${content}</div>
              </foreignObject>`;
            }
            // 纯文本使用原生text元素
            return `<text class="acu-graph-edge-label" x="${x}" y="${y}" data-edge-idx="${edgeIdx}">${escapeHtml(content)}</text>`;
          };

          // 1. 共同标签（显示在正中间，垂直于连线一上一下）
          if (commonLabels.length > 0) {
            commonLabels.slice(0, 1).forEach((lbl, i) => {
              if (!lbl) return;
              // 单个共同标签放在线的上方
              const lx = midX + px * 8;
              const ly = midY + py * 8 - 3;
              edgesHtml += createLabelHtml(lbl, lx, ly, edgeIdx, 5);
            });
          }

          // 2. Source侧标签（靠近source，垂直于连线排列）
          if (srcUnique.length > 0 || (hasFromSource && !hasFromTarget && commonLabels.length === 0)) {
            const labelsToShow = srcUnique.length > 0 ? srcUnique : srcLabels;
            // 基准点：从中点向source方向偏移
            const labelBaseX = midX - nx * safeOffset;
            const labelBaseY = midY - ny * safeOffset;

            labelsToShow.slice(0, 2).forEach((lbl, i) => {
              if (!lbl) return;
              // 垂直于连线方向排列：第一个在线上方，第二个在线下方
              const perpOffset = (i === 0 ? 1 : -1) * 10;
              const lx = labelBaseX + px * perpOffset;
              const ly = labelBaseY + py * perpOffset;
              edgesHtml += createLabelHtml(lbl, lx, ly, edgeIdx, 5);
            });
          }

          // 3. Target侧标签（靠近target，垂直于连线排列）
          if (tgtUnique.length > 0 || (hasFromTarget && !hasFromSource && commonLabels.length === 0)) {
            const labelsToShow = tgtUnique.length > 0 ? tgtUnique : tgtLabels;
            // 基准点：从中点向target方向偏移
            const labelBaseX = midX + nx * safeOffset;
            const labelBaseY = midY + ny * safeOffset;

            labelsToShow.slice(0, 2).forEach((lbl, i) => {
              if (!lbl) return;
              // 垂直于连线方向排列
              const perpOffset = (i === 0 ? -1 : 1) * 10;
              const lx = labelBaseX + px * perpOffset;
              const ly = labelBaseY + py * perpOffset;
              edgesHtml += createLabelHtml(lbl, lx, ly, edgeIdx, 5);
            });
          }
        }
      });
      $edgesGroup.html(edgesHtml);

      // [修复] 异步获取头像后再渲染节点（使用过滤后的节点）
      let nodesHtml = '';
      for (const node of filteredNodes) {
        // 使用异步方法获取头像（优先本地 > URL > ST头像）
        const nodeAvatar = await AvatarManager.getAsync(node.name);
        const isPlayer = node.isPlayer;

        // 在场标记：右下角小圆点（随节点大小缩放，Discord风格）
        const indicatorRadius = node.radius * 0.22;
        const indicatorOffset = node.radius * 0.62;
        const inSceneIndicator = node.isInScene
          ? `<circle class="acu-node-inscene-indicator" cx="${indicatorOffset}" cy="${indicatorOffset}" r="${indicatorRadius}" style="fill:var(--acu-accent);stroke:var(--acu-bg-panel);stroke-width:3;" />`
          : '';

        const nodeDisplayName = replaceUserPlaceholders(node.name);
        nodesHtml += `
                <g class="acu-graph-node acu-dash-preview-trigger" data-name="${escapeHtml(node.name)}" data-table-key="${node.tableKey || ''}" data-row-index="${node.rowIndex !== undefined ? node.rowIndex : ''}" transform="translate(${node.x}, ${node.y})">
                    <circle class="acu-node-bg" r="${node.radius}" />
                    ${
                      nodeAvatar
                        ? (() => {
                            const offsetX = AvatarManager.getOffsetX(node.name);
                            const offsetY = AvatarManager.getOffsetY(node.name);
                            const scaleVal = AvatarManager.getScale(node.name);
                            const size = (node.radius - 2) * 2;
                            const shadowWidth = 4; // 预留box-shadow的空间
                            const foSize = size + shadowWidth * 2;
                            const foOffset = foSize / 2;
                            return `<foreignObject x="${-foOffset}" y="${-foOffset}" width="${foSize}" height="${foSize}">
                            <div class="acu-node-avatar" xmlns="http://www.w3.org/1999/xhtml" style="
                                width: ${size}px;
                                height: ${size}px;
                                margin: ${shadowWidth}px;
                                border-radius: 50%;
                                background-image: url('${nodeAvatar}');
                                background-size: ${scaleVal}%;
                                background-position: ${offsetX}% ${offsetY}%;
                                background-repeat: no-repeat;
                            "></div>
                        </foreignObject>`;
                          })()
                        : `<text class="acu-node-char" dy="0.35em">${escapeHtml(nodeDisplayName.charAt(0))}</text>`
                    }
                    ${inSceneIndicator}
                    ${node.name === centerNodeName ? `<circle class="acu-node-center-indicator" r="${node.radius + 5}" />` : ''}
                    <text class="acu-node-label" dy="${node.radius + 14}">${escapeHtml(nodeDisplayName)}</text>
                </g>
            `;
      }
      $nodesGroup.html(nodesHtml);
    };

    // [新增] 悬浮高亮交互函数
    const highlightNode = nodeName => {
      $svg.addClass('highlighting');

      // 高亮当前节点
      $nodesGroup.find('.acu-graph-node').each(function () {
        if ($(this).data('name') === nodeName) {
          $(this).addClass('highlighted');
        }
      });

      // 找出所有与该节点相连的边和对端节点
      const connectedNodes = new Set([nodeName]);

      // 使用所有边（不仅仅是过滤后的），以便高亮显示所有相关连接
      edges.forEach(edge => {
        if (edge.source === nodeName || edge.target === nodeName) {
          const otherNode = edge.source === nodeName ? edge.target : edge.source;
          connectedNodes.add(otherNode);
        }
      });

      // 高亮相连的节点
      $nodesGroup.find('.acu-graph-node').each(function () {
        if (connectedNodes.has($(this).data('name'))) {
          $(this).addClass('highlighted');
        }
      });

      // 高亮相关的边和标签
      const connectedEdgeIndices = new Set();
      edges.forEach((edge, idx) => {
        if (edge.source === nodeName || edge.target === nodeName) {
          connectedEdgeIndices.add(idx);
        }
      });

      $edgesGroup.find('.acu-graph-edge').each(function () {
        const edgeIdx = parseInt($(this).attr('data-edge-idx'), 10);
        if (connectedEdgeIndices.has(edgeIdx)) {
          $(this).addClass('highlighted');
          if ($(this).attr('marker-end')) {
            $(this).attr('marker-end', 'url(#arrowhead-end-hl)');
          }
          if ($(this).attr('marker-start')) {
            $(this).attr('marker-start', 'url(#arrowhead-start-hl)');
          }
        }
      });

      $edgesGroup.find('.acu-graph-edge-label').each(function () {
        const edgeIdx = parseInt($(this).attr('data-edge-idx'), 10);
        if (connectedEdgeIndices.has(edgeIdx)) {
          $(this).addClass('highlighted');
        }
      });
    };

    const clearHighlight = () => {
      $svg.removeClass('highlighting');
      $nodesGroup.find('.highlighted').removeClass('highlighted');
      $edgesGroup.find('.highlighted').removeClass('highlighted');
      $edgesGroup.find('.acu-graph-edge').each(function () {
        if ($(this).attr('marker-end')) {
          $(this).attr('marker-end', 'url(#arrowhead-end)');
        }
        if ($(this).attr('marker-start')) {
          $(this).attr('marker-start', 'url(#arrowhead-start)');
        }
      });
    };

    // [修复] 节点交互 - PC悬浮高亮 + 移动端长按高亮 + 单击预览
    // 使用pointer媒体查询检测：fine表示精确指针设备(鼠标)，coarse表示粗略指针(触摸)
    const hasFinePointer = window.matchMedia('(pointer: fine)').matches;
    const isTouchDevice = !hasFinePointer;

    // 全局状态
    let currentHighlightedNode = null; // 当前高亮的节点名
    let longPressTimer = null;

    if (isTouchDevice) {
      // ========== 移动端逻辑 ==========
      let currentHighlightedNode = null;

      $nodesGroup.on('pointerdown', '.acu-graph-node', function (e) {
        const $node = $(this);
        const nodeName = $node.data('name');
        const startX = e.clientX;
        const startY = e.clientY;
        const startTime = Date.now();
        let hasMoved = false;
        let longPressTriggered = false;

        // 如果已有高亮，这次点击只用于清除
        if (currentHighlightedNode) {
          clearHighlight();
          currentHighlightedNode = null;
          // 直接return，不绑定后续事件
          e.preventDefault();
          e.stopPropagation();
          return;
        }

        // 长按计时器
        const longPressTimer = setTimeout(() => {
          if (!hasMoved && nodeName) {
            longPressTriggered = true;
            currentHighlightedNode = nodeName;
            highlightNode(nodeName);
            if (navigator.vibrate) navigator.vibrate(30);
          }
        }, 300);

        const onMove = moveE => {
          const dx = Math.abs(moveE.clientX - startX);
          const dy = Math.abs(moveE.clientY - startY);
          if (dx > 8 || dy > 8) {
            hasMoved = true;
            clearTimeout(longPressTimer);
          }
        };

        const onUp = () => {
          $(document).off('pointermove.mobilenode pointerup.mobilenode pointercancel.mobilenode');
          clearTimeout(longPressTimer);

          const elapsed = Date.now() - startTime;

          // 长按已触发 → 什么都不做（高亮保持）
          if (longPressTriggered) {
            return;
          }

          // 移动了 → 什么都不做
          if (hasMoved) {
            return;
          }

          // 快速点击（<300ms）且没移动 → 显示详情
          if (elapsed < 300) {
            const nodeName = $node.data('name');
            // 使用别名系统找到主名称，以定位正确的表格行
            const primaryName = AvatarManager.getPrimaryName(nodeName);
            const tableKey = $node.data('table-key');
            let rowIndex = $node.data('row-index');

            // 如果当前节点没有tableKey（只出现在别人关系中的角色），尝试通过主名称查找
            if (!tableKey || rowIndex === '' || rowIndex === undefined) {
              // 尝试查找NPC表中是否有该角色
              const rawData = cachedRawData || getTableData();
              if (rawData) {
                for (const key in rawData) {
                  const table = rawData[key];
                  if (!table?.content || !table.name?.includes('NPC')) continue;
                  const headers = table.content[0] || [];
                  const nameIdx = headers.findIndex(
                    h => h && (h.includes('姓名') || h.includes('名称') || h.includes('名字')),
                  );
                  if (nameIdx < 0) continue;
                  for (let i = 1; i < table.content.length; i++) {
                    const rowName = String(table.content[i][nameIdx] || '').trim();
                    if (rowName === primaryName || AvatarManager.getPrimaryName(rowName) === primaryName) {
                      // 找到了，触发预览
                      const tempNode = $('<div class="acu-dash-preview-trigger" style="display:none;"></div>')
                        .data('table-key', key)
                        .data('row-index', i - 1);
                      $('body').append(tempNode);
                      tempNode.trigger('click.acu_dash_preview');
                      tempNode.remove();
                      return;
                    }
                  }
                }
              }
              // 没有找到该角色的卡片
              if (window.toastr) {
                window.toastr.info(`「${primaryName}」暂无详细资料`, '', { timeOut: 2000 });
              }
              return;
            }

            // 有tableKey，正常触发预览
            const tempNode = $('<div class="acu-dash-preview-trigger" style="display:none;"></div>')
              .data('table-key', tableKey)
              .data('row-index', parseInt(rowIndex, 10));
            $('body').append(tempNode);
            tempNode.trigger('click.acu_dash_preview');
            tempNode.remove();
          }
        };

        $(document).on('pointermove.mobilenode', onMove);
        $(document).on('pointerup.mobilenode pointercancel.mobilenode', onUp);
      });

      // 点击画布空白处清除高亮
      $wrapper.on('pointerup.mobileclear', function (e) {
        if (currentHighlightedNode && !$(e.target).closest('.acu-graph-node').length) {
          clearHighlight();
          currentHighlightedNode = null;
        }
      });
    } else {
      // ========== PC端逻辑 ==========

      $nodesGroup.on('pointerenter.pchover', '.acu-graph-node', function () {
        const nodeName = $(this).data('name');
        if (nodeName) {
          highlightNode(nodeName);
        }
      });

      $nodesGroup.on('pointerleave.pchover', '.acu-graph-node', function () {
        clearHighlight();
      });

      // PC端点击显示详情
      $nodesGroup.on('click.pcclick', '.acu-graph-node', function (e) {
        e.stopPropagation();
        const $node = $(this);
        const nodeName = $node.data('name');
        // 使用别名系统找到主名称
        const primaryName = AvatarManager.getPrimaryName(nodeName);
        const tableKey = $node.data('table-key');
        let rowIndex = $node.data('row-index');

        // 如果当前节点没有tableKey（只出现在别人关系中的角色），尝试通过主名称查找
        if (!tableKey || rowIndex === '' || rowIndex === undefined) {
          const rawData = cachedRawData || getTableData();
          if (rawData) {
            for (const key in rawData) {
              const table = rawData[key];
              if (!table?.content || !table.name?.includes('NPC')) continue;
              const headers = table.content[0] || [];
              const nameIdx = headers.findIndex(
                h => h && (h.includes('姓名') || h.includes('名称') || h.includes('名字')),
              );
              if (nameIdx < 0) continue;
              for (let i = 1; i < table.content.length; i++) {
                const rowName = String(table.content[i][nameIdx] || '').trim();
                if (rowName === primaryName || AvatarManager.getPrimaryName(rowName) === primaryName) {
                  const tempNode = $('<div class="acu-dash-preview-trigger" style="display:none;"></div>')
                    .data('table-key', key)
                    .data('row-index', i - 1);
                  $('body').append(tempNode);
                  tempNode.trigger('click.acu_dash_preview');
                  tempNode.remove();
                  return;
                }
              }
            }
          }
          if (window.toastr) {
            window.toastr.info(`「${primaryName}」暂无详细资料`, '', { timeOut: 2000 });
          }
          return;
        }

        // 有tableKey，正常触发预览
        const tempNode = $('<div class="acu-dash-preview-trigger" style="display:none;"></div>')
          .data('table-key', tableKey)
          .data('row-index', parseInt(rowIndex, 10));
        $('body').append(tempNode);
        tempNode.trigger('click.acu_dash_preview');
        tempNode.remove();
      });
    }

    // 初始渲染
    render().then(() => {
      updateTransform();
    });

    // 画布平移和缩放 - 使用 Pointer Events API
    let isPanning = false;
    let panStartX = 0,
      panStartY = 0;
    let panStartPanX = 0,
      panStartPanY = 0;
    let lastPinchDist = 0;
    let activePointerId = null;

    const wrapperEl = $wrapper[0];
    const svgEl = $svg[0];

    // Pointer Down - 开始拖拽
    wrapperEl.onpointerdown = function (e) {
      if (e.button !== 0) return;
      // [修复] 如果点击的是节点，不启动画布拖拽
      if ($(e.target).closest('.acu-graph-node').length) return;
      // [修复] 如果点击的是滑条容器，不启动画布拖拽
      if ($(e.target).closest('.acu-node-size-slider-container').length) return;
      e.preventDefault();
      wrapperEl.setPointerCapture(e.pointerId);
      activePointerId = e.pointerId;
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartPanX = panX;
      panStartPanY = panY;
      svgEl.style.cursor = 'grabbing';
    };

    // Pointer Move - 拖拽中
    wrapperEl.onpointermove = function (e) {
      if (!isPanning || e.pointerId !== activePointerId) return;
      const dx = e.clientX - panStartX;
      const dy = e.clientY - panStartY;
      const rect = svgEl.getBoundingClientRect();
      panX = panStartPanX + (dx / rect.width) * 800;
      panY = panStartPanY + (dy / rect.height) * 600;
      updateTransform();
    };

    // Pointer Up - 结束拖拽
    wrapperEl.onpointerup = function (e) {
      if (e.pointerId === activePointerId) {
        wrapperEl.releasePointerCapture(e.pointerId);
        isPanning = false;
        activePointerId = null;
        svgEl.style.cursor = 'grab';
      }
    };

    // Pointer Cancel - 取消
    wrapperEl.onpointercancel = function (e) {
      if (e.pointerId === activePointerId) {
        isPanning = false;
        activePointerId = null;
        svgEl.style.cursor = 'grab';
      }
    };

    // 滚轮缩放
    wrapperEl.onwheel = function (e) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.15 : 0.15;
      zoomTo(scale + delta);
    };

    // 移动端双指缩放
    wrapperEl.addEventListener(
      'touchstart',
      function (e) {
        if (e.touches.length === 2) {
          e.preventDefault();
          isPanning = false;
          lastPinchDist = Math.hypot(
            e.touches[1].clientX - e.touches[0].clientX,
            e.touches[1].clientY - e.touches[0].clientY,
          );
        }
      },
      { passive: false },
    );

    wrapperEl.addEventListener(
      'touchmove',
      function (e) {
        if (e.touches.length === 2) {
          e.preventDefault();
          const newDist = Math.hypot(
            e.touches[1].clientX - e.touches[0].clientX,
            e.touches[1].clientY - e.touches[0].clientY,
          );
          if (lastPinchDist > 0) {
            zoomTo(scale * (newDist / lastPinchDist));
          }
          lastPinchDist = newDist;
        }
      },
      { passive: false },
    );

    wrapperEl.addEventListener('touchend', function (e) {
      if (e.touches.length < 2) lastPinchDist = 0;
    });

    // 清理函数
    const cleanupEvents = () => {
      wrapperEl.onpointerdown = null;
      wrapperEl.onpointermove = null;
      wrapperEl.onpointerup = null;
      wrapperEl.onpointercancel = null;
      wrapperEl.onwheel = null;
      // 清理滑条相关事件和定时器
      if (sliderHideTimer) {
        clearTimeout(sliderHideTimer);
        sliderHideTimer = null;
      }
      $(document).off('click.slider-hide');
    };

    // 节点大小滑条控制
    const $nodeSizeSlider = overlay.find('#node-size-slider');
    const $sliderSizeDisplay = overlay.find('#slider-size-display');
    const $sliderContainer = overlay.find('.acu-node-size-slider-container');
    const $nodeSizeDisplayTrigger = overlay.find('#node-size-display-trigger');
    const $legend = overlay.find('.acu-graph-legend');

    let sliderVisible = false;
    let sliderHideTimer: ReturnType<typeof setTimeout> | null = null;
    const SLIDER_AUTO_HIDE_DELAY = 4000; // 4秒无操作自动隐藏

    // 显示滑条
    const showSlider = () => {
      if (sliderVisible) return;

      // 清除之前的隐藏定时器
      if (sliderHideTimer) {
        clearTimeout(sliderHideTimer);
        sliderHideTimer = null;
      }

      sliderVisible = true;

      // 计算位置：在"节点"文字上方（因为滑条容器在wrapper内，而trigger在legend中，legend在wrapper下方）
      // 使用getBoundingClientRect获取相对于viewport的位置
      const triggerRect = $nodeSizeDisplayTrigger[0].getBoundingClientRect();
      const wrapperRect = $wrapper[0].getBoundingClientRect();

      // 修复：滑条应该显示在wrapper底部附近，在trigger上方
      const sliderHeight = 60; // 估算滑条高度
      const top = wrapperRect.height - sliderHeight - 10; // 在wrapper底部上方
      const left = triggerRect.left - wrapperRect.left;

      $sliderContainer.css({
        display: 'block',
        top: `${top}px`,
        left: `${left}px`,
      });

      // 设置自动隐藏定时器
      resetSliderHideTimer();
    };

    // 隐藏滑条
    const hideSlider = () => {
      if (!sliderVisible) return;

      if (sliderHideTimer) {
        clearTimeout(sliderHideTimer);
        sliderHideTimer = null;
      }

      sliderVisible = false;
      $sliderContainer.hide();
    };

    // 重置自动隐藏定时器
    const resetSliderHideTimer = () => {
      if (sliderHideTimer) {
        clearTimeout(sliderHideTimer);
      }
      sliderHideTimer = setTimeout(() => {
        hideSlider();
      }, SLIDER_AUTO_HIDE_DELAY);
    };

    // 点击"节点"文字切换滑条显示/隐藏（使用事件委托确保可靠触发）
    overlay.on('click', '#node-size-display-trigger, #node-size-display-trigger *', function (e) {
      e.stopPropagation();
      if (sliderVisible) {
        hideSlider();
      } else {
        showSlider();
      }
    });

    // 滑条操作时重置自动隐藏定时器
    $nodeSizeSlider.on('input mousedown touchstart', function (e) {
      e.stopPropagation();
      if (sliderVisible) {
        resetSliderHideTimer();
      }
    });

    // 滑条容器内操作时阻止事件冒泡
    $sliderContainer.on('pointerdown mousedown touchstart', function (e) {
      e.stopPropagation();
    });

    // 点击滑条外部区域时隐藏滑条
    $(document).on('click.slider-hide', function (e) {
      if (
        sliderVisible &&
        !$sliderContainer.is(e.target) &&
        $sliderContainer.has(e.target).length === 0 &&
        !$nodeSizeDisplayTrigger.is(e.target) &&
        $nodeSizeDisplayTrigger.has(e.target).length === 0
      ) {
        hideSlider();
      }
    });

    $nodeSizeSlider.on('input', function () {
      nodeSizeMultiplier = parseFloat($(this).val());
      $sliderSizeDisplay.text(Math.round(nodeSizeMultiplier * 100) + '%');
      updateNodeSizeDisplay();

      // 重新计算节点半径并渲染
      nodeArr.forEach(node => {
        node.radius = getNodeRadius(node.name, node.isPlayer);
      });
      render();

      // 重置自动隐藏定时器
      resetSliderHideTimer();
    });

    // 过滤 toggle 按钮
    const $filterInSceneBtn = overlay.find('#filter-in-scene');
    const $filterDirectOnlyBtn = overlay.find('#filter-direct-only');

    const updateFilterToggleStyles = () => {
      $filterInSceneBtn.toggleClass('active', filterInScene);
      $filterDirectOnlyBtn.toggleClass('active', filterDirectOnly);
    };

    // 初始化按钮样式
    updateFilterToggleStyles();

    $filterInSceneBtn.click(function (e) {
      e.stopPropagation();
      filterInScene = !filterInScene;
      updateFilterToggleStyles();
      render();
    });

    $filterDirectOnlyBtn.click(function (e) {
      e.stopPropagation();
      filterDirectOnly = !filterDirectOnly;
      updateFilterToggleStyles();
      render();
    });

    // [新增] 自定义中心角色下拉选择器
    const $centerDropdown = overlay.find('#graph-center-dropdown');
    const $centerTrigger = $centerDropdown.find('.acu-graph-center-trigger');
    const $centerMenu = $centerDropdown.find('.acu-graph-center-menu');
    const $centerLabel = $centerDropdown.find('.acu-center-label');

    // 点击触发器 toggle 菜单
    $centerTrigger.on('click', function (e) {
      e.stopPropagation();
      $centerDropdown.toggleClass('open');
    });

    // 点击选项
    $centerMenu.on('click', '.acu-center-option', function (e) {
      e.stopPropagation();
      const newCenter = $(this).data('value') as string;
      $centerDropdown.removeClass('open');
      if (newCenter && newCenter !== centerNodeName && nodes.has(newCenter)) {
        centerNodeName = newCenter;
        // 更新下拉显示
        $centerLabel.text(replaceUserPlaceholders(newCenter));
        $centerMenu.find('.acu-center-option').removeClass('active');
        $(this).addClass('active');
        // 清除布局缓存并重新布局
        clearLayoutCache();
        nodeArr.forEach(node => {
          node.radius = getNodeRadius(node.name, node.isPlayer);
        });
        runForceDirectedLayout();
        render();
        const displayName = replaceUserPlaceholders(newCenter);
        if (window.toastr) window.toastr.info(`已将「${displayName}」设为中心`, '', { timeOut: 1500 });
      }
    });

    // 点击外部关闭菜单
    overlay.on('click.center-dropdown', function () {
      $centerDropdown.removeClass('open');
    });

    // 重置视图（缩放、位置 + 节点布局 + 节点大小 + 中心角色）
    overlay.find('#graph-zoom-reset').click(() => {
      // 重置缩放和平移
      scale = 1;
      panX = 0;
      panY = 0;
      updateTransform();

      // 重置中心角色为主角
      centerNodeName = resolvedPlayerName;
      $centerLabel.text(replaceUserPlaceholders(resolvedPlayerName));
      $centerMenu.find('.acu-center-option').removeClass('active');
      $centerMenu.find(`.acu-center-option[data-value="${resolvedPlayerName}"]`).addClass('active');

      // 重置节点大小
      nodeSizeMultiplier = 1.0;
      $nodeSizeSlider.val(1.0);
      $sliderSizeDisplay.text('100%');
      updateNodeSizeDisplay();

      // 重置stepper显示值
      const $nodeSizeStepper = overlay.find('.acu-stepper[data-id="graph-node-size"]');
      if ($nodeSizeStepper.length) {
        $nodeSizeStepper.find('.acu-stepper-value').text('100%');
      }

      // 重新计算节点半径
      nodeArr.forEach(node => {
        node.radius = getNodeRadius(node.name, node.isPlayer);
      });

      // 重新加载布局（优先使用缓存）
      if (!loadLayoutCache()) {
        // 缓存不存在或不匹配，运行物理模拟
        runForceDirectedLayout();
      }
      render();
    });

    // Stepper 步进器事件处理 - 节点大小控制
    const $nodeSizeStepper = overlay.find('.acu-stepper[data-id="graph-node-size"]');
    if ($nodeSizeStepper.length) {
      const min = parseInt($nodeSizeStepper.data('min')); // 50
      const max = parseInt($nodeSizeStepper.data('max')); // 200
      const step = parseInt($nodeSizeStepper.data('step')); // 10
      const $value = $nodeSizeStepper.find('.acu-stepper-value');

      const updateNodeSizeValue = (newPercent: number) => {
        newPercent = Math.max(min, Math.min(max, newPercent));
        nodeSizeMultiplier = newPercent / 100; // 转换为倍数 (0.5-2.0)
        $value.text(`${newPercent}%`);
        updateNodeSizeDisplay();

        // 重新计算节点半径并渲染
        nodeArr.forEach(node => {
          node.radius = getNodeRadius(node.name, node.isPlayer);
        });
        render();
      };

      const getCurrentPercent = () => {
        const text = $value.text().replace(/[^\d]/g, '');
        return parseInt(text) || 100;
      };

      $nodeSizeStepper.find('.acu-stepper-dec').on('click', function () {
        updateNodeSizeValue(getCurrentPercent() - step);
      });

      $nodeSizeStepper.find('.acu-stepper-inc').on('click', function () {
        updateNodeSizeValue(getCurrentPercent() + step);
      });
    }

    // 重新布局按钮
    overlay.find('#graph-relayout').click(() => {
      // 清除缓存
      clearLayoutCache();

      // 重新计算节点半径
      nodeArr.forEach(node => {
        node.radius = getNodeRadius(node.name, node.isPlayer);
      });

      // 重新运行物理模拟
      runForceDirectedLayout();
      render();
    });

    overlay.find('#graph-manage-avatar').click(() => {
      // 使用过滤后的节点数组，但头像管理应该显示所有节点
      showAvatarManager(nodeArr, () => {
        // 重新计算节点半径（因为大小可能改变了）
        nodeArr.forEach(node => {
          node.radius = getNodeRadius(node.name, node.isPlayer);
        });
        render();
      });
    });

    const closeGraph = () => {
      cleanupEvents();
      overlay.remove();
    };
    overlay.find('.acu-graph-close').click(closeGraph);
    setupOverlayClose(overlay, 'acu-relation-graph-overlay', closeGraph);
  };
  // ========================================
  // 头像裁剪弹窗 - 统一PC/移动端体验
  // ========================================

  const showAvatarCropModal = (imageSource, characterName, onSave) => {
    const { $ } = getCore();
    $('.acu-crop-modal-overlay').remove();

    const config = getConfig();

    // 初始参数
    let scale = 150;
    let offsetX = 50;
    let offsetY = 50;

    // 尝试读取已有配置
    const existing = AvatarManager.getAll()[characterName];
    if (existing) {
      scale = existing.scale ?? 150;
      offsetX = existing.offsetX ?? 50;
      offsetY = existing.offsetY ?? 50;
    }

    const modalHtml = `
            <div class="acu-crop-modal-overlay acu-theme-${config.theme}">
                <div class="acu-crop-modal">
                    <div class="acu-crop-header">
                        <span><i class="fa-solid fa-crop-simple"></i> 调整头像 - ${escapeHtml(characterName)}</span>
                        <button class="acu-crop-close"><i class="fa-solid fa-times"></i></button>
                    </div>
                    <div class="acu-crop-body">
                        <div class="acu-crop-container">
                            <div class="acu-crop-image" style="
                                background-image: url('${imageSource}');
                                background-size: ${scale}%;
                                background-position: ${offsetX}% ${offsetY}%;
                            "></div>
                            <div class="acu-crop-mask"></div>
                        </div>
                        <div class="acu-crop-hint">拖拽移动 · 滚轮/双指缩放</div>
                    </div>
                    <div class="acu-crop-footer">
                        <label class="acu-crop-btn acu-crop-reupload" title="重新上传">
                            <i class="fa-solid fa-camera"></i>
                            <input type="file" accept="image/*" class="acu-crop-file-input" />
                        </label>
                        <button class="acu-crop-btn acu-crop-cancel">取消</button>
                        <button class="acu-crop-btn acu-crop-confirm"><i class="fa-solid fa-check"></i> 确定</button>
                    </div>
                </div>
            </div>
        `;

    const $modal = $(modalHtml);
    $('body').append($modal);

    const $image = $modal.find('.acu-crop-image');
    const $container = $modal.find('.acu-crop-container');
    const containerEl = $container[0];
    const imageEl = $image[0];

    // 更新图片样式
    const updateImageStyle = () => {
      imageEl.style.backgroundSize = `${scale}%`;
      imageEl.style.backgroundPosition = `${offsetX}% ${offsetY}%`;
    };

    // === 拖拽逻辑（使用 Pointer Events 统一处理） ===
    let isDragging = false;
    let startX = 0,
      startY = 0;
    let startOffsetX = 0,
      startOffsetY = 0;
    let activePointerId = null;

    imageEl.addEventListener('pointerdown', e => {
      // 忽略多点触控的额外手指
      if (activePointerId !== null) return;

      e.preventDefault();
      e.stopPropagation();

      isDragging = true;
      activePointerId = e.pointerId;
      startX = e.clientX;
      startY = e.clientY;
      startOffsetX = offsetX;
      startOffsetY = offsetY;

      imageEl.setPointerCapture(e.pointerId);
      imageEl.style.cursor = 'grabbing';
    });

    imageEl.addEventListener('pointermove', e => {
      if (!isDragging || e.pointerId !== activePointerId) return;

      e.preventDefault();
      e.stopPropagation();

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      // 灵敏度根据缩放调整
      const sensitivity = 100 / scale;
      offsetX = Math.max(0, Math.min(100, startOffsetX - deltaX * sensitivity));
      offsetY = Math.max(0, Math.min(100, startOffsetY - deltaY * sensitivity));
      updateImageStyle();
    });

    imageEl.addEventListener('pointerup', e => {
      if (e.pointerId !== activePointerId) return;

      isDragging = false;
      activePointerId = null;
      imageEl.releasePointerCapture(e.pointerId);
      imageEl.style.cursor = 'grab';
    });

    imageEl.addEventListener('pointercancel', e => {
      if (e.pointerId !== activePointerId) return;

      isDragging = false;
      activePointerId = null;
      imageEl.style.cursor = 'grab';
    });

    // === 缩放逻辑 ===
    // 滚轮缩放
    containerEl.addEventListener(
      'wheel',
      e => {
        e.preventDefault();
        e.stopPropagation();
        const delta = e.deltaY > 0 ? -10 : 10;
        scale = Math.max(100, Math.min(300, scale + delta));
        updateImageStyle();
      },
      { passive: false },
    );

    // 双指缩放
    let lastPinchDist = 0;
    let pinchStartScale = scale;

    containerEl.addEventListener(
      'touchstart',
      e => {
        if (e.touches.length === 2) {
          e.preventDefault();
          lastPinchDist = Math.hypot(
            e.touches[1].clientX - e.touches[0].clientX,
            e.touches[1].clientY - e.touches[0].clientY,
          );
          pinchStartScale = scale;
        }
      },
      { passive: false },
    );

    containerEl.addEventListener(
      'touchmove',
      e => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const newDist = Math.hypot(
            e.touches[1].clientX - e.touches[0].clientX,
            e.touches[1].clientY - e.touches[0].clientY,
          );
          if (lastPinchDist > 0) {
            const pinchRatio = newDist / lastPinchDist;
            scale = Math.max(100, Math.min(300, pinchStartScale * pinchRatio));
            updateImageStyle();
          }
        }
      },
      { passive: false },
    );

    containerEl.addEventListener('touchend', e => {
      if (e.touches.length < 2) {
        lastPinchDist = 0;
        pinchStartScale = scale;
      }
    });

    // === 按钮事件 ===
    // 重新上传
    $modal.find('.acu-crop-file-input').on('change', async function (e) {
      const file = e.target.files[0];
      if (!file) return;

      if (!file.type.startsWith('image/')) {
        if (window.toastr) window.toastr.warning('请选择图片文件');
        return;
      }

      if (file.size > 5 * 1024 * 1024) {
        if (window.toastr) window.toastr.warning('图片大小不能超过 5MB');
        return;
      }

      try {
        // 保存新图片
        const success = await AvatarManager.saveLocalAvatar(characterName, file);
        if (success) {
          // 获取新 URL 并更新预览
          const newUrl = await LocalAvatarDB.get(characterName);
          imageSource = newUrl;

          // 重置裁剪参数
          scale = 150;
          offsetX = 50;
          offsetY = 50;

          // 更新显示
          $image.css('background-image', `url('${newUrl}')`);
          updateImageStyle();
        }
      } catch (err) {
        console.error('[DICE]ACU 重新上传失败:', err);
        if (window.toastr) window.toastr.error('上传失败');
      }

      $(this).val('');
    });
    $modal.find('.acu-crop-close, .acu-crop-cancel').on('click', () => {
      $modal.remove();
    });

    $modal.find('.acu-crop-confirm').on('click', () => {
      onSave({ scale, offsetX, offsetY });
      $modal.remove();
    });

    // 点击遮罩关闭
    setupOverlayClose($modal, 'acu-crop-modal-overlay', () => {
      $modal.remove();
    });
  };
  // 头像管理弹窗（简化版 - 使用裁剪弹窗）
  const showAvatarManager = (nodeArr, onUpdate) => {
    try {
      const { $ } = getCore();
      $('.acu-avatar-manager-overlay').remove();

      const config = getConfig();
      const avatars = AvatarManager.getAll();

      // 视图和排序状态
      let currentView = 'chat'; // 'chat' | 'global'
      let sortBy = 'name'; // 'name' | 'date' | 'source'
      let sortOrder = 'asc'; // 'asc' | 'desc'
      let searchQuery = '';
      const expandedItems = new Set<string>(); // 跟踪展开的角色
      let isInitialLoad = true; // 首次加载标志，用于控制自动展开行为

      // 统一解析用户占位符为{{user}}主键（用于头像管理界面）
      const resolveUserPlaceholderForAvatar = name => {
        if (!name) return name;
        const playerName = getPlayerName();
        const personaName = getPersonaName();

        // 明确的用户占位符变体
        const diceCfg = getDiceConfig();
        const explicitUserVariants = ['<user>', '{{user}}'];
        if (diceCfg.autoMergeProtagonist !== false) {
          explicitUserVariants.push('主角');
        }
        const isExplicitUserVariant = explicitUserVariants.some(
          v => name === v || name.toLowerCase() === v.toLowerCase(),
        );

        // 如果当前persona名匹配，也视为用户占位符
        const isPersonaName = personaName && name === personaName;

        // 检查是否是主角表名称（模糊匹配：表名包含"主角"）
        const isPlayerName = (() => {
          if (!playerName) return false;
          // 精确匹配
          if (name === playerName) return true;
          // 或者通过别名系统检查
          const primaryName = AvatarManager.getPrimaryName(name);
          return primaryName === playerName;
        })();

        // 统一映射到{{user}}主键
        if (isExplicitUserVariant || isPersonaName || isPlayerName) {
          return '{{user}}';
        }

        // 其他情况使用别名系统解析
        return AvatarManager.getPrimaryName(name);
      };

      // 异步构建列表
      const buildList = async () => {
        let listHtml = '';

        // 预先获取所有头像数据 (必须在使用前声明)
        const allAvatarData = AvatarManager.getAll();

        // 根据视图模式获取节点列表
        let workingNodes = [];
        if (currentView === 'chat') {
          // 当前聊天视图：使用传入的 nodeArr
          workingNodes = nodeArr.map(n => ({ name: n.name, isPlayer: n.isPlayer }));
        } else {
          // 全局视图：合并当前聊天角色 + 全局已配置角色（去重）
          const seenNames = new Set<string>();
          const merged: { name: string; isPlayer: boolean }[] = [];

          // 先添加当前聊天的角色
          for (const n of nodeArr) {
            if (!seenNames.has(n.name)) {
              seenNames.add(n.name);
              merged.push({ name: n.name, isPlayer: n.isPlayer });
            }
          }

          // 再添加全局已配置但不在当前聊天中的角色
          for (const name of Object.keys(allAvatarData)) {
            if (!seenNames.has(name)) {
              seenNames.add(name);
              merged.push({ name, isPlayer: false });
            }
          }

          workingNodes = merged;
        }

        // 分离{{user}}节点和其他节点
        const userNode = workingNodes.find(n => {
          const resolved = resolveUserPlaceholderForAvatar(n.name);
          return resolved === '{{user}}';
        });
        let otherNodes = workingNodes.filter(n => {
          const resolved = resolveUserPlaceholderForAvatar(n.name);
          return resolved !== '{{user}}';
        });

        // 搜索过滤
        if (searchQuery) {
          const query = searchQuery.toLowerCase();
          otherNodes = otherNodes.filter(n => {
            const nameMatch = n.name.toLowerCase().includes(query);
            const aliasMatch = (allAvatarData[n.name]?.aliases || []).some(alias =>
              alias.toLowerCase().includes(query),
            );
            return nameMatch || aliasMatch;
          });
        }

        // 预计算来源信息（用于来源排序）
        const nodeSourceMap = new Map<string, { hasLocal: boolean; hasUrl: boolean }>();
        if (sortBy === 'source') {
          for (const node of otherNodes) {
            const hasLocal = await AvatarManager.hasLocalAvatar(node.name);
            const hasUrl = !!allAvatarData[node.name]?.url;
            nodeSourceMap.set(node.name, { hasLocal, hasUrl });
          }
        }

        // 对其他节点进行排序
        if (sortBy === 'source') {
          // 按来源排序：本地上传 > URL > 无头像
          // 正序: local(0) < url(1) < none(2)
          // 倒序: none(2) < url(1) < local(0)
          const getSourcePriority = (name: string) => {
            const info = nodeSourceMap.get(name);
            if (info?.hasLocal) return 0; // 本地上传
            if (info?.hasUrl) return 1; // URL
            return 2; // 无头像
          };
          otherNodes.sort((a, b) => {
            const priorityA = getSourcePriority(a.name);
            const priorityB = getSourcePriority(b.name);
            const cmp = priorityA - priorityB;
            return sortOrder === 'asc' ? cmp : -cmp;
          });
        } else if (sortBy === 'name') {
          otherNodes.sort((a, b) => {
            const cmp = a.name.localeCompare(b.name, 'zh-CN');
            return sortOrder === 'asc' ? cmp : -cmp;
          });
        } else {
          // 按日期排序
          otherNodes.sort((a, b) => {
            const timeA = allAvatarData[a.name]?.createdAt ?? 0;
            const timeB = allAvatarData[b.name]?.createdAt ?? 0;
            return sortOrder === 'asc' ? timeA - timeB : timeB - timeA;
          });
        }

        // 检查是否为空状态（全局视图）
        if (currentView === 'global' && workingNodes.length === 0) {
          return `
            <div class="acu-avatar-empty-state">
              <i class="fa-solid fa-images"></i>
              <p>暂无角色数据。请确保数据库正确启动并包含主角信息或重要人物表数据。</p>
            </div>
          `;
        }

        // 检查是否为空状态（当前聊天视图）
        if (currentView === 'chat' && workingNodes.length === 0) {
          return `
            <div class="acu-avatar-empty-state">
              <i class="fa-solid fa-user-slash"></i>
              <p>当前聊天中没有找到角色数据。请先在仪表盘中添加主角或NPC。</p>
            </div>
          `;
        }

        // 先渲染{{user}}（如果存在）
        if (userNode) {
          // 创建{{user}}节点的副本，使用'{{user}}'作为名称
          const userNodeForDisplay = {
            ...userNode,
            name: '{{user}}', // 统一使用{{user}}作为显示名称
          };

          const data = avatars[userNodeForDisplay.name] || {};
          let currentUrl = data.url || '';

          // 检查是否有本地图片
          const hasLocal = await AvatarManager.hasLocalAvatar(userNodeForDisplay.name);
          let displayUrl = '';
          let sourceLabel = '';

          if (hasLocal) {
            displayUrl = await LocalAvatarDB.get(userNodeForDisplay.name);
            sourceLabel = '<span class="acu-avatar-source acu-source-local">本地</span>';
          } else if (currentUrl) {
            displayUrl = currentUrl;
            sourceLabel = '<span class="acu-avatar-source acu-source-url">URL</span>';
          }

          const aliases = (data.aliases || []).join(', ');
          const hasAvatar = !!displayUrl;

          // 默认策略：仅在首次加载时，如果没有头像URL，自动展开方便编辑
          if (isInitialLoad && !hasAvatar && !data.url) {
            expandedItems.add(userNodeForDisplay.name);
          }
          const isExpanded = expandedItems.has(userNodeForDisplay.name);

          listHtml += `
                    <div class="acu-avatar-item ${isExpanded ? 'expanded' : ''}" data-name="${escapeHtml(userNodeForDisplay.name)}" data-has-local="${hasLocal}" data-display-url="${escapeHtml(displayUrl)}">
                        <!-- 折叠态 -->
                        <div class="acu-avatar-row-collapsed">
                            <div class="acu-avatar-preview-wrap">
                                <div class="acu-avatar-preview ${hasAvatar ? 'has-image' : ''}" data-avatar-url="${escapeHtml(displayUrl)}" data-avatar-x="${data.offsetX ?? 50}" data-avatar-y="${data.offsetY ?? 50}" data-avatar-scale="${data.scale ?? 150}">
                                    ${!hasAvatar ? `<span>${escapeHtml(userNodeForDisplay.name.charAt(0))}</span><i class="fa-solid fa-camera acu-avatar-camera-hint"></i>` : ''}
                                </div>
                                ${sourceLabel}
                            </div>
                            <div class="acu-avatar-info-summary">
                                <div class="acu-avatar-name">${escapeHtml(userNodeForDisplay.name)}<button class="acu-protagonist-toggle ${getDiceConfig().autoMergeProtagonist !== false ? 'active' : ''}" title="自动将&quot;主角&quot;合并为{{user}}的别名"><i class="fa-solid ${getDiceConfig().autoMergeProtagonist !== false ? 'fa-link' : 'fa-link-slash'}"></i></button></div>
                                <div class="acu-avatar-url-preview">${escapeHtml(currentUrl || '无头像设置')}</div>
                            </div>
                            <div class="acu-avatar-actions-collapsed">
                                <button class="acu-btn-action acu-btn-edit" title="编辑"><i class="fa-solid ${isExpanded ? 'fa-chevron-up' : 'fa-pencil'}"></i></button>
                                <button class="acu-btn-action acu-btn-delete acu-avatar-clear-btn" title="清除"><i class="fa-solid fa-trash"></i></button>
                            </div>
                        </div>

                        <!-- 展开态 -->
                        <div class="acu-avatar-row-expanded">
                            <div class="acu-avatar-details">
                                <div class="acu-input-group">
                                    <label class="acu-input-group-label">URL</label>
                                    <div class="acu-url-container">
                                        <input type="text" class="acu-input acu-avatar-url" placeholder="粘贴图片链接..." value="${escapeHtml(currentUrl)}" />
                                    </div>
                                </div>
                                <div class="acu-input-group">
                                    <label class="acu-input-group-label">别名</label>
                                    <div class="acu-alias-tags-container">
                                        ${(data.aliases || []).map(a => `<span class="acu-alias-tag" data-alias="${escapeHtml(a)}">${escapeHtml(a)} <i class="fa-solid fa-xmark"></i></span>`).join('')}
                                        <input type="text" class="acu-alias-input" placeholder="输入别名，逗号分隔..." />
                                    </div>
                                </div>
                                <div class="acu-avatar-expanded-footer">
                                    <button class="acu-btn-action acu-avatar-clear-all-btn" title="清除头像"><i class="fa-solid fa-user-slash"></i></button>
                                    <button class="acu-btn-action acu-avatar-clear-alias-btn" title="清空别名"><i class="fa-solid fa-tags"></i></button>
                                    <label class="acu-avatar-upload-trigger">
                                        <i class="fa-solid fa-cloud-arrow-up"></i> 本地上传
                                        <input type="file" accept="image/*" class="acu-avatar-file-input" style="display:none" />
                                    </label>
                                    <button class="acu-btn-action acu-btn-save acu-avatar-save-btn" title="保存"><i class="fa-solid fa-check"></i>&nbsp;保存</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
        }

        // 再渲染其他节点
        for (const node of otherNodes) {
          const data = avatars[node.name] || {};
          let currentUrl = data.url || '';

          // 检查是否有本地图片
          const hasLocal = await AvatarManager.hasLocalAvatar(node.name);
          let displayUrl = '';
          let sourceLabel = '';

          if (hasLocal) {
            displayUrl = await LocalAvatarDB.get(node.name);
            sourceLabel = '<span class="acu-avatar-source acu-source-local">本地</span>';
          } else if (currentUrl) {
            displayUrl = currentUrl;
            sourceLabel = '<span class="acu-avatar-source acu-source-url">URL</span>';
          }

          const aliases = (data.aliases || []).join(', ');
          const hasAvatar = !!displayUrl;

          // 默认策略：仅在首次加载时，如果没有头像URL，自动展开方便编辑
          if (isInitialLoad && !hasAvatar && !data.url) {
            expandedItems.add(node.name);
          }
          const isExpanded = expandedItems.has(node.name);

          listHtml += `
                    <div class="acu-avatar-item ${isExpanded ? 'expanded' : ''}" data-name="${escapeHtml(node.name)}" data-has-local="${hasLocal}" data-display-url="${escapeHtml(displayUrl)}">
                        <!-- 折叠态 -->
                        <div class="acu-avatar-row-collapsed">
                            <div class="acu-avatar-preview-wrap">
                                <div class="acu-avatar-preview ${hasAvatar ? 'has-image' : ''}" data-avatar-url="${escapeHtml(displayUrl)}" data-avatar-x="${data.offsetX ?? 50}" data-avatar-y="${data.offsetY ?? 50}" data-avatar-scale="${data.scale ?? 150}">
                                    ${!hasAvatar ? `<span>${escapeHtml(node.name.charAt(0))}</span><i class="fa-solid fa-camera acu-avatar-camera-hint"></i>` : ''}
                                </div>
                                ${sourceLabel}
                            </div>
                            <div class="acu-avatar-info-summary">
                                <div class="acu-avatar-name">${escapeHtml(node.name)}</div>
                                <div class="acu-avatar-url-preview">${escapeHtml(currentUrl || '无头像设置')}</div>
                            </div>
                            <div class="acu-avatar-actions-collapsed">
                                <button class="acu-btn-action acu-btn-edit" title="编辑"><i class="fa-solid ${isExpanded ? 'fa-chevron-up' : 'fa-pencil'}"></i></button>
                                <button class="acu-btn-action acu-btn-delete acu-avatar-clear-btn" title="清除"><i class="fa-solid fa-trash"></i></button>
                            </div>
                        </div>

                        <!-- 展开态 -->
                        <div class="acu-avatar-row-expanded">
                            <div class="acu-avatar-details">
                                <div class="acu-input-group">
                                    <label class="acu-input-group-label">URL</label>
                                    <div class="acu-url-container">
                                        <input type="text" class="acu-input acu-avatar-url" placeholder="粘贴图片链接..." value="${escapeHtml(currentUrl)}" />
                                    </div>
                                </div>
                                <div class="acu-input-group">
                                    <label class="acu-input-group-label">别名</label>
                                    <div class="acu-alias-tags-container">
                                        ${(data.aliases || []).map(a => `<span class="acu-alias-tag" data-alias="${escapeHtml(a)}">${escapeHtml(a)} <i class="fa-solid fa-xmark"></i></span>`).join('')}
                                        <input type="text" class="acu-alias-input" placeholder="输入别名，逗号分隔..." />
                                    </div>
                                </div>
                                <div class="acu-avatar-expanded-footer">
                                    <button class="acu-btn-action acu-avatar-clear-all-btn" title="清除头像"><i class="fa-solid fa-user-slash"></i></button>
                                    <button class="acu-btn-action acu-avatar-clear-alias-btn" title="清空别名"><i class="fa-solid fa-tags"></i></button>
                                    <label class="acu-avatar-upload-trigger">
                                        <i class="fa-solid fa-cloud-arrow-up"></i> 本地上传
                                        <input type="file" accept="image/*" class="acu-avatar-file-input" style="display:none" />
                                    </label>
                                    <button class="acu-btn-action acu-btn-save acu-avatar-save-btn" title="保存"><i class="fa-solid fa-check"></i>&nbsp;保存</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
        }

        return listHtml;
      };

      const applyAvatarPreviewStyles = $root => {
        $root.find('.acu-avatar-preview').each(function () {
          const $preview = $(this);
          const url = $preview.attr('data-avatar-url');
          if (!url) return;
          const offsetX = Number($preview.attr('data-avatar-x') || 50);
          const offsetY = Number($preview.attr('data-avatar-y') || 50);
          const scale = Number($preview.attr('data-avatar-scale') || 150);
          $preview.css({
            '--acu-avatar-image': `url('${url}')`,
            '--acu-avatar-x': `${offsetX}%`,
            '--acu-avatar-y': `${offsetY}%`,
            '--acu-avatar-scale': `${scale}%`,
          });
        });
      };

      // 先显示加载状态
      const managerHtml = `
            <div class="acu-avatar-manager-overlay acu-theme-${config.theme}">
                <div class="acu-avatar-manager">
                    <div class="acu-panel-header">
                        <div class="acu-avatar-title"><i class="fa-solid fa-user-circle"></i> 头像管理</div>
                        <div class="acu-avatar-header-actions">
                            <button class="acu-btn-icon acu-avatar-import-btn" title="导入"><i class="fa-solid fa-file-import"></i></button>
                            <button class="acu-btn-icon acu-avatar-export-btn" title="导出"><i class="fa-solid fa-file-export"></i></button>
                            <button class="acu-avatar-close"><i class="fa-solid fa-times"></i></button>
                        </div>
                    </div>
                    <div class="acu-avatar-toolbar">
                        <!-- 左侧:切换视图、排序、搜索 -->
                        <div class="acu-toolbar-group left">
                            <button class="acu-btn-icon acu-view-toggle" title="当前聊天 / 全局头像库" data-view="chat">
                                <i class="fa-solid fa-comments"></i>
                            </button>
                            <div class="acu-select-wrapper sort-field">
                                <select class="acu-toolbar-select acu-sort-field" title="排序方式">
                                    <option value="name">名字</option>
                                    <option value="date">日期</option>
                                    <option value="source">来源</option>
                                </select>
                            </div>
                            <button class="acu-btn-icon acu-sort-order" title="排序方向" data-dir="asc">
                                <i class="fa-solid fa-arrow-down-a-z"></i>
                            </button>
                            <div class="acu-search-wrapper">
                                <i class="fa-solid fa-magnifying-glass acu-search-icon"></i>
                                <input type="text" class="acu-avatar-search" placeholder="搜索..." autocomplete="off">
                                <i class="fa-solid fa-xmark acu-search-clear" style="display:none;"></i>
                            </div>
                        </div>
                    </div>
                    <div class="acu-avatar-list" id="acu-avatar-list-container">
                        <div class="acu-import-empty">
                            <i class="fa-solid fa-spinner fa-spin"></i> 加载中...
                        </div>
                    </div>
                </div>
                <input type="file" id="acu-avatar-file-input" accept=".json" />
            </div>
        `;

      const $manager = $(managerHtml);
      $('body').append($manager);

      // 异步加载列表
      buildList().then(listHtml => {
        $manager.find('#acu-avatar-list-container').html(listHtml);
        applyAvatarPreviewStyles($manager);
        bindAvatarEvents();
      });

      // 刷新单个条目的显示
      const refreshItem = async name => {
        const $item = $manager.find(`.acu-avatar-item[data-name="${name}"]`);
        if (!$item.length) return;

        const data = AvatarManager.getAll()[name] || {};
        const hasLocal = await AvatarManager.hasLocalAvatar(name);
        let displayUrl = '';
        let sourceLabel = '';

        if (hasLocal) {
          displayUrl = await LocalAvatarDB.get(name);
          sourceLabel = '<span class="acu-avatar-source acu-source-local">本地</span>';
        } else if (data.url) {
          displayUrl = data.url;
          sourceLabel = '<span class="acu-avatar-source acu-source-url">URL</span>';
        }

        const $preview = $item.find('.acu-avatar-preview');
        $item.find('.acu-avatar-source').remove();

        if (displayUrl) {
          $preview
            .addClass('has-image')
            .attr('data-avatar-url', displayUrl)
            .attr('data-avatar-x', data.offsetX ?? 50)
            .attr('data-avatar-y', data.offsetY ?? 50)
            .attr('data-avatar-scale', data.scale ?? 150)
            .css({
              '--acu-avatar-image': `url('${displayUrl}')`,
              '--acu-avatar-x': `${data.offsetX ?? 50}%`,
              '--acu-avatar-y': `${data.offsetY ?? 50}%`,
              '--acu-avatar-scale': `${data.scale ?? 150}%`,
            })
            .find('span')
            .remove();
          $item.find('.acu-avatar-preview-wrap').append(sourceLabel);
          $item.find('.acu-avatar-url-preview').text(data.url || '本地图片');
        } else {
          $preview
            .removeClass('has-image')
            .attr('data-avatar-url', '')
            .attr('data-avatar-x', 50)
            .attr('data-avatar-y', 50)
            .attr('data-avatar-scale', 150)
            .css({
              '--acu-avatar-image': '',
              '--acu-avatar-x': '',
              '--acu-avatar-y': '',
              '--acu-avatar-scale': '',
            })
            .html(
              `<span>${escapeHtml(name.charAt(0))}</span><i class="fa-solid fa-camera acu-avatar-camera-hint"></i>`,
            );
          $item.find('.acu-avatar-url-preview').text('无头像设置');
        }

        $item.attr('data-has-local', hasLocal);
        $item.attr('data-display-url', displayUrl);
      };

      // 刷新整个列表
      const refreshList = async () => {
        const listHtml = await buildList();
        $manager.find('#acu-avatar-list-container').html(listHtml);
        applyAvatarPreviewStyles($manager);
        // 首次加载完成后，禁止后续自动展开
        isInitialLoad = false;
      };

      // ========== 删除功能辅助函数 ==========

      // Part A: 在表格中查找角色
      const findCharacterInTable = (
        name: string,
      ): { tableKey: string; rowIndex: number; row: Record<string, unknown> } | null => {
        try {
          const rawData = typeof getTableData === 'function' ? getTableData() : null;
          if (!rawData) return null;

          // 获取角色的所有别名
          const avatarData = AvatarManager.getAll()[name];
          const aliases = avatarData?.aliases || [];
          const allNames = [name, ...aliases].map(n => n.toLowerCase());

          // 遍历所有表格
          for (const [tableKey, tableData] of Object.entries(rawData)) {
            if (!tableData || typeof tableData !== 'object') continue;
            const rows = (tableData as { rows?: unknown[] }).rows;
            if (!Array.isArray(rows)) continue;

            for (let i = 0; i < rows.length; i++) {
              const row = rows[i] as Record<string, unknown>;
              if (!row) continue;

              // 检查名字列（常见列名）
              const nameColumns = ['名字', '角色名', '姓名', 'name', 'Name', '名称'];
              for (const col of nameColumns) {
                const cellValue = row[col];
                if (cellValue && typeof cellValue === 'string') {
                  if (allNames.includes(cellValue.toLowerCase())) {
                    return { tableKey, rowIndex: i, row };
                  }
                }
              }
            }
          }
          return null;
        } catch (err) {
          console.error('[DICE] findCharacterInTable 错误:', err);
          return null;
        }
      };

      // Part A: 查找人际关系引用
      const findRelationshipReferences = (
        name: string,
        aliases: string[] = [],
      ): Array<{
        tableName: string;
        rowIndex: number;
        characterName: string;
        relationText: string;
        matchedRelation: string;
      }> => {
        const references: Array<{
          tableName: string;
          rowIndex: number;
          characterName: string;
          relationText: string;
          matchedRelation: string;
        }> = [];

        try {
          const rawData = typeof getTableData === 'function' ? getTableData() : null;
          if (!rawData) return references;

          const allNames = [name, ...aliases].map(n => n.toLowerCase());

          for (const [tKey, tData] of Object.entries(rawData)) {
            if (!tKey.startsWith('sheet_')) continue;
            if (!tData || typeof tData !== 'object') continue;

            const sheet = tData as { name?: string; content?: unknown[][] };
            if (!Array.isArray(sheet.content) || sheet.content.length < 2) continue;

            const headers = sheet.content[0] as string[];
            const tableName = sheet.name || tKey.replace('sheet_', '');

            // 查找"名字"列索引
            const nameColumns = ['名字', '角色名', '姓名', 'name', 'Name', '名称'];
            let nameColIndex = -1;
            for (const col of nameColumns) {
              const idx = headers.findIndex(h => h === col);
              if (idx !== -1) {
                nameColIndex = idx;
                break;
              }
            }

            // 查找"人际关系"列索引
            const relationColIndex = headers.findIndex(h => h === '人际关系');
            if (relationColIndex === -1) continue;

            // 遍历数据行（跳过表头）
            for (let i = 1; i < sheet.content.length; i++) {
              const row = sheet.content[i];
              if (!Array.isArray(row)) continue;

              // 获取该行角色名
              let rowCharacterName = '';
              if (nameColIndex !== -1) {
                const cellValue = row[nameColIndex];
                if (cellValue && typeof cellValue === 'string') {
                  rowCharacterName = cellValue;
                }
              }

              // 检查人际关系列
              const relationValue = row[relationColIndex];
              if (relationValue && typeof relationValue === 'string') {
                // 格式: "角色名:关系词;角色名:关系词"
                const parts = relationValue.split(/[;；]/);
                for (const part of parts) {
                  const splitResult = part.split(/[:：]/);
                  const refName = splitResult[0];
                  const relationWord = splitResult[1] || '';
                  if (refName && allNames.includes(refName.trim().toLowerCase())) {
                    references.push({
                      tableName,
                      rowIndex: i - 1, // 减1因为跳过了表头
                      characterName: rowCharacterName || `行${i}`,
                      relationText: relationValue,
                      matchedRelation: relationWord.trim(),
                    });
                    break; // 每行只记录一次
                  }
                }
              }
            }
          }
        } catch (err) {
          console.error('[DICE] findRelationshipReferences 错误:', err);
        }

        return references;
      };

      // Part B: 删除确认弹窗 (Redesigned)
      const showDeleteConfirmModal = (
        info: {
          name: string;
          avatarUrl: string;
          tableRow: { tableKey: string; rowIndex: number; row: Record<string, unknown> } | null;
          relationships: Array<{
            tableName: string;
            rowIndex: number;
            characterName: string;
            relationText: string;
            matchedRelation: string;
          }>;
        },
        onConfirm: () => void,
        onClose?: () => void,
      ) => {
        const { name, tableRow, relationships } = info;

        // 1. 获取头像完整配置 (包含偏移/缩放/别名)
        const avatarData = AvatarManager.getAll()[name] || {};
        const aliases = avatarData.aliases || [];
        const avX = avatarData.offsetX ?? 50;
        const avY = avatarData.offsetY ?? 50;
        const avScale = avatarData.scale ?? 150;
        const displayUrl = avatarData.url || info.avatarUrl;

        // 2. 扫描别名在表格中的分布
        const aliasRows: Array<{ tableKey: string; alias: string }> = [];
        if (aliases.length > 0) {
          try {
            const rawData = typeof getTableData === 'function' ? getTableData() : null;
            if (rawData) {
              const lowerAliases = aliases.map((a: string) => a.toLowerCase());
              for (const [tKey, tData] of Object.entries(rawData)) {
                if (!tKey.startsWith('sheet_')) continue;
                if (!tData || typeof tData !== 'object') continue;
                const sheet = tData as { content?: unknown[][] };
                if (!Array.isArray(sheet.content) || sheet.content.length < 2) continue;

                const headers = sheet.content[0] as string[];
                const nameColumns = ['名字', '角色名', '姓名', 'name', 'Name', '名称'];
                let nameColIndex = -1;
                for (const col of nameColumns) {
                  const idx = headers.findIndex(h => h === col);
                  if (idx !== -1) {
                    nameColIndex = idx;
                    break;
                  }
                }
                if (nameColIndex === -1) continue;

                for (let i = 1; i < sheet.content.length; i++) {
                  const row = sheet.content[i];
                  if (!Array.isArray(row)) continue;
                  const cellValue = row[nameColIndex];
                  if (cellValue && typeof cellValue === 'string') {
                    if (lowerAliases.includes(cellValue.toLowerCase())) {
                      aliasRows.push({ tableKey: tKey.replace('sheet_', ''), alias: cellValue });
                    }
                  }
                }
              }
            }
          } catch (e) {
            console.warn('[DeleteModal] Alias scan failed', e);
          }
        }

        // 3. 构建 HTML 内容
        const modalHtml = `
          <div class="acu-delete-confirm-overlay acu-theme-${config.theme}">
            <div class="acu-delete-confirm-modal redesign">

              <!-- 头部 -->
              <div class="acu-delete-header destruct">
                <i class="fa-solid fa-triangle-exclamation"></i>
                删除角色确认
                <button class="acu-delete-close-btn" title="关闭">
                  <i class="fa-solid fa-xmark"></i>
                </button>
              </div>

              <div class="acu-delete-content">

                <!-- 核心身份 (红色区域) -->
                <div class="acu-del-section destruct">
                  <div class="acu-del-section-head">
                    <i class="fa-solid fa-id-card"></i> 将永久删除
                  </div>
                  <div class="acu-del-card main-identity">
                    <div class="acu-del-avatar-box">
                      <div class="acu-avatar-preview ${displayUrl ? 'has-image' : ''}"
                           data-avatar-url="${escapeHtml(displayUrl || '')}"
                           data-avatar-x="${avX}"
                           data-avatar-y="${avY}"
                           data-avatar-scale="${avScale}">
                        ${!displayUrl ? `<span>${escapeHtml(name.charAt(0))}</span>` : ''}
                      </div>
                    </div>
                    <div class="acu-del-info">
                      <div class="acu-del-name">${escapeHtml(name)}</div>
                      <div class="acu-del-meta">头像配置与映射记录</div>
                    </div>
                  </div>
                </div>

                <!-- 关联数据 (橙色区域) -->
                ${
                  tableRow || aliases.length > 0
                    ? `
                <div class="acu-del-section warning">
                  <div class="acu-del-section-head">
                    <i class="fa-solid fa-database"></i> 关联数据清理
                  </div>
                  <ul class="acu-del-list">
                    ${
                      tableRow
                        ? `
                      <li>
                        <i class="fa-solid fa-table"></i>
                        <span>主数据行: <strong>${escapeHtml(tableRow.tableKey)}</strong></span>
                      </li>
                    `
                        : ''
                    }
                    ${
                      aliases.length > 0
                        ? `
                      <li class="sub-group">
                        <div class="group-title"><i class="fa-solid fa-tags"></i> 别名 (${aliases.length}个)</div>
                        <div class="group-content">${aliases.map((a: string) => `<span class="tag">${escapeHtml(a)}</span>`).join('')}</div>
                        ${
                          aliasRows.length > 0
                            ? `
                          <div class="group-warning">
                            <i class="fa-solid fa-trash-can"></i> 将删除 ${aliasRows.length} 行别名数据
                            <span class="detail">(${aliasRows
                              .map(r => r.tableKey)
                              .slice(0, 3)
                              .join(', ')}${aliasRows.length > 3 ? '...' : ''})</span>
                          </div>
                        `
                            : ''
                        }
                      </li>
                    `
                        : ''
                    }
                  </ul>
                </div>
                `
                    : ''
                }

                <!-- 关系引用 (橙色区域 - 与关联数据清理一致) -->
                ${
                  relationships.length > 0
                    ? `
                <div class="acu-del-section warning">
                  <div class="acu-del-section-head">
                    <i class="fa-solid fa-link"></i> 人际关系清除
                  </div>
                  <div class="acu-del-summary">
                    将从 <strong>${relationships.length}</strong> 处人际关系中移除此角色
                  </div>
                  <ul class="acu-del-list compact">
                    ${relationships
                      .slice(0, 5)
                      .map(
                        rel => `
                      <li>
                        <i class="fa-solid fa-user-tag"></i>
                        <span>${escapeHtml(rel.tableName)}.${escapeHtml(rel.characterName)}${rel.matchedRelation ? ` <span class="relation-tag">${escapeHtml(rel.matchedRelation)}</span>` : ''}</span>
                      </li>
                    `,
                      )
                      .join('')}
                    ${relationships.length > 5 ? `<li class="more">... 以及其他 ${relationships.length - 5} 处</li>` : ''}
                  </ul>
                </div>
                `
                    : ''
                }

                <div class="acu-del-final-warn">
                  此操作 <strong>不可撤销</strong>，请确认是否继续？
                </div>
              </div>

              <!-- 底部按钮 -->
              <div class="acu-delete-actions">
                <button class="acu-delete-cancel-btn">
                  取消
                </button>
                <button class="acu-delete-confirm-btn destruct">
                  <i class="fa-solid fa-trash"></i> 确认永久删除
                </button>
              </div>
            </div>
          </div>
        `;

        const $modal = $(modalHtml);
        $('body').append($modal);

        // 应用头像预览样式 (复用 applyAvatarPreviewStyles 逻辑)
        $modal.find('.acu-avatar-preview').each(function () {
          const $preview = $(this);
          const url = $preview.attr('data-avatar-url');
          if (!url) return;
          const offsetX = Number($preview.attr('data-avatar-x') || 50);
          const offsetY = Number($preview.attr('data-avatar-y') || 50);
          const scale = Number($preview.attr('data-avatar-scale') || 150);
          $preview.css({
            '--acu-avatar-image': `url('${url}')`,
            '--acu-avatar-x': `${offsetX}%`,
            '--acu-avatar-y': `${offsetY}%`,
            '--acu-avatar-scale': `${scale}%`,
          });
        });

        // 关闭弹窗
        const closeModal = () => {
          $modal.addClass('closing');
          setTimeout(() => {
            $modal.remove();
            onClose?.();
          }, 200);
        };

        // ESC 键关闭
        const handleKeydown = (e: KeyboardEvent) => {
          if (e.key === 'Escape') {
            closeModal();
            $(document).off(
              'keydown',
              handleKeydown as unknown as JQuery.TypeEventHandler<Document, unknown, Document, Document, 'keydown'>,
            );
          }
        };
        $(document).on(
          'keydown',
          handleKeydown as unknown as JQuery.TypeEventHandler<Document, unknown, Document, Document, 'keydown'>,
        );

        // 点击遮罩关闭
        $modal.on('click', function (e) {
          if ($(e.target).hasClass('acu-delete-confirm-overlay')) {
            closeModal();
          }
        });

        // 取消按钮
        $modal.find('.acu-delete-cancel-btn').on('click', closeModal);

        // 关闭按钮 (×)
        $modal.find('.acu-delete-close-btn').on('click', closeModal);

        // 确认按钮
        $modal.find('.acu-delete-confirm-btn').on('click', () => {
          const $btn = $modal.find('.acu-delete-confirm-btn');
          $btn.prop('disabled', true).html('<i class="fa-solid fa-spinner fa-spin"></i> 删除中...');
          setTimeout(() => {
            closeModal();
            onConfirm();
          }, 50);
        });
      };

      // Part D: 执行删除
      const executeCharacterDelete = async (name: string) => {
        try {
          const avatarData = AvatarManager.getAll()[name];
          const aliases = avatarData?.aliases || [];

          // 1. 删除头像
          await AvatarManager.deleteLocalAvatar(name);
          AvatarManager.remove(name);

          // 收集需要保存的表格keys
          const modifiedSheetKeys = new Set<string>();

          // 2. 获取表格数据（使用 cachedRawData 或 getTableData，与现有删除整行逻辑一致）
          let rawData = typeof getTableData === 'function' ? getTableData() : null;
          if (!rawData) {
            console.warn('[DICE] 无法获取表格数据，跳过表格行删除');
          }

          // 3. 删除表格行（复用现有删除整行的数据结构：content 二维数组）
          if (rawData) {
            const allNames = [name, ...aliases].map(n => n.toLowerCase());

            // 遍历所有表格查找并删除角色行
            for (const [tableKey, tableData] of Object.entries(rawData)) {
              if (!tableKey.startsWith('sheet_')) continue;
              if (!tableData || typeof tableData !== 'object') continue;

              const sheet = tableData as { content?: unknown[][] };
              if (!Array.isArray(sheet.content) || sheet.content.length < 2) continue;

              // 获取表头，找到"名字"列的索引
              const headers = sheet.content[0] as string[];
              const nameColumns = ['名字', '角色名', '姓名', 'name', 'Name', '名称'];
              let nameColIndex = -1;
              for (const col of nameColumns) {
                const idx = headers.findIndex(h => h === col);
                if (idx !== -1) {
                  nameColIndex = idx;
                  break;
                }
              }

              if (nameColIndex === -1) continue; // 该表格没有名字列

              // 从后向前遍历数据行（跳过表头 content[0]），删除所有匹配的行
              for (let i = sheet.content.length - 1; i >= 1; i--) {
                const row = sheet.content[i];
                if (!Array.isArray(row)) continue;

                const cellValue = row[nameColIndex];
                if (cellValue && typeof cellValue === 'string') {
                  if (allNames.includes(cellValue.toLowerCase())) {
                    // 删除该行（与现有删除整行逻辑一致）
                    sheet.content.splice(i, 1);
                    modifiedSheetKeys.add(tableKey);
                    console.log(`[DICE] 已从表格 ${tableKey} 删除角色行 [${i}]: ${cellValue}`);
                    // 不break，继续遍历删除所有别名对应的行
                  }
                }
              }
            }
          }

          // 4. 清理人际关系引用（直接在 rawData 上操作，使用 content 结构）
          if (rawData) {
            const allNames = [name, ...aliases].map(n => n.toLowerCase());

            for (const [tableKey, tableData] of Object.entries(rawData)) {
              if (!tableKey.startsWith('sheet_')) continue;
              if (!tableData || typeof tableData !== 'object') continue;

              const sheet = tableData as { content?: unknown[][] };
              if (!Array.isArray(sheet.content) || sheet.content.length < 2) continue;

              // 获取表头，找到"人际关系"列的索引
              const headers = sheet.content[0] as string[];
              const relationColIndex = headers.findIndex(h => h === '人际关系');
              if (relationColIndex === -1) continue;

              // 遍历数据行（跳过表头）
              for (let i = 1; i < sheet.content.length; i++) {
                const row = sheet.content[i];
                if (!Array.isArray(row)) continue;

                const relationValue = row[relationColIndex];
                if (typeof relationValue !== 'string' || !relationValue) continue;

                // 过滤掉包含被删除角色的部分
                const parts = relationValue.split(/[;；]/);
                const filteredParts = parts.filter(part => {
                  const [refName] = part.split(/[:：]/);
                  return !refName || !allNames.includes(refName.trim().toLowerCase());
                });

                const newValue = filteredParts.join(';');
                if (newValue !== relationValue) {
                  row[relationColIndex] = newValue;
                  modifiedSheetKeys.add(tableKey);
                }
              }
            }
          }

          // 5. 保存数据到数据库
          if (rawData && modifiedSheetKeys.size > 0) {
            await saveDataOnly(rawData, Array.from(modifiedSheetKeys));
            // 触发界面刷新
            if (typeof renderInterface === 'function') {
              renderInterface();
            }
          }

          // 6. 从 nodeArr 中移除被删除的角色（确保列表刷新时不再显示）
          const idx = nodeArr.findIndex(n => n.name === name);
          if (idx !== -1) {
            nodeArr.splice(idx, 1);
          }

          // 7. 刷新头像管理列表
          await refreshList();

          // 8. 显示成功提示
          if (window.toastr) {
            window.toastr.success(`已删除角色 "${name}"`);
          }

          onUpdate?.();
        } catch (err) {
          console.error('[DICE] 删除角色失败:', err);
          if (window.toastr) {
            window.toastr.error('删除失败');
          }
        }
      };

      // ========== 删除功能辅助函数结束 ==========

      const bindAvatarEvents = () => {
        // 视图切换(toggle图标)
        $manager.on('click', '.acu-view-toggle', async function () {
          const $btn = $(this);
          const isChat = $btn.attr('data-view') === 'chat';
          const newView = isChat ? 'global' : 'chat';

          $btn.attr('data-view', newView);
          currentView = newView;

          const $icon = $btn.find('i');
          if (newView === 'global') {
            $icon.removeClass('fa-comments').addClass('fa-globe');
            $btn.addClass('active');
          } else {
            $icon.removeClass('fa-globe').addClass('fa-comments');
            $btn.removeClass('active');
          }

          await refreshList();
        });

        // 搜索(带防抖)
        const debouncedSearch = _.debounce(async () => {
          await refreshList();
        }, 300);

        $manager.on('input', '.acu-avatar-search', function () {
          searchQuery = $(this).val().trim();
          const $clear = $manager.find('.acu-search-clear');
          $clear.toggle(!!searchQuery);
          debouncedSearch();
        });

        $manager.on('click', '.acu-search-clear', async function () {
          searchQuery = '';
          $manager.find('.acu-avatar-search').val('');
          $(this).hide();
          await refreshList();
        });

        // 排序字段
        $manager.on('change', '.acu-sort-field', async function () {
          sortBy = $(this).val();
          await refreshList();
        });

        // 排序方向(toggle图标)
        $manager.on('click', '.acu-sort-order', async function () {
          const $btn = $(this);
          const isAsc = $btn.attr('data-dir') === 'asc';
          const newDir = isAsc ? 'desc' : 'asc';

          $btn.attr('data-dir', newDir);
          sortOrder = newDir;

          const $icon = $btn.find('i');
          if (newDir === 'desc') {
            $icon.removeClass('fa-arrow-down-a-z').addClass('fa-arrow-up-a-z');
          } else {
            $icon.removeClass('fa-arrow-up-a-z').addClass('fa-arrow-down-a-z');
          }

          await refreshList();
        });

        // 点击头像预览
        $manager.on('click', '.acu-avatar-preview', async function (e) {
          e.stopPropagation();
          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name');
          const displayUrl = $item.attr('data-display-url');

          if (displayUrl) {
            // 有图片 → 打开裁剪弹窗
            showAvatarCropModal(displayUrl, name, async result => {
              const data = AvatarManager.getAll()[name] || {};
              AvatarManager.set(name, data.url || '', result.offsetX, result.offsetY, result.scale, data.aliases || []);
              await refreshItem(name);
              onUpdate && onUpdate();
            });
          } else {
            // 无图片 → 直接触发本地上传
            $item.find('.acu-avatar-file-input').click();
          }
        });

        // 展开/折叠切换
        $manager.on('click', '.acu-btn-edit', function (e) {
          e.stopPropagation();
          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name');
          const isExpanded = $item.hasClass('expanded');

          if (isExpanded) {
            $item.removeClass('expanded');
            expandedItems.delete(name);
            $(this).find('i').removeClass('fa-chevron-up').addClass('fa-pencil');
          } else {
            $item.addClass('expanded');
            expandedItems.add(name);
            $(this).find('i').removeClass('fa-pencil').addClass('fa-chevron-up');
          }
        });

        // 别名标签输入逻辑
        $manager.on('keydown', '.acu-alias-input', function (e) {
          if (e.key === 'Enter' || e.key === ',') {
            e.preventDefault();
            const val = $(this).val().trim();
            if (val) {
              const $container = $(this).closest('.acu-alias-tags-container');
              // 检查重复
              let exists = false;
              $container.find('.acu-alias-tag').each(function () {
                if ($(this).data('alias') === val) exists = true;
              });

              if (!exists) {
                const tagHtml = `<span class="acu-alias-tag" data-alias="${escapeHtml(val)}">${escapeHtml(val)} <i class="fa-solid fa-xmark"></i></span>`;
                $(this).before(tagHtml);
              }
              $(this).val('');
            }
          } else if (e.key === 'Backspace' && !$(this).val()) {
            // 删除最后一个标签
            $(this).prev('.acu-alias-tag').remove();
          }
        });

        // 逗号输入处理 (用于中文逗号)
        $manager.on('input', '.acu-alias-input', function (e) {
          const val = $(this).val();
          if (val.includes(',') || val.includes('，')) {
            const parts = val.split(/[,，]/);
            const lastPart = parts.pop(); // 保留最后一部分在输入框
            const $container = $(this).closest('.acu-alias-tags-container');

            parts.forEach(part => {
              const cleanPart = part.trim();
              if (cleanPart) {
                let exists = false;
                $container.find('.acu-alias-tag').each(function () {
                  if ($(this).data('alias') === cleanPart) exists = true;
                });
                if (!exists) {
                  const tagHtml = `<span class="acu-alias-tag" data-alias="${escapeHtml(cleanPart)}">${escapeHtml(cleanPart)} <i class="fa-solid fa-xmark"></i></span>`;
                  $(this).before(tagHtml);
                }
              }
            });
            $(this).val(lastPart);
          }
        });

        // 粘贴处理
        $manager.on('paste', '.acu-alias-input', function (e) {
          e.preventDefault();
          const clipboardData = (e.originalEvent || e).clipboardData;
          const pastedData = clipboardData.getData('text');
          if (!pastedData) return;

          const parts = pastedData.split(/[,，\n]/);
          const $container = $(this).closest('.acu-alias-tags-container');

          parts.forEach(part => {
            const cleanPart = part.trim();
            if (cleanPart) {
              let exists = false;
              $container.find('.acu-alias-tag').each(function () {
                if ($(this).data('alias') === cleanPart) exists = true;
              });
              if (!exists) {
                const tagHtml = `<span class="acu-alias-tag" data-alias="${escapeHtml(cleanPart)}">${escapeHtml(cleanPart)} <i class="fa-solid fa-xmark"></i></span>`;
                $(this).before(tagHtml);
              }
            }
          });
        });

        // 删除标签
        $manager.on('click', '.acu-alias-tag i', function () {
          $(this).parent().remove();
        });

        // 点击容器聚焦输入框
        $manager.on('click', '.acu-alias-tags-container', function (e) {
          if (e.target === this) {
            $(this).find('.acu-alias-input').focus();
          }
        });

        // 本地文件上传
        $manager.on('change', '.acu-avatar-file-input', async function (e) {
          const file = e.target.files[0];
          if (!file) return;

          if (!file.type.startsWith('image/')) {
            if (window.toastr) window.toastr.warning('请选择图片文件');
            return;
          }

          if (file.size > 5 * 1024 * 1024) {
            if (window.toastr) window.toastr.warning('图片大小不能超过 5MB');
            return;
          }

          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name');

          try {
            const success = await AvatarManager.saveLocalAvatar(name, file);
            if (success) {
              const newUrl = await LocalAvatarDB.get(name);
              await refreshItem(name);

              // 自动弹出裁剪弹窗
              showAvatarCropModal(newUrl, name, async result => {
                const data = AvatarManager.getAll()[name] || {};
                AvatarManager.set(
                  name,
                  data.url || '',
                  result.offsetX,
                  result.offsetY,
                  result.scale,
                  data.aliases || [],
                );
                await refreshItem(name);
                onUpdate && onUpdate();
              });
            }
          } catch (err) {
            console.error('[DICE]ACU 上传头像失败:', err);
            if (window.toastr) window.toastr.error('上传失败');
          }

          $(this).val('');
        });

        // "主角"自动合并开关
        $manager.on('click', '.acu-protagonist-toggle', function () {
          const $btn = $(this);
          const diceCfg = getDiceConfig();
          const newValue = diceCfg.autoMergeProtagonist === false ? true : false;
          saveDiceConfig({ autoMergeProtagonist: newValue });

          $btn.toggleClass('active', newValue);
          $btn.find('i').attr('class', `fa-solid ${newValue ? 'fa-link' : 'fa-link-slash'}`);

          if (window.toastr) window.toastr.info(newValue ? '已开启自动合并"主角"' : '已关闭自动合并"主角"');
        });

        // 保存URL → 弹出裁剪
        $manager.on('click', '.acu-avatar-save-btn', async function () {
          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name');
          const url = $item.find('.acu-avatar-url').val().trim();

          // 从标签收集别名
          const aliases = [];
          $item.find('.acu-alias-tag').each(function () {
            aliases.push($(this).data('alias'));
          });
          // 也检查输入框里有没有残留的内容
          const pendingAlias = $item.find('.acu-alias-input').val().trim();
          if (pendingAlias && !aliases.includes(pendingAlias)) {
            aliases.push(pendingAlias);
          }

          const data = AvatarManager.getAll()[name] || {};

          // 保存基础配置
          AvatarManager.set(name, url, data.offsetX ?? 50, data.offsetY ?? 50, data.scale ?? 150, aliases);

          // 如果有URL且没有本地图片，弹出裁剪
          const hasLocal = $item.attr('data-has-local') === 'true';
          if (url && !hasLocal) {
            await refreshItem(name);
            showAvatarCropModal(url, name, async result => {
              AvatarManager.set(name, url, result.offsetX, result.offsetY, result.scale, aliases);
              await refreshItem(name);
              onUpdate && onUpdate();
            });
          } else {
            await refreshItem(name);
            onUpdate && onUpdate();
          }
        });

        // 清除头像按钮（同时清除本地头像和URL）
        $manager.on('click', '.acu-avatar-clear-all-btn', async function () {
          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name') as string;

          // 清除URL输入框
          $item.find('.acu-avatar-url').val('');

          // 清除本地头像（如有）
          const hasLocal = await AvatarManager.hasLocalAvatar(name);
          if (hasLocal) {
            await LocalAvatarDB.delete(name);
          }

          // 更新数据：清除URL，保留别名和位置设置
          const data = AvatarManager.getAll()[name] || {};
          AvatarManager.set(name, '', data.offsetX ?? 50, data.offsetY ?? 50, data.scale ?? 150, data.aliases || []);

          // 刷新显示
          await refreshItem(name);
          onUpdate && onUpdate();
        });

        // 清空别名按钮
        $manager.on('click', '.acu-avatar-clear-alias-btn', function () {
          const $item = $(this).closest('.acu-avatar-item');
          $item.find('.acu-alias-tag').remove();
          $item.find('.acu-alias-input').val('');
        });

        // 清除（删除角色）
        $manager.on('click', '.acu-avatar-clear-btn', async function () {
          const $item = $(this).closest('.acu-avatar-item');
          const name = $item.data('name') as string;

          // {{user}} 不应被删除（按钮应该已隐藏，但做双重保护）
          if (name === '{{user}}') {
            if (window.toastr) window.toastr.warning('无法删除主角');
            return;
          }

          // 收集删除信息
          const avatarData = AvatarManager.getAll()[name];
          const aliases = avatarData?.aliases || [];
          const tableRow = findCharacterInTable(name);
          const relationships = findRelationshipReferences(name, aliases);

          // 获取头像 URL 用于预览
          let avatarUrl = '';
          const hasLocal = await AvatarManager.hasLocalAvatar(name);
          if (hasLocal) {
            avatarUrl = (await LocalAvatarDB.get(name)) || '';
          } else if (avatarData?.url) {
            avatarUrl = avatarData.url;
          }

          // 显示确认弹窗
          showDeleteConfirmModal({ name, avatarUrl, tableRow, relationships }, () => executeCharacterDelete(name));
        });

        // 导出
        $manager.on('click', '.acu-avatar-export-btn', function () {
          const exportData = AvatarManager.exportData();
          const jsonStr = JSON.stringify(exportData, null, 2);
          const blob = new Blob([jsonStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `avatar-config-${new Date().toISOString().slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

        // 导入
        $manager.on('click', '.acu-avatar-import-btn', function () {
          $manager.find('#acu-avatar-file-input').click();
        });

        $manager.on('change', '#acu-avatar-file-input', function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (evt) {
            try {
              const jsonData = JSON.parse(evt.target.result);
              const analysis = AvatarManager.analyzeImport(jsonData);

              if (!analysis.valid) {
                if (window.toastr) window.toastr.error(analysis.error);
                return;
              }

              showImportConfirmDialog(jsonData, analysis, () => {
                $manager.remove();
                showAvatarManager(nodeArr, onUpdate);
                onUpdate && onUpdate();
              });
            } catch (err) {
              console.error('[DICE]ACU 导入解析失败:', err);
              if (window.toastr) window.toastr.error('文件解析失败');
            }
          };
          reader.readAsText(file);
          $(this).val('');
        });
      };

      // 关闭
      const closeManager = () => $manager.remove();
      $manager.on('click', '.acu-avatar-close', closeManager);
      setupOverlayClose($manager, 'acu-avatar-manager-overlay', closeManager);
    } catch (error) {
      console.error('头像管理器错误:', error);
      if (window.toastr) {
        const errorMsg = error instanceof Error ? error.message : '未知错误';
        window.toastr.error(`头像管理器加载失败: ${errorMsg}`);
      }
      // 清理可能残留的DOM
      $('.acu-avatar-manager-overlay').remove();
    }
  };

  // 清理骰子系统脚本缓存
  const clearDiceSystemCache = async (): Promise<void> => {
    if (!('caches' in window)) {
      console.log('[DICE] Cache API 不可用，直接刷新');
      return;
    }

    try {
      const cacheNames = await caches.keys();
      const urlPatterns = ['jsdelivr.net/gh/jerryzmtz/my-tavern-scripts', '/dist/骰子系统/'];

      for (const cacheName of cacheNames) {
        const cache = await caches.open(cacheName);
        const requests = await cache.keys();

        for (const request of requests) {
          const url = request.url;
          // 匹配 jsDelivr 上的骰子系统脚本
          if (urlPatterns.some(pattern => url.includes(pattern))) {
            await cache.delete(request);
            console.log('[DICE] 已清理缓存:', url);
          }
        }
      }
      console.log('[DICE] 脚本缓存清理完成');
    } catch (err) {
      console.warn('[DICE] 缓存清理失败:', err);
    }
  };

  const clearDiceLocalCacheData = async (): Promise<number> => {
    let removedLocalStorageKeys = 0;

    for (let i = localStorage.length - 1; i >= 0; i--) {
      const key = localStorage.key(i);
      if (!key) continue;
      if (key.startsWith('acu_')) {
        localStorage.removeItem(key);
        removedLocalStorageKeys++;
      }
    }

    await Promise.allSettled([LocalAvatarDB.clearAll(), FavoritesDB.clear(), DiceHistoryStatsDB.clear()]);
    await clearDiceSystemCache();

    return removedLocalStorageKeys;
  };

  // 手动更新/确认弹窗（支持复用）
  const showManualUpdateDialog = (options?: {
    title?: string;
    iconClass?: string;
    description?: string;
    safeTitle?: string;
    safeDescription?: string;
    confirmText?: string;
    loadingText?: string;
    onConfirm?: () => Promise<void>;
    isDanger?: boolean;
    safeIconClass?: string;
  }) => {
    const { $ } = getCore();
    $('.acu-manual-update-overlay').remove();

    const config = getConfig();
    const title = options?.title || '手动更新';
    const iconClass = options?.iconClass || 'fa-rotate';
    const description = options?.description || '将清理脚本缓存并刷新页面，以获取最新版本。';
    const safeTitle = options?.safeTitle || '数据安全';
    const safeDescription =
      options?.safeDescription || '您的自定义规则、预设、正则转换、黑名单等数据存储在本地游览器中，不会受到影响。';
    const confirmText = options?.confirmText || '立即更新';
    const loadingText = options?.loadingText || '更新中...';
    const onConfirm = options?.onConfirm;
    const isDanger = options?.isDanger || false;
    const safeIconClass = options?.safeIconClass || (isDanger ? 'fa-triangle-exclamation' : 'fa-shield-check');

    // 颜色统一跟随主题变量，避免硬编码色与主题不协调
    const headerBg = 'var(--acu-table-head)';
    const headerTextColor = 'var(--acu-text-main)';
    const confirmBtnBg = 'var(--acu-accent)';
    const safeBoxBorder = 'var(--acu-border)';
    const safeBoxIconColor = 'var(--acu-accent)';

    const dialogHtml = `
    <div class="acu-manual-update-overlay acu-theme-${config.theme}">
      <div class="acu-manual-update-dialog" style="background:var(--acu-bg-panel);border-color:var(--acu-border);max-width:420px;box-shadow:0 8px 24px rgba(0,0,0,0.3);">
        <div class="acu-manual-update-header" style="background:${headerBg};color:${headerTextColor};border-bottom:1px solid var(--acu-border);padding:12px 16px;font-weight:bold;font-size:1.1em;display:flex;align-items:center;gap:8px;">
          <i class="fa-solid ${escapeHtml(iconClass)}" style="font-size:1.1em;"></i> ${escapeHtml(title)}
        </div>
        <div class="acu-manual-update-body" style="color:var(--acu-text-main);padding:20px 16px;">
          <p style="color:var(--acu-text-main);margin-bottom:16px;line-height:1.5;">${escapeHtml(description)}</p>
          <div class="acu-manual-update-safe-box" style="background:var(--acu-btn-bg);border:1px solid ${safeBoxBorder};border-radius:6px;padding:12px;display:flex;gap:12px;align-items:flex-start;">
            <i class="fa-solid ${escapeHtml(safeIconClass)}" style="color:${safeBoxIconColor};font-size:1.2em;margin-top:2px;"></i>
            <div class="safe-text" style="display:flex;flex-direction:column;gap:4px;">
              <strong style="color:var(--acu-text-main);font-size:0.95em;">${escapeHtml(safeTitle)}</strong>
              <span style="color:var(--acu-text-sub);font-size:0.85em;line-height:1.4;">${escapeHtml(safeDescription)}</span>
            </div>
          </div>
        </div>
        <div class="acu-manual-update-footer" style="background:var(--acu-table-head);border-top:1px solid var(--acu-border);padding:12px 16px;display:flex;justify-content:flex-end;gap:10px;">
          <button class="acu-manual-update-cancel-btn" style="background:transparent;color:var(--acu-text-sub);border:1px solid var(--acu-border);padding:6px 16px;border-radius:4px;cursor:pointer;transition:all 0.2s;">取消</button>
          <button class="acu-manual-update-confirm-btn" style="background:${confirmBtnBg};color:var(--acu-btn-active-text, #fff);border:none;padding:6px 20px;border-radius:4px;cursor:pointer;font-weight:bold;box-shadow:0 2px 4px rgba(0,0,0,0.2);transition:all 0.2s;">${escapeHtml(confirmText)}</button>
        </div>
      </div>
    </div>
  `;

    const $dialog = $(dialogHtml);
    $('body').append($dialog);

    const overlayEl = $dialog[0];

    // 事件绑定
    $dialog.find('.acu-manual-update-cancel-btn').on('click', () => {
      $dialog.remove();
    });

    $dialog.find('.acu-manual-update-confirm-btn').on('click', async () => {
      const $btn = $dialog.find('.acu-manual-update-confirm-btn');
      $btn.prop('disabled', true).html(`<i class="fa-solid fa-spinner fa-spin"></i> ${escapeHtml(loadingText)}`);

      try {
        if (onConfirm) {
          await onConfirm();
          $dialog.remove();
          return;
        }

        await clearDiceSystemCache();
        // 刷新整个酒馆页面并绕过缓存（相当于 Ctrl+Shift+R）
        if (window.parent !== window) {
          window.parent.location.reload();
        } else {
          window.location.reload();
        }
      } catch (err) {
        console.error('[DICE] 手动弹窗操作失败:', err);
        if (window.toastr) window.toastr.error('操作失败，请查看控制台日志');
        $btn.prop('disabled', false).html(escapeHtml(confirmText));
      }
    });

    // 点击遮罩关闭
    $dialog.on('click', e => {
      if (e.target === overlayEl) {
        $dialog.remove();
      }
    });
  };

  // 导入确认弹窗
  const showImportConfirmDialog = (jsonData, analysis, onComplete) => {
    const { $ } = getCore();
    $('.acu-import-confirm-overlay').remove();

    const config = getConfig();

    const hasConflicts = analysis.conflicts.length > 0;
    const conflictListHtml =
      analysis.conflicts.length > 0
        ? `<div style="max-height:80px;overflow-y:auto;background:rgba(0,0,0,0.1);border-radius:4px;padding:6px 8px;margin-top:6px;font-size:11px;color:var(--acu-text-sub);">${analysis.conflicts.map(n => escapeHtml(n)).join(', ')}</div>`
        : '';

    const dialogHtml = `
            <div class="acu-import-confirm-overlay acu-theme-${config.theme}">
                <div class="acu-import-confirm-dialog">
                    <div class="acu-import-confirm-header">
                        <span class="acu-import-confirm-title"><i class="fa-solid fa-file-import"></i> 导入头像配置</span>
                        <button class="acu-import-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
                    </div>
                    <div class="acu-import-confirm-body">
                        <div class="acu-import-stats">
                            <div class="acu-import-stat">
                                <span class="acu-stat-num">${analysis.total}</span>
                                <span class="acu-stat-label">总计</span>
                            </div>
                            <div class="acu-import-stat acu-stat-new">
                                <span class="acu-stat-num">${analysis.newItems.length}</span>
                                <span class="acu-stat-label">新增</span>
                            </div>
                            <div class="acu-import-stat acu-stat-conflict">
                                <span class="acu-stat-num">${analysis.conflicts.length}</span>
                                <span class="acu-stat-label">冲突</span>
                            </div>
                        </div>

                        ${
                          hasConflicts
                            ? `
                            <div class="acu-import-conflict-section">
                                <div class="acu-import-warning">
                                    <i class="fa-solid fa-exclamation-triangle"></i> 以下角色已存在：
                                </div>
                                ${conflictListHtml}
                                <div class="acu-import-conflict-options">
                                    <label class="acu-import-radio">
                                        <input type="radio" name="conflict-mode" value="overwrite" checked />
                                        <span>用导入的覆盖本地</span>
                                    </label>
                                    <label class="acu-import-radio">
                                        <input type="radio" name="conflict-mode" value="skip" />
                                        <span>保留本地的不变</span>
                                    </label>
                                </div>
                            </div>
                        `
                            : `
                            <div class="acu-import-success">
                                <i class="fa-solid fa-check-circle"></i> 无冲突，可直接导入
                            </div>
                        `
                        }
                    </div>
                    <div class="acu-import-confirm-footer">
                        <button class="acu-import-cancel-btn">取消</button>
                        <button class="acu-import-confirm-btn">确认导入</button>
                    </div>
                </div>
            </div>
        `;

    const $dialog = $(dialogHtml);
    $('body').append($dialog);

    // 强制样式
    const overlayEl = $dialog[0];
    overlayEl.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0,0,0,0.6) !important;
            z-index: 31300 !important;
            display: flex;
            justify-content: center !important;
            align-items: center !important;
            padding: 16px;
            box-sizing: border-box !important;
        `;

    const closeDialog = () => $dialog.remove();

    $dialog.find('.acu-import-cancel-btn').click(closeDialog);
    $dialog.find('.acu-import-close-btn').click(closeDialog);
    setupOverlayClose($dialog, 'acu-import-confirm-overlay', closeDialog);

    $dialog.find('.acu-import-confirm-btn').click(function () {
      const overwrite = $dialog.find('input[name="conflict-mode"]:checked').val() !== 'skip';
      try {
        const stats = AvatarManager.importData(jsonData, overwrite);
        closeDialog();
        onComplete && onComplete();
      } catch (err) {
        console.error('[DICE]ACU 导入失败:', err);
        if (window.toastr) window.toastr.error('导入失败：' + err.message);
      }
    });
  };
  // [新增] 整体编辑模态框 (已修复自动高度与样式复用)
  const showCardEditModal = (row, headers, tableName, rowIndex, tableKey) => {
    const { $ } = getCore();
    const config = getConfig();
    let rawData = cachedRawData || getTableData() || loadSnapshot();

    let displayRow = row;
    // 确保获取的是最新数据
    if (rawData && rawData[tableKey] && rawData[tableKey]?.content?.[rowIndex + 1]) {
      displayRow = rawData[tableKey]?.content?.[rowIndex + 1];
    }

    const inputsHtml = displayRow
      .map((cell, idx) => {
        if (idx === 0) return ''; // 跳过索引列
        const headerName = headers[idx] || `列 ${idx}`;
        const val = cell || '';
        // 自动高度的 textarea
        return `
                <div class="acu-card-edit-field">
                    <label class="acu-card-edit-label">${escapeHtml(headerName)}</label>
                    <textarea class="acu-card-edit-input acu-card-edit-textarea" data-col="${idx}" spellcheck="false" rows="1">${escapeHtml(val)}</textarea>
                </div>`;
      })
      .join('');

    const dialog = $(`
            <div class="acu-edit-overlay">
                <div class="acu-edit-dialog acu-theme-${config.theme}">
                    <div class="acu-edit-title">整体编辑 (#${rowIndex + 1} - ${escapeHtml(tableName)})</div>
                    <div class="acu-settings-content acu-settings-content-scroll">
                        ${inputsHtml}
                    </div>
                     <div class="acu-dialog-btns">
                        <button class="acu-dialog-btn" id="dlg-card-cancel"><i class="fa-solid fa-times"></i> 取消</button>
                        <button class="acu-dialog-btn acu-btn-confirm" id="dlg-card-save"><i class="fa-solid fa-check"></i> 保存</button>
                    </div>
                </div>
            </div>
        `);
    $('body').append(dialog);

    // --- [修复] 自动高度调节逻辑 ---
    const adjustHeight = el => {
      // 关键修复：使用 auto 而不是 0px，防止布局塌陷并正确获取 shrinking 时的 scrollHeight
      el.style.height = 'auto';
      const contentHeight = el.scrollHeight + 2;
      const maxHeight = 500;
      el.style.height = Math.min(contentHeight, maxHeight) + 'px';
      el.style.overflowY = contentHeight > maxHeight ? 'auto' : 'hidden';
    };

    // 1. 初始化时：使用 requestAnimationFrame 确保在 DOM 渲染后执行
    requestAnimationFrame(() => {
      dialog.find('textarea').each(function () {
        adjustHeight(this);
      });
    });

    // 2. 输入时：实时调整
    dialog.find('textarea').on('input', function () {
      adjustHeight(this);
    });
    // -----------------------------

    const closeDialog = () => dialog.remove();
    dialog.find('#dlg-card-cancel').click(closeDialog);

    // 保存逻辑：使用即时保存 + 单行快照更新（保留其他行的AI变更高亮）
    dialog.find('#dlg-card-save').click(async () => {
      let rawData = cachedRawData || getTableData() || loadSnapshot();
      if (rawData && rawData[tableKey]) {
        const currentRow = rawData[tableKey]?.content?.[rowIndex + 1];
        if (!currentRow) {
          closeDialog();
          return;
        }
        let hasChanges = false;
        dialog.find('textarea').each(function () {
          const colIdx = parseInt($(this).data('col'));
          const newVal = $(this).val();
          if (String(currentRow[colIdx]) !== String(newVal)) {
            hasChanges = true;
            currentRow[colIdx] = newVal;
          }
        });
        if (hasChanges) {
          try {
            // 使用 saveRowInstantly 执行即时保存 + 单行快照更新
            await saveRowInstantly(tableKey, rowIndex, [...currentRow]);
            renderInterface();
          } catch (e) {
            console.error('[DICE]ACU 保存失败:', e);
            // 保存失败时不关闭对话框，让用户重试
            return;
          }
        }
      }
      closeDialog();
    });
    // 点击遮罩层关闭
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);
    // 点击关闭按钮（双重保险）
    dialog.on('click', function (e) {
      if ($(e.target).closest('#dlg-close-x, #dlg-close, .acu-close-btn').length) {
        closeDialog();
      }
    });
  };

  // [优化] 内存配置缓存
  let _configCache = null;
  const getConfig = () => {
    if (!_configCache) _configCache = { ...DEFAULT_CONFIG, ...Store.get(STORAGE_KEY_UI_CONFIG, {}) };
    return _configCache;
  };
  const saveConfig = newCfg => {
    _configCache = { ...getConfig(), ...newCfg };
    Store.set(STORAGE_KEY_UI_CONFIG, _configCache);
    const fontVal = applyConfigStyles(_configCache);
    injectDatabaseStyles(_configCache.theme, fontVal);
    setDatabaseToastMute(_configCache.muteDatabaseToasts === true);
  };

  const generateDiffMap = currentData => {
    const lastData = loadSnapshot();
    const diffSet = new Set();
    if (!lastData) return diffSet;

    for (const sheetId in currentData) {
      const newSheet = currentData[sheetId];
      const oldSheet = lastData[sheetId];
      if (!newSheet || !newSheet.name) continue;
      const tableName = newSheet.name;

      if (!oldSheet) {
        // 整个表是新的
        if (newSheet.content) {
          newSheet.content.forEach((row, rIdx) => {
            if (rIdx > 0) diffSet.add(`${tableName}-row-${rIdx - 1}`);
          });
        }
        continue;
      }

      const newRows = newSheet.content || [];
      const oldRows = oldSheet.content || [];

      // [优化] 构建快照的标题映射表
      // 格式: { 标题 -> [{index, row}, ...] } (数组用于处理重复标题)
      const oldRowMap = new Map();
      oldRows.forEach((row, rIdx) => {
        if (rIdx === 0) return; // 跳过表头
        const title = String(row[1] ?? '').trim();
        if (title) {
          if (!oldRowMap.has(title)) {
            oldRowMap.set(title, []);
          }
          oldRowMap.get(title).push({ index: rIdx, row: row });
        }
      });

      // 记录哪些旧行索引被匹配了（用于空标题时的索引回退）
      const matchedOldIndices = new Set();

      // 遍历当前数据
      newRows.forEach((row, rIdx) => {
        if (rIdx === 0) return; // 跳过表头
        const title = String(row[1] ?? '').trim();

        let matchedOldRow = null;

        if (title && oldRowMap.has(title)) {
          // 标题匹配模式：从队列中取出第一个
          const candidates = oldRowMap.get(title);
          if (candidates.length > 0) {
            const matched = candidates.shift(); // 消耗一个
            matchedOldRow = matched.row;
            matchedOldIndices.add(matched.index);
            if (candidates.length === 0) {
              oldRowMap.delete(title);
            }
          }
        }

        if (!matchedOldRow && !title) {
          // 空标题时回退到索引匹配
          const oldRow = oldRows[rIdx];
          if (oldRow && !matchedOldIndices.has(rIdx)) {
            matchedOldRow = oldRow;
            matchedOldIndices.add(rIdx);
          }
        }

        if (!matchedOldRow) {
          // 在快照中找不到匹配的行，标记整行为新增
          diffSet.add(`${tableName}-row-${rIdx - 1}`);
        } else {
          // 找到匹配，对比每个单元格
          row.forEach((cell, cIdx) => {
            if (cIdx === 0) return; // 跳过索引列
            const oldCell = matchedOldRow[cIdx];
            if (String(cell ?? '') !== String(oldCell ?? '')) {
              diffSet.add(`${tableName}-${rIdx - 1}-${cIdx}`);
            }
          });
        }
      });
    }
    return diffSet;
  };

  const applyConfigStyles = config => {
    const { $ } = getCore();
    const $wrapper = $('.acu-wrapper');
    const fontVal = FONTS.find(f => f.id === config.fontFamily)?.val || FONTS[0].val;

    // [优化] 只有字体 ID 变化时才重写 Style 标签，避免闪烁
    const $styleTag = $('#acu-dynamic-font');
    const currentFontId = $styleTag.data('font-id');

    if (currentFontId !== config.fontFamily) {
      $styleTag.remove();
      const fontImport = `
                @import url("https://fontsapi.zeoseven.com/3/main/result.css");
                @import url("https://fontsapi.zeoseven.com/442/main/result.css");
                @import url("https://fontsapi.zeoseven.com/256/main/result.css");
                @import url("https://fontsapi.zeoseven.com/482/main/result.css");
                @import url("https://fontsapi.zeoseven.com/446/main/result.css");
                @import url("https://fontsapi.zeoseven.com/570/main/result.css");
                @import url("https://fontsapi.zeoseven.com/292/main/result.css");
                @import url("https://fontsapi.zeoseven.com/69/main/result.css");
                @import url("https://fontsapi.zeoseven.com/7/main/result.css");
            `;
      $('head').append(`
                <style id="acu-dynamic-font" data-font-id="${config.fontFamily}">
                    ${fontImport}
                    .acu-wrapper, .acu-edit-dialog, .acu-cell-menu, .acu-nav-container, .acu-data-card, .acu-panel-title, .acu-settings-label, .acu-btn-block, .acu-nav-btn, .acu-edit-textarea,
                    .acu-dice-panel, .acu-contest-panel, .acu-dice-config-dialog,
                    .acu-relation-graph-container, .acu-avatar-manager, .acu-import-confirm-dialog,
                    .acu-embedded-options-container, .acu-option-panel, .acu-opt-btn {
                        font-family: ${fontVal} !important;
                    }
                </style>
            `);
    }

    // [优化] 尺寸和颜色变化只更新 CSS 变量，完全不闪烁
    const cssVars = {
      '--acu-card-width': `${config.cardWidth}px`,
      '--acu-font-size': `${config.fontSize}px`,
      '--acu-opt-font-size': `${config.optionFontSize || 12}px`,
      '--acu-grid-cols': config.gridColumns,
    };

    if ($wrapper.length) {
      $wrapper.removeClass((idx, cls) => (cls.match(/(^|\s)acu-theme-\S+/g) || []).join(' '));
      $wrapper.addClass(`acu-theme-${config.theme}`);
      $wrapper.css(cssVars);
    }

    const $optContainer = $('.acu-embedded-options-container');
    if ($optContainer.length) {
      $optContainer.removeClass((idx, cls) => (cls.match(/(^|\s)acu-theme-\S+/g) || []).join(' '));
      $optContainer.addClass(`acu-theme-${config.theme}`);
      $optContainer.css(cssVars);
    }

    return fontVal;
  };

  /**
   * 注入骰子系统样式到页面
   *
   * CSS 样式定义已拆分到 ./styles.ts 文件中。
   * 如需修改样式，请编辑 styles.ts 中的 MAIN_STYLES 常量。
   *
   * @see ./styles.ts - MAIN_STYLES 常量
   */
  const addStyles = () => {
    if (window._acuStylesInjected && $(`#${SCRIPT_ID}-styles`).length) return;
    window._acuStylesInjected = true;
    const { $ } = getCore();

    // 动态加载 Tabler Icons 字体（用于 ti:xxx 图标）
    if (!$('#tabler-icons-css').length) {
      $('head').append(
        '<link id="tabler-icons-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/tabler-icons.min.css">',
      );
    }

    $('style').each(function () {
      if (this.id && this.id.startsWith('acu_') && this.id.endsWith('-styles') && this.id !== `${SCRIPT_ID}-styles`)
        $(this).remove();
    });
    $(`#${SCRIPT_ID}-styles`).remove();
    const styles = `<style id="${SCRIPT_ID}-styles">${MAIN_STYLES}</style>`;
    $('head').append(styles);
  };

  const getTableData = () => {
    const api = getCore().getDB();
    if (!api || !api.exportTableAsJson) {
      console.warn('[DICE]数据库 API 不可用，无法获取表格数据');
      return null;
    }
    try {
      const data = api.exportTableAsJson();
      if (data) {
        const sheetCount = Object.keys(data).filter(k => k.startsWith('sheet_')).length;
        console.info(`[DICE]已加载表格数据，包含 ${sheetCount} 个工作表`);
      }
      return data;
    } catch (e) {
      console.error('[DICE]获取表格数据失败:', e);
      return null;
    }
  };

  type DbChatMessage = {
    is_user?: boolean;
    TavernDB_ACU_IsolatedData?: unknown;
    TavernDB_ACU_Identity?: unknown;
    TavernDB_ACU_IndependentData?: unknown;
    TavernDB_ACU_ModifiedKeys?: unknown;
    TavernDB_ACU_UpdateGroupKeys?: unknown;
    TavernDB_ACU_Data?: unknown;
    TavernDB_ACU_SummaryData?: unknown;
  };

  const getDbChatMessages = (): DbChatMessage[] | null => {
    const st = window.SillyTavern || window.parent?.SillyTavern;
    const rawChat = st?.chat;
    return Array.isArray(rawChat) ? (rawChat as DbChatMessage[]) : null;
  };

  const parseIsolatedData = (value: unknown): Record<string, unknown> | null => {
    if (!value) return null;
    if (typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        if (parsed && typeof parsed === 'object') return parsed as Record<string, unknown>;
      } catch {
        return null;
      }
      return null;
    }
    if (typeof value === 'object') return value as Record<string, unknown>;
    return null;
  };

  const hasSheetKeys = (value: unknown): boolean => {
    if (!value || typeof value !== 'object') return false;
    return Object.keys(value as Record<string, unknown>).some(key => key.startsWith('sheet_'));
  };

  const hasDbPayload = (msg: DbChatMessage): boolean => {
    if (hasSheetKeys(msg.TavernDB_ACU_IndependentData)) return true;
    if (hasSheetKeys(msg.TavernDB_ACU_Data)) return true;
    if (hasSheetKeys(msg.TavernDB_ACU_SummaryData)) return true;
    const isolated = parseIsolatedData(msg.TavernDB_ACU_IsolatedData);
    if (!isolated) return false;
    return Object.values(isolated).some(tagData => {
      if (!tagData || typeof tagData !== 'object') return false;
      const data = (tagData as Record<string, unknown>).independentData;
      return hasSheetKeys(data);
    });
  };

  const findLatestDbMessageIndex = (includeUser = false): number => {
    const chat = getDbChatMessages();
    if (!chat) return -1;
    for (let i = chat.length - 1; i >= 0; i--) {
      const msg = chat[i];
      if (!includeUser && msg?.is_user) continue;
      if (hasDbPayload(msg)) return i;
    }
    return -1;
  };

  const resolveIsolationKey = (msg: DbChatMessage, isolated: Record<string, unknown> | null): string | null => {
    if (typeof msg?.TavernDB_ACU_Identity === 'string') {
      const identity = msg.TavernDB_ACU_Identity;
      if (isolated && Object.prototype.hasOwnProperty.call(isolated, identity)) return identity;
    }
    if (isolated && Object.prototype.hasOwnProperty.call(isolated, '')) return '';
    if (isolated) {
      const keys = Object.keys(isolated);
      if (keys.length === 1) return keys[0];
    }
    return null;
  };

  const relocateDbPayloadToAnchor = async (anchorIndex: number): Promise<void> => {
    if (anchorIndex < 0) return;
    const chat = getDbChatMessages();
    if (!chat || anchorIndex >= chat.length) return;
    const latestIndex = findLatestDbMessageIndex(true);
    if (latestIndex < 0 || latestIndex === anchorIndex) return;

    const source = chat[latestIndex];
    const target = chat[anchorIndex];
    if (!source || !target) return;
    if (target.is_user && !hasDbPayload(target)) return;

    let moved = false;

    const sourceIsolated = parseIsolatedData(source.TavernDB_ACU_IsolatedData);
    if (sourceIsolated) {
      const targetIsolated = parseIsolatedData(target.TavernDB_ACU_IsolatedData) || {};
      const isolationKey = resolveIsolationKey(source, sourceIsolated);
      if (isolationKey !== null) {
        if (Object.prototype.hasOwnProperty.call(sourceIsolated, isolationKey)) {
          targetIsolated[isolationKey] = sourceIsolated[isolationKey];
          const nextSource = { ...sourceIsolated };
          delete nextSource[isolationKey];
          if (Object.keys(nextSource).length > 0) {
            source.TavernDB_ACU_IsolatedData = nextSource;
          } else {
            delete source.TavernDB_ACU_IsolatedData;
          }
          target.TavernDB_ACU_IsolatedData = targetIsolated;
          moved = true;
        }
      } else {
        target.TavernDB_ACU_IsolatedData = sourceIsolated;
        delete source.TavernDB_ACU_IsolatedData;
        moved = true;
      }
    }

    if (source.TavernDB_ACU_Identity !== undefined) {
      target.TavernDB_ACU_Identity = source.TavernDB_ACU_Identity;
      delete source.TavernDB_ACU_Identity;
      moved = true;
    }
    if (source.TavernDB_ACU_IndependentData !== undefined) {
      target.TavernDB_ACU_IndependentData = source.TavernDB_ACU_IndependentData;
      delete source.TavernDB_ACU_IndependentData;
      moved = true;
    }
    if (source.TavernDB_ACU_ModifiedKeys !== undefined) {
      target.TavernDB_ACU_ModifiedKeys = source.TavernDB_ACU_ModifiedKeys;
      delete source.TavernDB_ACU_ModifiedKeys;
      moved = true;
    }
    if (source.TavernDB_ACU_UpdateGroupKeys !== undefined) {
      target.TavernDB_ACU_UpdateGroupKeys = source.TavernDB_ACU_UpdateGroupKeys;
      delete source.TavernDB_ACU_UpdateGroupKeys;
      moved = true;
    }
    if (source.TavernDB_ACU_Data !== undefined) {
      target.TavernDB_ACU_Data = source.TavernDB_ACU_Data;
      delete source.TavernDB_ACU_Data;
      moved = true;
    }
    if (source.TavernDB_ACU_SummaryData !== undefined) {
      target.TavernDB_ACU_SummaryData = source.TavernDB_ACU_SummaryData;
      delete source.TavernDB_ACU_SummaryData;
      moved = true;
    }

    if (moved) {
      await triggerSlash('savechat');
    }
  };

  const saveDataToDatabase = async (tableData, skipRender = false, commitDeletes = false) => {
    if (isSaving) {
      console.warn('[DICE]保存操作正在进行中，跳过重复请求');
      return; // 简单的防重入
    }
    console.info('[DICE]开始保存数据到数据库...');
    isSaving = true;
    const { $ } = getCore();
    const $saveBtn = $('#acu-btn-save-global');

    // UI 反馈
    if (!skipRender && $saveBtn.length) {
      $saveBtn.find('i').removeClass('fa-save').addClass('fa-spinner fa-spin');
      $saveBtn.prop('disabled', true);
    }

    try {
      // 1. 简单浅拷贝，只取 sheet_ 开头的数据 (白名单机制 = 不卡顿)
      const dataToSave = {};
      // 补全 mate 防止校验报错
      if (!tableData.mate) dataToSave.mate = { type: 'chatSheets', version: 1 };
      else dataToSave.mate = tableData.mate;

      Object.keys(tableData).forEach(k => {
        if (k.startsWith('sheet_')) {
          dataToSave[k] = tableData[k];
        }
      });

      // 2. 处理删除 (如果有)
      if (commitDeletes) {
        const deletions = getPendingDeletions();
        Object.keys(deletions).forEach(key => {
          if (dataToSave[key] && dataToSave[key].content) {
            deletions[key]
              .sort((a, b) => b - a)
              .forEach(idx => {
                if (dataToSave[key].content[idx + 1]) dataToSave[key].content.splice(idx + 1, 1);
              });
          }
        });
      }

      // 3. 验证数据并序列化
      let jsonString;
      try {
        jsonString = JSON.stringify(dataToSave);
        // 检查数据大小（约 10MB 限制）
        const sizeInMB = new Blob([jsonString]).size / (1024 * 1024);
        if (sizeInMB > 10) {
          throw new Error(`数据太大 (${sizeInMB.toFixed(2)}MB)，超过 10MB 限制`);
        }
        console.info(`[DICE]数据序列化完成，大小: ${sizeInMB.toFixed(2)}MB`);
      } catch (stringifyError) {
        console.error('[DICE]ACU JSON 序列化失败:', stringifyError);
        throw new Error(`数据序列化失败: ${stringifyError.message || stringifyError}`);
      }

      // 4. 直接调用 API 保存 (无中间商赚差价)
      const api = getCore().getDB();
      if (!api || !api.importTableAsJson) {
        throw new Error('数据库 API 不可用');
      }
      const anchorIndex = findLatestDbMessageIndex();

      try {
        // 调用 importTableAsJson，它内部会调用 saveChat()
        // 如果 saveChat() 失败，可能会抛出错误或显示 "Settings could not be saved" 提示
        const result = await api.importTableAsJson(jsonString);
        // 检查返回值，某些实现可能返回 false 表示失败
        if (result === false) {
          throw new Error('数据导入失败（返回 false）');
        }
        await relocateDbPayloadToAnchor(anchorIndex);
        console.info('[DICE]数据已成功保存到数据库');
      } catch (apiError) {
        console.error('[DICE]ACU API 保存失败:', apiError);
        // 检查是否是 "Settings could not be saved" 相关的错误
        const errorMsg = apiError.message || String(apiError);
        if (
          errorMsg.includes('Settings could not be saved') ||
          errorMsg.includes('server connection') ||
          errorMsg.includes('data loss')
        ) {
          throw new Error('保存失败：服务器连接问题或数据过大，请检查网络连接或减少数据量');
        }
        throw new Error(`保存到数据库失败: ${errorMsg}`);
      }

      // 5. 更新本地状态
      cachedRawData = dataToSave;
      saveSnapshot(dataToSave);
      hasUnsavedChanges = false;
      currentDiffMap = new Set();
      if (window.acuModifiedSet) window.acuModifiedSet.clear();
      console.info('[DICE]本地状态已更新，未保存更改已清除');

      if (!skipRender) {
        renderInterface();
      }
    } catch (e) {
      const errorMessage = e.message || '保存出错，请检查数据格式和大小';
      console.error('[DICE]保存数据失败:', {
        error: e,
        message: errorMessage,
        stack: e.stack,
      });
      if (window.toastr) {
        window.toastr.error(errorMessage, '保存失败', { timeOut: 5000 });
      } else {
        alert(`保存失败: ${errorMessage}`);
      }
      // 重新抛出错误以便上层处理
      throw e;
    } finally {
      isSaving = false;
      console.info('[DICE]保存操作完成');
      if (!skipRender && $saveBtn.length) {
        $saveBtn.find('i').removeClass('fa-spinner fa-spin').addClass('fa-save');
        $saveBtn.prop('disabled', false);
      }
    }
  };

  const performSaveDataOnly = async (tableData, modifiedSheetKeys?: string[]) => {
    try {
      const dataToSave = {};
      if (!tableData.mate) dataToSave.mate = { type: 'chatSheets', version: 1 };
      else dataToSave.mate = tableData.mate;

      Object.keys(tableData).forEach(k => {
        if (k.startsWith('sheet_')) {
          dataToSave[k] = tableData[k];
        }
      });

      // 验证数据并序列化
      let jsonString;
      try {
        jsonString = JSON.stringify(dataToSave);
        // 检查数据大小（约 10MB 限制）
        const sizeInMB = new Blob([jsonString]).size / (1024 * 1024);
        if (sizeInMB > 10) {
          throw new Error(`数据太大 (${sizeInMB.toFixed(2)}MB)，超过 10MB 限制`);
        }
      } catch (stringifyError) {
        console.error('[DICE]ACU JSON 序列化失败:', stringifyError);
        throw new Error(`数据序列化失败: ${stringifyError.message || stringifyError}`);
      }

      const api = getCore().getDB();
      if (!api || !api.importTableAsJson) {
        throw new Error('数据库 API 不可用');
      }
      const anchorIndex = findLatestDbMessageIndex();

      try {
        // 调用 importTableAsJson，它内部会调用 saveChat()
        const result = await api.importTableAsJson(jsonString);
        // 检查返回值，某些实现可能返回 false 表示失败
        if (result === false) {
          throw new Error('数据导入失败（返回 false）');
        }
        await relocateDbPayloadToAnchor(anchorIndex);
      } catch (apiError) {
        console.error('[DICE]ACU API 保存失败:', apiError);
        // 检查是否是 "Settings could not be saved" 相关的错误
        const errorMsg = apiError.message || String(apiError);
        if (
          errorMsg.includes('Settings could not be saved') ||
          errorMsg.includes('server connection') ||
          errorMsg.includes('data loss')
        ) {
          throw new Error('保存失败：服务器连接问题或数据过大，请检查网络连接或减少数据量');
        }
        throw new Error(`保存到数据库失败: ${errorMsg}`);
      }

      cachedRawData = dataToSave;
      // 注意：不调用 saveSnapshot()，不更新 hasUnsavedChanges
      return dataToSave;
    } catch (e) {
      console.error('[DICE]ACU saveDataOnly error:', e, modifiedSheetKeys ? { modifiedSheetKeys } : undefined);
      throw e;
    }
  };

  const runInSaveQueue = async <T>(task: () => Promise<T>): Promise<T> => {
    const operation = saveQueue
      .catch(error => {
        console.warn('[DICE]ACU runInSaveQueue previous step failed, continue next task:', error);
      })
      .then(task);

    saveQueue = operation
      .then(() => undefined)
      .catch(e => {
        console.error('[DICE]ACU runInSaveQueue error:', e);
      });
    return operation;
  };

  // [新增] 轻量级保存：只保存数据到数据库，不更新快照
  // 使用队列模式确保快速连续编辑时所有修改都能保存成功
  const saveDataOnly = async (tableData, modifiedSheetKeys?: string[]) =>
    runInSaveQueue(() => performSaveDataOnly(tableData, modifiedSheetKeys));

  // [新增] 即时保存单行数据并只更新该行快照
  // 用途：弹窗编辑后立即保存，同时保留其他行的AI变更高亮
  // 注意：不调用 saveDataToDatabase（它会更新完整快照），只更新指定行的快照
  const saveRowInstantly = async (tableKey: string, rowIndex: number, newRowData: unknown[]): Promise<void> => {
    try {
      // 1. 获取当前数据
      const rawData = cachedRawData || getTableData();
      if (!rawData || !rawData[tableKey]) {
        throw new Error(`表格 "${tableKey}" 不存在`);
      }
      if (!rawData[tableKey].content) {
        throw new Error(`表格 "${tableKey}" 内容为空`);
      }

      // 2. 更新该行数据（rowIndex 是从0开始的行索引，content[0] 是表头）
      rawData[tableKey].content[rowIndex + 1] = newRowData;

      // 3. 保存到数据库（不更新完整快照）
      await saveDataOnly(rawData, [tableKey]);

      // 4. 只更新快照中这一行（关键：保留其他行的变更高亮）
      const snapshot = loadSnapshot();
      if (snapshot && snapshot[tableKey] && snapshot[tableKey].content) {
        snapshot[tableKey].content[rowIndex + 1] = [...newRowData];
        saveSnapshot(snapshot);
      }
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      console.error('[DICE]ACU saveRowInstantly error:', e);
      toastr.error(`保存失败: ${errorMsg}`);
      throw e;
    }
  };

  const processJsonData = json => {
    const tables = {};
    if (!json || typeof json !== 'object') return tables;
    for (const sheetId in json) {
      if (json[sheetId]?.name) {
        const sheet = json[sheetId];
        tables[sheet.name] = {
          key: sheetId,
          headers: sheet.content ? sheet.content[0] || [] : [],
          rows: sheet.content ? sheet.content.slice(1) : [],
          rawContent: sheet.content || [],
          exportConfig: sheet.exportConfig || {},
          updateConfig: sheet.updateConfig || {},
          ...sheet,
        };
      }
    }
    return tables;
  };

  // ========================================
  // 智能修改辅助函数
  // ========================================

  // 格式验证智能推算
  function suggestFormatValue(pattern, rowIndex, existingValues = [], tableContent = null) {
    if (!pattern || rowIndex === undefined || rowIndex < 0) return null;

    try {
      // 识别 "前缀+数字" 模式，如 ^AM\d{3}$
      // pattern 在 JavaScript 字符串中是 '^AM\\d{3}$'，实际内容是 '^AM\d{3}$'
      // 在正则匹配时，要匹配字面量 \d{3}，需要用 /\\d\{3\}/（转义后的反斜杠+d，转义后的花括号）
      // 匹配格式：^?[字母]+\d\{数字\}$?
      const prefixMatch = pattern.match(/^\^?([A-Za-z]+)\\d\{(\d+)\}\$?$/);

      if (prefixMatch) {
        const prefix = prefixMatch[1]; // "AM"
        const digits = parseInt(prefixMatch[2], 10); // 3

        // 【改进】对于总结表和总体大纲，基于现有值计算下一个编码
        if (tableContent && (tableContent.name === '总结表' || tableContent.name === '总体大纲')) {
          const headers = tableContent.content?.[0] || [];
          const rows = tableContent.content?.slice(1) || [];
          const codeIndex = headers.indexOf('编码索引');

          if (codeIndex >= 0) {
            // 提取所有现有编码索引的数字部分
            const existingNumbers = [];
            rows.forEach(row => {
              const codeValue = row?.[codeIndex];
              if (codeValue && typeof codeValue === 'string') {
                const match = codeValue.match(new RegExp(`^${prefix}(\\d+)$`));
                if (match) {
                  const num = parseInt(match[1], 10);
                  if (!isNaN(num)) existingNumbers.push(num);
                }
              }
            });

            // 计算下一个数字
            const maxNum = existingNumbers.length > 0 ? Math.max(...existingNumbers) : 0;
            const nextNum = String(maxNum + 1).padStart(digits, '0');
            return prefix + nextNum;
          }
        }

        // 原有逻辑：基于行索引（作为后备方案）
        const nextNum = String(rowIndex + 1).padStart(digits, '0');
        return prefix + nextNum;
      }

      // 尝试识别其他常见模式，如 \d{3} 单独出现（仅数字）
      const numOnlyMatch = pattern.match(/^\^?\\d\{(\d+)\}\$?$/);
      if (numOnlyMatch) {
        const digits = parseInt(numOnlyMatch[1], 10);
        return String(rowIndex + 1).padStart(digits, '0');
      }
    } catch (e) {
      console.error('[DICE]ACU 格式推算失败:', e);
    }

    return null; // 无法推算，显示空输入框
  }

  // 关联验证下拉选项提取（支持多列 OR 合并）
  function getRelationOptions(refTable, refColumns, rawData) {
    const options = new Set();
    if (!refTable || !refColumns || !rawData) return Array.from(options);

    const columns = Array.isArray(refColumns) ? refColumns : [refColumns];

    // 查找引用表
    for (const sheetId in rawData) {
      if (rawData[sheetId]?.name === refTable) {
        const headers = rawData[sheetId].content?.[0] || [];
        const rows = rawData[sheetId].content?.slice(1) || [];

        // 遍历所有指定的列
        columns.forEach(col => {
          const colIdx = headers.indexOf(col);
          if (colIdx >= 0) {
            rows.forEach(row => {
              const value = row?.[colIdx];
              if (value !== null && value !== undefined && String(value).trim() !== '') {
                options.add(String(value).trim());
              }
            });
          }
        });

        break; // 找到表后跳出
      }
    }

    return Array.from(options).sort();
  }

  // 检查值是否已存在于关联表的任何列中（用于判断是否需要反向写入）
  function isValueInRelationTable(value, refTable, refColumns, rawData) {
    if (!value || !refTable || !refColumns || !rawData) return false;
    if (String(value).trim() === '') return false;

    const columns = Array.isArray(refColumns) ? refColumns : [refColumns];
    const strVal = String(value).trim();

    // 查找引用表
    for (const sheetId in rawData) {
      if (rawData[sheetId]?.name === refTable) {
        const headers = rawData[sheetId].content?.[0] || [];
        const rows = rawData[sheetId].content?.slice(1) || [];

        // 遍历所有指定的列
        for (const col of columns) {
          const colIdx = headers.indexOf(col);
          if (colIdx === -1) continue;

          // 检查值是否存在于该列
          for (let i = 0; i < rows.length; i++) {
            const cellValue = rows[i]?.[colIdx];
            if (cellValue !== null && cellValue !== undefined && String(cellValue).trim() === strVal) {
              return true; // 找到匹配值
            }
          }
        }

        break; // 找到表后跳出
      }
    }

    return false; // 值不存在于任何列中
  }

  // 获取同列其他行的示例值（用于 required 规则）
  function getColumnExamples(tableName, columnName, currentRowIndex, rawData, maxCount = 5) {
    const examples = new Set();
    if (!tableName || !columnName || !rawData) return [];

    for (const sheetId in rawData) {
      if (rawData[sheetId]?.name === tableName) {
        const headers = rawData[sheetId].content?.[0] || [];
        const rows = rawData[sheetId].content?.slice(1) || [];
        const colIdx = headers.indexOf(columnName);

        if (colIdx >= 0) {
          rows.forEach((row, idx) => {
            if (idx !== currentRowIndex) {
              const value = row?.[colIdx];
              if (value !== null && value !== undefined && String(value).trim() !== '') {
                examples.add(String(value).trim());
              }
            }
          });
        }
        break;
      }
    }

    return Array.from(examples).slice(0, maxCount);
  }

  // 获取数值的最近有效值
  function getNearestValidNumber(currentValue, min, max) {
    const num = parseFloat(currentValue);
    if (isNaN(num)) return min !== undefined ? min : 0;
    if (min !== undefined && num < min) return min;
    if (max !== undefined && num > max) return max;
    return num;
  }

  // ========================================
  // [新增] 正则规则列表局部刷新函数 - 避免全量重渲染
  // ========================================
  const refreshRegexRulesList = () => {
    const { $ } = getCore();
    const dialog = $('.acu-settings-dialog');
    if (!dialog.length) return;

    const $rulesList = dialog.find('#regex-rules-list');
    if (!$rulesList.length) return;

    // 生成新的规则列表HTML
    const rules = RegexTransformationManager.getAllRules();
    const html = rules
      .map(rule => {
        const scopeIcon =
          rule.scope.type === 'global' ? 'fa-globe' : rule.scope.type === 'table' ? 'fa-table' : 'fa-columns';
        const scopeText =
          rule.scope.type === 'global'
            ? '全局'
            : rule.scope.type === 'table'
              ? rule.scope.tableNames?.join(',')
              : `${rule.scope.tableNames?.join(',')}.${rule.scope.columnNames?.join(',')}`;
        return `
          <div class="acu-validation-rule-item ${rule.enabled ? '' : 'disabled'}" data-rule-id="${escapeHtml(rule.id)}">
              <div class="acu-rule-type-icon" title="作用域: ${escapeHtml(rule.scope.type)}">
                  <i class="fa-solid ${scopeIcon}"></i>
              </div>
              <div class="acu-rule-info">
                  <div class="acu-rule-name">${escapeHtml(rule.name)}</div>
                  <div class="acu-rule-target" style="font-size:10px;">${escapeHtml(scopeText)} | ${escapeHtml(rule.operation)}</div>
              </div>
              <button class="acu-rule-edit" data-rule-id="${escapeHtml(rule.id)}" title="编辑此规则" style="background:none;border:none;color:var(--text-sub);cursor:pointer;padding:4px;opacity:0.6;transition:all 0.2s;flex-shrink:0;"><i class="fa-solid fa-pen"></i></button>
              <div class="acu-rule-toggle ${rule.enabled ? 'active' : ''}" title="点击切换启用/禁用">
                  <i class="fa-solid ${rule.enabled ? 'fa-toggle-on' : 'fa-toggle-off'}"></i>
              </div>
              <button class="acu-rule-delete" data-rule-id="${escapeHtml(rule.id)}" title="删除此规则"><i class="fa-solid fa-trash"></i></button>
          </div>
      `;
      })
      .join('');

    // 局部替换HTML,不影响其他面板
    $rulesList.html(html);
  };

  // ========================================
  // 添加/编辑自定义验证规则弹窗
  // ========================================
  const showAddValidationRuleModal = (parentDialog: JQuery, editRuleId?: string) => {
    const { $ } = getCore();
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;

    // 获取所有表名
    const rawData = cachedRawData || getTableData();
    const tables = processJsonData(rawData || {});
    const tableNames = Object.keys(tables);

    // 编辑模式：获取现有规则数据
    const isEditMode = !!editRuleId;
    const existingRule = isEditMode ? ValidationRuleManager.getRule(editRuleId) : null;

    const dialog = $(`
      <div class="acu-edit-overlay acu-validation-modal-overlay" ${isEditMode ? 'style="opacity:0;transition:opacity 0.15s ease-in;"' : ''}>
        <div class="acu-edit-dialog acu-validation-modal ${currentThemeClass}">
          <div class="acu-dice-cfg-header">
            <span><i class="fa-solid ${isEditMode ? 'fa-pen' : 'fa-plus'}"></i> ${isEditMode ? '编辑验证规则' : '添加自定义验证规则'}</span>
            <button class="acu-config-close" id="dlg-rule-close"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="acu-validation-modal-body">
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">规则名称</span></div>
              <input type="text" id="rule-name" class="acu-panel-input" placeholder="如：物品数量限制" style="flex:1;">
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">目标表格</span></div>
              <select id="rule-table" class="acu-setting-select">
                <option value="">请选择...</option>
                ${tableNames.map(name => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`).join('')}
              </select>
            </div>
            <div class="acu-setting-row" id="row-column">
              <div class="acu-setting-info"><span class="acu-setting-label">目标列</span></div>
              <select id="rule-column" class="acu-setting-select" disabled>
                <option value="">请先选择表格...</option>
              </select>
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">规则类型</span></div>
              <select id="rule-type" class="acu-setting-select">
                <optgroup label="── 表级规则 ──">
                  <option value="tableReadonly">表级只读（禁止修改）</option>
                  <option value="rowLimit">行数限制</option>
                  <option value="sequence">序列递增</option>
                </optgroup>
                <optgroup label="── 字段级规则 ──">
                  <option value="required">必填</option>
                  <option value="format">格式验证（正则）</option>
                  <option value="enum">枚举验证（可选值）</option>
                  <option value="numeric">数值范围</option>
                  <option value="relation">关联验证（引用其他表）</option>
                  <option value="keyValue">键值对验证</option>
                </optgroup>
              </select>
            </div>
            <!-- 表级只读无需配置 -->
            <div class="acu-rule-config-section" id="config-tableReadonly">
              <div style="font-size:12px;color:var(--acu-warning-text);padding:10px 12px;background:var(--acu-warning-bg);border-left:3px solid var(--acu-warning-icon);border-radius:6px;line-height:1.5;">
                <i class="fa-solid fa-info-circle" style="color:var(--acu-warning-icon);margin-right:6px;"></i> 启用后,该表将不允许任何修改
              </div>
            </div>
            <!-- 行数限制配置 -->
            <div class="acu-rule-config-section" id="config-rowLimit" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">最少行数</span></div>
                <input type="number" id="cfg-row-min" class="acu-panel-input" placeholder="0" style="width:80px;">
                <div class="acu-setting-info" style="margin-left:16px;"><span class="acu-setting-label">最多行数</span></div>
                <input type="number" id="cfg-row-max" class="acu-panel-input" placeholder="不限" style="width:80px;">
              </div>
            </div>
            <!-- 序列递增配置 -->
            <div class="acu-rule-config-section" id="config-sequence" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">编码前缀</span></div>
                <input type="text" id="cfg-sequence-prefix" class="acu-panel-input" placeholder="如：AM" style="width:120px;">
              </div>
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">起始数字</span></div>
                <input type="number" id="cfg-sequence-start" class="acu-panel-input" placeholder="1" value="1" style="width:120px;">
              </div>
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">配对表（可选）</span></div>
                <select id="cfg-sequence-paired-table" class="acu-setting-select" style="flex:1;">
                  <option value="">无（单表修复）</option>
                  ${tableNames.map(name => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`).join('')}
                </select>
              </div>
              <div style="font-size:12px;color:var(--acu-warning-text);padding:10px 12px;background:var(--acu-warning-bg);border-left:3px solid var(--acu-warning-icon);border-radius:6px;line-height:1.5;margin-top:8px;">
                <i class="fa-solid fa-info-circle" style="color:var(--acu-warning-icon);margin-right:6px;"></i> 检查指定列的值是否从"前缀+起始数字"开始严格递增(如AM0001, AM0002, AM0003...),不可跳号或重复。需要指定目标列。<br>
                <i class="fa-solid fa-link" style="margin-top:4px;display:block;color:var(--acu-warning-icon);margin-right:6px;"></i> 如果设置了配对表,修复时会同时修复两个表的编码,确保相同编码值修复后仍然相同。
              </div>
            </div>
            <!-- 必填无需配置 -->
            <div class="acu-rule-config-section" id="config-required" style="display:none;">
              <div style="font-size:12px;color:var(--acu-warning-text);padding:10px 12px;background:var(--acu-warning-bg);border-left:3px solid var(--acu-warning-icon);border-radius:6px;line-height:1.5;">
                <i class="fa-solid fa-info-circle" style="color:var(--acu-warning-icon);margin-right:6px;"></i> 该字段不能为空
              </div>
            </div>
            <!-- 格式验证配置 -->
            <div class="acu-rule-config-section" id="config-format" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">正则表达式</span></div>
                <input type="text" id="cfg-pattern" class="acu-panel-input" placeholder="如：^AM\\d{3}$" style="flex:1;">
              </div>
            </div>
            <!-- 枚举验证配置 -->
            <div class="acu-rule-config-section" id="config-enum" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">允许的值</span></div>
                <input type="text" id="cfg-values" class="acu-panel-input" placeholder="用逗号分隔，如：进行中,已完成,已失败" style="flex:1;">
              </div>
            </div>
            <!-- 数值范围配置 -->
            <div class="acu-rule-config-section" id="config-numeric" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">最小值</span></div>
                <input type="number" id="cfg-min" class="acu-panel-input" placeholder="0" style="width:80px;">
                <div class="acu-setting-info" style="margin-left:16px;"><span class="acu-setting-label">最大值</span></div>
                <input type="number" id="cfg-max" class="acu-panel-input" placeholder="100" style="width:80px;">
              </div>
            </div>
            <!-- 关联验证配置 -->
            <div class="acu-rule-config-section" id="config-relation" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">关联表格</span></div>
                <select id="cfg-ref-table" class="acu-setting-select">
                  <option value="">请选择...</option>
                  ${tableNames.map(name => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`).join('')}
                </select>
              </div>
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">关联列</span></div>
                <select id="cfg-ref-column" class="acu-setting-select" multiple style="flex:1;min-height:80px;">
                  <option value="">请先选择关联表格...</option>
                </select>
              </div>
              <div style="font-size:12px;color:var(--acu-warning-text);padding:10px 12px;background:var(--acu-warning-bg);border-left:3px solid var(--acu-warning-icon);border-radius:6px;line-height:1.5;margin-top:8px;">
                <i class="fa-solid fa-info-circle" style="color:var(--acu-warning-icon);margin-right:6px;"></i> 可选择多列,任一列匹配即通过验证(OR 逻辑)。使用 Ctrl/Cmd 键可选择多个列。
              </div>
            </div>
            <!-- 键值对验证配置 -->
            <div class="acu-rule-config-section" id="config-keyValue" style="display:none;">
              <div class="acu-setting-row">
                <div class="acu-setting-info"><span class="acu-setting-label">值类型</span></div>
                <select id="cfg-keyvalue-type" class="acu-setting-select">
                  <option value="text">文本型（只验证格式）</option>
                  <option value="numeric">数值型（验证格式和数值范围）</option>
                </select>
              </div>
              <div class="acu-setting-row" id="row-keyvalue-range" style="display:none;">
                <div class="acu-setting-info"><span class="acu-setting-label">最小值</span></div>
                <input type="number" id="cfg-keyvalue-min" class="acu-panel-input" placeholder="0" style="width:80px;">
                <div class="acu-setting-info" style="margin-left:16px;"><span class="acu-setting-label">最大值</span></div>
                <input type="number" id="cfg-keyvalue-max" class="acu-panel-input" placeholder="100" style="width:80px;">
              </div>
              <div style="font-size:12px;color:var(--acu-warning-text);padding:10px 12px;background:var(--acu-warning-bg);border-left:3px solid var(--acu-warning-icon);border-radius:6px;line-height:1.5;margin-top:8px;">
                <i class="fa-solid fa-info-circle" style="color:var(--acu-warning-icon);margin-right:6px;"></i> 格式:键:值;键:值(使用英文标点,自动去除空格)。数值型会验证每个值的范围。
              </div>
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">错误提示</span></div>
              <input type="text" id="rule-error-msg" class="acu-panel-input" placeholder="验证失败时显示的提示信息" style="flex:1;">
            </div>
          </div>
          <div class="acu-dice-cfg-actions">
            <button id="dlg-rule-cancel">取消</button>
            <button id="dlg-rule-save">${isEditMode ? '保存' : '添加'}</button>
          </div>
        </div>
      </div>
    `);

    $('body').append(dialog);

    // 统一设置select的颜色（当选中空值时显示为灰色）
    const updateSelectColor = $select => {
      const val = $select.val();
      if (!val || val === '') {
        $select.css('color', 'var(--acu-text-sub)');
        $select.css('opacity', '0.7');
      } else {
        $select.css('color', 'var(--acu-text-main)');
        $select.css('opacity', '1');
      }
    };

    // 初始化所有select的颜色
    dialog.find('select').each(function () {
      updateSelectColor($(this));
      $(this).on('change', function () {
        updateSelectColor($(this));
      });
    });

    // 表格选择变化时更新列选项和配对表选项
    dialog.find('#rule-table').on('change', function () {
      const tableName = $(this).val();
      const $colSelect = dialog.find('#rule-column');
      const $pairedTableSelect = dialog.find('#cfg-sequence-paired-table');
      updateSelectColor($(this));

      // 更新配对表选项（排除当前选择的表）
      if ($pairedTableSelect.length > 0) {
        const currentPairedValue = $pairedTableSelect.val();
        $pairedTableSelect.empty();
        $pairedTableSelect.append('<option value="">无（单表修复）</option>');
        tableNames
          .filter(name => name !== tableName)
          .forEach(name => {
            $pairedTableSelect.append(`<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`);
          });
        // 如果之前选择的值仍然有效，恢复它
        if (currentPairedValue && currentPairedValue !== tableName) {
          $pairedTableSelect.val(currentPairedValue);
        }
        updateSelectColor($pairedTableSelect);
      }

      if (!tableName || !tables[tableName]) {
        $colSelect.html('<option value="">请先选择表格...</option>').prop('disabled', true);
        updateSelectColor($colSelect);
        return;
      }

      const headers = tables[tableName].headers || [];
      const options = headers
        .filter((h, i) => i > 0 && h) // 跳过索引列
        .map(h => `<option value="${escapeHtml(h)}">${escapeHtml(h)}</option>`)
        .join('');

      $colSelect.html('<option value="">请选择...</option>' + options).prop('disabled', false);
      updateSelectColor($colSelect);
    });

    // 关联表格选择变化时更新关联列选项
    dialog.find('#cfg-ref-table').on('change', function () {
      const refTableName = $(this).val();
      const $refColSelect = dialog.find('#cfg-ref-column');
      updateSelectColor($(this));

      if (!refTableName || !tables[refTableName]) {
        $refColSelect.html('<option value="">请先选择关联表格...</option>').prop('disabled', true);
        updateSelectColor($refColSelect);
        return;
      }

      const headers = tables[refTableName].headers || [];
      const options = headers
        .filter((h, i) => i > 0 && h) // 跳过索引列
        .map(h => `<option value="${escapeHtml(h)}">${escapeHtml(h)}</option>`)
        .join('');

      $refColSelect.html(options).prop('disabled', false);
      updateSelectColor($refColSelect);
    });

    // 规则类型变化时切换配置区域和目标列显示
    dialog.find('#rule-type').on('change', function () {
      const type = $(this).val();
      const typeInfo = RULE_TYPE_INFO[type];
      const isTableRule = typeInfo?.scope === 'table';
      updateSelectColor($(this));

      // 切换配置区域
      dialog.find('.acu-rule-config-section').hide();
      dialog.find('#config-' + type).show();

      // 表级规则隐藏目标列选择（但sequence规则需要目标列）
      if (isTableRule && type !== 'sequence') {
        dialog.find('#row-column').hide();
        dialog.find('#rule-column').val('').prop('disabled', true);
      } else {
        dialog.find('#row-column').show();
        // 如果已选择表格，启用列选择
        if (dialog.find('#rule-table').val()) {
          dialog.find('#rule-column').prop('disabled', false);
        }
      }
    });

    // 键值对类型变化时显示/隐藏数值范围输入框
    dialog.find('#cfg-keyvalue-type').on('change', function () {
      const valueType = $(this).val();
      if (valueType === 'numeric') {
        dialog.find('#row-keyvalue-range').show();
      } else {
        dialog.find('#row-keyvalue-range').hide();
      }
    });

    // 关闭
    const closeDialog = () => dialog.remove();
    dialog.on('click', '#dlg-rule-close, #dlg-rule-cancel', function (e) {
      e.stopPropagation(); // 阻止事件冒泡到设置面板
      closeDialog();
    });
    setupOverlayClose(dialog, 'acu-validation-modal-overlay', () => {
      closeDialog();
    });

    // 保存
    dialog.find('#dlg-rule-save').on('click', function () {
      const name = dialog.find('#rule-name').val()?.trim();
      const targetTable = dialog.find('#rule-table').val();
      const targetColumn = dialog.find('#rule-column').val();
      const ruleType = dialog.find('#rule-type').val();
      const errorMessage = dialog.find('#rule-error-msg').val()?.trim();
      const typeInfo = RULE_TYPE_INFO[ruleType];
      const isTableRule = typeInfo?.scope === 'table';

      // 验证必填项
      if (!name) {
        if (window.toastr) window.toastr.warning('请输入规则名称');
        return;
      }
      if (!targetTable) {
        if (window.toastr) window.toastr.warning('请选择目标表格');
        return;
      }
      // 字段级规则和sequence规则必须选择目标列
      if ((!isTableRule || ruleType === 'sequence') && !targetColumn) {
        if (window.toastr) window.toastr.warning('请选择目标列');
        return;
      }

      // 构建配置
      const ruleConfig = {};
      if (ruleType === 'tableReadonly') {
        // 无需配置
      } else if (ruleType === 'rowLimit') {
        const min = dialog.find('#cfg-row-min').val();
        const max = dialog.find('#cfg-row-max').val();
        if (min !== '') ruleConfig.min = parseInt(min, 10);
        if (max !== '') ruleConfig.max = parseInt(max, 10);
      } else if (ruleType === 'required') {
        // 无需配置
      } else if (ruleType === 'format') {
        const pattern = dialog.find('#cfg-pattern').val()?.trim();
        if (!pattern) {
          if (window.toastr) window.toastr.warning('请输入正则表达式');
          return;
        }
        // 验证正则表达式有效性
        try {
          new RegExp(pattern);
        } catch (e) {
          if (window.toastr) window.toastr.error('正则表达式无效');
          return;
        }
        ruleConfig.pattern = pattern;
      } else if (ruleType === 'enum') {
        const valuesStr = dialog.find('#cfg-values').val()?.trim();
        if (!valuesStr) {
          if (window.toastr) window.toastr.warning('请输入允许的值');
          return;
        }
        ruleConfig.values = valuesStr
          .split(',')
          .map(v => v.trim())
          .filter(v => v);
      } else if (ruleType === 'numeric') {
        const min = dialog.find('#cfg-min').val();
        const max = dialog.find('#cfg-max').val();
        if (min !== '') ruleConfig.min = parseFloat(min);
        if (max !== '') ruleConfig.max = parseFloat(max);
      } else if (ruleType === 'relation') {
        const refTable = dialog.find('#cfg-ref-table').val();
        const refColumns = dialog.find('#cfg-ref-column').val(); // 多选时返回数组

        if (!refTable) {
          if (window.toastr) window.toastr.warning('请选择关联表格');
          return;
        }

        const selectedColumns = Array.isArray(refColumns) ? refColumns : refColumns ? [refColumns] : [];
        if (selectedColumns.length === 0 || (selectedColumns.length === 1 && !selectedColumns[0])) {
          if (window.toastr) window.toastr.warning('请至少选择一列作为关联列');
          return;
        }

        ruleConfig.refTable = refTable;
        // 如果只有一列，保存为字符串；如果多列，保存为数组
        ruleConfig.refColumn = selectedColumns.length === 1 ? selectedColumns[0] : selectedColumns;
      } else if (ruleType === 'keyValue') {
        const valueType = dialog.find('#cfg-keyvalue-type').val();
        ruleConfig.valueType = valueType || 'text';

        if (valueType === 'numeric') {
          const min = dialog.find('#cfg-keyvalue-min').val();
          const max = dialog.find('#cfg-keyvalue-max').val();
          if (min !== '') ruleConfig.valueMin = parseFloat(min);
          if (max !== '') ruleConfig.valueMax = parseFloat(max);
        }
      } else if (ruleType === 'sequence') {
        const prefix = dialog.find('#cfg-sequence-prefix').val()?.trim() || '';
        const startFrom = dialog.find('#cfg-sequence-start').val();
        const pairedTable = dialog.find('#cfg-sequence-paired-table').val()?.trim() || null;
        ruleConfig.prefix = prefix;
        ruleConfig.startFrom = startFrom !== '' ? parseInt(startFrom, 10) : 1;
        if (isNaN(ruleConfig.startFrom)) {
          if (window.toastr) window.toastr.warning('起始数字必须是有效数字');
          return;
        }
        if (pairedTable) {
          ruleConfig.pairedTable = pairedTable;
        }
      }

      // 编辑模式使用原规则ID，新建模式生成新ID
      const finalRuleId = isEditMode
        ? editRuleId
        : 'custom_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);

      // 构建规则对象
      const ruleData = {
        id: finalRuleId,
        name: name,
        description: existingRule?.description || '',
        targetTable: targetTable,
        targetColumn: isTableRule && ruleType !== 'sequence' ? '' : targetColumn, // 表级规则不需要 targetColumn，但sequence规则需要
        ruleType: ruleType,
        config: ruleConfig,
        errorMessage: errorMessage || typeInfo?.desc || '数据验证失败',
        intercept: existingRule?.intercept ?? false, // 编辑模式保留原拦截状态，新建模式默认不启用
        enabled: existingRule?.enabled ?? true, // 编辑模式保留原启用状态，新建模式默认启用
      };

      let success = false;
      if (isEditMode) {
        // 编辑模式：更新规则
        success = ValidationRuleManager.updateCustomRule(editRuleId, ruleData);
      } else {
        // 新建模式：添加规则
        success = ValidationRuleManager.addCustomRule(ruleData);
      }

      if (success) {
        closeDialog();

        // 清除缓存确保获取最新数据
        ValidationRuleManager.clearCache();

        // 刷新规则列表
        const $rulesList = parentDialog.find('#validation-rules-list');

        if (isEditMode) {
          // 编辑模式：更新现有规则项
          const $existingItem = $rulesList.find(`.acu-validation-rule-item[data-rule-id="${escapeHtml(editRuleId)}"]`);
          if ($existingItem.length) {
            const hasIntercept = ruleData.intercept;
            const isEnabled = ruleData.enabled;
            $existingItem.find('.acu-rule-name').text(name);
            $existingItem
              .find('.acu-rule-target')
              .text(`${targetTable}${isTableRule && ruleType !== 'sequence' ? ' (整表)' : '.' + targetColumn}`);
            $existingItem
              .find('.acu-rule-type-icon')
              .attr('title', `${typeInfo?.name || ruleType}${isTableRule ? ' (表级)' : ''}`)
              .find('i')
              .attr('class', `fa-solid ${typeInfo?.icon || 'fa-question'}`);
            $existingItem.toggleClass('disabled', !isEnabled);
          }
        } else {
          // 新建模式：追加新规则项
          const ruleHtml = `
          <div class="acu-validation-rule-item" data-rule-id="${escapeHtml(finalRuleId)}">
            <div class="acu-rule-type-icon" title="${escapeHtml(typeInfo?.name || ruleType)}${isTableRule ? ' (表级)' : ''}">
              <i class="fa-solid ${typeInfo?.icon || 'fa-question'}"></i>
            </div>
            <div class="acu-rule-info">
              <div class="acu-rule-name">${escapeHtml(name)}</div>
              <div class="acu-rule-target">${escapeHtml(targetTable)}${isTableRule && ruleType !== 'sequence' ? ' (整表)' : '.' + escapeHtml(targetColumn)}</div>
            </div>
            <div class="acu-rule-intercept" data-rule-id="${escapeHtml(finalRuleId)}" title="点击启用拦截（违反时回滚）"><i class="fa-solid fa-shield-halved"></i></div>
            <button class="acu-rule-edit" data-rule-id="${escapeHtml(finalRuleId)}" title="编辑此规则" style="background:none;border:none;color:var(--text-sub);cursor:pointer;padding:4px;opacity:0.6;transition:all 0.2s;flex-shrink:0;"><i class="fa-solid fa-pen"></i></button>
            <div class="acu-rule-toggle active" title="点击切换启用/禁用">
              <i class="fa-solid fa-toggle-on"></i>
            </div>
            <button class="acu-rule-delete" data-rule-id="${escapeHtml(finalRuleId)}" title="删除此规则"><i class="fa-solid fa-trash"></i></button>
          </div>
        `;
          $rulesList.append(ruleHtml);
        }
        // 事件由父级事件委托处理，无需单独绑定
      } else {
        if (window.toastr) window.toastr.error(isEditMode ? '规则更新失败' : '规则添加失败');
      }
    });

    // 编辑模式：预填充现有规则数据（必须在事件绑定之后执行）
    if (isEditMode && existingRule) {
      dialog.find('#rule-name').val(existingRule.name || '');
      dialog.find('#rule-error-msg').val(existingRule.errorMessage || '');

      // 先设置表格，触发 change 事件更新列选项
      dialog
        .find('#rule-table')
        .val(existingRule.targetTable || '')
        .trigger('change');

      // 再设置规则类型，触发 change 事件切换配置区域
      dialog
        .find('#rule-type')
        .val(existingRule.ruleType || 'required')
        .trigger('change');

      // 延迟填充目标列和配置（等待表格/类型 change 事件处理完成）
      setTimeout(() => {
        // 填充目标列
        if (existingRule.targetColumn) {
          dialog.find('#rule-column').val(existingRule.targetColumn);
          updateSelectColor(dialog.find('#rule-column'));
        }

        // 填充规则配置
        const cfg = existingRule.config || {};
        const ruleType = existingRule.ruleType;

        if (ruleType === 'rowLimit') {
          if (cfg.min !== undefined) dialog.find('#cfg-row-min').val(cfg.min);
          if (cfg.max !== undefined) dialog.find('#cfg-row-max').val(cfg.max);
        } else if (ruleType === 'sequence') {
          dialog.find('#cfg-sequence-prefix').val(cfg.prefix || '');
          dialog.find('#cfg-sequence-start').val(cfg.startFrom ?? 1);
          if (cfg.pairedTable) {
            dialog.find('#cfg-sequence-paired-table').val(cfg.pairedTable);
            updateSelectColor(dialog.find('#cfg-sequence-paired-table'));
          }
        } else if (ruleType === 'format') {
          dialog.find('#cfg-pattern').val(cfg.pattern || '');
        } else if (ruleType === 'enum') {
          dialog.find('#cfg-values').val((cfg.values || []).join(','));
        } else if (ruleType === 'numeric') {
          if (cfg.min !== undefined) dialog.find('#cfg-min').val(cfg.min);
          if (cfg.max !== undefined) dialog.find('#cfg-max').val(cfg.max);
        } else if (ruleType === 'relation') {
          if (cfg.refTable) {
            dialog.find('#cfg-ref-table').val(cfg.refTable).trigger('change');
            // 延迟填充关联列，然后显示弹窗
            setTimeout(() => {
              const refColumns = Array.isArray(cfg.refColumn) ? cfg.refColumn : cfg.refColumn ? [cfg.refColumn] : [];
              dialog.find('#cfg-ref-column').val(refColumns);
              updateSelectColor(dialog.find('#cfg-ref-column'));
              // 显示弹窗
              dialog.css('opacity', '1');
            }, 100);
            return; // relation 类型在嵌套 setTimeout 中显示弹窗
          }
        } else if (ruleType === 'keyValue') {
          dialog
            .find('#cfg-keyvalue-type')
            .val(cfg.valueType || 'text')
            .trigger('change');
          if (cfg.valueMin !== undefined) dialog.find('#cfg-keyvalue-min').val(cfg.valueMin);
          if (cfg.valueMax !== undefined) dialog.find('#cfg-keyvalue-max').val(cfg.valueMax);
        }

        // 数据填充完成，显示弹窗
        dialog.css('opacity', '1');
      }, 100);
    }
  };

  // ========================================
  // 智能修改弹窗
  // ========================================
  const showSmartFixModal = error => {
    if (!error || !error.rule) {
      if (window.toastr) window.toastr.warning('无法获取规则信息');
      return;
    }

    const { $ } = getCore();
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;
    const rule = error.rule;
    const ruleType = error.ruleType || rule.ruleType;
    const typeInfo = RULE_TYPE_INFO[ruleType] || { name: ruleType, icon: 'fa-question' };
    const isTableRule = typeInfo?.scope === 'table';

    // 获取原始数据和快照
    const rawData = cachedRawData || getTableData();
    const snapshot = loadSnapshot();

    // 如果错误对象中没有 rowTitle，尝试从原始数据中获取
    if (!error.rowTitle && error.rowIndex >= 0 && rawData && error.tableName) {
      for (const sheetId in rawData) {
        if (rawData[sheetId]?.name === error.tableName) {
          const row = rawData[sheetId].content?.[error.rowIndex + 1];
          if (row) {
            error.rowTitle = row[1] || row[0] || `行 ${error.rowIndex + 1}`;
          }
          break;
        }
      }
    }

    // 获取快照值（用于字段级规则）
    let snapshotValue = '';
    if (!isTableRule && snapshot && error.tableName && error.columnName !== undefined) {
      for (const sheetId in snapshot) {
        if (snapshot[sheetId]?.name === error.tableName) {
          const headers = snapshot[sheetId].content?.[0] || [];
          const colIdx = headers.indexOf(error.columnName);
          const rowIdx = error.rowIndex + 1;
          if (colIdx >= 0 && snapshot[sheetId].content?.[rowIdx]) {
            snapshotValue = snapshot[sheetId].content[rowIdx][colIdx] ?? '';
          }
          break;
        }
      }
    }

    const hasSnapshotValue = snapshotValue !== '' && String(snapshotValue) !== String(error.currentValue || '');

    // ========================================
    // 表级规则特殊处理
    // ========================================
    if (isTableRule) {
      showTableRuleFixModal(error, rule, ruleType, rawData, snapshot, currentThemeClass);
      return;
    }

    // ========================================
    // 字段级规则处理
    // ========================================

    // 根据规则类型生成不同的修改UI
    let inputHtml = '';

    if (ruleType === 'enum' && rule.config?.values) {
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    } else if (ruleType === 'relation' && rule.config?.refTable && rule.config?.refColumn) {
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    } else if (ruleType === 'numeric') {
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    } else if (ruleType === 'format' && rule.config?.pattern) {
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    } else if (ruleType === 'keyValue') {
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    } else {
      // 必填或其他
      inputHtml = `<textarea id="smart-fix-value" class="acu-edit-textarea" spellcheck="false"
        style="width:100%;min-height:60px;max-height:200px;resize:none;">${escapeHtml(error.currentValue || '')}</textarea>`;
    }

    // 生成智能修复建议内容
    let smartSuggestHtml = '';

    if (ruleType === 'required') {
      // 必填验证：显示同列示例值
      const examples = getColumnExamples(error.tableName, error.columnName, error.rowIndex, rawData, 5);
      if (examples.length > 0) {
        smartSuggestHtml = `
          <div class="acu-smart-fix-suggest">
            <div class="acu-smart-fix-suggest-label">
              <i class="fa-solid fa-lightbulb"></i> 同列示例值:
            </div>
            <div class="acu-smart-fix-suggest-options">
              ${examples
                .map(
                  val => `
                <span class="acu-smart-fix-option" data-value="${escapeHtml(val)}" title="点击填充">
                  ${escapeHtml(val.length > 20 ? val.substring(0, 20) + '...' : val)}
                </span>
              `,
                )
                .join('')}
            </div>
          </div>
        `;
      }
    } else if (ruleType === 'enum' && rule.config?.values) {
      // 枚举验证：显示所有可用选项
      const validValues = rule.config.values;
      smartSuggestHtml = `
        <div class="acu-smart-fix-suggest">
          <div class="acu-smart-fix-suggest-label">
            <i class="fa-solid fa-list"></i> 允许的值 (点击选择):
          </div>
          <div class="acu-smart-fix-suggest-options acu-smart-fix-suggest-options-scroll">
            ${validValues
              .map(
                val => `
              <span class="acu-smart-fix-option ${error.currentValue === val ? 'acu-smart-fix-option-current' : ''}"
                    data-value="${escapeHtml(val)}" title="${error.currentValue === val ? '当前值（无效）' : '点击选择'}">
                ${escapeHtml(val)}
              </span>
            `,
              )
              .join('')}
          </div>
        </div>
      `;
    } else if (ruleType === 'format' && rule.config?.pattern) {
      // 格式验证：显示格式说明和推荐值
      // 获取表数据用于智能推算
      let tableContent = null;
      if (rawData && error.tableName) {
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === error.tableName) {
            tableContent = rawData[sheetId];
            break;
          }
        }
      }
      const suggestedValue = suggestFormatValue(rule.config.pattern, error.rowIndex, [], tableContent);
      smartSuggestHtml = `
        <div class="acu-smart-fix-suggest">
          <div class="acu-smart-fix-suggest-label">
            <i class="fa-solid fa-font"></i> 格式要求: <code>${escapeHtml(rule.config.pattern)}</code>
          </div>
          ${
            suggestedValue
              ? `
            <div style="margin-top:8px;">
              <span class="acu-smart-fix-suggest-label" style="margin-bottom:4px;display:block;">
                <i class="fa-solid fa-lightbulb"></i> 推荐值:
              </span>
              <span class="acu-smart-fix-quick-btn" data-value="${escapeHtml(suggestedValue)}">
                <i class="fa-solid fa-magic"></i> ${escapeHtml(suggestedValue)}
              </span>
            </div>
          `
              : ''
          }
        </div>
      `;
    } else if (ruleType === 'numeric') {
      // 数值范围验证：显示范围和快速修正按钮
      const min = rule.config?.min;
      const max = rule.config?.max;
      const currentNum = parseFloat(error.currentValue);
      const isOutOfRange =
        !isNaN(currentNum) && ((min !== undefined && currentNum < min) || (max !== undefined && currentNum > max));
      const nearestValid = isOutOfRange ? getNearestValidNumber(error.currentValue, min, max) : null;

      smartSuggestHtml = `
        <div class="acu-smart-fix-suggest">
          <div class="acu-smart-fix-suggest-label">
            <i class="fa-solid fa-hashtag"></i> 允许范围: ${min !== undefined ? min : '-∞'} ~ ${max !== undefined ? max : '+∞'}
          </div>
          ${
            isOutOfRange && nearestValid !== null
              ? `
            <div style="margin-top:8px;">
              <span class="acu-smart-fix-quick-btn" data-value="${nearestValid}">
                <i class="fa-solid fa-arrow-right"></i> 修正为 ${nearestValid}
              </span>
            </div>
          `
              : ''
          }
        </div>
      `;
    } else if (ruleType === 'relation' && rule.config?.refTable && rule.config?.refColumn) {
      // 关联验证：显示可用值列表（带搜索）
      const options = getRelationOptions(rule.config.refTable, rule.config.refColumn, rawData);
      const refColumns = Array.isArray(rule.config.refColumn) ? rule.config.refColumn : [rule.config.refColumn];
      const hasMultipleColumns = refColumns.length > 1;
      const currentInvalidValue = String(error.currentValue || '').trim();
      const valueExists = isValueInRelationTable(
        currentInvalidValue,
        rule.config.refTable,
        rule.config.refColumn,
        rawData,
      );

      // 构建可用值列表HTML
      let optionsHtml = '';
      if (options.length > 0) {
        optionsHtml = `
          <div class="acu-smart-fix-suggest-label">
            <i class="fa-solid fa-link"></i> 关联表 "${escapeHtml(rule.config.refTable)}" 可用值 (${options.length}项):
          </div>
          <div class="acu-smart-fix-suggest-options acu-smart-fix-suggest-options-scroll" id="smart-fix-options-container">
            ${options
              .map(
                val => `
              <span class="acu-smart-fix-option ${error.currentValue === val ? 'acu-smart-fix-option-current' : ''}"
                    data-value="${escapeHtml(val)}" title="${error.currentValue === val ? '当前值（无效）' : '点击选择'}">
                ${escapeHtml(val)}
              </span>
            `,
              )
              .join('')}
          </div>
        `;
      }

      // 反向写入选项：仅在值不存在于关联表中时显示
      let reverseWriteHtml = '';
      if (currentInvalidValue && !valueExists) {
        if (hasMultipleColumns) {
          // 多个列：显示选择器
          reverseWriteHtml = `
            <div class="acu-smart-fix-reverse-write" style="margin-top:15px;padding-top:15px;border-top:1px solid var(--acu-border);">
              <div class="acu-smart-fix-suggest-label">
                <i class="fa-solid fa-arrow-left"></i> 反向写入到关联表:
              </div>
              <div style="margin-top:8px;">
                <select id="smart-fix-reverse-column" class="acu-edit-select" style="width:100%;margin-bottom:8px;">
                  ${refColumns.map(col => `<option value="${escapeHtml(col)}">${escapeHtml(col)}</option>`).join('')}
                </select>
                <button class="acu-smart-fix-quick-btn" id="smart-fix-reverse-write-btn" style="width:100%;">
                  <i class="fa-solid fa-plus"></i> 将 "${escapeHtml(currentInvalidValue.length > 30 ? currentInvalidValue.substring(0, 30) + '...' : currentInvalidValue)}" 写入到 "${escapeHtml(rule.config.refTable)}"
                </button>
              </div>
            </div>
          `;
        } else {
          // 单个列：直接显示按钮
          reverseWriteHtml = `
            <div class="acu-smart-fix-reverse-write" style="margin-top:15px;padding-top:15px;border-top:1px solid var(--acu-border);">
              <div class="acu-smart-fix-suggest-label">
                <i class="fa-solid fa-arrow-left"></i> 反向写入到关联表:
              </div>
              <div style="margin-top:8px;">
                <button class="acu-smart-fix-quick-btn" id="smart-fix-reverse-write-btn" data-column="${escapeHtml(refColumns[0])}" style="width:100%;">
                  <i class="fa-solid fa-plus"></i> 将 "${escapeHtml(currentInvalidValue.length > 30 ? currentInvalidValue.substring(0, 30) + '...' : currentInvalidValue)}" 写入到 "${escapeHtml(rule.config.refTable)}.${escapeHtml(refColumns[0])}"
                </button>
              </div>
            </div>
          `;
        }
      }

      if (optionsHtml || reverseWriteHtml) {
        smartSuggestHtml = `
          <div class="acu-smart-fix-suggest">
            ${optionsHtml}
            ${reverseWriteHtml}
          </div>
        `;
      }
    } else if (ruleType === 'keyValue') {
      // 键值对验证：显示格式说明和问题列表
      const valueType = rule.config?.valueType || 'text';
      const valueMin = rule.config?.valueMin;
      const valueMax = rule.config?.valueMax;

      // 预处理当前值
      let processedValue = String(error.currentValue || '');
      processedValue = processedValue.replace(/：/g, ':').replace(/；/g, ';').replace(/，/g, ';').replace(/\s+/g, '');

      // 解析键值对并检测问题
      const pairs = processedValue.split(';').filter(p => p.trim());
      const issues = [];
      const fixedPairs = [];

      for (const pair of pairs) {
        const colonIndex = pair.indexOf(':');
        if (colonIndex === -1 || colonIndex === 0 || colonIndex === pair.length - 1) {
          issues.push({ pair, error: '格式错误：缺少冒号或键/值为空' });
          continue;
        }

        const key = pair.substring(0, colonIndex);
        const val = pair.substring(colonIndex + 1);

        if (!key || !val) {
          issues.push({ pair, error: '键或值不能为空' });
          continue;
        }

        let fixedVal = val;
        let hasIssue = false;

        if (valueType === 'numeric') {
          const numVal = parseFloat(val);
          if (isNaN(numVal)) {
            issues.push({ pair, error: `"${val}" 不是有效数字` });
            hasIssue = true;
          } else {
            if (valueMin !== undefined && valueMin !== null && numVal < valueMin) {
              fixedVal = String(valueMin);
              issues.push({ pair, error: `数值 ${numVal} 小于最小值 ${valueMin}` });
              hasIssue = true;
            } else if (valueMax !== undefined && valueMax !== null && numVal > valueMax) {
              fixedVal = String(valueMax);
              issues.push({ pair, error: `数值 ${numVal} 大于最大值 ${valueMax}` });
              hasIssue = true;
            }
          }
        }

        fixedPairs.push({ key, val: fixedVal, originalVal: val, hasIssue });
      }

      // 生成修正后的完整字符串
      const fixedValue = fixedPairs.map(p => `${p.key}:${p.val}`).join(';');
      const hasIssues = issues.length > 0 || fixedPairs.some(p => p.hasIssue);

      let issuesHtml = '';
      if (hasIssues) {
        issuesHtml = `
          <div class="acu-smart-fix-suggest-label" style="margin-bottom:8px;">
            <i class="fa-solid fa-exclamation-triangle"></i> 问题列表:
          </div>
          <div style="margin-bottom:8px;">
            ${issues
              .map(
                issue => `
              <div style="font-size:11px;color:var(--acu-text-sub);padding:4px 8px;background:var(--acu-card-bg);border-radius:4px;margin-bottom:4px;">
                <span style="color:var(--acu-hl-manual);">❌</span> ${escapeHtml(issue.pair)} - ${escapeHtml(issue.error)}
              </div>
            `,
              )
              .join('')}
            ${fixedPairs
              .filter(p => p.hasIssue)
              .map(
                p => `
              <div style="font-size:11px;color:var(--acu-text-sub);padding:4px 8px;background:var(--acu-card-bg);border-radius:4px;margin-bottom:4px;">
                <span style="color:var(--acu-hl-manual);">⚠️</span> ${escapeHtml(p.key)}:${escapeHtml(p.originalVal)} → ${escapeHtml(p.val)}
              </div>
            `,
              )
              .join('')}
          </div>
        `;
      }

      smartSuggestHtml = `
        <div class="acu-smart-fix-suggest">
          <div class="acu-smart-fix-suggest-label">
            <i class="fa-solid fa-key"></i> 格式要求: 键:值;键:值（使用英文标点，自动去除空格）
          </div>
          ${
            valueType === 'numeric'
              ? `
            <div class="acu-smart-fix-suggest-label" style="margin-top:8px;">
              <i class="fa-solid fa-hashtag"></i> 数值范围: ${valueMin !== undefined ? valueMin : '-∞'} ~ ${valueMax !== undefined ? valueMax : '+∞'}
            </div>
          `
              : ''
          }
          ${issuesHtml}
          ${
            hasIssues
              ? `
            <div style="margin-top:8px;">
              <span class="acu-smart-fix-quick-btn" data-value="${escapeHtml(fixedValue)}">
                <i class="fa-solid fa-magic"></i> 一键修正所有问题
              </span>
            </div>
            <div style="margin-top:8px;padding:8px;background:var(--acu-card-bg);border-radius:4px;font-size:11px;color:var(--acu-text-sub);">
              <div style="margin-bottom:4px;"><strong>修正后预览:</strong></div>
              <code style="color:var(--acu-success-text);">${escapeHtml(fixedValue)}</code>
            </div>
          `
              : `
            <div style="margin-top:8px;padding:8px;background:var(--acu-success-bg);border-radius:4px;font-size:11px;color:var(--acu-success-text);">
              <i class="fa-solid fa-check-circle"></i> 格式正确
            </div>
          `
          }
        </div>
      `;
    }

    // 弹窗HTML
    const dialog = $(`
      <div class="acu-edit-overlay acu-validation-modal-overlay">
        <div class="acu-edit-dialog acu-validation-modal ${currentThemeClass}" style="max-width:450px;">
          <div class="acu-edit-title">智能修改: ${escapeHtml(error.tableName || '')} - ${escapeHtml(error.columnName || '')}</div>
          <div class="acu-settings-content" style="flex:1; overflow-y:auto; padding:15px;">
            <!-- 规则说明 -->
            <div class="acu-smart-fix-rule-info">
              <div class="acu-smart-fix-rule-header">
                <i class="fa-solid ${typeInfo.icon}"></i>
                <span>${escapeHtml(error.ruleName || rule.name || '')}</span>
              </div>
              <div class="acu-smart-fix-rule-desc">${escapeHtml(error.errorMessage || rule.errorMessage || typeInfo.desc || '')}</div>
            </div>

            <!-- 快照值（只读） -->
            ${
              hasSnapshotValue
                ? `
              <div class="acu-diff-section acu-diff-old-section">
                <div class="acu-diff-label">
                  <i class="fa-solid fa-clock-rotate-left"></i> 快照值（原始）
                </div>
                <div class="acu-diff-readonly">${escapeHtml(snapshotValue)}</div>
              </div>
              <div class="acu-diff-arrow-down"><i class="fa-solid fa-arrow-down"></i></div>
            `
                : ''
            }

            <!-- 当前值（可编辑） -->
            <div class="acu-diff-section acu-diff-new-section">
              ${
                error.rowTitle && error.rowIndex >= 0
                  ? `<div style="font-size:12px;color:var(--acu-text-sub);margin-bottom:8px;padding:4px 8px;background:var(--acu-bg-sub);border-radius:4px;">
                <i class="fa-solid fa-tag" style="margin-right:4px;"></i>${escapeHtml(error.rowTitle)}
              </div>`
                  : ''
              }
              <div class="acu-diff-label">
                <i class="fa-solid fa-pen"></i> 当前值（可编辑）
              </div>
              ${inputHtml}
            </div>

            <!-- 智能建议 -->
            ${
              smartSuggestHtml
                ? `
              <div class="acu-smart-fix-suggest-section">
                ${smartSuggestHtml}
              </div>
            `
                : ''
            }
          </div>
          <div class="acu-dialog-btns">
            <button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 取消</button>
            ${hasSnapshotValue ? `<button class="acu-dialog-btn acu-btn-revert" id="smart-fix-revert"><i class="fa-solid fa-rotate-left"></i> 恢复快照值</button>` : ''}
            <button class="acu-dialog-btn acu-btn-clear" id="smart-fix-clear"><i class="fa-solid fa-eraser"></i> 清空当前值</button>
            <button class="acu-dialog-btn acu-btn-confirm" id="smart-fix-confirm"><i class="fa-solid fa-check"></i> 保存</button>
          </div>
        </div>
      </div>
    `);

    $('body').append(dialog);

    // 点击建议选项或快速修正按钮，填充到输入框
    dialog.on('click', '.acu-smart-fix-option, .acu-smart-fix-quick-btn', function () {
      // 排除反向写入按钮
      if ($(this).attr('id') === 'smart-fix-reverse-write-btn') return;
      if ($(this).hasClass('acu-smart-fix-option-current')) return;
      const optionValue = $(this).data('value') || $(this).text().trim();
      dialog.find('#smart-fix-value').val(optionValue).trigger('input');
    });

    // 反向写入到关联表
    dialog.on('click', '#smart-fix-reverse-write-btn', async function () {
      const currentInvalidValue = String(error.currentValue || '').trim();
      if (!currentInvalidValue) {
        if (window.toastr) window.toastr.warning('无法写入空值');
        return;
      }

      // 确定要写入的列
      let targetColumn;
      if (ruleType === 'relation' && rule.config?.refColumn) {
        const refColumns = Array.isArray(rule.config.refColumn) ? rule.config.refColumn : [rule.config.refColumn];
        if (refColumns.length > 1) {
          // 多个列：从选择器获取
          targetColumn = dialog.find('#smart-fix-reverse-column').val();
        } else {
          // 单个列：从按钮的data属性或直接使用
          targetColumn = $(this).data('column') || refColumns[0];
        }
      } else {
        if (window.toastr) window.toastr.error('无法确定目标列');
        return;
      }

      if (!targetColumn || !rule.config?.refTable) {
        if (window.toastr) window.toastr.error('无法确定目标表或列');
        return;
      }

      try {
        const rawData = cachedRawData || getTableData();
        let refSheet = null;
        let refSheetId = null;

        // 查找关联表
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === rule.config.refTable) {
            refSheet = rawData[sheetId];
            refSheetId = sheetId;
            break;
          }
        }

        if (!refSheet || !refSheet.content) {
          if (window.toastr) window.toastr.error(`找不到关联表 "${rule.config.refTable}"`);
          return;
        }

        const headers = refSheet.content[0] || [];
        const targetColIdx = headers.indexOf(targetColumn);

        if (targetColIdx === -1) {
          if (window.toastr) window.toastr.error(`关联表中不存在列 "${targetColumn}"`);
          return;
        }

        // 创建新行：长度与表头一致，填充空字符串
        const newRow = new Array(headers.length).fill('');
        newRow[targetColIdx] = currentInvalidValue;

        // 添加到表末尾
        refSheet.content.push(newRow);

        // 保存数据
        await saveDataToDatabase(rawData, false, false);

        // 关闭弹窗并重新渲染界面（会自动重新验证，所有相关错误会消失）
        closeDialog();
        renderInterface();
      } catch (e) {
        console.error('[DICE]ACU 反向写入失败:', e);
        if (window.toastr) window.toastr.error('反向写入失败: ' + (e.message || '未知错误'));
      }
    });

    // 恢复快照值
    dialog.on('click', '#smart-fix-revert', function () {
      dialog.find('#smart-fix-value').val(snapshotValue);
    });

    // 清空当前值
    dialog.on('click', '#smart-fix-clear', function () {
      dialog.find('#smart-fix-value').val('').trigger('input');
    });

    // 关闭
    const closeDialog = () => dialog.remove();
    dialog.on('click', '#smart-fix-close, #smart-fix-cancel', closeDialog);
    setupOverlayClose(dialog, 'acu-validation-modal-overlay', closeDialog);

    // 确认修改
    dialog.find('#smart-fix-confirm').on('click', async function () {
      const newValue = dialog.find('#smart-fix-value').val()?.trim() || '';

      if (newValue === '' && ruleType === 'required') {
        if (window.toastr) window.toastr.warning('必填字段不能为空');
        return;
      }

      // 更新单元格值
      try {
        const rawData = cachedRawData || getTableData();
        let updated = false;

        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === error.tableName) {
            const sheet = rawData[sheetId];
            const headers = sheet.content?.[0] || [];

            if (error.rowIndex >= 0 && error.columnName) {
              const colIdx = headers.indexOf(error.columnName);
              const rowIdx = error.rowIndex + 1;

              if (colIdx >= 0 && sheet.content && sheet.content[rowIdx]) {
                sheet.content[rowIdx][colIdx] = newValue;
                updated = true;
                break;
              }
            }
          }
        }

        if (updated) {
          await saveDataToDatabase(rawData, false, false);
          closeDialog();
          renderInterface();
        } else {
          if (window.toastr) window.toastr.error('无法找到目标单元格');
        }
      } catch (e) {
        console.error('[DICE]ACU 更新单元格失败:', e);
        if (window.toastr) window.toastr.error('更新失败: ' + (e.message || '未知错误'));
      }
    });
  };

  // ========================================
  // ========================================
  // 配对表编码修复辅助函数
  // ========================================

  // 从表中提取所有编码值
  function extractCodesFromTable(sheet, columnName, prefix) {
    if (!sheet || !sheet.content || sheet.content.length < 2) {
      return { codes: new Map(), allCodes: new Set(), codeToRows: new Map() };
    }

    const headers = sheet.content[0] || [];
    const rows = sheet.content.slice(1) || [];
    const colIndex = headers.indexOf(columnName);

    if (colIndex < 0) {
      return { codes: new Map(), allCodes: new Set(), codeToRows: new Map() };
    }

    const codes = new Map(); // Map<编码值, 行索引数组>
    const allCodes = new Set(); // Set<编码值>
    const codeToRows = new Map(); // Map<编码值, 行索引数组>

    for (let i = 0; i < rows.length; i++) {
      const value = rows[i]?.[colIndex];
      if (value === null || value === undefined || value === '') continue;

      const strValue = String(value).trim();
      if (!strValue) continue;

      // 验证编码格式
      let isValid = false;
      if (prefix) {
        const match = strValue.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
        if (match) {
          isValid = true;
        }
      } else {
        const num = parseInt(strValue, 10);
        if (!isNaN(num)) {
          isValid = true;
        }
      }

      if (isValid) {
        allCodes.add(strValue);
        if (!codeToRows.has(strValue)) {
          codeToRows.set(strValue, []);
        }
        codeToRows.get(strValue).push(i);
      }
    }

    return { codes, allCodes, codeToRows };
  }

  // 构建编码映射：旧编码 → 新编码
  function buildCodeMapping(codes1, codes2, prefix, startFrom) {
    // 合并两个表的所有唯一编码值
    const allUniqueCodes = new Set([...codes1, ...codes2]);

    // 提取数字部分并排序
    const codeNumbers = [];
    for (const code of allUniqueCodes) {
      let num = null;
      if (prefix) {
        const match = code.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
        if (match) {
          num = parseInt(match[1], 10);
        }
      } else {
        num = parseInt(code, 10);
      }

      if (!isNaN(num)) {
        codeNumbers.push({ code, num });
      }
    }

    // 按数字部分排序
    codeNumbers.sort((a, b) => a.num - b.num);

    // 建立映射：旧编码 → 新编码
    const mapping = new Map();
    for (let i = 0; i < codeNumbers.length; i++) {
      const oldCode = codeNumbers[i].code;
      const newNum = startFrom + i;
      const newCode = prefix + String(newNum).padStart(4, '0');
      mapping.set(oldCode, newCode);
    }

    return mapping;
  }

  // 对齐和修复配对表
  // 核心逻辑：
  // 1. 编码为空的行保持原位置不动（这些是错误数据，由必填规则检测）
  // 2. 有效编码行更新编码值，修复跳号
  // 3. 缺失的编码插入空白行，保证两表有编码的行数一致
  function alignAndFixPairedTables(
    table1Sheet,
    table1SheetId,
    table2Sheet,
    table2SheetId,
    columnName,
    mapping,
    prefix,
    startFrom,
    rawData,
  ) {
    if (!table1Sheet || !table2Sheet) return { fixedCount1: 0, fixedCount2: 0 };

    const headers1 = table1Sheet.content[0] || [];
    const rows1 = table1Sheet.content.slice(1) || [];
    const colIndex1 = headers1.indexOf(columnName);

    const headers2 = table2Sheet.content[0] || [];
    const rows2 = table2Sheet.content.slice(1) || [];
    const colIndex2 = headers2.indexOf(columnName);

    if (colIndex1 < 0 || colIndex2 < 0) return { fixedCount1: 0, fixedCount2: 0 };

    let fixedCount1 = 0;
    let fixedCount2 = 0;

    // 构建反向映射：新编码 -> 旧编码
    const reverseMapping = new Map();
    for (const [oldCode, newCode] of mapping.entries()) {
      reverseMapping.set(newCode, oldCode);
    }

    // 按新编码的数字部分排序
    const sortedNewCodes = Array.from(mapping.values()).sort((a, b) => {
      const numA = parseInt(a.replace(prefix, ''), 10);
      const numB = parseInt(b.replace(prefix, ''), 10);
      return numA - numB;
    });

    // 分析表结构：识别有效编码行和空白编码行，记录空白行在哪两个编码之间
    const analyzeTable = (rows, colIndex) => {
      const codeRows = []; // {rowIndex, oldCode, row}
      const emptyRows = []; // {rowIndex, row, prevOldCode, nextOldCode}

      for (let i = 0; i < rows.length; i++) {
        const value = rows[i]?.[colIndex];
        const strValue = value === null || value === undefined ? '' : String(value).trim();

        // 检查是否是有效编码
        let isValid = false;
        if (strValue && prefix) {
          const match = strValue.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
          if (match) isValid = true;
        } else if (strValue) {
          const num = parseInt(strValue, 10);
          if (!isNaN(num)) isValid = true;
        }

        if (isValid) {
          codeRows.push({ rowIndex: i, oldCode: strValue, row: rows[i] });
        } else {
          emptyRows.push({ rowIndex: i, row: rows[i], prevOldCode: null, nextOldCode: null });
        }
      }

      // 为每个空白行确定它在哪两个编码之间
      for (const emptyRow of emptyRows) {
        let prevCode = null;
        let nextCode = null;

        for (const codeRow of codeRows) {
          if (codeRow.rowIndex < emptyRow.rowIndex) {
            prevCode = codeRow.oldCode;
          }
          if (codeRow.rowIndex > emptyRow.rowIndex && nextCode === null) {
            nextCode = codeRow.oldCode;
            break;
          }
        }

        emptyRow.prevOldCode = prevCode;
        emptyRow.nextOldCode = nextCode;
      }

      return { codeRows, emptyRows };
    };

    const analysis1 = analyzeTable(rows1, colIndex1);
    const analysis2 = analyzeTable(rows2, colIndex2);

    // 构建新的行序列
    const buildNewRows = (analysis, headers, colIndex, allOldCodes) => {
      const newRows = [];
      const codeRowMap = new Map(); // oldCode -> row data

      // 构建旧编码到行数据的映射
      for (const cr of analysis.codeRows) {
        codeRowMap.set(cr.oldCode, cr.row);
      }

      // 按新编码顺序构建有效编码行
      for (const newCode of sortedNewCodes) {
        const oldCode = reverseMapping.get(newCode);

        if (codeRowMap.has(oldCode)) {
          // 有对应的旧数据，更新编码
          const oldRow = codeRowMap.get(oldCode);
          const newRow = oldRow.map(cell => cell);
          newRow[colIndex] = newCode;
          newRows.push({ newCode, row: newRow, isCodeRow: true });
        } else {
          // 缺失的编码，创建空白行（只有编码，其他列为空）
          const newRow = new Array(headers.length).fill(null);
          newRow[colIndex] = newCode;
          newRows.push({ newCode, row: newRow, isCodeRow: true, isInserted: true });
        }
      }

      // 把空白编码行插入到它们原来的相对位置
      // 相对位置由 prevOldCode 和 nextOldCode 确定
      const result = [];
      let codeRowIndex = 0;

      // 先处理在所有编码之前的空白行
      for (const emptyRow of analysis.emptyRows) {
        if (emptyRow.prevOldCode === null && emptyRow.nextOldCode !== null) {
          // 在第一个编码之前
          const nextNewCode = mapping.get(emptyRow.nextOldCode);
          // 在对应的新编码之前插入
          while (codeRowIndex < newRows.length && newRows[codeRowIndex].newCode !== nextNewCode) {
            result.push(newRows[codeRowIndex].row);
            codeRowIndex++;
          }
          result.push(emptyRow.row);
        } else if (emptyRow.prevOldCode === null && emptyRow.nextOldCode === null) {
          // 表中只有空白行，没有有效编码
          result.push(emptyRow.row);
        }
      }

      // 处理有效编码行和在编码之间的空白行
      for (; codeRowIndex < newRows.length; codeRowIndex++) {
        result.push(newRows[codeRowIndex].row);
        const currentNewCode = newRows[codeRowIndex].newCode;
        const currentOldCode = reverseMapping.get(currentNewCode);

        // 检查是否有空白行应该在这个编码之后
        for (const emptyRow of analysis.emptyRows) {
          if (emptyRow.prevOldCode === currentOldCode) {
            result.push(emptyRow.row);
          }
        }
      }

      // 处理在所有编码之后的空白行（prevOldCode 是最后一个编码，nextOldCode 为 null）
      for (const emptyRow of analysis.emptyRows) {
        if (emptyRow.prevOldCode !== null && emptyRow.nextOldCode === null) {
          // 已经在上面的循环中处理了
        }
      }

      return result;
    };

    // 构建两个表的新行
    const newRows1 = buildNewRows(analysis1, headers1, colIndex1, new Set(analysis1.codeRows.map(r => r.oldCode)));
    const newRows2 = buildNewRows(analysis2, headers2, colIndex2, new Set(analysis2.codeRows.map(r => r.oldCode)));

    // 计算修复数量
    const countCodeChanges = (oldAnalysis, newRows, colIndex) => {
      let count = 0;
      // 统计编码变化的数量
      const oldCodes = new Set(oldAnalysis.codeRows.map(r => r.oldCode));
      const newCodes = new Set();

      for (const row of newRows) {
        const code = row[colIndex];
        if (code) newCodes.add(code);
      }

      // 计算更新的编码数量和新插入的行数量
      for (const [oldCode, newCode] of mapping.entries()) {
        if (oldCodes.has(oldCode) && oldCode !== newCode) {
          count++; // 编码被更新
        }
      }

      // 计算新插入的行数量
      for (const newCode of sortedNewCodes) {
        const oldCode = reverseMapping.get(newCode);
        if (!oldCodes.has(oldCode)) {
          count++; // 新插入的行
        }
      }

      return count;
    };

    fixedCount1 = countCodeChanges(analysis1, newRows1, colIndex1);
    fixedCount2 = countCodeChanges(analysis2, newRows2, colIndex2);

    // 更新表内容
    table1Sheet.content = [headers1, ...newRows1];
    table2Sheet.content = [headers2, ...newRows2];

    return { fixedCount1, fixedCount2 };
  }

  // 表级规则智能修改弹窗
  // ========================================
  const showTableRuleFixModal = (error, rule, ruleType, rawData, snapshot, currentThemeClass) => {
    const { $ } = getCore();
    const typeInfo = RULE_TYPE_INFO[ruleType] || { name: ruleType, icon: 'fa-question' };

    let contentHtml = '';
    let actionBtns = '';

    if (ruleType === 'tableReadonly') {
      // 表只读规则：显示修改概览，提供恢复整表功能
      let changeCount = 0;
      let changeDetails = [];

      if (snapshot && rawData) {
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === error.tableName && snapshot[sheetId]) {
            const newRows = rawData[sheetId].content?.slice(1) || [];
            const oldRows = snapshot[sheetId].content?.slice(1) || [];

            // 检测修改
            newRows.forEach((row, idx) => {
              const oldRow = oldRows[idx];
              if (!oldRow) {
                changeDetails.push(`第${idx + 1}行: 新增`);
                changeCount++;
              } else {
                for (let c = 0; c < row.length; c++) {
                  if (String(row[c] || '') !== String(oldRow[c] || '')) {
                    changeDetails.push(`第${idx + 1}行: 有修改`);
                    changeCount++;
                    break;
                  }
                }
              }
            });

            // 检测删除
            if (oldRows.length > newRows.length) {
              for (let i = newRows.length; i < oldRows.length; i++) {
                changeDetails.push(`第${i + 1}行: 已删除`);
                changeCount++;
              }
            }
            break;
          }
        }
      }

      contentHtml = `
        <div class="acu-smart-fix-rule-info">
          <div class="acu-smart-fix-rule-header">
            <i class="fa-solid fa-lock"></i>
            <span>表只读保护</span>
          </div>
          <div class="acu-smart-fix-rule-desc">此表被设置为只读，但检测到有修改。</div>
        </div>
        <div class="acu-smart-fix-table-summary">
          <div class="acu-smart-fix-stat">
            <i class="fa-solid fa-exclamation-triangle"></i>
            检测到 <strong>${changeCount}</strong> 处修改
          </div>
          ${
            changeDetails.length > 0
              ? `
            <div class="acu-smart-fix-change-list">
              ${changeDetails
                .slice(0, 10)
                .map(d => `<div class="acu-smart-fix-change-item">${escapeHtml(d)}</div>`)
                .join('')}
              ${changeDetails.length > 10 ? `<div class="acu-smart-fix-change-item">... 还有 ${changeDetails.length - 10} 处</div>` : ''}
            </div>
          `
              : ''
          }
        </div>
      `;
      actionBtns = `
        <button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 取消</button>
        <button class="acu-dialog-btn acu-btn-revert" id="smart-fix-restore-table"><i class="fa-solid fa-rotate-left"></i> 恢复整表</button>
      `;
    } else if (ruleType === 'rowLimit') {
      // 行数限制规则：显示超出的行，提供删除功能
      const minRows = rule.config?.min;
      const maxRows = rule.config?.max;
      let currentRowCount = 0;
      let excessRows = [];

      for (const sheetId in rawData) {
        if (rawData[sheetId]?.name === error.tableName) {
          currentRowCount = (rawData[sheetId].content?.length || 1) - 1; // 减去表头
          break;
        }
      }

      const isTooMany = maxRows !== undefined && currentRowCount > maxRows;
      const isTooFew = minRows !== undefined && currentRowCount < minRows;

      if (isTooMany) {
        for (let i = maxRows + 1; i <= currentRowCount; i++) {
          excessRows.push(i);
        }
      }

      contentHtml = `
        <div class="acu-smart-fix-rule-info">
          <div class="acu-smart-fix-rule-header">
            <i class="fa-solid fa-arrows-up-down"></i>
            <span>行数限制</span>
          </div>
          <div class="acu-smart-fix-rule-desc">${escapeHtml(error.errorMessage || rule.errorMessage || '')}</div>
        </div>
        <div class="acu-smart-fix-table-summary">
          <div class="acu-smart-fix-stat">
            当前行数: <strong>${currentRowCount}</strong> 行
            ${minRows !== undefined || maxRows !== undefined ? ` | 限制: ${minRows !== undefined ? minRows : 0} ~ ${maxRows !== undefined ? maxRows : '∞'} 行` : ''}
          </div>
          ${
            isTooMany && excessRows.length > 0
              ? `
            <div class="acu-smart-fix-excess-rows">
              <div class="acu-smart-fix-suggest-label">
                <i class="fa-solid fa-trash"></i> 需删除的行 (第 ${excessRows[0]} 行及之后):
              </div>
              <div class="acu-smart-fix-change-list">
                ${excessRows
                  .slice(0, 10)
                  .map(r => `<div class="acu-smart-fix-change-item">第 ${r} 行</div>`)
                  .join('')}
                ${excessRows.length > 10 ? `<div class="acu-smart-fix-change-item">... 共 ${excessRows.length} 行</div>` : ''}
              </div>
            </div>
          `
              : ''
          }
          ${
            isTooFew
              ? `
            <div class="acu-smart-fix-hint">
              <i class="fa-solid fa-info-circle"></i> 需要添加 ${minRows - currentRowCount} 行才能满足最小行数要求
            </div>
          `
              : ''
          }
        </div>
      `;

      if (isTooMany && excessRows.length > 0) {
        actionBtns = `
          <button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 取消</button>
          <button class="acu-dialog-btn acu-btn-confirm" id="smart-fix-delete-rows" data-start="${maxRows}" data-table="${escapeHtml(error.tableName)}">
            <i class="fa-solid fa-trash"></i> 删除多余的 ${excessRows.length} 行
          </button>
        `;
      } else {
        actionBtns = `<button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 关闭</button>`;
      }
    } else if (ruleType === 'sequence' && rule.targetColumn) {
      // 序列递增规则：检测跳号、重复，提供自动修复
      const prefix = rule.config?.prefix || '';
      const startFrom = rule.config?.startFrom !== undefined ? rule.config?.startFrom : 1;
      let targetSheet = null;
      let issues = [];
      let fixSuggestions = [];

      // 找到目标表
      for (const sheetId in rawData) {
        if (rawData[sheetId]?.name === error.tableName) {
          targetSheet = rawData[sheetId];
          break;
        }
      }

      if (targetSheet && targetSheet.content && targetSheet.content.length > 1) {
        const headers = targetSheet.content[0] || [];
        const rows = targetSheet.content.slice(1) || [];
        const colIndex = ValidationEngine.findColumnIndex(headers, rule.targetColumn);

        if (colIndex >= 0) {
          // 提取所有编码索引的数字部分
          const numbers = [];
          for (let i = 0; i < rows.length; i++) {
            const value = rows[i]?.[colIndex];
            if (value === null || value === undefined || value === '') continue;

            const strValue = String(value).trim();
            if (!strValue) continue;

            let num = null;
            if (prefix) {
              const match = strValue.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
              if (match) {
                num = parseInt(match[1], 10);
              }
            } else {
              num = parseInt(strValue, 10);
            }

            if (!isNaN(num)) {
              numbers.push({ rowIndex: i, value: strValue, num, originalRowIndex: i + 2 }); // +2 因为表头+1索引
            }
          }

          // 按行索引排序
          numbers.sort((a, b) => a.rowIndex - b.rowIndex);

          // 检测问题
          const numCountMap = new Map(); // 记录每个数字出现的次数和位置
          const duplicates = [];
          const gaps = [];
          const outOfOrder = [];

          // 第一遍：统计每个数字出现的次数
          for (let i = 0; i < numbers.length; i++) {
            const actualNum = numbers[i].num;
            if (!numCountMap.has(actualNum)) {
              numCountMap.set(actualNum, []);
            }
            numCountMap.get(actualNum).push(i);
          }

          // 第二遍：检测问题
          for (let i = 0; i < numbers.length; i++) {
            const expectedNum = startFrom + i;
            const actualNum = numbers[i].num;
            const rowNum = numbers[i].originalRowIndex;

            // 检测重复（如果这个数字出现了多次）
            const occurrences = numCountMap.get(actualNum) || [];
            if (occurrences.length > 1) {
              // 只有第一次出现时才添加到重复列表（避免重复报告）
              if (occurrences[0] === i) {
                duplicates.push({
                  rowNum,
                  value: numbers[i].value,
                  num: actualNum,
                  expectedNum,
                  count: occurrences.length,
                });
              }
            }

            // 检测跳号或顺序错误
            if (actualNum !== expectedNum) {
              if (actualNum < expectedNum) {
                // 数字小于期望值（可能是重复或顺序错误）
                outOfOrder.push({ rowNum, value: numbers[i].value, num: actualNum, expectedNum });
              } else {
                // 数字大于期望值（跳号）
                gaps.push({ rowNum, value: numbers[i].value, num: actualNum, expectedNum });
              }
            }
          }

          // 生成修复建议
          for (let i = 0; i < numbers.length; i++) {
            const expectedNum = startFrom + i;
            const actualNum = numbers[i].num;
            const rowNum = numbers[i].originalRowIndex;
            const currentValue = numbers[i].value;
            const fixedValue = prefix + String(expectedNum).padStart(4, '0');

            if (actualNum !== expectedNum || duplicates.some(d => d.num === actualNum && d.rowNum === rowNum)) {
              fixSuggestions.push({
                rowNum,
                currentValue,
                fixedValue,
                reason: actualNum < expectedNum ? '重复或顺序错误' : actualNum > expectedNum ? '跳号' : '重复',
              });
            }
          }

          // 合并所有问题（去重，因为重复和顺序错误可能有重叠）
          const issueSet = new Set();
          duplicates.forEach(d => {
            issueSet.add(`第${d.rowNum}行: "${d.value}" 重复 (出现${d.count}次)`);
          });
          gaps.forEach(g => {
            issueSet.add(
              `第${g.rowNum}行: "${g.value}" 应为 "${prefix}${String(g.expectedNum).padStart(4, '0')}" (跳号)`,
            );
          });
          outOfOrder.forEach(o => {
            issueSet.add(
              `第${o.rowNum}行: "${o.value}" 应为 "${prefix}${String(o.expectedNum).padStart(4, '0')}" (顺序错误)`,
            );
          });
          issues = Array.from(issueSet);
        }
      }

      contentHtml = `
        <div class="acu-smart-fix-rule-info">
          <div class="acu-smart-fix-rule-header">
            <i class="fa-solid fa-sort-numeric-up"></i>
            <span>序列递增验证</span>
          </div>
          <div class="acu-smart-fix-rule-desc">${escapeHtml(error.errorMessage || rule.errorMessage || '')}</div>
        </div>
        <div class="acu-smart-fix-table-summary">
          <div class="acu-smart-fix-stat">
            <i class="fa-solid fa-exclamation-triangle"></i>
            检测到 <strong>${issues.length}</strong> 个问题
          </div>
          ${
            issues.length > 0
              ? `
            <div class="acu-smart-fix-change-list" style="max-height:200px;overflow-y:auto;margin-top:8px;">
              ${issues
                .slice(0, 20)
                .map(issue => `<div class="acu-smart-fix-change-item">${escapeHtml(issue)}</div>`)
                .join('')}
              ${issues.length > 20 ? `<div class="acu-smart-fix-change-item">... 还有 ${issues.length - 20} 个问题</div>` : ''}
            </div>
          `
              : ''
          }
          ${
            fixSuggestions.length > 0
              ? `
            <div class="acu-smart-fix-suggest" style="margin-top:12px;">
              <div class="acu-smart-fix-suggest-label">
                <i class="fa-solid fa-lightbulb"></i> 修复建议:
              </div>
              <div class="acu-smart-fix-change-list" style="max-height:200px;overflow-y:auto;margin-top:8px;">
                ${fixSuggestions
                  .slice(0, 20)
                  .map(
                    fix => `
                  <div class="acu-smart-fix-change-item">
                    <span style="color:var(--acu-text-sub);">第${fix.rowNum}行:</span>
                    <span style="color:var(--acu-hl-manual);">${escapeHtml(fix.currentValue)}</span>
                    <span style="color:var(--acu-text-sub);"> → </span>
                    <span style="color:var(--acu-hl-auto);">${escapeHtml(fix.fixedValue)}</span>
                    <span style="color:var(--acu-text-sub);font-size:11px;"> (${escapeHtml(fix.reason)})</span>
                  </div>
                `,
                  )
                  .join('')}
                ${fixSuggestions.length > 20 ? `<div class="acu-smart-fix-change-item">... 还有 ${fixSuggestions.length - 20} 处需要修复</div>` : ''}
              </div>
            </div>
          `
              : ''
          }
        </div>
      `;

      if (fixSuggestions.length > 0) {
        // 检测是否有配对表
        const pairedTable =
          rule.config?.pairedTable ||
          (error.tableName === '总结表' ? '总体大纲' : error.tableName === '总体大纲' ? '总结表' : null);
        const pairedTableAttr = pairedTable ? `data-paired-table="${escapeHtml(pairedTable)}"` : '';

        actionBtns = `
          <button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 取消</button>
          <button class="acu-dialog-btn acu-btn-confirm" id="smart-fix-fix-sequence" data-table="${escapeHtml(error.tableName)}" data-column="${escapeHtml(rule.targetColumn)}" data-prefix="${escapeHtml(prefix)}" data-start="${startFrom}" ${pairedTableAttr}>
            <i class="fa-solid fa-magic"></i> 自动修复 ${fixSuggestions.length} 处
          </button>
        `;
      } else {
        actionBtns = `<button class="acu-dialog-btn" id="smart-fix-cancel"><i class="fa-solid fa-times"></i> 关闭</button>`;
      }
    }

    const dialog = $(`
      <div class="acu-edit-overlay acu-validation-modal-overlay">
        <div class="acu-edit-dialog acu-validation-modal ${currentThemeClass}" style="max-width:450px;">
          <div class="acu-edit-title">智能修改: ${escapeHtml(error.tableName || '')} (表级规则)</div>
          <div class="acu-settings-content" style="flex:1; overflow-y:auto; padding:15px;">
            ${contentHtml}
          </div>
          <div class="acu-dialog-btns">
            ${actionBtns}
          </div>
        </div>
      </div>
    `);

    $('body').append(dialog);

    // 关闭
    const closeDialog = () => dialog.remove();
    dialog.on('click', '#smart-fix-cancel', closeDialog);
    setupOverlayClose(dialog, 'acu-validation-modal-overlay', closeDialog);

    // 恢复整表
    dialog.on('click', '#smart-fix-restore-table', async function () {
      if (!snapshot) {
        if (window.toastr) window.toastr.warning('无快照数据');
        return;
      }

      try {
        // 恢复指定表的数据
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === error.tableName && snapshot[sheetId]) {
            rawData[sheetId] = JSON.parse(JSON.stringify(snapshot[sheetId]));
            break;
          }
        }

        await saveDataToDatabase(rawData, false, false);
        closeDialog();
        renderInterface();
      } catch (e) {
        console.error('[DICE]ACU 恢复表失败:', e);
        if (window.toastr) window.toastr.error('恢复失败: ' + (e.message || '未知错误'));
      }
    });

    // 自动修复序列递增
    dialog.on('click', '#smart-fix-fix-sequence', async function () {
      const $btn = $(this);
      const tableName = $btn.data('table');
      const columnName = $btn.data('column');
      const prefix = $btn.data('prefix') || '';
      const startFrom = parseInt($btn.data('start') || '1', 10);
      const pairedTableName = $btn.data('paired-table') || null;

      try {
        $btn.prop('disabled', true).html('<i class="fa-solid fa-spinner fa-spin"></i> 修复中...');

        // 找到目标表
        let targetSheet = null;
        let targetSheetId = null;
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === tableName) {
            targetSheet = rawData[sheetId];
            targetSheetId = sheetId;
            break;
          }
        }

        if (!targetSheet || !targetSheet.content || targetSheet.content.length < 2) {
          if (window.toastr) window.toastr.warning('未找到目标表');
          $btn.prop('disabled', false).html('<i class="fa-solid fa-magic"></i> 自动修复');
          return;
        }

        const headers = targetSheet.content[0] || [];
        const rows = targetSheet.content.slice(1) || [];
        const colIndex = headers.indexOf(columnName);

        if (colIndex < 0) {
          if (window.toastr) window.toastr.warning('未找到目标列');
          $btn.prop('disabled', false).html('<i class="fa-solid fa-magic"></i> 自动修复');
          return;
        }

        // 如果有配对表，使用配对修复逻辑
        if (pairedTableName) {
          // 找到配对表
          let pairedSheet = null;
          let pairedSheetId = null;
          for (const sheetId in rawData) {
            if (rawData[sheetId]?.name === pairedTableName) {
              pairedSheet = rawData[sheetId];
              pairedSheetId = sheetId;
              break;
            }
          }

          if (!pairedSheet || !pairedSheet.content || pairedSheet.content.length < 1) {
            if (window.toastr) window.toastr.warning(`未找到配对表: ${pairedTableName}`);
            $btn.prop('disabled', false).html('<i class="fa-solid fa-magic"></i> 自动修复');
            return;
          }

          const pairedHeaders = pairedSheet.content[0] || [];
          const pairedColIndex = pairedHeaders.indexOf(columnName);

          if (pairedColIndex < 0) {
            if (window.toastr) window.toastr.warning(`配对表中未找到目标列: ${columnName}`);
            $btn.prop('disabled', false).html('<i class="fa-solid fa-magic"></i> 自动修复');
            return;
          }

          // 提取两个表的编码
          const extract1 = extractCodesFromTable(targetSheet, columnName, prefix);
          const extract2 = extractCodesFromTable(pairedSheet, columnName, prefix);

          // 构建编码映射
          const mapping = buildCodeMapping(extract1.allCodes, extract2.allCodes, prefix, startFrom);

          // 对齐和修复
          const { fixedCount1, fixedCount2 } = alignAndFixPairedTables(
            targetSheet,
            targetSheetId,
            pairedSheet,
            pairedSheetId,
            columnName,
            mapping,
            prefix,
            startFrom,
            rawData,
          );

          // 保存数据
          await saveDataToDatabase(rawData, false, false);
          closeDialog();
          renderInterface();
        } else {
          // 原有的单表修复逻辑
          // 提取所有编码索引的数字部分
          const numbers = [];
          for (let i = 0; i < rows.length; i++) {
            const value = rows[i]?.[colIndex];
            if (value === null || value === undefined || value === '') continue;

            const strValue = String(value).trim();
            if (!strValue) continue;

            let num = null;
            if (prefix) {
              const match = strValue.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
              if (match) {
                num = parseInt(match[1], 10);
              }
            } else {
              num = parseInt(strValue, 10);
            }

            if (!isNaN(num)) {
              numbers.push({ rowIndex: i, value: strValue, num });
            }
          }

          // 按行索引排序
          numbers.sort((a, b) => a.rowIndex - b.rowIndex);

          // 修复编号
          let fixedCount = 0;
          for (let i = 0; i < numbers.length; i++) {
            const expectedNum = startFrom + i;
            const actualNum = numbers[i].num;
            const rowIndex = numbers[i].rowIndex;

            if (actualNum !== expectedNum) {
              const fixedValue = prefix + String(expectedNum).padStart(4, '0');
              rows[rowIndex][colIndex] = fixedValue;
              fixedCount++;
            }
          }

          // 保存数据
          await saveDataToDatabase(rawData, false, false);
          closeDialog();
          renderInterface();
        }
      } catch (e) {
        console.error('[DICE]ACU 修复序列递增失败:', e);
        if (window.toastr) window.toastr.error('修复失败: ' + (e.message || '未知错误'));
        $btn.prop('disabled', false).html('<i class="fa-solid fa-magic"></i> 自动修复');
      }
    });

    // 删除多余行
    dialog.on('click', '#smart-fix-delete-rows', async function () {
      const startRow = parseInt($(this).data('start'), 10);
      const tableName = $(this).data('table');

      try {
        for (const sheetId in rawData) {
          if (rawData[sheetId]?.name === tableName) {
            // 保留表头(index 0)和前 startRow 行数据(index 1 到 startRow)
            rawData[sheetId].content = rawData[sheetId].content.slice(0, startRow + 1);
            break;
          }
        }

        await saveDataToDatabase(rawData, false, false);
        closeDialog();
        renderInterface();
      } catch (e) {
        console.error('[DICE]ACU 删除行失败:', e);
        if (window.toastr) window.toastr.error('删除失败: ' + (e.message || '未知错误'));
      }
    });
  };

  // ========================================
  // 属性预设管理面板
  // ========================================

  // 黑名单管理模态框
  const showBlacklistManagerModal = () => {
    const { $ } = getCore();
    const config = getConfig();

    $('.acu-blacklist-manager-overlay').remove();

    const blacklist = BlacklistManager.getBlacklist();

    const modalHtml = `
      <div class="acu-blacklist-manager-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="max-width: 600px; width: 90%;">
          <div class="acu-edit-title" style="position: relative;">
            <i class="fa-solid fa-filter"></i> 变量过滤黑名单管理
            <button class="acu-close-btn" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--acu-text-main); cursor: pointer; font-size: 18px; z-index: 10;">
              <i class="fa-solid fa-times"></i>
            </button>
          </div>
          <div class="acu-settings-content" style="flex: 1; overflow-y: auto; padding: 20px;">
            <div style="margin-bottom: 15px;">
              <div style="margin-bottom: 8px; font-size: 12px; color: var(--acu-text-sub);">
                黑名单中的关键词对应的最下层变量名或列名将不会显示快捷骰子图标
              </div>
              <textarea id="blacklist-textarea" style="width: 100%; min-height: 120px; max-height: 300px; padding: 10px !important; border: 1px solid var(--acu-border) !important; border-radius: 4px !important; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; font-size: 13px !important; box-sizing: border-box !important; resize: vertical; font-family: monospace; line-height: 1.5;" placeholder="输入关键词，用逗号分隔（支持中英文逗号）"></textarea>
              <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: nowrap;">
                <input type="text" id="blacklist-input" placeholder="输入关键词..." style="flex: 1; min-width: 0; padding: 8px !important; border: 1px solid var(--acu-border) !important; border-radius: 4px !important; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; font-size: 13px !important; box-sizing: border-box !important;">
                <button id="blacklist-add-btn" style="padding: 8px 16px; background: var(--acu-accent); color: var(--acu-btn-active-text); border: none; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap; flex-shrink: 0;">
                  <i class="fa-solid fa-plus"></i> 添加
                </button>
              </div>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 15px;">
              <button id="blacklist-reset-btn" style="flex: 1; padding: 10px; background: var(--acu-btn-bg); color: var(--acu-text-main); border: 1px solid var(--acu-text-sub); border-radius: 4px; cursor: pointer; font-size: 13px;">
                <i class="fa-solid fa-undo"></i> 重置为默认
              </button>
              <button id="blacklist-close-btn" style="flex: 1; padding: 10px; background: var(--acu-accent); color: var(--acu-btn-active-text); border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">
                <i class="fa-solid fa-check"></i> 完成
              </button>
            </div>
          </div>
        </div>
      </div>
    `;

    const $modal = $(modalHtml);
    $('body').append($modal);

    // 设置模态框样式
    $modal.css({
      position: 'fixed',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      width: '100vw',
      height: '100vh',
      background: 'rgba(0,0,0,0.6)',
      'z-index': '31300',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center',
      padding: '20px',
      'box-sizing': 'border-box',
    });

    // 更新textarea内容
    const updateTextarea = () => {
      const blacklist = BlacklistManager.getBlacklist();
      const $textarea = $modal.find('#blacklist-textarea');
      $textarea.val(blacklist.join('，'));
    };

    // 从textarea同步到BlacklistManager
    const syncFromTextarea = () => {
      const $textarea = $modal.find('#blacklist-textarea');
      const text = $textarea.val().trim();
      if (!text) {
        BlacklistManager.setBlacklist([]);
        return;
      }
      // 支持中英文逗号分隔
      const items = text
        .split(/[，,]/)
        .map(s => s.trim())
        .filter(s => s.length > 0);
      // 去重
      const uniqueItems = [...new Set(items)];
      BlacklistManager.setBlacklist(uniqueItems);
      // 更新textarea（去除重复后）
      if (uniqueItems.length !== items.length) {
        updateTextarea();
      }
    };

    // 初始化textarea
    updateTextarea();

    // textarea内容变化时同步
    $modal.find('#blacklist-textarea').on('input', function () {
      syncFromTextarea();
    });

    // 添加按钮：支持批量添加（逗号分隔）
    $modal.find('#blacklist-add-btn').click(function () {
      const input = $modal.find('#blacklist-input');
      const value = input.val().trim();
      if (!value) return;

      // 支持中英文逗号分隔批量添加
      const newItems = value
        .split(/[，,]/)
        .map(s => s.trim())
        .filter(s => s.length > 0);

      if (newItems.length === 0) return;

      const blacklist = BlacklistManager.getBlacklist();
      const existingSet = new Set(blacklist);
      const addedItems = [];

      newItems.forEach(item => {
        if (!existingSet.has(item)) {
          blacklist.push(item);
          existingSet.add(item);
          addedItems.push(item);
        }
      });

      if (addedItems.length === 0) {
        if (window.toastr) window.toastr.warning('所有项已存在');
        return;
      }

      BlacklistManager.setBlacklist(blacklist);
      input.val('');
      updateTextarea();
    });

    $modal.find('#blacklist-input').on('keypress', function (e) {
      if (e.which === 13) {
        $modal.find('#blacklist-add-btn').click();
      }
    });

    $modal.find('#blacklist-reset-btn').click(function () {
      if (confirm('确定要重置黑名单为默认值吗？')) {
        BlacklistManager.resetToDefault();
        updateTextarea();
      }
    });

    const closeModal = () => {
      $modal.remove();
      // 重新渲染界面以应用黑名单变化
      renderInterface();
    };

    $modal.find('#blacklist-close-btn, .acu-close-btn').click(closeModal);
    setupOverlayClose($modal, 'acu-blacklist-manager-overlay', closeModal);
  };

  const showAttributePresetManager = () => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showAttributePresetManager', showAttributePresetManager);

    const config = getConfig();
    const presets = AttributePresetManager.getAllPresets();
    const activeId = Store.get(STORAGE_KEY_ACTIVE_ATTR_PRESET, null);

    // 生成默认规则项HTML（当activeId为null时启用）
    const isDefaultActive = activeId === null;
    const defaultPresetHtml = `
      <div class="acu-preset-item" data-id="__default__">
        <div class="acu-preset-info">
          <div class="acu-preset-name">
            六维属性百分制
            <span style="font-size: 10px; color: var(--acu-text-sub); margin-left: 6px;">(默认)</span>
          </div>
          <div class="acu-preset-desc">使用百分制生成六维基础属性（力量、敏捷、体质、智力、感知、魅力），范围5-95</div>
          <div class="acu-preset-stats">
            基础属性: 6 | 特别属性: 0
          </div>
        </div>
<div class="acu-preset-actions" style="display: flex; align-items: center; gap: 8px;">
            <label class="acu-toggle" style="margin: 0;">
              <input type="checkbox" class="acu-preset-toggle" data-id="__default__" ${isDefaultActive ? 'checked' : ''}>
              <span class="acu-toggle-slider"></span>
            </label>
            <button class="acu-preset-btn acu-preset-copy" data-id="__default__" title="复制为自定义预设"><i class="fa-solid fa-copy"></i></button>
            <button class="acu-preset-btn acu-preset-export" data-id="__default__" title="导出"><i class="fa-solid fa-download"></i></button>
          </div>
        </div>
    `;

    // 生成预设列表HTML
    const presetsHtml = presets
      .map(preset => {
        const isActive = preset.id === activeId;
        const isBuiltin = preset.builtin;

        return `
        <div class="acu-preset-item" data-id="${preset.id}">
          <div class="acu-preset-info">
            <div class="acu-preset-name">
              ${escapeHtml(preset.name)}
              ${isBuiltin ? `<span style="font-size: 10px; color: var(--acu-text-sub); margin-left: 6px;">(内置)</span>` : ''}
            </div>
            ${preset.description ? `<div class="acu-preset-desc">${escapeHtml(preset.description)}</div>` : ''}
            <div class="acu-preset-stats">
              基础属性: ${preset.baseAttributes.length} | 特别属性: ${preset.specialAttributes?.length || 0}
            </div>
          </div>
          <div class="acu-preset-actions" style="display: flex; align-items: center; gap: 8px;">
            <label class="acu-toggle" style="margin: 0;">
              <input type="checkbox" class="acu-preset-toggle" data-id="${preset.id}" ${isActive ? 'checked' : ''}>
              <span class="acu-toggle-slider"></span>
            </label>
            ${
              isBuiltin
                ? `<button class="acu-preset-btn acu-preset-copy" data-id="${preset.id}" title="复制为自定义预设"><i class="fa-solid fa-copy"></i></button>`
                : `<button class="acu-preset-btn acu-preset-edit" data-id="${preset.id}" title="编辑"><i class="fa-solid fa-pen"></i></button>`
            }
            <button class="acu-preset-btn acu-preset-export" data-id="${preset.id}" title="导出"><i class="fa-solid fa-download"></i></button>
            ${!isBuiltin ? `<button class="acu-preset-btn acu-preset-delete" data-id="${preset.id}" title="删除" style="color: var(--acu-error-text);"><i class="fa-solid fa-trash"></i></button>` : ''}
          </div>
        </div>
      `;
      })
      .join('');

    // 合并默认规则和预设列表
    const allPresetsHtml = defaultPresetHtml + presetsHtml;

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 600px; max-width: 92vw; max-height: 80vh;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border);">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-dice-d20"></i> 自定义属性规则管理
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div id="acu-presets-list">
              ${allPresetsHtml || `<div style="text-align: center; padding: 40px; color: var(--acu-text-sub);">暂无预设</div>`}
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border);">
            <button id="acu-preset-new" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-plus"></i> 新建预设
            </button>
            <button id="acu-preset-import" style="flex: 1; padding: 10px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-file-import"></i> 导入
            </button>
            <button id="acu-preset-back" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-arrow-left"></i> 返回
            </button>
          </div>

          <input type="file" id="acu-preset-file-input" accept=".json" style="display: none;" />
        </div>
      </div>
    `);

    $('body').append(overlay);

    // 关闭按钮
    overlay.find('.acu-close-btn, #acu-preset-back').on('click', () => {
      overlay.remove();
      popModal();
    });

    // Toggle切换预设激活状态
    overlay.on('change', '.acu-preset-toggle', function () {
      const $toggle = $(this);
      const id = $toggle.data('id');
      const isChecked = $toggle.is(':checked');

      if (isChecked) {
        // 激活该预设（如果是默认规则，id为"__default__"，需要设置为null）
        const finalId = id === '__default__' ? null : id;
        AttributePresetManager.setActivePreset(finalId);

        // 将其他所有toggle设置为未选中状态（确保只有一个激活）
        overlay.find('.acu-preset-toggle').each(function () {
          const $thisToggle = $(this);
          const thisId = $thisToggle.data('id');
          if (thisId !== id) {
            $thisToggle.prop('checked', false);
          }
        });
      } else {
        // 取消激活（设置为null，使用默认规则）
        AttributePresetManager.setActivePreset(null);
      }
    });

    // 编辑预设
    overlay.on('click', '.acu-preset-edit', function () {
      const id = $(this).data('id');
      overlay.remove();
      showAttributePresetEditor(id);
    });

    // 导出预设
    overlay.on('click', '.acu-preset-export', function () {
      const id = $(this).data('id');

      let json;
      let filename;

      if (id === '__default__') {
        // 导出默认预设（六维属性百分制）
        const STANDARD_ATTRS = ['力量', '敏捷', '体质', '智力', '感知', '魅力'];
        const defaultPresetData = {
          format: 'acu_attr_preset_v1',
          version: PRESET_FORMAT_VERSION,
          id: 'default_percentile',
          name: '六维属性百分制',
          description: '使用百分制生成六维基础属性（力量、敏捷、体质、智力、感知、魅力），范围5-95',
          baseAttributes: STANDARD_ATTRS.map(name => ({
            name,
            formula: '3d6*5',
            range: [15, 90],
            modifier: '1d10-5',
          })),
          specialAttributes: [],
        };
        json = JSON.stringify(defaultPresetData, null, 2);
        filename = `acu_preset_六维属性百分制_${Date.now()}.json`;
      } else {
        json = AttributePresetManager.exportPreset(id);
        if (!json) {
          if (window.toastr) window.toastr.error('导出失败');
          return;
        }
        const preset = presets.find(p => p.id === id);
        filename = `acu_preset_${preset?.name || id}_${Date.now()}.json`;
      }

      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 删除预设
    overlay.on('click', '.acu-preset-delete', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);

      if (confirm(`确定要删除预设「${preset?.name}」吗？`)) {
        const success = AttributePresetManager.deletePreset(id);
        if (success) {
          overlay.remove();
          showAttributePresetManager();
        } else {
          if (window.toastr) window.toastr.error('删除失败');
        }
      }
    });

    // 复制预设为自定义预设
    overlay.on('click', '.acu-preset-copy', function () {
      const id = $(this).data('id');

      let copyData;
      if (id === '__default__') {
        // 复制默认预设（六维属性百分制）
        // 使用与内置预设相同的数据结构：formula + range + modifier
        const STANDARD_ATTRS = ['力量', '敏捷', '体质', '智力', '感知', '魅力'];
        copyData = {
          name: '六维属性百分制 (副本)',
          description: '使用百分制生成六维基础属性（力量、敏捷、体质、智力、感知、魅力），范围5-95',
          baseAttributes: STANDARD_ATTRS.map(name => ({
            name,
            formula: '3d6*5',
            range: [15, 90],
            modifier: '1d10-5',
          })),
          specialAttributes: [],
        };
      } else {
        // 复制内置预设
        const preset = presets.find(p => p.id === id);
        if (!preset) return;

        copyData = {
          name: preset.name + ' (副本)',
          description: preset.description || '',
          baseAttributes: JSON.parse(JSON.stringify(preset.baseAttributes)),
          specialAttributes: JSON.parse(JSON.stringify(preset.specialAttributes || [])),
        };
      }

      const newPreset = AttributePresetManager.createPreset(copyData);
      if (newPreset) {
        if (window.toastr) window.toastr.success(`已创建副本：${newPreset.name}`);
        overlay.remove();
        showAttributePresetManager(); // 刷新列表
      }
    });

    // 新建预设
    overlay.find('#acu-preset-new').on('click', () => {
      overlay.remove();
      showAttributePresetEditor();
    });

    // 导入预设
    overlay.find('#acu-preset-import').on('click', () => {
      overlay.find('#acu-preset-file-input').click();
    });

    overlay.find('#acu-preset-file-input').on('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const jsonStr = evt.target.result as string;
          if (!jsonStr?.trim()) return;

          // 先解析JSON获取预设名称，检查是否有同名预设
          let parsedData;
          try {
            parsedData = JSON.parse(jsonStr.trim());
          } catch {
            if (window.toastr) window.toastr.error('JSON格式无效');
            return;
          }

          const importingName = parsedData?.name || '导入的预设';
          const existingPresets = AttributePresetManager.getAllPresets();
          const existingNames = existingPresets.map(p => p.name);
          const hasConflict = existingNames.includes(importingName);

          // 执行导入的函数
          const doImport = (overwrite: boolean, newName?: string) => {
            // 如果需要重命名，修改JSON中的名称
            let finalJson = jsonStr.trim();
            if (newName) {
              parsedData.name = newName;
              // 同时生成新的ID避免ID冲突
              parsedData.id = `attr_preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              finalJson = JSON.stringify(parsedData);
            }

            // 如果是覆盖模式且存在同名预设，先删除旧预设
            if (overwrite && hasConflict) {
              const existingPreset = existingPresets.find(p => p.name === importingName);
              if (existingPreset && !existingPreset.builtin) {
                AttributePresetManager.deletePreset(existingPreset.id);
              }
            }

            const imported = AttributePresetManager.importPreset(finalJson);
            if (imported) {
              overlay.remove();
              showAttributePresetManager();
            } else {
              if (window.toastr) window.toastr.error('导入失败：格式不正确');
            }
          };

          // 如果有冲突，显示冲突处理弹窗
          if (hasConflict) {
            showPresetConflictDialog({
              presetName: importingName,
              presetType: '属性规则',
              existingNames,
              onOverwrite: () => doImport(true),
              onRename: newName => doImport(false, newName),
              onCancel: () => {},
            });
          } else {
            // 无冲突，直接导入
            doImport(false);
          }
        } catch (err) {
          console.error('[DICE]ACU 导入预设失败:', err);
          if (window.toastr) window.toastr.error('导入失败');
        }
      };
      reader.readAsText(file);

      // 重置输入框
      $(this).val('');
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };

  // 规则预设编辑器
  const showAttributePresetEditor = (presetId = null) => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showAttributePresetEditor', () => showAttributePresetEditor(presetId));

    const config = getConfig();
    const isEdit = !!presetId;
    const existingPreset = isEdit ? AttributePresetManager.getAllPresets().find(p => p.id === presetId) : null;

    // 默认值
    const defaultData = {
      name: existingPreset?.name || '新规则预设',
      description: existingPreset?.description || '',
      baseAttributes: existingPreset?.baseAttributes || [
        { name: '力量', formula: '3d6', range: [3, 18] },
        { name: '敏捷', formula: '3d6', range: [3, 18] },
        { name: '体质', formula: '3d6', range: [3, 18] },
        { name: '智力', formula: '3d6', range: [3, 18] },
        { name: '感知', formula: '3d6', range: [3, 18] },
        { name: '魅力', formula: '3d6', range: [3, 18] },
      ],
      specialAttributes: existingPreset?.specialAttributes || [],
    };

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 650px; max-width: 95vw; max-height: 85vh;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border);">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-pen"></i> ${isEdit ? '编辑' : '新建'}规则预设
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">预设名称</label>
              <input id="preset-name" type="text" value="${escapeHtml(defaultData.name)}" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">描述</label>
              <input id="preset-desc" type="text" value="${escapeHtml(defaultData.description)}" placeholder="可选" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 8px;">
                JSON配置 <span style="font-size: 10px; color: var(--acu-text-sub);">(支持直接编辑或导入)</span>
              </label>
              <textarea id="preset-json" class="acu-preset-editor-textarea" style="width: 100%; height: 320px; padding: 10px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; font-family: 'Consolas', 'Monaco', monospace !important; font-size: 12px; resize: vertical; box-sizing: border-box;"></textarea>
            </div>

            <div style="font-size: 11px; color: var(--acu-text-sub); padding: 8px; background: var(--acu-table-head); border-radius: 6px; line-height: 1.6;">
              <strong>配置格式说明：</strong><br/>
              • baseAttributes: 基本属性数组，每项包含 name、formula、range、modifier(可选)<br/>
              • specialAttributes: 特别属性数组，每项包含 name、formula、range(可选)<br/>
              • 公式支持: 3d6, 4d6kh3, 变量引用(力量/2), 数学运算(+、-、*、/)
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border);">
            <button id="preset-save" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px; font-weight: bold;">
              <i class="fa-solid fa-check"></i> 保存
            </button>
            <button id="preset-cancel" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-times"></i> 取消
            </button>
          </div>
        </div>
      </div>
    `);

    $('body').append(overlay);

    const $jsonTextarea = overlay.find('#preset-json');

    // 初始化JSON
    const updateJSON = () => {
      const data = {
        baseAttributes: defaultData.baseAttributes,
        specialAttributes: defaultData.specialAttributes,
      };
      $jsonTextarea.val(JSON.stringify(data, null, 2));
    };
    updateJSON();

    // 关闭
    overlay.find('.acu-close-btn, #preset-cancel').on('click', () => {
      overlay.remove();
      popModal();
    });

    // 保存
    overlay.find('#preset-save').on('click', () => {
      try {
        const name = overlay.find('#preset-name').val().trim();
        const description = overlay.find('#preset-desc').val().trim();
        const jsonStr = $jsonTextarea.val().trim();

        if (!name) {
          if (window.toastr) window.toastr.warning('请输入预设名称');
          return;
        }

        // 解析JSON
        const jsonData = JSON.parse(jsonStr);

        // 校验必需字段
        if (
          !jsonData.baseAttributes ||
          !Array.isArray(jsonData.baseAttributes) ||
          jsonData.baseAttributes.length === 0
        ) {
          if (window.toastr) window.toastr.error('基本属性不能为空');
          return;
        }

        // 构建预设
        const preset = {
          format: 'acu_attr_preset_v1',
          version: 1,
          id: presetId || `custom_${Date.now()}`,
          name,
          description,
          baseAttributes: jsonData.baseAttributes,
          specialAttributes: jsonData.specialAttributes || [],
        };

        // 保存
        if (isEdit) {
          AttributePresetManager.updatePreset(presetId, preset);
        } else {
          AttributePresetManager.createPreset(preset);
        }

        overlay.remove();
        popModal();
      } catch (err) {
        console.error('[DICE]ACU 保存预设失败:', err);
        if (window.toastr) window.toastr.error('保存失败：' + (err.message || 'JSON格式错误'));
      }
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };

  // ========================================
  // 高级骰子预设UI
  // ========================================
  type SortableListOptions = {
    container: JQuery | HTMLElement;
    itemSelector: string;
    handleSelector?: string;
    cancelSelector?: string;
    onOrderChange: (newOrder: string[]) => void;
    getItemId: (item: HTMLElement) => string | null;
    ghostClass?: string;
    dragClass?: string;
    placeholderClass?: string;
    indicatorClass?: string;
    longPressDelay?: number;
  };

  const createSortableList = (options: SortableListOptions) => {
    const containerEl = options.container instanceof HTMLElement ? options.container : options.container[0];
    if (!containerEl) return;

    const ghostClass = options.ghostClass ?? 'acu-drag-ghost';
    const dragClass = options.dragClass ?? 'acu-dragging';
    const placeholderClass = options.placeholderClass ?? 'acu-drag-placeholder';
    const indicatorClass = options.indicatorClass ?? 'acu-drag-indicator';
    const longPressDelay = options.longPressDelay ?? 350;

    const state = {
      isDragging: false,
      draggedItem: null as HTMLElement | null,
      ghost: null as HTMLElement | null,
      indicator: null as HTMLElement | null,
      timer: null as number | null,
      startX: 0,
      startY: 0,
      pointerId: null as number | null,
      offsetX: 0,
      offsetY: 0,
      startOrder: [] as string[],
    };

    const buildOrder = () => {
      const ids: string[] = [];
      const items = containerEl.querySelectorAll<HTMLElement>(options.itemSelector);
      items.forEach(item => {
        const id = options.getItemId(item);
        if (id) ids.push(id);
      });
      return ids;
    };

    const clearTimer = () => {
      if (state.timer) {
        window.clearTimeout(state.timer);
        state.timer = null;
      }
    };

    const cleanupGhost = () => {
      if (state.ghost && state.ghost.parentElement) {
        state.ghost.parentElement.removeChild(state.ghost);
      }
      state.ghost = null;
    };

    const cleanupIndicator = () => {
      if (state.indicator && state.indicator.parentElement) {
        state.indicator.parentElement.removeChild(state.indicator);
      }
      state.indicator = null;
    };

    const updateGhostPosition = (clientX: number, clientY: number) => {
      if (!state.ghost) return;
      state.ghost.style.left = `${clientX - state.offsetX}px`;
      state.ghost.style.top = `${clientY - state.offsetY}px`;
    };

    const ensureIndicator = () => {
      if (!state.indicator) {
        const indicator = document.createElement('div');
        indicator.className = indicatorClass;
        state.indicator = indicator;
      }
      return state.indicator;
    };

    const placeIndicator = (clientY: number) => {
      if (!state.draggedItem) return;
      const items = Array.from(containerEl.querySelectorAll<HTMLElement>(options.itemSelector)).filter(
        item => item !== state.draggedItem,
      );
      let target: HTMLElement | null = null;
      let insertBefore = true;

      for (const item of items) {
        const rect = item.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (clientY < midY) {
          target = item;
          insertBefore = true;
          break;
        }
        if (clientY >= rect.top && clientY <= rect.bottom) {
          target = item;
          insertBefore = false;
        }
      }

      const indicator = ensureIndicator();
      if (target) {
        if (insertBefore) containerEl.insertBefore(indicator, target);
        else containerEl.insertBefore(indicator, target.nextSibling);
      } else {
        containerEl.appendChild(indicator);
      }
    };

    const startDrag = (
      item: HTMLElement,
      clientX: number,
      clientY: number,
      pointerId: number,
      captureEl: HTMLElement,
    ) => {
      if (state.isDragging) return;
      state.isDragging = true;
      state.draggedItem = item;
      state.pointerId = pointerId;
      state.startOrder = buildOrder();

      const rect = item.getBoundingClientRect();
      state.offsetX = clientX - rect.left;
      state.offsetY = clientY - rect.top;

      const ghost = item.cloneNode(true) as HTMLElement;
      ghost.classList.add(ghostClass);
      ghost.style.width = `${rect.width}px`;
      ghost.style.height = `${rect.height}px`;
      ghost.style.left = `${rect.left}px`;
      ghost.style.top = `${rect.top}px`;
      ghost.style.position = 'fixed';
      ghost.style.margin = '0';
      ghost.style.pointerEvents = 'none';
      document.body.appendChild(ghost);
      state.ghost = ghost;

      item.classList.add(placeholderClass);
      item.classList.add(dragClass);

      updateGhostPosition(clientX, clientY);
      placeIndicator(clientY);

      if (captureEl.setPointerCapture) {
        captureEl.setPointerCapture(pointerId);
      }
    };

    const finishDrag = () => {
      if (!state.isDragging || !state.draggedItem) {
        clearTimer();
        cleanupIndicator();
        cleanupGhost();
        return;
      }

      if (state.indicator && state.indicator.parentElement === containerEl) {
        containerEl.replaceChild(state.draggedItem, state.indicator);
      }

      const finalRect = state.draggedItem.getBoundingClientRect();
      const draggedItem = state.draggedItem;
      const ghost = state.ghost;
      if (ghost) {
        ghost.style.transition = 'left 0.18s ease, top 0.18s ease, opacity 0.18s ease';
        ghost.style.left = `${finalRect.left}px`;
        ghost.style.top = `${finalRect.top}px`;
        ghost.style.opacity = '0';
        window.setTimeout(() => {
          if (ghost.parentElement) ghost.parentElement.removeChild(ghost);
        }, 180);
      }

      window.setTimeout(() => {
        draggedItem.classList.remove(placeholderClass);
        draggedItem.classList.remove(dragClass);
      }, 180);

      cleanupIndicator();
      if (!ghost) cleanupGhost();

      const newOrder = buildOrder();
      const orderChanged = state.startOrder.join('|') !== newOrder.join('|');

      state.isDragging = false;
      state.draggedItem = null;
      state.pointerId = null;
      state.startOrder = [];
      clearTimer();

      if (orderChanged) options.onOrderChange(newOrder);
    };

    containerEl.addEventListener(
      'pointerdown',
      e => {
        const target = e.target as HTMLElement | null;
        if (!target) return;
        if (options.cancelSelector && target.closest(options.cancelSelector)) return;

        const item = target.closest(options.itemSelector) as HTMLElement | null;
        if (!item) return;

        const handle = options.handleSelector ? (target.closest(options.handleSelector) as HTMLElement | null) : null;

        if (handle) {
          e.preventDefault();
          startDrag(item, e.clientX, e.clientY, e.pointerId, handle);
          return;
        }

        if (!options.handleSelector) {
          e.preventDefault();
          startDrag(item, e.clientX, e.clientY, e.pointerId, item);
          return;
        }

        state.startX = e.clientX;
        state.startY = e.clientY;
        state.pointerId = e.pointerId;
        clearTimer();
        state.timer = window.setTimeout(() => {
          startDrag(item, state.startX, state.startY, state.pointerId ?? e.pointerId, item);
        }, longPressDelay);
      },
      { passive: false },
    );

    containerEl.addEventListener(
      'pointermove',
      e => {
        if (state.timer && (Math.abs(e.clientY - state.startY) > 8 || Math.abs(e.clientX - state.startX) > 8)) {
          clearTimer();
        }

        if (!state.isDragging || !state.draggedItem) return;
        e.preventDefault();
        updateGhostPosition(e.clientX, e.clientY);
        placeIndicator(e.clientY);
      },
      { passive: false },
    );

    containerEl.addEventListener('pointerup', finishDrag);
    containerEl.addEventListener('pointercancel', finishDrag);
    containerEl.addEventListener(
      'touchmove',
      e => {
        if (state.isDragging) {
          e.preventDefault();
        }
      },
      { passive: false },
    );
  };

  // 刷新已打开的检定面板的预设按钮
  const refreshDicePanelPresets = () => {
    const { $ } = getCore();
    const $panel = $('.acu-dice-panel');
    if ($panel.length === 0) return; // 面板未打开，无需刷新

    // 重新生成预设按钮HTML
    const presets = AdvancedDicePresetManager.getAllPresets()
      .filter(p => p.visible !== false)
      .sort((a, b) => (a.order || 0) - (b.order || 0));

    let html = `<button class="acu-dice-quick-preset-btn" data-id="__custom__">自定义</button>`;
    presets.forEach(p => {
      html += `<button class="acu-dice-quick-preset-btn" data-id="${escapeHtml(p.id)}">${escapeHtml(p.name)}</button>`;
    });

    // 替换预设按钮区域内容
    $panel.find('.acu-dice-quick-presets').html(html);
  };

  const showPresetListDialog = (options: { fromDicePanel?: boolean } = {}) => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();

    const config = getConfig();
    const presets = AdvancedDicePresetManager.getAllPresets();
    const fromDicePanel = options.fromDicePanel === true;

    // 将当前弹窗推入栈中
    pushModal('showPresetListDialog', () => showPresetListDialog(options));

    const presetsHtml = presets
      .sort((a, b) => (a.order ?? 999) - (b.order ?? 999))
      .map(preset => {
        const isBuiltin = preset.builtin;
        const isVisible = preset.visible !== false;

        return `
        <div class="acu-preset-item${!isVisible ? ' acu-preset-hidden' : ''}" data-id="${preset.id}" draggable="false">
           <div class="acu-preset-check" title="点击切换显示/隐藏" style="padding: 8px; cursor: pointer; color: var(--acu-text-sub); display: flex; align-items: center; justify-content: center; width: 30px;">
            <i class="fa-solid ${isVisible ? 'fa-eye' : 'fa-eye-slash'}" style="${!isVisible ? 'opacity: 0.6;' : ''}"></i>
          </div>
          <div class="acu-preset-info" style="flex: 1;">
            <div class="acu-preset-name">
              ${escapeHtml(preset.name)}
              ${isBuiltin ? `<span style="font-size: 10px; color: var(--acu-text-sub); margin-left: 6px;">(内置)</span>` : ''}
            </div>
            ${preset.description ? `<div class="acu-preset-desc">${escapeHtml(preset.description)}</div>` : ''}
            <div class="acu-preset-stats">
              骰子: ${escapeHtml(preset.diceExpression)} | 判定分支: ${preset.outcomes?.length || 0}个
            </div>
          </div>
          <div class="acu-preset-actions" style="display: flex; align-items: center; gap: 8px;">
            ${
              isBuiltin
                ? `<button class="acu-preset-btn acu-advanced-preset-copy" data-id="${preset.id}" title="复制为自定义预设"><i class="fa-solid fa-copy"></i></button>`
                : `<button class="acu-preset-btn acu-advanced-preset-edit" data-id="${preset.id}" title="编辑"><i class="fa-solid fa-pen"></i></button>`
            }
            <button class="acu-preset-btn acu-advanced-preset-export" data-id="${preset.id}" title="导出"><i class="fa-solid fa-download"></i></button>
            ${!isBuiltin ? `<button class="acu-preset-btn acu-advanced-preset-delete" data-id="${preset.id}" title="删除" style="color: var(--acu-error-text);"><i class="fa-solid fa-trash"></i></button>` : ''}
          </div>
          <div class="acu-preset-handle" title="拖拽排序" style="cursor: grab; padding: 4px; color: var(--acu-text-sub); touch-action: none; display: flex; align-items: center; justify-content: center; width: 22px;">
            <i class="fa-solid fa-grip-vertical"></i>
          </div>
        </div>
      `;
      })
      .join('');

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 600px; max-width: 92vw; max-height: 85vh; display: flex; flex-direction: column;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border); flex-shrink: 0;">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-sliders"></i> 检定预设管理
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div class="acu-table-manager-hint" style="font-size:11px;color:var(--acu-text-sub);margin-bottom:8px;padding:0 4px;">
              <i class="fa-solid fa-info-circle"></i> 点击眼睛图标切换显示，拖拽条目或手柄排序
            </div>
            <div id="acu-advanced-presets-list" style="display: flex; flex-direction: column; gap: 8px;">
              ${presetsHtml || `<div style="text-align: center; padding: 40px; color: var(--acu-text-sub);">暂无预设</div>`}
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border); flex-shrink: 0;">
            <button id="acu-advanced-preset-new" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-plus"></i> 新建预设
            </button>
            <button id="acu-advanced-preset-import" style="flex: 1; padding: 10px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-file-import"></i> 导入
            </button>
            <button id="acu-advanced-preset-back" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-arrow-left"></i> 返回
            </button>
          </div>

          <input type="file" id="acu-advanced-preset-file-input" accept=".json" style="display: none;" />
        </div>
      </div>
    `);

    $('body').append(overlay);

    overlay.find('.acu-close-btn, #acu-advanced-preset-back').on('click', () => {
      overlay.remove();
      popModal(); // 返回上一个弹窗
    });

    overlay.on('click', '.acu-preset-check', function (e) {
      e.stopPropagation();
      const $item = $(this).closest('.acu-preset-item');
      const id = $item.data('id');
      const preset = presets.find(p => p.id === id);
      if (!preset) return;

      const isVisible = preset.visible !== false;
      if (preset.builtin) {
        AdvancedDicePresetManager.setBuiltinPresetVisibility(id, !isVisible);
      } else {
        AdvancedDicePresetManager.updatePreset(id, { visible: !isVisible });
      }
      showPresetListDialog({ fromDicePanel });
      refreshDicePanelPresets();
    });

    overlay.on('click', '.acu-advanced-preset-edit', function () {
      const id = $(this).data('id');
      overlay.remove();
      showAdvancedPresetEditor(id);
    });

    overlay.on('click', '.acu-advanced-preset-copy', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);
      if (!preset) return;

      const copied = {
        ...preset,
        name: preset.name + ' (副本)',
        id: undefined,
        builtin: false,
      };
      AdvancedDicePresetManager.createPreset(copied);
      overlay.remove();
      showPresetListDialog({ fromDicePanel });
      refreshDicePanelPresets();
    });

    overlay.on('click', '.acu-advanced-preset-export', function () {
      const id = $(this).data('id');
      const json = AdvancedDicePresetManager.exportPreset(id);
      if (!json) {
        if (window.toastr) window.toastr.error('导出失败');
        return;
      }
      const preset = presets.find(p => p.id === id);
      const filename = `acu_advanced_preset_${preset?.name || id}_${Date.now()}.json`;

      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    overlay.on('click', '.acu-advanced-preset-delete', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);

      if (confirm(`确定要删除预设「${preset?.name}」吗？`)) {
        try {
          AdvancedDicePresetManager.deletePreset(id);
          overlay.remove();
          showPresetListDialog({ fromDicePanel });
          refreshDicePanelPresets();
        } catch (err) {
          if (window.toastr) window.toastr.error('删除失败: ' + err.message);
        }
      }
    });

    overlay.find('#acu-advanced-preset-new').on('click', () => {
      overlay.remove();
      showAdvancedPresetEditor();
    });

    overlay.find('#acu-advanced-preset-import').on('click', () => {
      overlay.find('#acu-advanced-preset-file-input').trigger('click');
    });

    const $list = overlay.find('#acu-advanced-presets-list');
    createSortableList({
      container: $list,
      itemSelector: '.acu-preset-item',
      handleSelector: '.acu-preset-handle',
      cancelSelector: '.acu-preset-actions button, .acu-toggle, .acu-preset-check',
      getItemId: item => {
        const id = $(item).data('id');
        if (typeof id === 'string') return id;
        if (id !== undefined && id !== null) return String(id);
        return null;
      },
      onOrderChange: newOrderIds => {
        newOrderIds.forEach((id, index) => {
          AdvancedDicePresetManager.setPresetOrder(id, index);
        });
        refreshDicePanelPresets();
      },
    });

    overlay.find('#acu-advanced-preset-file-input').on('change', function (e) {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = ev => {
        try {
          const jsonStr = ev.target?.result as string;
          const result = AdvancedDicePresetManager.importPreset(jsonStr);
          if (result) {
            overlay.remove();
            showPresetListDialog({ fromDicePanel });
            refreshDicePanelPresets();
          } else {
            if (window.toastr) window.toastr.error('导入失败: 格式错误');
          }
        } catch (err) {
          if (window.toastr) window.toastr.error('导入失败: ' + (err.message || '未知错误'));
        }
      };
      reader.readAsText(file);
    });

    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal(); // 返回上一个弹窗
    });
  };

  const showAdvancedPresetManager = (options: { fromDicePanel?: boolean } = {}) => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showAdvancedPresetManager', () => showAdvancedPresetManager(options));

    const config = getConfig();
    const diceCfg = getDiceConfig();
    const fromDicePanel = options.fromDicePanel === true;

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 600px; max-width: 92vw; max-height: 85vh; display: flex; flex-direction: column;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border); flex-shrink: 0;">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-dice-d20"></i> 检定设置
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

           <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
              <div class="acu-setting-row">
                  <div class="acu-setting-info">
                      <span class="acu-setting-label"><i class="fa-solid fa-sliders"></i> 检定预设</span>
                  </div>
                  <button id="acu-open-preset-list" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                      <i class="fa-solid fa-cog"></i> 管理
                  </button>
              </div>
              <div class="acu-setting-row" style="margin-top: 12px;">
                  <div class="acu-setting-info">
                      <span class="acu-setting-label"><i class="fa-solid fa-gem"></i> 自定义属性预设</span>
                  </div>
                  <button id="acu-open-attr-preset" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                      <i class="fa-solid fa-cog"></i> 管理
                  </button>
              </div>
              <div class="acu-setting-row" style="margin-top: 12px;">
                  <div class="acu-setting-info">
                      <span class="acu-setting-label"><i class="fa-solid fa-fire"></i> 疯狂模式</span>
                  </div>
                  <select id="cfg-crazy-mode" class="acu-setting-select" style="width: 90px; min-width: 90px; text-align: center; text-align-last: center;">
                      <option value="0">○ 关闭</option>
                      <option value="25">◔ 低</option>
                      <option value="50">◑ 中</option>
                      <option value="75">◕ 高</option>
                      <option value="100">● 极限</option>
                  </select>
              </div>
              <div style="padding-top: 12px; border-top: 1px solid var(--acu-border);">
                <div class="acu-setting-row acu-setting-row-toggle" style="margin-bottom: 8px;">
                    <div class="acu-setting-info">
                        <span class="acu-setting-label">隐藏输入栏中的检定结果</span>
                    </div>
                    <label class="acu-toggle">
                        <input type="checkbox" id="cfg-hide-dice-result" ${diceCfg.hideDiceResultFromUser ? 'checked' : ''}>
                        <span class="acu-toggle-slider"></span>
                    </label>
                </div>
                 <div class="acu-setting-row acu-setting-row-toggle">
                    <div class="acu-setting-info">
                        <span class="acu-setting-label">隐藏聊天记录中的检定结果</span>
                    </div>
                    <label class="acu-toggle">
                        <input type="checkbox" id="cfg-hide-dice-result-chat" ${diceCfg.hideDiceResultInChat ? 'checked' : ''}>
                        <span class="acu-toggle-slider"></span>
                    </label>
                </div>
            </div>
           </div>
         </div>
      </div>
    `);

    $('body').append(overlay);

    // 关闭按钮
    overlay.find('.acu-close-btn').on('click', () => {
      overlay.remove();
      popModal();
    });

    overlay.find('#acu-open-preset-list').on('click', () => {
      overlay.remove();
      showPresetListDialog({ fromDicePanel });
    });

    overlay.find('#acu-open-attr-preset').on('click', () => {
      overlay.remove();
      showAttributePresetManager();
    });

    // 疯狂模式设置
    const initCrazyModeUI = () => {
      const crazyConfig = getCrazyModeConfig();
      // 根据enabled和crazyLevel设置下拉框的值
      const selectValue = crazyConfig.enabled ? crazyConfig.crazyLevel : 0;
      overlay.find('#cfg-crazy-mode').val(selectValue);

      // 下拉选择事件
      overlay.find('#cfg-crazy-mode').on('change', function () {
        const value = parseInt($(this).val() as string, 10);
        if (value === 0) {
          saveCrazyModeConfig({ enabled: false, crazyLevel: 50 });
        } else {
          saveCrazyModeConfig({ enabled: true, crazyLevel: value });
        }
      });
    };
    initCrazyModeUI();

    // 隐藏设置开关
    overlay.find('#cfg-hide-dice-result').on('change', function () {
      const hide = $(this).is(':checked');
      saveDiceConfig({ hideDiceResultFromUser: hide });
      console.info('[DICE]应用投骰结果隐藏/显示设置(输入栏)...', hide);
      hideDiceResultsInUserMessages();
    });

    overlay.find('#cfg-hide-dice-result-chat').on('change', function () {
      const hide = $(this).is(':checked');
      saveDiceConfig({ hideDiceResultInChat: hide });
      console.info('[DICE]应用投骰结果隐藏/显示设置(聊天记录)...', hide);
      // 这里不需要立即重新渲染聊天，因为只有新生成的才会受影响，
      // 或者如果需要立即生效可能需要重新处理dom，但通常只需保存配置
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };

  const showAdvancedPresetEditor = (presetId = null) => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showAdvancedPresetEditor', () => showAdvancedPresetEditor(presetId));

    const config = getConfig();
    const isEdit = !!presetId;
    const existingPreset = isEdit ? AdvancedDicePresetManager.getAllPresets().find(p => p.id === presetId) : null;

    // 默认值 - 完整示例模板，展示所有可用字段
    const defaultData = existingPreset
      ? JSON.parse(JSON.stringify(existingPreset))
      : {
          name: '新检定预设',
          description: '自定义检定规则示例',
          diceExpression: '1d20',
          attribute: {
            label: '属性值',
            placeholder: '留空=10',
            defaultValue: 10,
            key: '属性值',
          },
          dc: {
            label: '难度等级(DC)',
            placeholder: '留空=10',
            defaultValue: 10,
          },
          mod: {
            label: '修正值',
            placeholder: '留空=0',
            defaultValue: 0,
          },
          customFields: [
            {
              id: 'advantage',
              type: 'select',
              label: '优势/劣势',
              defaultValue: 0,
              options: [
                { label: '正常', value: 0 },
                { label: '优势', value: 1 },
                { label: '劣势', value: -1 },
              ],
            },
          ],
          derivedVars: [{ id: 'attrMod', expr: 'floor(($attr - 10) / 2)' }],
          dicePatches: [
            { when: '$advantage > 0', op: 'replace', template: '2d20kh1' },
            { when: '$advantage < 0', op: 'replace', template: '2d20kl1' },
          ],
          outcomes: [
            {
              id: 'crit_success',
              name: '大成功',
              condition: "$roll.hasTag('nat20')",
              priority: 1,
              rank: 3,
              contestRank: 100,
            },
            {
              id: 'success',
              name: '成功',
              condition: '$roll.total + $attrMod + $mod >= $dc',
              priority: 10,
              rank: 1,
              contestRank: 60,
            },
            {
              id: 'failure',
              name: '失败',
              condition: '$roll.total + $attrMod + $mod < $dc',
              displayExpr: '$roll.total + $attrMod + $mod >= $dc',
              priority: 50,
              rank: 0,
              contestRank: 40,
            },
            {
              id: 'crit_failure',
              name: '大失败',
              condition: "$roll.hasTag('nat1')",
              priority: 2,
              rank: -1,
              contestRank: 20,
            },
          ],
          contestRule: {
            mode: 'rank',
            tieBreakers: ['higher_roll', 'initiator_wins'],
          },
          outputTemplate:
            '<meta:检定结果>\n$outcomeText\n元叙事：$initiator 发起了 $attrName 检定，$formula=$roll，判定 $conditionExpr？$judgeResult，判定为【$outcomeName】\n</meta:检定结果>',
          contestOutputTemplate: '',
          secondaryTriggerMode: 'first',
          secondaryMaxDepth: 3,
          secondaryEffects: [],
        };

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 650px; max-width: 95vw; max-height: 85vh;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border);">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-pen"></i> ${isEdit ? '编辑' : '新建'}检定设置
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">预设名称</label>
              <input id="advanced-preset-name" type="text" value="${escapeHtml(defaultData.name)}" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">描述</label>
              <input id="advanced-preset-desc" type="text" value="${escapeHtml(defaultData.description)}" placeholder="可选" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 8px;">
                JSON配置 <span style="font-size: 10px; color: var(--acu-text-sub);">(支持直接编辑或导入)</span>
              </label>
              <textarea id="advanced-preset-json" class="acu-preset-editor-textarea" style="width: 100%; height: 400px; padding: 10px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; font-family: 'Consolas', 'Monaco', monospace !important; font-size: 12px; resize: vertical; box-sizing: border-box;"></textarea>
            </div>

            <div style="font-size: 11px; color: var(--acu-text-sub); padding: 8px; background: var(--acu-table-head); border-radius: 6px; line-height: 1.6;">
              <strong>配置格式说明：</strong><br/>
              <strong>骰子表达式 (diceExpression)</strong><br/>
              • 基础: "1d20", "3d6", "4dF" (Fate骰)<br/>
              • 保留/舍弃: "4d6kh3" (保留最高3个), "2d20kl1" (保留最低1个)<br/>
              • 成功计数: "4d6=3" (统计=3的个数), "6d10>=7" (统计≥7的个数)<br/>
              • CoC奖惩骰: "1d100b1" (奖励骰), "1d100p2" (2个惩罚骰)<br/>
              • 爆炸骰: "4d6!" (最大值爆炸), "4d6!!" (累加爆炸)<br/>
              <br/>
              <strong>$roll 对象属性</strong><br/>
              • $roll.total: 骰子结果总和（或成功计数）<br/>
              • $roll.hasTag('nat20'): 检查是否有自然20（仅d20）<br/>
              • $roll.hasTag('nat1'): 检查是否有自然1（仅d20）<br/>
              <br/>
              <strong>输入字段配置</strong><br/>
              • attribute: 属性值 { label, placeholder, defaultValue, hidden, key? }<br/>
              • dc: 目标值 { label, placeholder, defaultValue, hidden }<br/>
              • mod: 修正值 { label, placeholder, defaultValue, hidden }<br/>
              <br/>
              <strong>判定结果 (outcomes)</strong><br/>
              • 数组，每项: { id, name, condition, priority, rank?, contestRank? }<br/>
              • condition: 表达式如 "$roll.total >= $dc", "$roll.total == 4"<br/>
              • priority: 数字越小越优先匹配<br/>
              <br/>
              <strong>高级功能</strong><br/>
              • customFields: 自定义字段 [{ id, type, label, defaultValue, options? }]<br/>
              • derivedVars: 派生变量 [{ id, expr }] 如 { id: "mod", expr: "floor(($attr-10)/2)" }<br/>
              • dicePatches: 条件骰子 [{ when?, op, template }]<br/>
              • contestRule: 对抗规则 { disabled?, mode, tieBreakers }<br/>
              <br/>
              <strong>输出模板变量</strong><br/>
              • $roll, $attr, $dc, $mod, $outcomeName, $formula, $initiator 等<br/>
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border);">
            <button id="advanced-preset-save" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px; font-weight: bold;">
              <i class="fa-solid fa-check"></i> 保存
            </button>
            <button id="advanced-preset-cancel" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-times"></i> 取消
            </button>
          </div>
        </div>
      </div>
    `);

    $('body').append(overlay);

    const $jsonTextarea = overlay.find('#advanced-preset-json');

    // 初始化JSON
    $jsonTextarea.val(JSON.stringify(defaultData, null, 2));

    // 关闭
    overlay.find('.acu-close-btn, #advanced-preset-cancel').on('click', () => {
      overlay.remove();
      popModal();
    });

    // 保存
    overlay.find('#advanced-preset-save').on('click', () => {
      try {
        const name = overlay.find('#advanced-preset-name').val().trim();
        const description = overlay.find('#advanced-preset-desc').val().trim();
        const jsonStr = $jsonTextarea.val().trim();

        if (!name) {
          if (window.toastr) window.toastr.warning('请输入预设名称');
          return;
        }

        // 解析JSON
        const jsonData = JSON.parse(jsonStr);

        // 校验必需字段
        if (
          !jsonData.diceExpression ||
          !jsonData.outcomes ||
          !Array.isArray(jsonData.outcomes) ||
          jsonData.outcomes.length === 0
        ) {
          if (window.toastr) window.toastr.error('骰子表达式和判定结果列表(outcomes)不能为空');
          return;
        }

        // 验证每个 outcome 必填字段
        for (const outcome of jsonData.outcomes) {
          if (!outcome.id || !outcome.name || outcome.condition === undefined || outcome.priority === undefined) {
            if (window.toastr)
              window.toastr.error(
                `判定结果 "${outcome.name || outcome.id || '未知'}" 缺少必填字段(id, name, condition, priority)`,
              );
            return;
          }
        }

        // 构建预设
        const preset = {
          ...(isEdit && existingPreset ? existingPreset : {}),
          ...(isEdit ? {} : { builtin: false }),
          ...jsonData,
          kind: 'advanced' as const,
          version: PRESET_FORMAT_VERSION,
          id: presetId || `custom_${Date.now()}`,
          name,
          description,
        };

        // 保存
        if (isEdit) {
          AdvancedDicePresetManager.updatePreset(presetId, preset);
        } else {
          AdvancedDicePresetManager.createPreset(preset);
        }

        overlay.remove();
        popModal();
        refreshDicePanelPresets(); // 刷新检定面板预设按钮
      } catch (err) {
        console.error('[DICE]ACU 保存高级预设失败:', err);
        const errMsg = err.message || '';
        if (errMsg.includes('JSON') || errMsg.includes('position') || errMsg.includes('token')) {
          if (window.toastr)
            window.toastr.error('JSON格式错误：请确保所有键名和字符串值都用双引号包裹，例如 "name": "值"');
        } else {
          if (window.toastr) window.toastr.error('保存失败：' + (errMsg || '未知错误'));
        }
      }
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };

  // ========================================
  // 自定义交互规则管理
  // ========================================
  const showActionPresetManager = () => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showActionPresetManager', showActionPresetManager);

    const config = getConfig();
    const presets = ActionPresetManager.getAllPresets();
    const activeId = ActionPresetManager.getActivePresetId();

    // 生成预设列表HTML
    const presetsHtml =
      presets.length === 0
        ? `<div style="text-align: center; padding: 40px; color: var(--acu-text-sub);">暂无自定义规则，点击下方按钮创建</div>`
        : presets
            .map(preset => {
              const isActive = preset.id === activeId;
              const isBuiltin = (preset as any).builtin === true;
              const keywordsSummary =
                (preset.rules || [])
                  .flatMap(r => r.table_keywords || [])
                  .slice(0, 3)
                  .join('、') || '无';
              const actionsSummary =
                (preset.rules || [])
                  .flatMap(r => (r.actions || []).map(a => a.label))
                  .slice(0, 4)
                  .join('、') || '无';

              return `
          <div class="acu-preset-item" data-id="${preset.id}">
            <div class="acu-preset-info">
              <div class="acu-preset-name">${escapeHtml(preset.name)}${isBuiltin ? `<span style="font-size: 10px; color: var(--acu-text-sub); margin-left: 6px;">(内置)</span>` : ''}</div>
              ${preset.description ? `<div class="acu-preset-desc">${escapeHtml(preset.description)}</div>` : ''}
              <div class="acu-preset-stats" style="font-size: 11px; color: var(--acu-text-sub);">
                关键词: ${escapeHtml(keywordsSummary)} | 动作: ${escapeHtml(actionsSummary)}
              </div>
            </div>
            <div class="acu-preset-actions" style="display: flex; align-items: center; gap: 8px;">
              <label class="acu-toggle" style="margin: 0;">
                <input type="checkbox" class="acu-action-preset-toggle" data-id="${preset.id}" ${isActive ? 'checked' : ''}>
                <span class="acu-toggle-slider"></span>
              </label>
              ${
                isBuiltin
                  ? `<button class="acu-preset-btn acu-action-preset-copy" data-id="${preset.id}" title="复制为自定义规则"><i class="fa-solid fa-copy"></i></button>`
                  : `<button class="acu-preset-btn acu-action-preset-edit" data-id="${preset.id}" title="编辑"><i class="fa-solid fa-pen"></i></button>`
              }
              <button class="acu-preset-btn acu-action-preset-export" data-id="${preset.id}" title="导出"><i class="fa-solid fa-download"></i></button>
              ${!isBuiltin ? `<button class="acu-preset-btn acu-action-preset-delete" data-id="${preset.id}" title="删除" style="color: var(--acu-error-text);"><i class="fa-solid fa-trash"></i></button>` : ''}
            </div>
          </div>
        `;
            })
            .join('');

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 600px; max-width: 92vw; max-height: 80vh;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border);">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-wand-magic-sparkles"></i> 自定义交互规则管理
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div id="acu-action-presets-list">
              ${presetsHtml}
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border);">
            <button id="acu-action-preset-new" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-plus"></i> 新建规则
            </button>
            <button id="acu-action-preset-import" style="flex: 1; padding: 10px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-file-import"></i> 导入
            </button>
            <button id="acu-action-preset-back" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-arrow-left"></i> 返回
            </button>
          </div>
        </div>
      </div>
    `);

    $('body').append(overlay);

    // 关闭按钮
    overlay.find('.acu-close-btn, #acu-action-preset-back').on('click', () => {
      overlay.remove();
      popModal();
    });

    // Toggle切换预设激活状态（单选）
    overlay.on('change', '.acu-action-preset-toggle', function () {
      const $toggle = $(this);
      const id = $toggle.data('id');
      const isChecked = $toggle.is(':checked');

      if (isChecked) {
        ActionPresetManager.setActivePresetId(id);
        // 取消其他toggle
        overlay.find('.acu-action-preset-toggle').each(function () {
          if ($(this).data('id') !== id) {
            $(this).prop('checked', false);
          }
        });
      } else {
        // 只有当取消的是当前激活的预设时，才清空
        if (ActionPresetManager.getActivePresetId() === id) {
          ActionPresetManager.setActivePresetId(null);
          if (window.toastr) window.toastr.info('所有交互规则已禁用');
        }
      }
    });

    // 编辑预设
    overlay.on('click', '.acu-action-preset-edit', function () {
      const id = $(this).data('id');
      overlay.remove();
      showActionPresetEditor(id);
    });

    // 导出预设 - 下载为JSON文件
    overlay.on('click', '.acu-action-preset-export', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);
      const json = ActionPresetManager.exportPreset(id);
      if (!json) {
        if (window.toastr) window.toastr.error('导出失败');
        return;
      }

      // 下载为JSON文件
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${preset?.name || '交互规则'}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      if (window.toastr) window.toastr.success('已导出文件');
    });

    // 复制内置预设为自定义预设
    overlay.on('click', '.acu-action-preset-copy', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);
      if (!preset) return;

      const copyData = {
        name: preset.name + ' (副本)',
        description: preset.description || '',
        rules: JSON.parse(JSON.stringify(preset.rules)),
      };

      const newPreset = ActionPresetManager.createPreset(copyData);
      if (newPreset) {
        if (window.toastr)
          window.toastr.success(`已创建副本：${newPreset.name}，包含 ${newPreset.rules.length} 个规则组`);
        overlay.remove();
        showActionPresetManager(); // 刷新列表而不是打开编辑器
      }
    });

    // 删除预设
    overlay.on('click', '.acu-action-preset-delete', function () {
      const id = $(this).data('id');
      const preset = presets.find(p => p.id === id);

      if (confirm(`确定要删除规则「${preset?.name}」吗？`)) {
        const success = ActionPresetManager.deletePreset(id);
        if (success) {
          overlay.remove();
          showActionPresetManager();
        } else {
          if (window.toastr) window.toastr.error('删除失败');
        }
      }
    });

    // 新建预设
    overlay.find('#acu-action-preset-new').on('click', () => {
      overlay.remove();
      showActionPresetEditor();
    });

    // 导入预设 - 选择JSON文件上传
    overlay.find('#acu-action-preset-import').on('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = () => {
        const file = input.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
          const jsonStr = e.target?.result as string;
          if (!jsonStr?.trim()) {
            if (window.toastr) window.toastr.error('文件内容为空');
            return;
          }

          const result = ActionPresetManager.importPreset(jsonStr.trim());
          if (result) {
            if (window.toastr) window.toastr.success(`导入成功：${result.name}`);
            overlay.remove();
            showActionPresetManager();
          } else {
            if (window.toastr) window.toastr.error('导入失败，请检查JSON格式');
          }
        };
        reader.onerror = () => {
          if (window.toastr) window.toastr.error('文件读取失败');
        };
        reader.readAsText(file);
      };
      input.click();
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };

  // 交互规则编辑器（JSON配置风格）
  const showActionPresetEditor = (presetId?: string) => {
    const { $ } = getCore();
    $('.acu-edit-overlay').remove();
    pushModal('showActionPresetEditor', () => showActionPresetEditor(presetId));

    const config = getConfig();
    const isEdit = !!presetId;
    const existingPreset = isEdit ? ActionPresetManager.getPresetById(presetId) : null;

    // 默认值
    const defaultData = {
      name: existingPreset?.name || '新交互规则',
      description: existingPreset?.description || '',
      rules: existingPreset?.rules || [
        {
          table_keywords: ['地点（输入表格名关键词，表名中包含关键词的表格将应用此规则）', '场所'],
          actions: [
            {
              label: '前往（按钮显示的文字）',
              template:
                '<user>对{Name}执行互动:前往。（点击按钮后发送的内容，{Name}会替换为表格第一列的列名，一般为名称）',
            },
            {
              label: '调查',
              template: '<user>仔细调查了{Name}的情况。',
            },
          ],
        },
        {
          table_keywords: ['魔法', '奥术'],
          actions: [
            {
              label: '学习',
              template: '<user>尝试学习{Name}。',
            },
            {
              label: '释放',
              template: '<user>释放了{Name}！',
            },
          ],
        },
      ],
    };

    const overlay = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-theme-${config.theme}" style="width: 700px; max-width: 95vw; max-height: 85vh;">
          <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 12px; border-bottom: 1px solid var(--acu-border);">
            <div style="font-size: 16px; font-weight: bold; color: var(--acu-text-main);">
              <i class="fa-solid fa-wand-magic-sparkles"></i> ${isEdit ? '编辑' : '新建'}交互规则
            </div>
            <button class="acu-close-btn"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex: 1; overflow-y: auto; padding: 12px 0;">
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">预设名称</label>
              <input id="action-preset-name" type="text" value="${escapeHtml(defaultData.name)}" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 4px;">描述</label>
              <input id="action-preset-desc" type="text" value="${escapeHtml(defaultData.description)}" placeholder="可选" class="acu-preset-editor-input" style="width: 100%; padding: 8px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; box-sizing: border-box;" />
            </div>

            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 12px; color: var(--acu-text-sub); margin-bottom: 8px;">
                JSON配置 <span style="font-size: 10px; color: var(--acu-text-sub);">(必须使用标准JSON格式：键名和字符串值都要用双引号)</span>
              </label>
              <textarea id="action-preset-json" class="acu-preset-editor-textarea" style="width: 100%; height: 300px; padding: 10px; border: 1px solid var(--acu-border) !important; border-radius: 6px; background: var(--acu-input-bg) !important; color: var(--acu-text-main) !important; font-family: 'Consolas', 'Monaco', monospace; font-size: 12px; resize: vertical; box-sizing: border-box;"></textarea>
            </div>

            <div style="font-size: 11px; color: var(--acu-text-sub); padding: 8px; background: var(--acu-table-head); border-radius: 6px; line-height: 1.6;">
              <strong>配置格式说明：</strong><br/>
              • 每个规则包含 table_keywords（表名关键词数组）和 actions（动作数组）<br/>
              • 动作包含 label（按钮文字）和 template（发送模板，{Name}为行名称）<br/>
              • 示例: { "table_keywords": ["人物"], "actions": [{ "label": "交谈", "template": "<user>与{Name}交谈。" }] }
            </div>
          </div>

          <div style="display: flex; gap: 8px; padding-top: 12px; border-top: 1px solid var(--acu-border);">
            <button id="action-preset-save" style="flex: 1; padding: 10px; background: var(--acu-accent); border: none; border-radius: 6px; color: var(--acu-btn-active-text); cursor: pointer; font-size: 13px; font-weight: bold;">
              <i class="fa-solid fa-check"></i> 保存
            </button>
            <button id="action-preset-cancel" style="padding: 10px 16px; background: var(--acu-btn-bg); border: 1px solid var(--acu-text-sub); border-radius: 6px; color: var(--acu-text-main); cursor: pointer; font-size: 13px;">
              <i class="fa-solid fa-times"></i> 取消
            </button>
          </div>
        </div>
      </div>
    `);

    $('body').append(overlay);

    const $jsonTextarea = overlay.find('#action-preset-json');

    // 初始化JSON（只显示 rules 部分）
    $jsonTextarea.val(JSON.stringify(defaultData.rules, null, 2));

    // 关闭
    overlay.find('.acu-close-btn, #action-preset-cancel').on('click', () => {
      overlay.remove();
      popModal();
    });

    // 保存
    overlay.find('#action-preset-save').on('click', () => {
      try {
        const name = (overlay.find('#action-preset-name').val() as string).trim();
        const description = (overlay.find('#action-preset-desc').val() as string).trim();
        const jsonStr = ($jsonTextarea.val() as string).trim();

        if (!name) {
          if (window.toastr) window.toastr.warning('请输入预设名称');
          return;
        }

        // 解析JSON
        const rules = JSON.parse(jsonStr);

        // 校验格式
        if (!Array.isArray(rules) || rules.length === 0) {
          if (window.toastr) window.toastr.error('规则不能为空，需要至少一个规则');
          return;
        }

        // 校验每个规则
        for (let i = 0; i < rules.length; i++) {
          const rule = rules[i];
          if (!rule.table_keywords || !Array.isArray(rule.table_keywords) || rule.table_keywords.length === 0) {
            if (window.toastr) window.toastr.error(`规则 ${i + 1} 缺少 table_keywords`);
            return;
          }
          if (!rule.actions || !Array.isArray(rule.actions) || rule.actions.length === 0) {
            if (window.toastr) window.toastr.error(`规则 ${i + 1} 缺少 actions`);
            return;
          }
        }

        if (isEdit && presetId) {
          // 更新现有预设
          ActionPresetManager.updatePreset(presetId, { name, description, rules });
          if (window.toastr) window.toastr.success('规则已更新');
        } else {
          // 创建新预设
          ActionPresetManager.createPreset({ name, description, rules });
          if (window.toastr) window.toastr.success('规则已创建');
        }

        overlay.remove();
        popModal();
      } catch (e) {
        if (window.toastr) window.toastr.error('JSON 格式错误: ' + (e as Error).message);
      }
    });

    // 点击遮罩关闭
    setupOverlayClose(overlay, 'acu-edit-overlay', () => {
      overlay.remove();
      popModal();
    });
  };
  // ========================================
  const showDebugConsoleModal = () => {
    const { $ } = getCore();
    $('.acu-edit-overlay').not(':has(.acu-debug-console-dialog)').remove();
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;

    // 获取过滤状态（从localStorage读取）
    const savedFilters = Store.get('acu_debug_filters', { log: true, info: true, warn: true, error: true });
    ConsoleCaptureManager.setFilters(savedFilters);

    const renderLogs = () => {
      const filteredLogs = ConsoleCaptureManager.getFilteredLogs();
      const $logContainer = dialog.find('.acu-debug-log-container');
      $logContainer.empty();

      if (filteredLogs.length === 0) {
        $logContainer.html(`
          <div class="acu-debug-empty">
            <i class="fa-solid fa-inbox"></i>
            <div class="acu-debug-empty-text">暂无日志</div>
            <div class="acu-debug-empty-hint">开启 Console 抓取后，日志将显示在这里</div>
          </div>
        `);
        return;
      }

      filteredLogs.forEach(log => {
        const logItem = $(`
          <div class="acu-debug-log-item" data-type="${log.type}">
            <div class="acu-debug-log-header">
              <span class="acu-debug-log-time">${log.timeStr}</span>
              <span class="acu-debug-log-type ${log.type}">${log.type.toUpperCase()}</span>
            </div>
            <div class="acu-debug-log-content">${escapeHtml(log.content)}</div>
            ${log.stack ? `<div class="acu-debug-log-stack">${escapeHtml(log.stack)}</div>` : ''}
          </div>
        `);
        $logContainer.append(logItem);
      });
    };

    const dialog = $(`
      <div class="acu-edit-overlay">
        <div class="acu-edit-dialog acu-debug-console-dialog ${currentThemeClass}">
          <div class="acu-settings-header">
            <div class="acu-settings-title"><i class="fa-solid fa-bug"></i> Debug控制台</div>
            <button class="acu-close-btn" id="debug-console-close"><i class="fa-solid fa-times"></i></button>
          </div>

          <div style="flex:1;display:flex;flex-direction:column;overflow:hidden;">
            <!-- 工具栏 -->
            <div class="acu-debug-toolbar">
              <!-- Console抓取开关 -->
              <div class="acu-debug-capture-row">
                <span class="acu-debug-capture-label">Console 抓取</span>
                <label class="acu-toggle">
                  <input type="checkbox" id="debug-console-capture-toggle" ${ConsoleCaptureManager.enabled ? 'checked' : ''}>
                  <span class="acu-toggle-slider"></span>
                </label>
                <span id="debug-console-capture-status" class="acu-debug-capture-status ${ConsoleCaptureManager.enabled ? 'enabled' : 'disabled'}">${ConsoleCaptureManager.enabled ? '已启用' : '已关闭'}</span>
              </div>
              <!-- 过滤按钮组 -->
              <div class="acu-debug-filter-group">
                <button class="acu-debug-filter-btn ${savedFilters.log ? 'active' : ''}" data-filter-type="log">
                  <i class="fa-solid fa-circle indicator"></i> Log
                </button>
                <button class="acu-debug-filter-btn ${savedFilters.info ? 'active' : ''}" data-filter-type="info">
                  <i class="fa-solid fa-info-circle indicator"></i> Info
                </button>
                <button class="acu-debug-filter-btn ${savedFilters.warn ? 'active' : ''}" data-filter-type="warn">
                  <i class="fa-solid fa-exclamation-triangle indicator"></i> Warn
                </button>
                <button class="acu-debug-filter-btn ${savedFilters.error ? 'active' : ''}" data-filter-type="error">
                  <i class="fa-solid fa-exclamation-circle indicator"></i> Error
                </button>
              </div>
              <!-- 操作按钮 -->
              <div class="acu-debug-actions">
                <button class="acu-debug-action-btn danger" id="debug-console-clear">
                  <i class="fa-solid fa-trash"></i> <span class="btn-text">清空</span>
                </button>
                <button class="acu-debug-action-btn" id="debug-console-copy">
                  <i class="fa-solid fa-copy"></i> <span class="btn-text">复制</span>
                </button>
                <button class="acu-debug-action-btn primary" id="debug-console-export">
                  <i class="fa-solid fa-download"></i> <span class="btn-text">导出</span>
                </button>
              </div>
            </div>

            <!-- 日志显示区域 -->
            <div class="acu-debug-log-scroll">
              <div class="acu-debug-log-container"></div>
            </div>

            <!-- 底部状态栏 -->
            <div class="acu-debug-footer">
              <div class="acu-debug-stats">
                <div class="acu-debug-stat">
                  <span>总计</span>
                  <span class="acu-debug-stat-value" id="debug-total-count">0</span>
                </div>
                <div class="acu-debug-stat">
                  <span>显示</span>
                  <span class="acu-debug-stat-value" id="debug-filtered-count">0</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `);

    $('body').append(dialog);

    // 更新计数
    const updateCounts = () => {
      const total = ConsoleCaptureManager.logs.length;
      const filtered = ConsoleCaptureManager.getFilteredLogs().length;
      dialog.find('#debug-total-count').text(total);
      dialog.find('#debug-filtered-count').text(filtered);
    };

    // 初始渲染
    renderLogs();
    updateCounts();

    // Console抓取开关
    dialog.find('#debug-console-capture-toggle').on('change', function () {
      const checked = $(this).is(':checked');
      const $status = dialog.find('#debug-console-capture-status');
      if (checked) {
        ConsoleCaptureManager.enable();
        $status.text('已启用').removeClass('disabled').addClass('enabled');
        // 添加启动日志
        console.log('[DICE]Debug控制台抓取模式已开启');
      } else {
        ConsoleCaptureManager.disable();
        $status.text('已关闭').removeClass('enabled').addClass('disabled');
      }
    });

    // 过滤选项变化
    dialog.find('.acu-debug-filter-btn').on('click', function () {
      const type = $(this).data('filter-type');
      const isActive = $(this).hasClass('active');
      const newState = !isActive;

      // 更新按钮样式
      if (newState) {
        $(this).addClass('active');
      } else {
        $(this).removeClass('active');
      }

      // 更新过滤器
      ConsoleCaptureManager.setFilters({ [type]: newState });
      Store.set('acu_debug_filters', ConsoleCaptureManager.filters);
      renderLogs();
      updateCounts();
    });

    // 清空日志（直接清空，不弹窗）
    dialog.find('#debug-console-clear').on('click', () => {
      ConsoleCaptureManager.clear();
      renderLogs();
      updateCounts();
    });

    // 复制日志
    dialog.find('#debug-console-copy').on('click', async () => {
      const filteredLogs = ConsoleCaptureManager.getFilteredLogs();
      if (filteredLogs.length === 0) {
        if (window.toastr) window.toastr.warning('没有可复制的日志');
        return;
      }

      const text = filteredLogs
        .map(log => {
          let line = `[${log.timeStr}] [${log.type.toUpperCase()}] ${log.content}`;
          if (log.stack) {
            line += '\n' + log.stack;
          }
          return line;
        })
        .join('\n');

      try {
        // 优先使用酒馆接口
        if (window.TavernHelper && window.TavernHelper.triggerSlash) {
          const safeContent = text.replace(/\"/g, '\\"').replace(/\}/g, '\\}');
          await window.TavernHelper.triggerSlash(`/clipboard-set "${safeContent}"`);
          return;
        }
        // 使用浏览器原生API
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
        } else {
          // 降级方案：使用execCommand
          const textArea = document.createElement('textarea');
          textArea.value = text;
          textArea.style.position = 'fixed';
          textArea.style.left = '-9999px';
          textArea.style.top = '0';
          textArea.setAttribute('readonly', '');
          document.body.appendChild(textArea);
          textArea.select();
          textArea.setSelectionRange(0, 99999);
          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);
          if (!successful) {
            throw new Error('execCommand failed');
          }
        }
      } catch (err) {
        console.error('[DICE]DebugConsole 复制失败:', err);
        if (window.toastr) window.toastr.error('复制失败');
      }
    });

    // 导出日志
    dialog.find('#debug-console-export').on('click', () => {
      const filteredLogs = ConsoleCaptureManager.getFilteredLogs();
      if (filteredLogs.length === 0) {
        if (window.toastr) window.toastr.warning('没有可导出的日志');
        return;
      }

      const text = filteredLogs
        .map(log => {
          let line = `[${log.timeStr}] [${log.type.toUpperCase()}] ${log.content}`;
          if (log.stack) {
            line += '\n' + log.stack;
          }
          return line;
        })
        .join('\n\n');

      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `debug-console-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 关闭按钮
    dialog.find('#debug-console-close, .acu-edit-overlay').on('click', function (e) {
      if (e.target === this || $(e.target).closest('.acu-close-btn').length) {
        dialog.remove();
      }
    });

    // 定期刷新日志显示（实时模式）
    // [已删除] 自动滚动功能，避免出错
    const refreshInterval = setInterval(() => {
      if (dialog.length && dialog.is(':visible')) {
        renderLogs();
        updateCounts();
      }
    }, 500);

    // 窗口关闭时清理定时器
    dialog.on('remove', () => {
      clearInterval(refreshInterval);
    });
  };

  // ========================================
  // showAddRegexRuleModal - 添加/编辑正则转换规则弹窗 (Phase 4.2)
  // ========================================
  const showAddRegexRuleModal = (editRuleId?: string) => {
    const { $ } = getCore();
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;

    // 获取要编辑的规则(如果有)
    const editRule = editRuleId ? RegexTransformationManager.getRule(editRuleId) : null;

    // 获取所有表格名
    const tableData = cachedRawData || getTableData();
    const tableNames = Object.keys(tableData || {})
      .filter(k => k.startsWith('sheet_'))
      .map(k => tableData[k]?.name || k)
      .sort();

    const dialog = $(`
      <div class="acu-edit-overlay acu-validation-modal-overlay">
        <div class="acu-edit-dialog acu-validation-modal ${currentThemeClass}">
          <div class="acu-dice-cfg-header">
            <span><i class="fa-solid fa-magic"></i> ${editRule ? '编辑' : '添加'}正则转换规则</span>
            <button class="acu-config-close" id="acu-close-regex-rule"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="acu-validation-modal-body">
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">规则名称 *</span></div>
              <input type="text" id="rule-name" class="acu-panel-input" value="${editRule ? escapeHtml(editRule.name) : ''}" placeholder="例如: 清理多余空格" style="flex:1;" required>
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">规则描述</span></div>
              <textarea id="rule-description" class="acu-panel-input" placeholder="输入规则介绍" style="flex:1; resize: none; overflow-wrap: break-word; overflow-y: hidden; min-height: 34px; height: 34px; line-height: 1.4;">${editRule ? escapeHtml(editRule.description || '') : ''}</textarea>
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">匹配模式 *</span></div>
              <input type="text" id="rule-pattern" class="acu-panel-input" value="${editRule ? escapeHtml(editRule.pattern) : ''}" placeholder="例如: \\s+ 或 /test/g" style="flex:1; font-family: monospace;" required>
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">替换内容</span></div>
              <input type="text" id="rule-replacement" class="acu-panel-input" value="${editRule ? escapeHtml(editRule.replacement || '') : ''}" placeholder="留空表示删除,或使用 $1, $2 等捕获组" style="flex:1; font-family: monospace;">
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">作用范围 *</span></div>
              <select id="rule-scope-type" class="acu-setting-select" style="width:120px;">
                <option value="global" ${editRule?.scope?.type === 'global' ? 'selected' : ''}>全局</option>
                <option value="table" ${editRule?.scope?.type === 'table' ? 'selected' : ''}>表级</option>
                <option value="column" ${editRule?.scope?.type === 'column' ? 'selected' : ''}>列级</option>
              </select>
            </div>
            <div class="acu-setting-row" id="field-table-names" style="display: ${editRule?.scope?.type === 'global' ? 'none' : 'flex'};">
              <div class="acu-setting-info"><span class="acu-setting-label">表格名 (多个用逗号分隔)</span></div>
              <input type="text" id="rule-table-names" class="acu-panel-input" value="${editRule?.scope?.tableNames?.join(',') || ''}" placeholder="例如: 物品表,装备表" style="flex:1;">
            </div>
            <div class="acu-setting-row" id="field-column-names" style="display: ${editRule?.scope?.type === 'column' ? 'flex' : 'none'};">
              <div class="acu-setting-info"><span class="acu-setting-label">列名 (多个用逗号分隔)</span></div>
              <input type="text" id="rule-column-names" class="acu-panel-input" value="${editRule?.scope?.columnNames?.join(',') || ''}" placeholder="例如: 品质,描述" style="flex:1;">
            </div>
            <div class="acu-setting-row">
              <div class="acu-setting-info"><span class="acu-setting-label">优先级</span></div>
              <input type="number" id="rule-priority" class="acu-panel-input" value="${editRule?.priority || 50}" min="1" max="100" style="width:80px;">
            </div>

          </div>
          <div class="acu-dice-cfg-actions">
            <button id="acu-regex-rule-cancel">取消</button>
            <button id="acu-regex-rule-confirm">保存</button>
          </div>
        </div>
      </div>
    `);

    // 作用域类型变化时显示/隐藏字段
    const updateScopeFields = () => {
      const scopeType = dialog.find('#rule-scope-type').val();
      if (scopeType === 'global') {
        dialog.find('#field-table-names, #field-column-names').hide();
      } else if (scopeType === 'table') {
        dialog.find('#field-table-names').css('display', 'flex').show();
        dialog.find('#field-column-names').hide();
      } else if (scopeType === 'column') {
        dialog.find('#field-table-names, #field-column-names').css('display', 'flex').show();
      }
    };

    dialog.find('#rule-scope-type').on('change', updateScopeFields);

    // Textarea自动调节高度
    const $textarea = dialog.find('#rule-description');
    const autoResizeTextarea = () => {
      // 重置高度以获取正确的scrollHeight
      $textarea.css('height', '34px');
      // 设置为内容高度,最小1行
      const scrollHeight = $textarea[0].scrollHeight;
      $textarea.css('height', Math.max(34, scrollHeight) + 'px');
    };
    // 监听输入事件
    $textarea.on('input', autoResizeTextarea);

    // 保存按钮(原立即替换按钮)
    dialog.find('#acu-regex-rule-confirm').on('click', async function () {
      const name = dialog.find('#rule-name').val();
      const pattern = dialog.find('#rule-pattern').val();
      const scopeType = dialog.find('#rule-scope-type').val();

      if (!name || !pattern) {
        toastr.error('请填写规则名称和匹配模式');
        return;
      }

      // 构建 scope 配置
      const scope: RegexScopeConfig = { type: scopeType as RegexScopeType };
      if (scopeType !== 'global') {
        const tableNames = dialog.find('#rule-table-names').val();
        if (tableNames)
          scope.tableNames = String(tableNames)
            .split(',')
            .map(s => s.trim())
            .filter(s => s);
      }
      if (scopeType === 'column') {
        const columnNames = dialog.find('#rule-column-names').val();
        if (columnNames)
          scope.columnNames = String(columnNames)
            .split(',')
            .map(s => s.trim())
            .filter(s => s);
      }

      // 从 pattern 中提取内联 flags（如果存在）
      const patternStr = String(pattern);
      const { flags: extractedFlags, patternWithoutFlags } = RegexTransformationEngine._extractFlags(patternStr);

      // 校验正则表达式合法性
      try {
        new RegExp(patternWithoutFlags);
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : String(e);
        toastr.error(`正则表达式无效: ${errorMsg}`, '保存失败');
        return;
      }

      // 获取 UI 中的 flags（如果复选框存在）
      const $flagGlobal = dialog.find('#flag-global');
      const $flagIgnoreCase = dialog.find('#flag-ignorecase');
      const $flagMultiline = dialog.find('#flag-multiline');

      const uiFlags = {
        global: $flagGlobal.length > 0 ? $flagGlobal.is(':checked') : false,
        caseInsensitive: $flagIgnoreCase.length > 0 ? $flagIgnoreCase.is(':checked') : false,
        multiline: $flagMultiline.length > 0 ? $flagMultiline.is(':checked') : false,
      };

      // 如果 pattern 包含内联 flags，使用提取后的 pattern 和合并后的 flags
      const finalPattern = patternWithoutFlags !== patternStr ? patternWithoutFlags : patternStr;
      const finalFlags =
        patternWithoutFlags !== patternStr
          ? { ...uiFlags, ...extractedFlags } // 内联 flags 覆盖 UI flags
          : uiFlags; // 没有内联 flags，使用 UI flags

      const ruleData = {
        name: String(name),
        description: dialog.find('#rule-description').val(),
        operation: 'replace', // 固定为替换操作
        pattern: finalPattern, // 使用提取后的 pattern（去除内联 flags）
        flags: finalFlags, // 使用合并后的 flags
        replacement: dialog.find('#rule-replacement').val(),
        scope,
        enabled: true, // 默认启用
        priority: parseInt(dialog.find('#rule-priority').val(), 10),
        executeMode: 'auto', // 所有规则默认自动执行
      };

      // 保存规则
      if (editRuleId) {
        // 更新现有规则
        RegexTransformationManager.updateRule(editRuleId, ruleData);
      } else {
        // 添加新规则
        const newRule = RegexTransformationManager.addCustomRule(ruleData);
        if (newRule) {
          editRuleId = newRule.id;
        }
      }

      // [修复] 关闭当前对话框并刷新规则列表
      dialog.remove();
      $(document).off('keydown.regex-rule-modal'); // 移除ESC键监听
      refreshRegexRulesList(); // 刷新规则列表而不是重渲染整个界面
    });

    // 关闭弹窗的统一函数（注意：不重置 isSettingsOpen，因为设置面板仍在后面打开）
    const closeDialog = () => {
      dialog.remove();
      $(document).off('keydown.regex-rule-modal'); // 移除ESC键监听
    };

    // 取消和关闭按钮（阻止事件冒泡，防止触发设置面板的关闭事件）
    dialog.find('#acu-regex-rule-cancel, #acu-close-regex-rule').on('click', function (e) {
      e.stopPropagation();
      closeDialog();
    });

    // 点击遮罩层关闭
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);

    // ESC 键关闭
    $(document).on('keydown.regex-rule-modal', function (e) {
      if (e.key === 'Escape' && dialog.length && dialog.is(':visible')) {
        e.preventDefault();
        closeDialog();
        $(document).off('keydown.regex-rule-modal'); // 移除事件监听
      }
    });

    $('body').append(dialog);

    // 在DOM完全渲染后调整textarea高度
    requestAnimationFrame(() => {
      const $textarea = dialog.find('#rule-description');
      if ($textarea.length && $textarea[0].scrollHeight > 34) {
        $textarea.css('height', $textarea[0].scrollHeight + 'px');
      }
    });
  };

  // 暴露到全局
  window.showAddRegexRuleModal = showAddRegexRuleModal;

  // 暴露到全局，供紧急入口按钮调用
  window.showDebugConsoleModal = showDebugConsoleModal;

  // ========================================
  // AcuDice 公共 API - 供其他插件和角色卡调用
  // ========================================

  const ACUDICE_READY_EVENT = 'acudice:ready';

  const resolveRootWindow = (): Window => {
    try {
      return window.top ?? window;
    } catch (error) {
      return window;
    }
  };

  const rootWindow = resolveRootWindow();
  const readyCallbacks: Array<() => void> = [];
  let isAcuDiceReady = false;

  const runReadyCallback = (callback: () => void) => {
    try {
      callback();
    } catch (error) {
      console.error('[AcuDice] onReady 回调出错', error);
    }
  };

  const notifyReady = () => {
    if (isAcuDiceReady) return;
    isAcuDiceReady = true;
    for (const callback of readyCallbacks) {
      runReadyCallback(callback);
    }
    readyCallbacks.length = 0;
  };

  const defineAcuDiceOnWindow = (target: Window) => {
    if ('AcuDice' in target) return;
    Object.defineProperty(target, 'AcuDice', {
      value: AcuDiceAPI,
      writable: false,
      configurable: false,
    });
  };

  const dispatchReadyEvent = (target: Window) => {
    try {
      target.dispatchEvent(new CustomEvent(ACUDICE_READY_EVENT));
    } catch (error) {
      console.warn('[AcuDice] ready 事件触发失败', error);
    }
  };

  // 事件系统
  const eventHandlers: Map<string, Set<Function>> = new Map();
  type CheckHistoryEntry = AcuDice.CheckResult & CheckHistoryExtension & { timestamp: number };
  type ContestHistoryEntry = AcuDice.ContestResult & { timestamp: number; detailId?: string; detailLines?: string[] };
  type AcuDiceSharedHistoryStore = {
    checkHistory: CheckHistoryEntry[];
    contestHistory: ContestHistoryEntry[];
    maxHistory: number;
  };
  type RootWindowWithAcuDiceHistory = Window & {
    __AcuDiceHistoryStore__?: AcuDiceSharedHistoryStore;
  };
  const rootWindowWithHistory = rootWindow as RootWindowWithAcuDiceHistory;
  if (!rootWindowWithHistory.__AcuDiceHistoryStore__) {
    rootWindowWithHistory.__AcuDiceHistoryStore__ = {
      checkHistory: [],
      contestHistory: [],
      maxHistory: 100,
    };
  }
  const sharedHistoryStore = rootWindowWithHistory.__AcuDiceHistoryStore__;
  const checkHistory: CheckHistoryEntry[] = sharedHistoryStore.checkHistory;
  const contestHistory: ContestHistoryEntry[] = sharedHistoryStore.contestHistory;
  const MAX_HISTORY = sharedHistoryStore.maxHistory;

  const globalExpandedHistoryIds = new Set<string>();
  let globalHistoryFilterStatus = 'all';
  let globalHistoryKeyword = '';
  let globalHistoryStatsScope: DiceStatsScope = 'chat';

  const copyTextWithTavernApi = async (text: string): Promise<boolean> => {
    try {
      if (window.TavernHelper && window.TavernHelper.triggerSlash) {
        const safeContent = text
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\n/g, '\\n')
          .replace(/\{/g, '\\{')
          .replace(/\}/g, '\\}');
        await window.TavernHelper.triggerSlash(`/clipboard-set "${safeContent}"`);
        return true;
      }
    } catch (error) {
      console.warn('[DICE] history copy via TavernHelper failed:', error);
    }

    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch (error) {
      console.warn('[DICE] history copy via navigator.clipboard failed:', error);
    }

    try {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-9999px';
      textArea.style.top = '0';
      textArea.setAttribute('readonly', '');
      document.body.appendChild(textArea);
      textArea.select();
      textArea.setSelectionRange(0, 99999);
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      return successful;
    } catch (error) {
      console.error('[DICE] history copy fallback failed:', error);
      return false;
    }
  };

  const showGlobalDiceHistoryDialog = () => {
    $('.acu-dice-history-overlay').remove();
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;
    const detailCopyTextMap = new Map<string, string>();

    const renderHistoryItems = (): string => {
      type UnifiedItem =
        | (CheckHistoryEntry & { historyType: 'check' })
        | (ContestHistoryEntry & { historyType: 'contest' });

      detailCopyTextMap.clear();

      const items: UnifiedItem[] = [
        ...checkHistory.map(item => ({ ...item, historyType: 'check' as const })),
        ...contestHistory.map(item => ({ ...item, historyType: 'contest' as const })),
      ]
        .sort((a, b) => b.timestamp - a.timestamp)
        .filter(item => {
          if (globalHistoryFilterStatus !== 'all') {
            const status = String((item as Record<string, unknown>).effectStatus || '');
            if (!status || status !== globalHistoryFilterStatus) return false;
          }
          const keyword = globalHistoryKeyword.trim().toLowerCase();
          if (!keyword) return true;
          const raw = item as Record<string, unknown>;
          const left = (raw.left || {}) as Record<string, unknown>;
          const right = (raw.right || {}) as Record<string, unknown>;
          const haystack = [
            raw.attrName,
            raw.message,
            raw.outcomeText,
            raw.initiatorName,
            left.name,
            right.name,
            raw.effectStatus,
          ]
            .map(text => String(text || '').toLowerCase())
            .join(' ');
          return haystack.includes(keyword);
        })
        .slice(0, 80);

      if (items.length === 0) {
        return `<div style="padding:20px 12px; color:var(--acu-text-sub); text-align:center; display:flex; flex-direction:column; gap:8px; align-items:center;"><i class="fa-solid fa-dice-d20" style="font-size:20px; opacity:.35;"></i><span>暂无检定历史</span></div>`;
      }

      const statusTextMap: Record<string, string> = {
        planned: '待执行',
        confirmed: '已确认',
        committed: '已提交',
        failed: '失败',
        cancelled: '已取消',
      };
      const statusColorMap: Record<string, string> = {
        planned: 'var(--acu-text-sub)',
        confirmed: 'var(--acu-accent)',
        committed: 'var(--acu-success-text)',
        failed: 'var(--acu-error-text)',
        cancelled: 'var(--acu-text-sub)',
      };

      return items
        .map(item => {
          const raw = item as Record<string, unknown>;
          const isContest = item.historyType === 'contest';
          const left = (raw.left || {}) as Record<string, unknown>;
          const right = (raw.right || {}) as Record<string, unknown>;
          const status = String(raw.effectStatus || '');
          const statusText = status ? statusTextMap[status] || status : '';
          const statusColor = status ? statusColorMap[status] || 'var(--acu-text-sub)' : 'var(--acu-text-sub)';

          const detailId = String(raw.detailId || raw.effectRunId || `${item.historyType}-${item.timestamp}`);
          const detailLinesRaw = Array.isArray(raw.detailLines) ? (raw.detailLines as unknown[]) : [];
          const traceLinesRaw = Array.isArray(raw.effectTrace) ? (raw.effectTrace as unknown[]) : [];
          const detailLines = detailLinesRaw.map(line => String(line || '').trim()).filter(Boolean);
          const traceLines = traceLinesRaw.map(line => String(line || '').trim()).filter(Boolean);
          const canExpand = detailLines.length > 0 || traceLines.length > 0;
          const isExpanded = canExpand && globalExpandedHistoryIds.has(detailId);

          let title = String(raw.attrName || '检定');
          let subtitle = String(raw.outcomeText || (raw.success ? '成功' : '失败'));
          let resultColor = raw.success ? 'var(--acu-success-text)' : 'var(--acu-error-text)';
          let rollText = `${String(raw.total ?? '-')}/${String(raw.target ?? '-')}`;
          let typeTag = '普通';

          if (isContest) {
            typeTag = '对抗';
            title = `${String(left.name || '发起方')} vs ${String(right.name || '对抗方')}`;
            subtitle = String(raw.message || '对抗检定');
            const winner = String(raw.winner || 'tie');
            resultColor = winner === 'tie' ? 'var(--acu-text-sub)' : 'var(--acu-accent)';
            rollText = `${String(left.roll ?? '-')} : ${String(right.roll ?? '-')}`;
          } else {
            const initiator = String(raw.initiatorName || '').trim();
            if (initiator) title = `${initiator} · ${title}`;
          }

          const pushedBadge = raw.isPushed
            ? '<i class="fa-solid fa-skull" style="font-size:10px;color:var(--acu-text-sub);margin-left:4px;" title="孤注一掷"></i>'
            : '';

          const sections: string[] = [];
          if (detailLines.length > 0) {
            sections.push(
              `<div><div style="font-weight:700; color:var(--acu-text-main); margin-bottom:4px;">检定详情</div>${detailLines.map(line => escapeHtml(line)).join('<br>')}</div>`,
            );
          }
          if (traceLines.length > 0) {
            sections.push(
              `<div><div style="font-weight:700; color:var(--acu-text-main); margin-bottom:4px;">效果链路</div>${traceLines.map(line => escapeHtml(line)).join('<br>')}</div>`,
            );
          }

          if (canExpand) {
            const copyParts: string[] = [
              `[${typeTag}] ${title}`,
              `时间: ${new Date(item.timestamp).toLocaleString('zh-CN')}`,
            ];
            if (subtitle) copyParts.push(`结果: ${subtitle}`);
            if (rollText) copyParts.push(`数值: ${rollText}`);
            if (detailLines.length > 0) copyParts.push('--- 检定详情 ---', ...detailLines);
            if (traceLines.length > 0) copyParts.push('--- 效果链路 ---', ...traceLines);
            detailCopyTextMap.set(detailId, copyParts.join('\n'));
          }

          const detailHtml =
            canExpand && isExpanded
              ? `<div style="margin-top:8px; padding:9px 10px; background: color-mix(in srgb, var(--acu-card-bg) 72%, transparent); border:1px solid var(--acu-border); border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:11px; line-height:1.45; color:var(--acu-text-sub); white-space: normal;">${sections.join('<div style="height:1px; background:var(--acu-border); margin:8px 0;"></div>')}</div>`
              : '';

          return `
            <div style="padding:10px 12px; border:1px solid var(--acu-border); border-radius:10px; margin-bottom:8px; background:var(--acu-bg-panel);">
              <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px;">
                <div style="min-width:0; flex:1;">
                  <div style="display:flex; align-items:center; gap:6px;">
                    <span style="font-size:10px; color:var(--acu-text-sub); border:1px solid var(--acu-border); border-radius:999px; padding:1px 7px;">${typeTag}</span>
                    <span style="font-weight:700; color:var(--acu-text-main); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(title)}${pushedBadge}</span>
                    ${canExpand ? `<button class="acu-history-detail-copy" data-detail-id="${escapeHtml(detailId)}" title="复制详情" style="border:1px solid var(--acu-border); background:var(--acu-btn-bg); color:var(--acu-text-sub); border-radius:6px; width:24px; height:24px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; flex-shrink:0;"><i class="fa-solid fa-copy"></i></button>` : ''}
                  </div>
                  <div style="margin-top:6px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px;">
                    <span style="color:${resultColor}; font-weight:700;">${escapeHtml(subtitle)}</span>
                    <span style="color:var(--acu-text-sub); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;">${escapeHtml(rollText)}</span>
                    ${statusText ? `<span style="color:${statusColor}; border:1px solid color-mix(in srgb, ${statusColor} 40%, transparent); border-radius:999px; padding:1px 7px; font-size:11px;">效果:${statusText}</span>` : ''}
                  </div>
                </div>
                <div style="display:flex; align-items:center; gap:5px; flex-shrink:0;">
                  <span style="font-size:12px; color:var(--acu-text-sub);">${new Date(item.timestamp).toLocaleTimeString('zh-CN', { hour12: false })}</span>
                  ${canExpand ? `<button class="acu-history-trace-toggle" data-run-id="${escapeHtml(detailId)}" style="border:none;background:transparent;color:var(--acu-text-sub);cursor:pointer;padding:2px 4px;font-size:13px;" title="${isExpanded ? '收起详情' : '展开详情'}">${isExpanded ? '▼' : '▶'}</button>` : ''}
                </div>
              </div>
              ${detailHtml}
            </div>
          `;
        })
        .join('');
    };

    const dialog = $(`
      <div class="acu-edit-overlay acu-dice-history-overlay">
        <div class="acu-edit-dialog ${currentThemeClass}" style="max-width:600px; width:min(94vw,600px); max-height:82vh; display:flex; flex-direction:column; padding:14px;">
          <div style="display:flex; justify-content:space-between; align-items:center; padding-bottom:8px; border-bottom:1px solid var(--acu-border);">
            <div style="font-size:19px; color:var(--acu-text-main); font-weight:700; display:flex; align-items:center; gap:8px;"><i class="fa-solid fa-clock-rotate-left" style="color:var(--acu-accent);"></i> 检定历史</div>
            <button class="acu-close-btn acu-history-close"><i class="fa-solid fa-times"></i></button>
          </div>
          <div style="display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:8px; margin-top:6px; align-items:center;">
            <select id="acu-history-scope-filter" class="acu-dice-select" style="width:100%; min-width:0;">
              <option value="chat">本聊天</option>
              <option value="character">本角色卡</option>
              <option value="global">全局</option>
            </select>
            <select id="acu-history-status-filter" class="acu-dice-select" style="width:100%; min-width:0;">
              <option value="all">全部状态</option>
              <option value="planned">待执行</option>
              <option value="confirmed">已确认</option>
              <option value="committed">已提交</option>
              <option value="failed">失败</option>
              <option value="cancelled">已取消</option>
            </select>
            <div style="position:relative; min-width:0;">
              <i class="fa-solid fa-search" style="position:absolute; left:11px; top:50%; transform:translateY(-50%); font-size:12px; color:var(--acu-text-sub); pointer-events:none;"></i>
              <input id="acu-history-search" class="acu-dice-input" style="width:100%; padding-left:34px !important;" placeholder="搜索" value="${escapeHtml(globalHistoryKeyword)}">
            </div>
          </div>
          <div id="acu-dice-history-stats" style="margin-top:2px; padding:9px; border:1px solid var(--acu-border); border-radius:8px; background:var(--acu-card-bg);"></div>
          <div id="acu-dice-history-list" style="margin-top:8px; overflow-y:auto; flex:1; min-height:220px; max-height:52vh; -webkit-overflow-scrolling:touch; overscroll-behavior:contain; touch-action:pan-y;">
            ${renderHistoryItems()}
          </div>
          <div style="display:flex; justify-content:flex-end; gap:8px; padding-top:10px; border-top:1px solid var(--acu-border); margin-top:8px;">
            <button class="acu-dialog-btn" id="acu-history-clear" style="background:var(--acu-btn-bg); border-color:var(--acu-border);"><i class="fa-solid fa-trash"></i> 清理历史</button>
            <button class="acu-dialog-btn acu-history-close"><i class="fa-solid fa-times"></i> 关闭</button>
          </div>
        </div>
      </div>
    `);
    $('body').append(dialog);

    const renderHistoryStats = async () => {
      const $stats = dialog.find('#acu-dice-history-stats');
      if ($stats.length === 0) return;
      const allStats = await DiceHistoryStatsDB.getDashboardStats();
      const activeStats = allStats[globalHistoryStatsScope];
      const context = getDiceStatsContext();
      const mobile = window.innerWidth <= 640;
      const scopeLabelMap: Record<DiceStatsScope, string> = {
        chat: '本聊天',
        character: '本角色卡',
        global: '全局',
      };
      const scopeUnavailable =
        (globalHistoryStatsScope === 'chat' && context.chatId === 'unknown_chat') ||
        (globalHistoryStatsScope === 'character' && context.characterId === 'unknown_character');

      $stats.html(`
        <div style="display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:${mobile ? '6px' : '8px'}; margin-bottom:8px;">
          <div style="padding:${mobile ? '6px' : '8px'}; border:1px solid var(--acu-border); border-radius:6px;"><div style="font-size:${mobile ? '10px' : '11px'}; color:var(--acu-text-sub);">本聊天检定数</div><div style="font-size:${mobile ? '16px' : '18px'}; font-weight:700; color:var(--acu-text-main);">${allStats.chat.total}</div></div>
          <div style="padding:${mobile ? '6px' : '8px'}; border:1px solid var(--acu-border); border-radius:6px;"><div style="font-size:${mobile ? '10px' : '11px'}; color:var(--acu-text-sub);">本角色卡检定数</div><div style="font-size:${mobile ? '16px' : '18px'}; font-weight:700; color:var(--acu-text-main);">${allStats.character.total}</div></div>
          <div style="padding:${mobile ? '6px' : '8px'}; border:1px solid var(--acu-border); border-radius:6px;"><div style="font-size:${mobile ? '10px' : '11px'}; color:var(--acu-text-sub);">全局检定数</div><div style="font-size:${mobile ? '16px' : '18px'}; font-weight:700; color:var(--acu-text-main);">${allStats.global.total}</div></div>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; font-size:${mobile ? '11px' : '12px'};">
          <div style="color:var(--acu-text-sub);">当前统计范围：${scopeLabelMap[globalHistoryStatsScope]}</div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <span style="color:var(--acu-text-main);">总数：<b>${activeStats.total}</b></span>
            <span style="color:var(--acu-text-main);">普通：<b>${activeStats.checks}</b></span>
            <span style="color:var(--acu-text-main);">对抗：<b>${activeStats.contests}</b></span>
            <span style="color:var(--acu-text-main);">成功率：<b style="color:var(--acu-success-text);">${activeStats.checkSuccessRate}%</b></span>
          </div>
        </div>
        ${scopeUnavailable ? '<div style="margin-top:6px; font-size:11px; color:var(--acu-text-sub);">当前环境未识别到该范围ID，仅显示可识别范围数据。</div>' : ''}
      `);
    };

    const rerender = () => {
      dialog.find('#acu-dice-history-list').html(renderHistoryItems());
      void renderHistoryStats();
    };

    dialog.find('#acu-history-status-filter').val(globalHistoryFilterStatus);
    dialog.find('#acu-history-scope-filter').val(globalHistoryStatsScope);

    const refreshByEvent = () => rerender();
    const canListen = Boolean(window.AcuDice && typeof window.AcuDice.on === 'function');
    if (canListen) {
      window.AcuDice.on('check', refreshByEvent);
      window.AcuDice.on('contest', refreshByEvent);
      window.AcuDice.on('effect_run', refreshByEvent);
    }

    void renderHistoryStats();

    dialog.on('change', '#acu-history-scope-filter', function () {
      const val = String($(this).val() || 'chat') as DiceStatsScope;
      globalHistoryStatsScope = val === 'character' || val === 'global' ? val : 'chat';
      void renderHistoryStats();
    });

    dialog.on('change', '#acu-history-status-filter', function () {
      globalHistoryFilterStatus = String($(this).val() || 'all');
      rerender();
    });

    dialog.on('input', '#acu-history-search', function () {
      globalHistoryKeyword = String($(this).val() || '');
      rerender();
    });

    dialog.on('touchstart touchmove', '#acu-dice-history-list', function (e) {
      e.stopPropagation();
    });

    dialog.on('click', '.acu-history-trace-toggle', function (e) {
      e.preventDefault();
      e.stopPropagation();
      const runId = String($(this).data('run-id') || '');
      if (!runId) return;
      if (globalExpandedHistoryIds.has(runId)) globalExpandedHistoryIds.delete(runId);
      else globalExpandedHistoryIds.add(runId);
      rerender();
    });

    dialog.on('click', '.acu-history-detail-copy', async function (e) {
      e.preventDefault();
      e.stopPropagation();
      const detailId = String($(this).data('detail-id') || '');
      const detailText = (detailCopyTextMap.get(detailId) || '').trim();
      if (!detailText) {
        if (window.toastr) window.toastr.warning('没有可复制的详情');
        return;
      }
      const ok = await copyTextWithTavernApi(detailText);
      if (window.toastr) {
        if (ok) window.toastr.success('详情已复制');
        else window.toastr.error('复制失败');
      }
    });

    dialog.on('click', '#acu-history-clear', async function (e) {
      e.preventDefault();
      e.stopPropagation();
      const ok = window.confirm('确定清理检定历史吗？此操作会清空当前会话内历史和统计库记录。');
      if (!ok) return;
      checkHistory.length = 0;
      contestHistory.length = 0;
      globalExpandedHistoryIds.clear();
      await DiceHistoryStatsDB.clear();
      rerender();
      if (window.toastr) window.toastr.success('检定历史已清理');
    });

    const closeDialog = () => {
      if (canListen) {
        window.AcuDice.off('check', refreshByEvent);
        window.AcuDice.off('contest', refreshByEvent);
        window.AcuDice.off('effect_run', refreshByEvent);
      }
      dialog.remove();
    };
    dialog.on('click', '.acu-history-close', closeDialog);
    setupOverlayClose(dialog, 'acu-dice-history-overlay', closeDialog);
  };

  function emitEvent(event: string, data: any) {
    if (event === 'check' || event === 'contest') {
      void DiceHistoryStatsDB.recordEvent(event, data);
    }
    const handlers = eventHandlers.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (e) {
          console.error('[AcuDice] Event handler error:', e);
        }
      });
    }
  }

  /**
   * AcuDice 公共 API
   * 提供骰子投掷和检定功能给外部插件使用
   */
  const AcuDiceAPI = {
    /** API 版本号 */
    version: '1.2.0',

    /**
     * 骰子投掷（同步）
     * @param formula 骰子表达式，如 "2d6", "1d20+5", "4d6kh3"
     * @returns 投掷结果对象
     * @example
     * AcuDice.roll('2d6') // => { total: 7, formula: '2d6', breakdown: '2d6 = 7' }
     * AcuDice.roll('1d20+5') // => { total: 15, formula: '1d20+5', breakdown: '1d20+5 = 15' }
     */
    roll(formula: string): { total: number; formula: string; breakdown: string } {
      if (!formula || typeof formula !== 'string') {
        throw new Error('[AcuDice] roll() 需要一个有效的骰子表达式字符串');
      }
      // 校验公式：必须包含骰子表达式（如 2d6）或是纯数学运算（如 3+5）
      const hasDice = /\d*d(\d+|F)/i.test(formula);
      const isMath = /^[\d\s+\-*/().]+$/.test(formula.trim());
      if (!hasDice && !isMath) {
        throw new Error(`[AcuDice] 无效的骰子表达式: ${formula}`);
      }
      const total = evaluateFormula(formula, {});
      return {
        total,
        formula,
        breakdown: `${formula} = ${total}`,
      };
    },

    /**
     * 属性/技能检定（异步）
     * @param options 检定选项
     * @returns 检定结果对象
     * @example
     * await AcuDice.check({ attribute: '力量' })
     * await AcuDice.check({ attribute: '力量', targetValue: 50, diceType: '1d100' })
     */
    async check(
      options: {
        attribute?: string;
        skill?: string;
        targetValue?: number;
        diceType?: string;
        successCriteria?: 'lte' | 'gte';
        modifier?: number;
      } = {},
    ): Promise<{
      success: boolean;
      roll: number;
      target: number;
      margin: number;
      criticalSuccess: boolean;
      criticalFailure: boolean;
      message: string;
      diceType: string;
      rule: 'coc' | 'dnd';
    }> {
      const diceCfg = getDiceConfig();
      const diceType = options.diceType || diceCfg.lastDiceType || '1d100';
      const successCriteria = options.successCriteria || (diceType === '1d20' ? 'gte' : 'lte');
      const isDND = successCriteria === 'gte';
      const modifier = options.modifier || 0;

      // 获取目标值
      let targetValue = options.targetValue;

      // 如果指定了属性名但没有目标值，尝试从角色数据获取
      if (targetValue === undefined && (options.attribute || options.skill)) {
        const attrName = options.attribute || options.skill || '';
        const rawData = cachedRawData || getTableData();

        if (rawData) {
          // 从主角信息表查找属性值
          for (const key in rawData) {
            const sheet = rawData[key];
            if (sheet?.name === '主角信息' && sheet.content?.[1]) {
              const headers = sheet.content[0] || [];
              const row = sheet.content[1];
              for (let idx = 0; idx < headers.length; idx++) {
                const h = headers[idx];
                if (h && (h.includes('属性') || h.includes('技能'))) {
                  const parsed = parseAttributeString(row[idx] || '');
                  const found = parsed.find((attr: { name: string; value: number }) => attr.name === attrName);
                  if (found) {
                    targetValue = found.value;
                    break;
                  }
                }
              }
              if (targetValue !== undefined) break;
            }
          }
        }

        if (targetValue === undefined) {
          throw new Error(`[AcuDice] 未找到属性或技能: ${attrName}`);
        }
      }

      if (targetValue === undefined) {
        throw new Error('[AcuDice] check() 需要 targetValue 或有效的 attribute/skill 名称');
      }

      // 投骰
      const rollResult = rollComplexDiceExpression(diceType);
      if (Number.isNaN(rollResult.total)) {
        throw new Error(`[AcuDice] 无效的骰子表达式: ${diceType}`);
      }

      const finalRoll = rollResult.total + modifier;
      const target = targetValue;

      // 判定结果
      let success = false;
      let criticalSuccess = false;
      let criticalFailure = false;
      let message = '';

      if (isDND) {
        // DND 规则: roll >= target 成功
        success = finalRoll >= target;
        criticalSuccess = rollResult.total === diceCfg.dndCritSuccess;
        criticalFailure = rollResult.total === diceCfg.dndCritFail;

        if (criticalSuccess) {
          success = true;
          message = `大成功！掷出 ${rollResult.total}${modifier ? ` + ${modifier}` : ''} = ${finalRoll}，DC ${target}`;
        } else if (criticalFailure) {
          success = false;
          message = `大失败！掷出 ${rollResult.total}${modifier ? ` + ${modifier}` : ''} = ${finalRoll}，DC ${target}`;
        } else if (success) {
          message = `成功！掷出 ${finalRoll} >= DC ${target}`;
        } else {
          message = `失败！掷出 ${finalRoll} < DC ${target}`;
        }
      } else {
        // COC 规则: roll <= target 成功
        success = finalRoll <= target;
        criticalSuccess = finalRoll <= diceCfg.critSuccessMax;
        criticalFailure = finalRoll >= diceCfg.critFailMin;

        if (criticalSuccess) {
          success = true;
          message = `大成功！掷出 ${finalRoll}，目标 ${target}`;
        } else if (criticalFailure) {
          success = false;
          message = `大失败！掷出 ${finalRoll}，目标 ${target}`;
        } else if (success) {
          const hardSuccess = finalRoll <= Math.floor(target / diceCfg.hardSuccessDiv);
          const extremeSuccess = finalRoll <= Math.floor(target / diceCfg.difficultSuccessDiv);
          if (extremeSuccess) {
            message = `极难成功！掷出 ${finalRoll} <= ${Math.floor(target / diceCfg.difficultSuccessDiv)}`;
          } else if (hardSuccess) {
            message = `困难成功！掷出 ${finalRoll} <= ${Math.floor(target / diceCfg.hardSuccessDiv)}`;
          } else {
            message = `成功！掷出 ${finalRoll} <= ${target}`;
          }
        } else {
          message = `失败！掷出 ${finalRoll} > ${target}`;
        }
      }

      const checkResult: AcuDice.CheckResult = {
        success,
        total: finalRoll,
        target,
        outcomeText: message,
        attrName: options.attribute || options.skill || '',
        formula: diceType,
        criteria: isDND ? 'gte' : 'lte',
        isAutoTarget: options.targetValue === undefined,
      };

      // 写入历史记录
      const detailId = `check_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const attrLabel = options.attribute || options.skill || '未指定';
      const checkResultWithTimestamp = {
        ...checkResult,
        timestamp: Date.now(),
        detailId,
        initiatorName: 'API',
        historyType: 'check' as const,
        detailLines: [
          `发起者: API`,
          `属性: ${attrLabel} (值=${target})`,
          `公式: ${diceType}`,
          `掷骰: ${finalRoll}`,
          `目标: ${target}`,
          ...(modifier ? [`修正: ${modifier >= 0 ? '+' + modifier : modifier}`] : []),
          `结果: ${message}`,
        ],
      };
      checkHistory.push(checkResultWithTimestamp);
      if (checkHistory.length > MAX_HISTORY) {
        checkHistory.shift();
      }

      // 触发事件
      emitEvent('check', checkResultWithTimestamp);

      return {
        success,
        roll: finalRoll,
        target,
        margin: isDND ? finalRoll - target : target - finalRoll,
        criticalSuccess,
        criticalFailure,
        message,
        diceType,
        rule: isDND ? 'dnd' : 'coc',
      };
    },

    /**
     * 初始化回调 - API 已就绪时调用
     * @param callback 回调函数
     */
    onReady(callback: () => void): void {
      if (typeof callback !== 'function') {
        console.warn('[AcuDice] onReady() 需要一个函数');
        return;
      }

      if (isAcuDiceReady) {
        runReadyCallback(callback);
        return;
      }

      readyCallbacks.push(callback);
    },

    /**
     * 订阅事件
     * @param event 事件类型 ('check' | 'contest')
     * @param handler 事件处理函数
     */
    on(event: string, handler: Function): void {
      if (!eventHandlers.has(event)) {
        eventHandlers.set(event, new Set());
      }
      eventHandlers.get(event)!.add(handler);
    },

    /**
     * 取消事件订阅
     * @param event 事件类型 ('check' | 'contest')
     * @param handler 事件处理函数
     */
    off(event: string, handler: Function): void {
      const handlers = eventHandlers.get(event);
      if (handlers) {
        handlers.delete(handler);
      }
    },

    /**
     * 获取最近一次普通检定结果
     */
    getLatestCheck(): (AcuDice.CheckResult & { timestamp: number }) | null {
      return checkHistory.length > 0 ? checkHistory[checkHistory.length - 1] : null;
    },

    /**
     * 获取最近一次对抗检定结果
     */
    getLatestContest(): (AcuDice.ContestResult & { timestamp: number }) | null {
      return contestHistory.length > 0 ? contestHistory[contestHistory.length - 1] : null;
    },

    /**
     * 获取历史记录
     * @param options 查询选项
     * @param options.limit 限制返回数量
     * @param options.type 筛选类型 ('check' | 'contest')
     */
    getHistory(options?: { limit?: number; type?: 'check' | 'contest' }): Array<any> {
      const limit = options?.limit;
      const type = options?.type;

      let results: Array<any> = [];

      if (!type || type === 'check') {
        results = results.concat(checkHistory.map(item => ({ ...item, _type: 'check' })));
      }
      if (!type || type === 'contest') {
        results = results.concat(contestHistory.map(item => ({ ...item, _type: 'contest' })));
      }

      // 按时间戳倒序排序
      results.sort((a, b) => b.timestamp - a.timestamp);

      // 应用 limit
      if (limit && limit > 0) {
        results = results.slice(0, limit);
      }

      return results;
    },

    /**
     * 获取所有预设列表（摘要信息）
     * @returns 预设摘要数组
     */
    listPresets(): Array<{ id: string; name: string; description?: string; builtin: boolean }> {
      const allPresets = ActionPresetManager.getAllPresets();
      return allPresets.map((p: any) => ({
        id: p.id,
        name: p.name,
        description: p.description || '',
        builtin: !!p.builtin,
      }));
    },

    /**
     * 获取当前激活的预设 ID
     * @returns 预设 ID 字符串，无激活预设时返回 null
     */
    getActivePresetId(): string | null {
      const id = ActionPresetManager.getActivePresetId();
      return id === '__none__' ? null : id;
    },

    /**
     * 获取指定预设的摘要信息
     * @param presetId 预设 ID
     * @returns 预设摘要，未找到时返回 null
     */
    getPresetSummary(presetId: string): { id: string; name: string; description?: string; builtin: boolean } | null {
      const preset = ActionPresetManager.getPresetById(presetId);
      if (!preset) return null;
      return {
        id: preset.id,
        name: preset.name,
        description: preset.description || '',
        builtin: !!preset.builtin,
      };
    },

    /**
     * 获取所有可用角色名列表
     * @returns 角色名数组，包括 '<user>' 和所有 NPC
     * @example
     * AcuDice.listCharacters() // => ['<user>', 'NPC1', 'NPC2']
     */
    listCharacters(): string[] {
      const rawData = cachedRawData || getTableData();
      if (!rawData) return [];

      const allTables = processJsonData(rawData || {});
      const characters: string[] = [];

      // 检查是否有主角信息
      const playerResult = DashboardDataParser.findTable(allTables, 'player');
      if (playerResult?.data?.rows?.length > 0) {
        characters.push('<user>');
      }

      // 获取所有 NPC
      const npcResult = DashboardDataParser.findTable(allTables, 'npc');
      if (npcResult) {
        const npcParsed = DashboardDataParser.parseRows(npcResult, 'npc');
        npcParsed.forEach(npc => {
          if (npc.name && typeof npc.name === 'string') {
            characters.push(npc.name);
          }
        });
      }

      return characters;
    },

    /**
     * 获取指定角色的所有属性
     * @param name 角色名，可以是 '<user>' 或 NPC 名称
     * @returns 属性数组，每个元素包含 name 和 value
     * @example
     * AcuDice.getCharacterAttributes('<user>') // => [{ name: '力量', value: 50 }, { name: '敏捷', value: 60 }]
     * AcuDice.getCharacterAttributes('张三') // => [{ name: '力量', value: 70 }]
     */
    getCharacterAttributes(name: string): Array<{ name: string; value: number }> {
      if (!name || typeof name !== 'string') {
        throw new Error('[AcuDice] getCharacterAttributes() 需要一个有效的角色名');
      }
      return getFullAttributesForCharacter(name);
    },

    /**
     * 获取指定角色的指定属性值
     * @param name 角色名
     * @param attribute 属性名
     * @returns 属性值，如果未找到则返回 null
     * @example
     * AcuDice.getAttributeValue('<user>', '力量') // => 50
     * AcuDice.getAttributeValue('张三', '敏捷') // => 60
     */
    getAttributeValue(name: string, attribute: string): number | null {
      if (!name || typeof name !== 'string') {
        throw new Error('[AcuDice] getAttributeValue() 需要一个有效的角色名');
      }
      if (!attribute || typeof attribute !== 'string') {
        throw new Error('[AcuDice] getAttributeValue() 需要一个有效的属性名');
      }
      return getAttributeValue(name, attribute);
    },

    /**
     * 按角色名和属性名进行便捷检定
     * @param options 检定选项
     * @returns 检定结果对象
     * @example
     * await AcuDice.checkByCharacter({ name: '<user>', attribute: '力量' })
     * await AcuDice.checkByCharacter({ name: 'NPC1', attribute: '敏捷', modifier: 5 })
     */
    async checkByCharacter(options: {
      name: string;
      attribute: string;
      modifier?: number;
      diceType?: string;
      successCriteria?: 'lte' | 'gte';
    }): Promise<{
      success: boolean;
      roll: number;
      target: number;
      margin: number;
      criticalSuccess: boolean;
      criticalFailure: boolean;
      message: string;
      diceType: string;
      rule: 'coc' | 'dnd';
    }> {
      if (!options || !options.name || !options.attribute) {
        throw new Error('[AcuDice] checkByCharacter() 需要 name 和 attribute 参数');
      }

      // 获取角色属性值
      const targetValue = getAttributeValue(options.name, options.attribute);
      if (targetValue === null) {
        throw new Error(`[AcuDice] 未找到角色 "${options.name}" 的属性 "${options.attribute}"`);
      }

      // 调用现有的 check 方法
      return this.check({
        attribute: options.attribute,
        targetValue,
        modifier: options.modifier,
        diceType: options.diceType,
        successCriteria: options.successCriteria,
      });
    },

    /**
     * 对抗检定
     * @param options 对抗检定选项
     * @returns 对抗检定结果
     * @example
     * await AcuDice.contest({
     *   left: { name: '<user>', attribute: '力量' },
     *   right: { name: 'NPC1', attribute: '力量' }
     * })
     */
    async contest(options: {
      left?: { name: string; attribute: string; targetValue?: number };
      right?: { name: string; attribute: string; targetValue?: number };
      /** @deprecated 使用 left 代替 */
      attacker?: { name: string; attribute: string; targetValue?: number };
      /** @deprecated 使用 right 代替 */
      defender?: { name: string; attribute: string; targetValue?: number };
      rule?: 'initiator_win' | 'initiator_lose' | 'tie';
    }): Promise<{
      left: { name: string; attribute: string; roll: number; target: number; successLevel: number };
      right: { name: string; attribute: string; roll: number; target: number; successLevel: number };
      winner: 'left' | 'right' | 'tie';
      message: string;
    }> {
      // 兼容 attacker/defender 别名
      const left = options?.left || options?.attacker;
      const right = options?.right || options?.defender;

      if (!left?.name || !left?.attribute) {
        throw new Error('[AcuDice] contest() 需要 left.name 和 left.attribute 参数');
      }
      if (!right?.name || !right?.attribute) {
        throw new Error('[AcuDice] contest() 需要 right.name 和 right.attribute 参数');
      }

      try {
        const rawDataForAlias = cachedRawData || getTableData();
        if (rawDataForAlias) {
          NameAliasRegistry.rebuild(processJsonData(rawDataForAlias || {}));
        }
      } catch (error) {
        console.warn('[AcuDice] contest() 别名映射刷新失败', error);
      }

      const leftName = left.name === '<user>' ? left.name : NameAliasRegistry.resolve(left.name);
      const rightName = right.name === '<user>' ? right.name : NameAliasRegistry.resolve(right.name);

      // 获取双方属性值（优先使用 targetValue，否则从角色数据查找）
      let leftTarget = left.targetValue ?? null;
      if (leftTarget === null) {
        leftTarget = getAttributeValue(leftName, left.attribute);
        if (leftTarget === null) {
          throw new Error(`[AcuDice] 未找到角色 "${leftName}" 的属性 "${left.attribute}"`);
        }
      }

      let rightTarget = right.targetValue ?? null;
      if (rightTarget === null) {
        rightTarget = getAttributeValue(rightName, right.attribute);
        if (rightTarget === null) {
          throw new Error(`[AcuDice] 未找到角色 "${rightName}" 的属性 "${right.attribute}"`);
        }
      }

      // 获取骰子配置
      const diceCfg = getDiceConfig();
      const formula = diceCfg.lastDiceType || '1d100';

      // 投骰
      const leftResult = rollComplexDiceExpression(formula).total;
      const rightResult = rollComplexDiceExpression(formula).total;
      if (Number.isNaN(leftResult) || Number.isNaN(rightResult)) {
        throw new Error(`[AcuDice] 无效的骰子公式: ${formula}`);
      }

      // 解析骰子类型获取 sides
      const sidesMatch = formula.match(/\d+d(\d+)/i);
      const sides = sidesMatch ? parseInt(sidesMatch[1], 10) : 100;

      // 计算成功等级
      const leftSuccessLevel = getSuccessLevel(leftResult, leftTarget, sides);
      const rightSuccessLevel = getSuccessLevel(rightResult, rightTarget, sides);

      // 判定胜负
      let winner: 'left' | 'right' | 'tie';
      let message: string;

      if (leftSuccessLevel.level > rightSuccessLevel.level) {
        winner = 'left';
        message = `${leftName} 胜利！(${leftSuccessLevel.name} 胜过 ${rightSuccessLevel.name})`;
      } else if (leftSuccessLevel.level < rightSuccessLevel.level) {
        winner = 'right';
        message = `${rightName} 胜利！(${rightSuccessLevel.name} 胜过 ${leftSuccessLevel.name})`;
      } else {
        // 平手情况
        const tieRule = options.rule || diceCfg.contestTieRule || 'initiator_lose';
        message = `双方平手！(均为 ${leftSuccessLevel.name})`;

        if (tieRule === 'initiator_win') {
          winner = 'left';
          message += ` - ${leftName} 判胜`;
        } else if (tieRule === 'tie') {
          winner = 'tie';
        } else {
          // initiator_lose
          winner = 'right';
          message += ` - ${leftName} 判负`;
        }
      }

      const result = {
        left: {
          name: leftName,
          attribute: left.attribute,
          roll: leftResult,
          target: leftTarget,
          successLevel: leftSuccessLevel.level,
        },
        right: {
          name: rightName,
          attribute: right.attribute,
          roll: rightResult,
          target: rightTarget,
          successLevel: rightSuccessLevel.level,
        },
        winner,
        message,
      };

      // 触发事件
      emitEvent('contest', result);

      // 记录到历史
      contestHistory.push({
        ...result,
        timestamp: Date.now(),
        detailId: `contest_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        detailLines: [
          `发起方: ${result.left.name} / 对抗方: ${result.right.name}`,
          `属性: ${result.left.attribute} vs ${result.right.attribute}`,
          `掷骰: ${result.left.roll} vs ${result.right.roll}`,
          `目标: ${result.left.target} vs ${result.right.target}`,
          `胜者: ${result.winner === 'left' ? result.left.name : result.winner === 'right' ? result.right.name : '平局'}`,
          `说明: ${result.message}`,
        ],
      });
      if (contestHistory.length > MAX_HISTORY) {
        contestHistory.shift();
      }

      return result;
    },
  };

  // 使用 Object.defineProperty 防止意外覆盖
  defineAcuDiceOnWindow(window);

  if (rootWindow !== window) {
    try {
      defineAcuDiceOnWindow(rootWindow);
    } catch (error) {
      console.warn('[AcuDice] 无法写入顶层窗口，可能跨域', error);
    }
  }

  notifyReady();
  dispatchReadyEvent(window);
  if (rootWindow !== window) {
    dispatchReadyEvent(rootWindow);
  }

  console.info('[AcuDice] API v1.2.0 已加载');

  // ========================================
  // ========================================
  // 收藏夹面板 (旧弹窗版本 - 已废弃，保留用于兼容)
  // 新版本使用 renderFavoritesPanel() + bindFavoritesEvents() 面板模式
  // ========================================
  /** @deprecated 使用新的面板模式 renderFavoritesPanel() 替代 */
  const showFavoritesPanel = async () => {
    const { $ } = getCore();
    $('.acu-favorites-overlay').remove();

    const config = getConfig();

    // 获取所有收藏和标签
    const allFavorites = await FavoritesManager.getAll();
    const allTags = await FavoritesManager.getAllTags();

    // 获取当前聊天的表格（用于新建卡片选择模板）
    const rawData = cachedRawData || getTableData();
    const currentTables = rawData || {};

    // 按标签分组
    const groupedByTag: Record<string, FavoriteItem[]> = {};
    const untagged: FavoriteItem[] = [];

    for (const fav of allFavorites) {
      if (fav.tags && fav.tags.length > 0) {
        for (const tag of fav.tags) {
          if (!groupedByTag[tag]) groupedByTag[tag] = [];
          groupedByTag[tag].push(fav);
        }
      } else {
        untagged.push(fav);
      }
    }

    // 生成卡片HTML
    const renderFavoriteCard = (fav: FavoriteItem) => {
      const preview = fav.header
        .slice(0, 3)
        .map(
          (h, i) =>
            `<span class="acu-fav-preview-item"><b>${escapeHtml(h)}:</b> ${escapeHtml(String(fav.rowData[i] || ''))}</span>`,
        )
        .join('');
      const tagsHtml = fav.tags.map(tag => `<span class="acu-favorites-tag">${escapeHtml(tag)}</span>`).join('');
      const sourceInfo = fav.sourceInfo ? `来自: ${escapeHtml(fav.sourceInfo.tableName)}` : '';

      return `
        <div class="acu-favorites-card" data-id="${escapeHtml(fav.id)}">
          <div class="acu-favorites-card-header">
            <div class="acu-favorites-card-preview">${preview}</div>
            <div class="acu-favorites-card-source">${sourceInfo}</div>
          </div>
          <div class="acu-favorites-card-tags">${tagsHtml}</div>
          <div class="acu-favorites-card-actions">
            <button class="acu-fav-btn acu-fav-edit" title="编辑"><i class="fa-solid fa-pen"></i></button>
            <button class="acu-fav-btn acu-fav-copy" title="复制"><i class="fa-solid fa-copy"></i></button>
            <button class="acu-fav-btn acu-fav-send" title="发送到表格"><i class="fa-solid fa-paper-plane"></i></button>
            <button class="acu-fav-btn acu-fav-delete" title="删除"><i class="fa-solid fa-trash"></i></button>
          </div>
        </div>
      `;
    };

    // 生成分组内容HTML
    let contentHtml = '';

    // 按标签分组显示
    for (const tag of Object.keys(groupedByTag).sort()) {
      contentHtml += `
        <div class="acu-favorites-group">
          <div class="acu-favorites-group-title"><i class="fa-solid fa-tag"></i> ${escapeHtml(tag)} (${groupedByTag[tag].length})</div>
          <div class="acu-favorites-group-cards">
            ${groupedByTag[tag].map(renderFavoriteCard).join('')}
          </div>
        </div>
      `;
    }

    // 无标签的平铺显示
    if (untagged.length > 0) {
      contentHtml += `
        <div class="acu-favorites-group">
          <div class="acu-favorites-group-title"><i class="fa-solid fa-inbox"></i> 未分类 (${untagged.length})</div>
          <div class="acu-favorites-group-cards">
            ${untagged.map(renderFavoriteCard).join('')}
          </div>
        </div>
      `;
    }

    if (allFavorites.length === 0) {
      contentHtml = `
        <div class="acu-favorites-empty">
          <i class="fa-solid fa-star" style="font-size: 48px; opacity: 0.3;"></i>
          <p>暂无收藏</p>
          <p style="font-size: 12px; opacity: 0.7;">右键点击表格行 → 选择"收藏此行"</p>
        </div>
      `;
    }

    // 标签筛选下拉
    const tagFilterOptions = allTags
      .map(tag => `<option value="${escapeHtml(tag)}">${escapeHtml(tag)}</option>`)
      .join('');

    const overlayHtml = `
      <div class="acu-favorites-overlay acu-theme-${config.theme}">
        <div class="acu-favorites-panel">
          <div class="acu-favorites-header">
            <h3><i class="fa-solid fa-star"></i> 收藏夹</h3>
            <div class="acu-favorites-header-actions">
              <button class="acu-fav-header-btn" id="acu-fav-new" title="新建卡片"><i class="fa-solid fa-plus"></i> 新建</button>
              <button class="acu-fav-header-btn" id="acu-fav-import" title="导入"><i class="fa-solid fa-file-import"></i> 导入</button>
              <button class="acu-fav-header-btn" id="acu-fav-export" title="导出"><i class="fa-solid fa-file-export"></i> 导出</button>
              <button class="acu-fav-header-btn acu-fav-close" title="关闭"><i class="fa-solid fa-times"></i></button>
            </div>
          </div>
          <div class="acu-favorites-filter">
            <select id="acu-fav-tag-filter">
              <option value="">全部标签</option>
              ${tagFilterOptions}
            </select>
            <input type="text" id="acu-fav-search" placeholder="搜索收藏..." />
          </div>
          <div class="acu-favorites-content">
            ${contentHtml}
          </div>
        </div>
      </div>
    `;

    $('body').append(overlayHtml);

    const $overlay = $('.acu-favorites-overlay');
    const $panel = $overlay.find('.acu-favorites-panel');

    // 关闭面板
    const closePanel = () => {
      $overlay.remove();
    };

    $overlay.on('click', e => {
      if ($(e.target).hasClass('acu-favorites-overlay')) {
        closePanel();
      }
    });

    $panel.find('.acu-fav-close').on('click', closePanel);

    // 标签筛选
    $panel.find('#acu-fav-tag-filter').on('change', async function () {
      const tag = $(this).val() as string;
      const filtered = tag ? await FavoritesManager.getByTag(tag) : await FavoritesManager.getAll();
      const $content = $panel.find('.acu-favorites-content');

      if (filtered.length === 0) {
        $content.html('<div class="acu-favorites-empty"><p>没有匹配的收藏</p></div>');
      } else {
        $content.html(`<div class="acu-favorites-group-cards">${filtered.map(renderFavoriteCard).join('')}</div>`);
      }
    });

    // 搜索
    $panel.find('#acu-fav-search').on('input', async function () {
      const query = ($(this).val() as string).toLowerCase().trim();
      const all = await FavoritesManager.getAll();
      const filtered = query
        ? all.filter(fav => {
            const headerMatch = fav.header.some(h => h.toLowerCase().includes(query));
            const dataMatch = fav.rowData.some(d => String(d).toLowerCase().includes(query));
            const tagMatch = fav.tags.some(t => t.toLowerCase().includes(query));
            return headerMatch || dataMatch || tagMatch;
          })
        : all;

      const $content = $panel.find('.acu-favorites-content');
      if (filtered.length === 0) {
        $content.html('<div class="acu-favorites-empty"><p>没有匹配的收藏</p></div>');
      } else {
        $content.html(`<div class="acu-favorites-group-cards">${filtered.map(renderFavoriteCard).join('')}</div>`);
      }
    });

    // 编辑卡片
    $panel.on('click', '.acu-fav-edit', async function () {
      const id = $(this).closest('.acu-favorites-card').data('id');
      const fav = await FavoritesManager.getById(id);
      if (!fav) return;

      showFavoriteEditModal(fav, async updated => {
        await FavoritesManager.updateFavorite(id, updated);
        toastr.success('保存成功');
        closePanel();
        showFavoritesPanel();
      });
    });

    // 复制卡片
    $panel.on('click', '.acu-fav-copy', async function () {
      const id = $(this).closest('.acu-favorites-card').data('id');
      const result = await FavoritesManager.duplicateFavorite(id);
      if (result) {
        toastr.success('复制成功');
        closePanel();
        showFavoritesPanel();
      } else {
        toastr.error('复制失败');
      }
    });

    // 发送到表格
    $panel.on('click', '.acu-fav-send', async function () {
      const id = $(this).closest('.acu-favorites-card').data('id');
      const fav = await FavoritesManager.getById(id);
      if (!fav) return;

      const compatible = FavoritesManager.findCompatibleTables(fav, currentTables);
      if (compatible.length === 0) {
        toastr.warning('当前聊天没有兼容的表格');
        return;
      }

      showSendToTableModal(fav, compatible, currentTables, () => {
        toastr.success('发送成功');
        closePanel();
        renderInterface();
      });
    });

    // 删除卡片
    $panel.on('click', '.acu-fav-delete', async function () {
      const id = $(this).closest('.acu-favorites-card').data('id');
      if (!confirm('确定要删除这个收藏吗？')) return;

      const result = await FavoritesManager.deleteFavorite(id);
      if (result) {
        toastr.success('删除成功');
        $(this)
          .closest('.acu-favorites-card')
          .fadeOut(200, function () {
            $(this).remove();
          });
      } else {
        toastr.error('删除失败');
      }
    });

    // 新建卡片
    $panel.find('#acu-fav-new').on('click', () => {
      const tableKeys = Object.keys(currentTables);
      if (tableKeys.length === 0) {
        toastr.warning('当前聊天没有表格模板');
        return;
      }

      showNewFavoriteModal(currentTables, async (header, tableName) => {
        const emptyRowData = header.map(() => '');
        const newFav = await FavoritesManager.addFavorite('', tableName, header, emptyRowData, []);
        if (newFav) {
          toastr.success('创建成功');
          closePanel();
          showFavoritesPanel();
          // 立即打开编辑
          setTimeout(async () => {
            const freshFav = await FavoritesManager.getById(newFav.id);
            if (freshFav) {
              showFavoriteEditModal(freshFav, async updated => {
                await FavoritesManager.updateFavorite(newFav.id, updated);
                toastr.success('保存成功');
                $('.acu-favorites-overlay').remove();
                showFavoritesPanel();
              });
            }
          }, 100);
        }
      });
    });

    // 导出
    $panel.find('#acu-fav-export').on('click', async () => {
      const json = await FavoritesManager.exportFavorites();
      if (!json) {
        toastr.error('导出失败');
        return;
      }

      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const now = new Date();
      const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
      a.href = url;
      a.download = `favorites_${dateStr}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toastr.success('导出成功');
    });

    // 导入
    $panel.find('#acu-fav-import').on('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async e => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
          const text = await file.text();
          const result = await FavoritesManager.importFavorites(text);
          if (result) {
            toastr.success(`导入成功: ${result.added}项新增, ${result.updated}项更新`);
            closePanel();
            showFavoritesPanel();
          } else {
            toastr.error('导入失败: 格式无效');
          }
        } catch (err) {
          toastr.error('导入失败: ' + (err instanceof Error ? err.message : String(err)));
        }
      };
      input.click();
    });
  };

  // 收藏卡片编辑弹窗
  const showFavoriteEditModal = (fav: FavoriteItem, onSave: (updated: Partial<FavoriteItem>) => void) => {
    const { $ } = getCore();
    $('.acu-fav-edit-overlay').remove();

    const config = getConfig();

    // 生成编辑行HTML
    const renderEditRows = (header: string[], rowData: (string | number)[]) => {
      return header
        .map(
          (h, i) => `
        <div class="acu-fav-edit-row" data-index="${i}">
          <input type="text" class="acu-fav-edit-header" value="${escapeHtml(h)}" placeholder="列名" />
          <input type="text" class="acu-fav-edit-value" value="${escapeHtml(String(rowData[i] || ''))}" placeholder="值" />
          <button class="acu-fav-edit-remove" title="删除列"><i class="fa-solid fa-minus"></i></button>
        </div>
      `,
        )
        .join('');
    };

    const overlayHtml = `
      <div class="acu-fav-edit-overlay acu-theme-${config.theme}">
        <div class="acu-fav-edit-modal">
          <div class="acu-fav-edit-modal-header">
            <h4>编辑收藏</h4>
            <button class="acu-fav-edit-close"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="acu-fav-edit-modal-body">
            <div class="acu-fav-edit-tags-section">
              <label>标签 (逗号分隔):</label>
              <input type="text" id="acu-fav-edit-tags" value="${escapeHtml(fav.tags.join(', '))}" />
            </div>
            <div class="acu-fav-edit-rows">
              ${renderEditRows(fav.header, fav.rowData)}
            </div>
            <button class="acu-fav-edit-add-col"><i class="fa-solid fa-plus"></i> 添加列</button>
          </div>
          <div class="acu-fav-edit-modal-footer">
            <button class="acu-fav-edit-cancel">取消</button>
            <button class="acu-fav-edit-save">保存</button>
          </div>
        </div>
      </div>
    `;

    $('body').append(overlayHtml);

    const $overlay = $('.acu-fav-edit-overlay');
    const $modal = $overlay.find('.acu-fav-edit-modal');

    const closeModal = () => $overlay.remove();

    $overlay.on('click', e => {
      if ($(e.target).hasClass('acu-fav-edit-overlay')) closeModal();
    });

    $modal.find('.acu-fav-edit-close, .acu-fav-edit-cancel').on('click', closeModal);

    // 删除列
    $modal.on('click', '.acu-fav-edit-remove', function () {
      $(this).closest('.acu-fav-edit-row').remove();
    });

    // 添加列
    $modal.find('.acu-fav-edit-add-col').on('click', () => {
      const newIndex = $modal.find('.acu-fav-edit-row').length;
      const newRowHtml = `
        <div class="acu-fav-edit-row" data-index="${newIndex}">
          <input type="text" class="acu-fav-edit-header" value="" placeholder="列名" />
          <input type="text" class="acu-fav-edit-value" value="" placeholder="值" />
          <button class="acu-fav-edit-remove" title="删除列"><i class="fa-solid fa-minus"></i></button>
        </div>
      `;
      $modal.find('.acu-fav-edit-rows').append(newRowHtml);
    });

    // 保存
    $modal.find('.acu-fav-edit-save').on('click', () => {
      const newHeader: string[] = [];
      const newRowData: (string | number)[] = [];

      $modal.find('.acu-fav-edit-row').each(function () {
        const h = $(this).find('.acu-fav-edit-header').val() as string;
        const v = $(this).find('.acu-fav-edit-value').val() as string;
        if (h.trim()) {
          newHeader.push(h.trim());
          newRowData.push(v);
        }
      });

      const tagsStr = ($modal.find('#acu-fav-edit-tags').val() as string) || '';
      const newTags = tagsStr
        .split(',')
        .map(t => t.trim())
        .filter(t => t.length > 0);

      onSave({
        header: newHeader,
        rowData: newRowData,
        tags: newTags,
      });

      closeModal();
    });
  };

  // 标签输入弹窗（替代浏览器原生 prompt）
  const showTagInputModal = (): Promise<string | null> => {
    const { $ } = getCore();
    const config = getConfig();

    return new Promise(resolve => {
      $('.acu-fav-tag-overlay').remove();

      const overlayHtml = `
        <div class="acu-fav-tag-overlay acu-theme-${config.theme}">
          <div class="acu-fav-tag-modal">
            <div class="acu-fav-tag-modal-header">
              <h4><i class="fa-solid fa-tags"></i> 添加标签</h4>
              <button class="acu-fav-tag-close"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="acu-fav-tag-modal-body">
              <div class="acu-fav-tag-input-section">
                <label>标签（多个标签用逗号分隔，留空则无标签）</label>
                <input type="text" id="acu-fav-tag-input" placeholder="例如：武器, 稀有, 攻击" />
              </div>
            </div>
            <div class="acu-fav-tag-modal-footer">
              <button class="acu-fav-tag-cancel">取消</button>
              <button class="acu-fav-tag-confirm">确认收藏</button>
            </div>
          </div>
        </div>
      `;

      $('body').append(overlayHtml);

      const $overlay = $('.acu-fav-tag-overlay');
      // 内联样式确保移动端层叠上下文正确（与发送到表格弹窗同策略）
      $overlay.css({
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        bottom: '0',
        width: '100vw',
        height: '100vh',
        'z-index': '31300',
        display: 'flex',
        'align-items': 'center',
        'justify-content': 'center',
        padding: '16px',
        'box-sizing': 'border-box',
      });
      const $modal = $overlay.find('.acu-fav-tag-modal');
      const $input = $modal.find('#acu-fav-tag-input');
      let resolved = false;

      const closeModal = (result: string | null) => {
        if (resolved) return;
        resolved = true;
        $overlay.remove();
        resolve(result);
      };

      // 点击遮罩关闭
      $overlay.on('click', e => {
        if ($(e.target).hasClass('acu-fav-tag-overlay')) closeModal(null);
      });

      // 关闭/取消按钮
      $modal.find('.acu-fav-tag-close, .acu-fav-tag-cancel').on('click', () => closeModal(null));

      // 确认按钮
      $modal.find('.acu-fav-tag-confirm').on('click', () => {
        closeModal(($input.val() as string) || '');
      });

      // 回车确认
      $input.on('keydown', (e: JQuery.KeyDownEvent) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          closeModal(($input.val() as string) || '');
        }
      });

      // 自动聚焦输入框
      setTimeout(() => $input.trigger('focus'), 100);
    });
  };

  // 新建收藏弹窗（选择模板）
  const showNewFavoriteModal = (
    currentTables: Record<string, any>,
    onCreate: (header: string[], tableName: string) => void,
  ) => {
    const { $ } = getCore();
    $('.acu-fav-new-overlay').remove();

    const config = getConfig();

    const tableOptions = Object.keys(currentTables)
      .map(key => {
        const table = currentTables[key];
        const name = table.name || key;
        return `<option value="${escapeHtml(key)}">${escapeHtml(name)}</option>`;
      })
      .join('');

    const overlayHtml = `
      <div class="acu-fav-new-overlay acu-theme-${config.theme}">
        <div class="acu-fav-new-modal">
          <div class="acu-fav-new-modal-header">
            <h4>选择模板</h4>
            <button class="acu-fav-new-close"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="acu-fav-new-modal-body">
            <label>从以下表格中选择结构作为模板:</label>
            <select id="acu-fav-new-template">
              ${tableOptions}
            </select>
          </div>
          <div class="acu-fav-new-modal-footer">
            <button class="acu-fav-new-cancel">取消</button>
            <button class="acu-fav-new-create">创建</button>
          </div>
        </div>
      </div>
    `;

    $('body').append(overlayHtml);

    const $overlay = $('.acu-fav-new-overlay');
    const $modal = $overlay.find('.acu-fav-new-modal');

    const closeModal = () => $overlay.remove();

    $overlay.on('click', e => {
      if ($(e.target).hasClass('acu-fav-new-overlay')) closeModal();
    });

    $modal.find('.acu-fav-new-close, .acu-fav-new-cancel').on('click', closeModal);

    $modal.find('.acu-fav-new-create').on('click', () => {
      const key = $modal.find('#acu-fav-new-template').val() as string;
      const table = currentTables[key];
      if (!table || !table.content || !table.content[0]) {
        toastr.error('无效的表格模板');
        return;
      }

      const fullHeader = table.content[0];
      const header: string[] = fullHeader.slice(1).map((h: any) => String(h || ''));
      const tableName = table.name || key;

      onCreate(header, tableName);
      closeModal();
    });
  };

  // 发送到表格弹窗
  const showSendToTableModal = (
    fav: FavoriteItem,
    compatible: TableCompatibility[],
    currentTables: Record<string, any>,
    onSuccess: () => void,
  ) => {
    const { $ } = getCore();
    $('.acu-fav-send-overlay').remove();

    const config = getConfig();

    const tableListHtml = compatible
      .map(c => {
        const modeLabel =
          c.mode === 'strict'
            ? '<span class="acu-match-full">✓ 完全匹配</span>'
            : `<span class="acu-match-partial">⚠ 部分匹配 (${c.matchedCols.length}/${fav.header.length}列)</span>`;
        const unmatchedInfo =
          c.unmatchedCols.length > 0
            ? `<div class="acu-fav-send-unmatched">未匹配: ${c.unmatchedCols.join(', ')}</div>`
            : '';

        return `
        <div class="acu-fav-send-option" data-uid="${escapeHtml(c.tableUid)}" data-mode="${c.mode}">
          <div class="acu-fav-send-option-name">${escapeHtml(c.tableName)}</div>
          <div class="acu-fav-send-option-mode">${modeLabel}</div>
          ${unmatchedInfo}
        </div>
      `;
      })
      .join('');

    const overlayHtml = `
      <div class="acu-fav-send-overlay acu-theme-${config.theme}">
        <div class="acu-fav-send-modal">
          <div class="acu-fav-send-modal-header">
            <h4>选择目标表格</h4>
            <button class="acu-fav-send-close"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="acu-fav-send-modal-body">
            ${tableListHtml}
          </div>
          <div class="acu-fav-send-modal-footer">
            <button class="acu-fav-send-cancel">取消</button>
          </div>
        </div>
      </div>
    `;

    $('body').append(overlayHtml);

    const $overlay = $('.acu-fav-send-overlay');
    // 内联样式确保移动端层叠上下文正确（与骰子配置弹窗同策略）
    $overlay.css({
      position: 'fixed',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      width: '100vw',
      height: '100vh',
      'z-index': '31300',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center',
      padding: '16px',
      'box-sizing': 'border-box',
    });
    const $modal = $overlay.find('.acu-fav-send-modal');

    const closeModal = () => $overlay.remove();

    $overlay.on('click', e => {
      if ($(e.target).hasClass('acu-fav-send-overlay')) closeModal();
    });

    $modal.find('.acu-fav-send-close, .acu-fav-send-cancel').on('click', closeModal);

    // 点击选项发送
    $modal.on('click', '.acu-fav-send-option', async function () {
      const uid = $(this).data('uid') as string;
      const mode = $(this).data('mode') as string;
      const table = currentTables[uid];

      if (!table || !table.content) {
        toastr.error('无法获取目标表格');
        return;
      }

      const targetHeader: string[] = table.content[0].slice(1).map((h: any) => String(h || ''));
      const newRow = FavoritesManager.mapRowToTable(fav, targetHeader);

      // 插入新行
      table.content.push(newRow);

      // 更新缓存并写入数据库（复用 saveDataOnly 统一保存路径）
      const rawData = cachedRawData || getTableData();
      if (!rawData || !rawData[uid]?.content) {
        toastr.error('无法获取目标表格数据');
        return;
      }
      rawData[uid].content = table.content;
      cachedRawData = rawData;

      try {
        await saveDataOnly(rawData, [uid]);
        console.log('[DICE]FavoritesManager 发送成功，已写入数据库');
      } catch (err) {
        console.error('[DICE]FavoritesManager 写入数据库失败:', err);
        toastr.error('写入数据库失败: ' + (err.message || err));
        return;
      }

      // 提示未匹配列
      if (mode === 'loose') {
        const unmatchedCount = fav.header.filter(h => !targetHeader.includes(h)).length;
        if (unmatchedCount > 0) {
          toastr.info(`${unmatchedCount}列未匹配，已填充空值`);
        }
      }

      closeModal();
      onSuccess();
    });
  };

  const showSettingsModal = () => {
    const { $ } = getCore();
    $('.acu-edit-overlay').not(':has(.acu-settings-dialog)').remove();
    clearModalStack();
    pushModal('showSettingsModal', showSettingsModal);

    isSettingsOpen = true;
    const config = getConfig();
    const currentThemeClass = `acu-theme-${config.theme}`;

    // 分组折叠状态（从存储读取，默认第一组展开）
    const expandedGroups = Store.get('acu_settings_expanded', ['appearance']);

    const isGroupExpanded = groupId => expandedGroups.includes(groupId);
    // 生成表格管理列表HTML（包含特殊按钮：投骰、审核、MVU变量）
    const SPECIAL_BUTTONS_CONFIG = [
      { key: '__dice__', name: '投骰', icon: 'fa-dice-d20' },
      { key: '__changes__', name: '变更审核', icon: 'fa-code-compare' },
      { key: '__mvu__', name: 'MVU变量', icon: 'fa-code-branch' },
      { key: '__favorites__', name: '收藏夹', icon: 'fa-star' },
    ];

    const tableManagerHtml = (() => {
      const rawData = cachedRawData || getTableData();
      const tables = processJsonData(rawData || {});
      const savedOrder = getSavedTableOrder() || [];
      const hiddenList = getHiddenTables();

      // 构建所有可管理项：特殊按钮 + 真实表格
      let allItems = [];

      // 添加特殊按钮
      SPECIAL_BUTTONS_CONFIG.forEach(btn => {
        // MVU 按钮始终参与管理，让用户可以设置顺序和可见性
        allItems.push({ key: btn.key, name: btn.name, icon: btn.icon, isSpecial: true });
      });

      // 添加真实表格
      Object.keys(tables).forEach(name => {
        allItems.push({ key: name, name: name, icon: getIconForTableName(name), isSpecial: false });
      });

      // 应用保存的排序
      if (savedOrder.length > 0) {
        const orderMap = new Map(savedOrder.map((k, i) => [k, i]));
        allItems.sort((a, b) => {
          const aIdx = orderMap.has(a.key) ? orderMap.get(a.key) : 9999;
          const bIdx = orderMap.has(b.key) ? orderMap.get(b.key) : 9999;
          return aIdx - bIdx;
        });
      }

      return allItems
        .map(item => {
          const isHidden = hiddenList.includes(item.key);
          const specialClass = item.isSpecial ? ' acu-special-item' : '';
          const displayName = item.name;
          return (
            '<div class="acu-table-manager-item' +
            specialClass +
            (isHidden ? ' hidden-table' : '') +
            '" data-table-name="' +
            escapeHtml(item.key) +
            '" draggable="false">' +
            '<div class="acu-table-item-check" title="点击切换显示/隐藏">' +
            '<i class="fa-solid ' +
            (isHidden ? 'fa-eye-slash' : 'fa-eye') +
            '"></i>' +
            '</div>' +
            '<div class="acu-table-item-icon"><i class="fa-solid ' +
            item.icon +
            '"></i></div>' +
            '<div class="acu-table-item-name">' +
            escapeHtml(displayName) +
            '</div>' +
            '<div class="acu-table-item-handle" title="拖拽排序">' +
            '<i class="fa-solid fa-grip-vertical"></i>' +
            '</div>' +
            '</div>'
          );
        })
        .join('');
    })();
    const chevron = groupId => (isGroupExpanded(groupId) ? 'fa-chevron-down' : 'fa-chevron-right');

    const dialog = $(`
        <div class="acu-edit-overlay">
            <div class="acu-edit-dialog acu-settings-dialog ${currentThemeClass}">
                <div class="acu-settings-header">
                    <div class="acu-settings-title">
                        <span class="acu-settings-text">
                            <i class="fa-solid fa-cog"></i> 设置
                            <span class="acu-version-badge">${SCRIPT_VERSION}</span><button class="acu-manual-update-btn" id="acu-manual-update-btn" title="清理缓存并刷新以获取最新版本"><i class="fa-solid fa-rotate"></i></button>
                        </span>
                    </div>
                    <div class="acu-header-actions">
                        <button class="acu-help-btn" id="acu-help-btn" title="查看使用文档"><i class="fa-solid fa-question-circle"></i></button>
                        <button class="acu-close-btn" id="dlg-close-x"><i class="fa-solid fa-times"></i></button>
                    </div>
                </div>

                <div class="acu-settings-body">
                <!-- 外观样式 -->
                <div class="acu-settings-group ${isGroupExpanded('appearance') ? '' : 'collapsed'}" data-group="appearance">                    <div class="acu-settings-group-title">
                        <i class="fa-solid ${chevron('appearance')} acu-group-chevron"></i>
                        <i class="fa-solid fa-palette"></i> 外观样式
                    </div>
                    <div class="acu-settings-group-body">
                        <div class="acu-setting-row">
                            <div class="acu-setting-info">
                                <span class="acu-setting-label">背景主题</span>
                            </div>
                            <select id="cfg-theme" class="acu-setting-select">
                                ${THEMES.map(t => `<option value="${t.id}" ${t.id === config.theme ? 'selected' : ''}>${t.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="acu-setting-row">
                            <div class="acu-setting-info">
                                <span class="acu-setting-label">字体风格</span>
                            </div>
                            <select id="cfg-font-family" class="acu-setting-select">
                                ${FONTS.map(f => `<option value="${f.id}" ${f.id === config.fontFamily ? 'selected' : ''}>${f.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="acu-setting-row">
                            <div class="acu-setting-info">
                                <span class="acu-setting-label">字体大小 (界面)</span>
                            </div>
                            <div class="acu-stepper" data-id="cfg-font-main" data-min="10" data-max="24" data-step="1">
                                <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                <span class="acu-stepper-value">${config.fontSize}px</span>
                                <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                            </div>
                        </div>
                        <div class="acu-setting-row">
                            <div class="acu-setting-info">
                                <span class="acu-setting-label">字体大小 (选项)</span>
                            </div>
                            <div class="acu-stepper" data-id="cfg-font-opt" data-min="10" data-max="24" data-step="1">
                                <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                <span class="acu-stepper-value">${config.optionFontSize || 12}px</span>
                                <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                            </div>
                        </div>
                        <div class="acu-setting-row acu-setting-row-toggle">
                            <div class="acu-setting-info">
                                <span class="acu-setting-label">高亮变化内容</span>
                            </div>
                            <label class="acu-toggle">
                                <input type="checkbox" id="cfg-new" ${config.highlightNew ? 'checked' : ''}>
                                <span class="acu-toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                    <!-- 布局设置 -->
                    <div class="acu-settings-group ${isGroupExpanded('layout') ? '' : 'collapsed'}" data-group="layout">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('layout')} acu-group-chevron"></i>
                            <i class="fa-solid fa-th-large"></i> 布局设置
                        </div>
                        <div class="acu-settings-group-body">
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">卡片宽度</span>
                                </div>
                                <div class="acu-stepper" data-id="cfg-width" data-min="200" data-max="500" data-step="10">
                                    <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                    <span class="acu-stepper-value">${config.cardWidth}px</span>
                                    <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">布局模式</span>
                                </div>
                                <select id="cfg-layout" class="acu-setting-select">
                                    <option value="horizontal" ${config.layout !== 'vertical' ? 'selected' : ''}>横向滚动</option>
                                    <option value="vertical" ${config.layout === 'vertical' ? 'selected' : ''}>竖向滚动</option>
                                </select>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">底部按钮列数</span>
                                    <span class="acu-setting-hint">仅移动端</span>
                                </div>
                                <select id="cfg-grid-cols" class="acu-setting-select acu-select-short">
                                    <option value="2" ${config.gridColumns == 2 ? 'selected' : ''}>2列</option>
                                    <option value="3" ${config.gridColumns == 3 ? 'selected' : ''}>3列</option>
                                    <option value="4" ${config.gridColumns == 4 ? 'selected' : ''}>4列</option>
                                    <option value="auto" ${config.gridColumns === 'auto' ? 'selected' : ''}>自动</option>
                                </select>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">每页显示条数</span>
                                </div>
                                <div class="acu-stepper" data-id="cfg-per-page" data-min="10" data-max="200" data-step="10">
                                    <button class="acu-stepper-btn acu-stepper-dec"><i class="fa-solid fa-minus"></i></button>
                                    <span class="acu-stepper-value">${config.itemsPerPage}</span>
                                    <button class="acu-stepper-btn acu-stepper-inc"><i class="fa-solid fa-plus"></i></button>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- 位置与交互 -->
                    <div class="acu-settings-group ${isGroupExpanded('position') ? '' : 'collapsed'}" data-group="position">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('position')} acu-group-chevron"></i>
                            <i class="fa-solid fa-arrows-alt"></i> 位置与交互
                        </div>
                        <div class="acu-settings-group-body">
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">面板位置</span>
                                </div>
                                <select id="cfg-position" class="acu-setting-select">
                                    <option value="fixed" ${config.positionMode !== 'embedded' ? 'selected' : ''}>悬浮底部</option>
                                    <option value="embedded" ${config.positionMode === 'embedded' ? 'selected' : ''}>跟随消息</option>
                                </select>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">功能按钮位置</span>
                                </div>
                                <select id="cfg-action-pos" class="acu-setting-select acu-select-short">
                                    <option value="bottom" ${config.actionsPosition !== 'top' ? 'selected' : ''}>底部</option>
                                    <option value="top" ${config.actionsPosition === 'top' ? 'selected' : ''}>顶部</option>
                                </select>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">收起样式</span>
                                </div>
                                <select id="cfg-col-style" class="acu-setting-select acu-select-short">
                                    <option value="bar" ${config.collapseStyle === 'bar' ? 'selected' : ''}>长条</option>
                                    <option value="pill" ${config.collapseStyle === 'pill' ? 'selected' : ''}>胶囊</option>
                                    <option value="mini" ${config.collapseStyle === 'mini' ? 'selected' : ''}>圆钮</option>
                                </select>
                            </div>
                            <div class="acu-setting-row" id="cfg-col-align-row" style="${config.collapseStyle === 'bar' ? 'display:none;' : ''}">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">收起位置</span>
                                </div>
                                <select id="cfg-col-align" class="acu-setting-select acu-select-short">
                                    <option value="right" ${config.collapseAlign === 'right' ? 'selected' : ''}>靠右</option>
                                    <option value="left" ${config.collapseAlign === 'left' ? 'selected' : ''}>靠左</option>
                                    <option value="center" ${config.collapseAlign === 'center' ? 'selected' : ''}>居中</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- 行动选项 -->
                    <div class="acu-settings-group ${isGroupExpanded('options') ? '' : 'collapsed'}" data-group="options">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('options')} acu-group-chevron"></i>
                            <i class="fa-solid fa-gamepad"></i> 行动选项
                        </div>
                        <div class="acu-settings-group-body">
                            <div class="acu-setting-row acu-setting-row-toggle">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">显示行动选项面板</span>
                                </div>
                                <label class="acu-toggle">
                                    <input type="checkbox" id="cfg-show-opt" ${config.showOptionPanel !== false ? 'checked' : ''}>
                                    <span class="acu-toggle-slider"></span>
                                </label>
                            </div>
                            <div class="acu-setting-row acu-setting-row-toggle" id="row-auto-send" style="${config.showOptionPanel !== false ? '' : 'display:none;'}">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label">点击选项直接发送</span>
                                </div>
                                <label class="acu-toggle">
                                    <input type="checkbox" id="cfg-auto-send" ${config.clickOptionToAutoSend !== false ? 'checked' : ''}>
                                    <span class="acu-toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                <!-- 表格管理 -->
                    <div class="acu-settings-group ${isGroupExpanded('tables') ? '' : 'collapsed'}" data-group="tables">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('tables')} acu-group-chevron"></i>
                            <i class="fa-solid fa-table"></i> 表格管理
                        </div>
                        <div class="acu-settings-group-body">
                            <div class="acu-table-manager-hint" style="font-size:11px;color:var(--acu-text-sub);margin-bottom:8px;padding:0 4px;">
                                <i class="fa-solid fa-info-circle"></i> 点击切换显示，长按拖拽排序
                            </div>
                            <div class="acu-table-manager-list" id="table-manager-list">
                                ${tableManagerHtml}
                            </div>
                        </div>
                    </div>

                    <!-- 数据验证规则 -->
                    <div class="acu-settings-group ${isGroupExpanded('validation') ? '' : 'collapsed'}" data-group="validation">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('validation')} acu-group-chevron"></i>
                            <i class="fa-solid fa-clipboard-check"></i> 数据验证规则
                        </div>
                        <div class="acu-settings-group-body">
                            <!-- 预设选择器 -->
                            <div class="acu-setting-row" style="margin-bottom:8px;">
                                <span>当前预设</span>
                                <select class="acu-setting-select" id="preset-select" style="flex:1;max-width:160px;">
                                    ${PresetManager.getAllPresets()
                                      .map(
                                        p =>
                                          `<option value="${escapeHtml(p.id)}" ${p.id === PresetManager.getActivePreset()?.id ? 'selected' : ''}>${escapeHtml(p.name)}${p.id === 'default' ? ` v${PRESET_FORMAT_VERSION}` : p.builtin ? ' (内置)' : ''}</option>`,
                                      )
                                      .join('')}
                                </select>
                            </div>
                            <!-- 预设操作按钮 -->
                            <div style="display:flex;gap:6px;margin-bottom:10px;">
                                <button class="acu-action-btn" id="btn-preset-dup" title="复制预设" style="flex:1;height:28px;"><i class="fa-solid fa-copy"></i></button>
                                <button class="acu-action-btn" id="btn-preset-new" title="新建预设" style="flex:1;height:28px;"><i class="fa-solid fa-plus"></i></button>
                                <button class="acu-action-btn" id="btn-preset-del" title="删除预设" style="flex:1;height:28px;"><i class="fa-solid fa-trash"></i></button>
                                <button class="acu-action-btn" id="btn-preset-export" title="导出" style="flex:1;height:28px;"><i class="fa-solid fa-file-export"></i></button>
                                <button class="acu-action-btn" id="btn-preset-import" title="导入" style="flex:1;height:28px;"><i class="fa-solid fa-file-import"></i></button>
                                <button class="acu-action-btn" id="btn-preset-reset" title="恢复默认预设规则" style="flex:1;height:28px;"><i class="fa-solid fa-rotate-left"></i></button>
                            </div>
                            <div class="acu-validation-hint" style="font-size:11px;color:var(--acu-text-sub);margin-bottom:8px;padding:0 4px;">
                                <i class="fa-solid fa-info-circle"></i> 验证规则用于检测数据合法性，<i class="fa-solid fa-shield-halved"></i> 表示启用拦截
                            </div>
                            <div class="acu-validation-rules-list" id="validation-rules-list">
                                ${ValidationRuleManager.getAllRules()
                                  .map(rule => {
                                    const typeInfo = RULE_TYPE_INFO[rule.ruleType] || {
                                      name: rule.ruleType,
                                      icon: 'fa-question',
                                    };
                                    const isTableRule = typeInfo.scope === 'table';
                                    const hasIntercept = rule.intercept;
                                    return `
                                    <div class="acu-validation-rule-item ${rule.enabled ? '' : 'disabled'}" data-rule-id="${escapeHtml(rule.id)}">
                                        <div class="acu-rule-type-icon" title="${escapeHtml(typeInfo.name)}${isTableRule ? ' (表级)' : ''}">
                                            <i class="fa-solid ${typeInfo.icon}"></i>
                                        </div>
                                        <div class="acu-rule-info">
                                            <div class="acu-rule-name">${escapeHtml(rule.name)}</div>
                                            <div class="acu-rule-target">${escapeHtml(rule.targetTable)}${rule.targetColumn ? '.' + escapeHtml(rule.targetColumn) : isTableRule ? ' (整表)' : ''}</div>
                                        </div>
                                        <div class="acu-rule-intercept ${hasIntercept ? 'active' : ''}" data-rule-id="${escapeHtml(rule.id)}" title="${hasIntercept ? '点击关闭拦截' : '点击启用拦截（违反时回滚）'}"><i class="fa-solid fa-shield-halved"></i></div>
                                        <button class="acu-rule-edit" data-rule-id="${escapeHtml(rule.id)}" title="编辑此规则" style="background:none;border:none;color:var(--text-sub);cursor:pointer;padding:4px;opacity:0.6;transition:all 0.2s;flex-shrink:0;"><i class="fa-solid fa-pen"></i></button>
                                        <div class="acu-rule-toggle ${rule.enabled ? 'active' : ''}" title="点击切换启用/禁用">
                                            <i class="fa-solid ${rule.enabled ? 'fa-toggle-on' : 'fa-toggle-off'}"></i>
                                        </div>
                                        <button class="acu-rule-delete" data-rule-id="${escapeHtml(rule.id)}" title="删除此规则"><i class="fa-solid fa-trash"></i></button>
                                    </div>
                                `;
                                  })
                                  .join('')}
                            </div>
                            <button class="acu-add-rule-btn" id="btn-add-validation-rule">
                                <i class="fa-solid fa-plus"></i> 添加自定义验证规则
                            </button>
                        </div>
                    </div>

                    <!-- 正则转换规则 - Phase 4.1 -->
                    <div class="acu-settings-group ${isGroupExpanded('regex') ? '' : 'collapsed'}" data-group="regex">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('regex')} acu-group-chevron"></i>
                            <i class="fa-solid fa-wand-magic-sparkles"></i> 正则转换规则
                        </div>
                        <div class="acu-settings-group-body">
                            <!-- 预设选择器 -->
                            <div class="acu-setting-row" style="margin-bottom:8px;">
                                <span>当前预设</span>
                                <select class="acu-setting-select" id="regex-preset-select" style="flex:1;max-width:160px;">
                                    ${RegexPresetManager.getAllPresets()
                                      .map(
                                        p =>
                                          `<option value="${escapeHtml(p.id)}" ${p.id === RegexPresetManager.getActivePreset()?.id ? 'selected' : ''}>${escapeHtml(p.name)}${p.id === 'regex_default' ? ` v${PRESET_FORMAT_VERSION}` : ''}</option>`,
                                      )
                                      .join('')}
                                </select>
                            </div>
                            <!-- 预设操作按钮 -->
                            <div style="display:flex;gap:6px;margin-bottom:10px;">
                                <button class="acu-action-btn" id="btn-regex-preset-dup" title="复制预设" style="flex:1;height:28px;"><i class="fa-solid fa-copy"></i></button>
                                <button class="acu-action-btn" id="btn-regex-preset-new" title="新建预设" style="flex:1;height:28px;"><i class="fa-solid fa-plus"></i></button>
                                <button class="acu-action-btn" id="btn-regex-preset-del" title="删除预设" style="flex:1;height:28px;"><i class="fa-solid fa-trash"></i></button>
                                <button class="acu-action-btn" id="btn-regex-preset-export" title="导出" style="flex:1;height:28px;"><i class="fa-solid fa-file-export"></i></button>
                                <button class="acu-action-btn" id="btn-regex-preset-import" title="导入" style="flex:1;height:28px;"><i class="fa-solid fa-file-import"></i></button>
                                <button class="acu-action-btn" id="btn-regex-preset-reset" title="恢复默认预设" style="flex:1;height:28px;"><i class="fa-solid fa-rotate-left"></i></button>
                            </div>
                            <div class="acu-validation-hint" style="font-size:11px;color:var(--acu-text-sub);margin-bottom:8px;padding:0 4px;">
                                <i class="fa-solid fa-info-circle"></i> 正则转换规则用于自动修改数据库表格内容
                            </div>
                            <!-- 规则列表 -->
                            <div class="acu-validation-rules-list" id="regex-rules-list">
                                ${RegexTransformationManager.getAllRules()
                                  .map(rule => {
                                    const scopeIcon =
                                      rule.scope.type === 'global'
                                        ? 'fa-globe'
                                        : rule.scope.type === 'table'
                                          ? 'fa-table'
                                          : 'fa-columns';
                                    const scopeText =
                                      rule.scope.type === 'global'
                                        ? '全局'
                                        : rule.scope.type === 'table'
                                          ? rule.scope.tableNames?.join(',')
                                          : `${rule.scope.tableNames?.join(',')}.${rule.scope.columnNames?.join(',')}`;
                                    return `
                                    <div class="acu-validation-rule-item ${rule.enabled ? '' : 'disabled'}" data-rule-id="${escapeHtml(rule.id)}">
                                        <div class="acu-rule-type-icon" title="作用域: ${escapeHtml(rule.scope.type)}">
                                            <i class="fa-solid ${scopeIcon}"></i>
                                        </div>
                                        <div class="acu-rule-info">
                                            <div class="acu-rule-name">${escapeHtml(rule.name)}</div>
                                            <div class="acu-rule-target" style="font-size:10px;">${escapeHtml(scopeText)} | ${escapeHtml(rule.operation)}</div>
                                        </div>
                                        <button class="acu-rule-edit" data-rule-id="${escapeHtml(rule.id)}" title="编辑此规则" style="background:none;border:none;color:var(--text-sub);cursor:pointer;padding:4px;opacity:0.6;transition:all 0.2s;flex-shrink:0;"><i class="fa-solid fa-pen"></i></button>
                                        <div class="acu-rule-toggle ${rule.enabled ? 'active' : ''}" title="点击切换启用/禁用">
                                            <i class="fa-solid ${rule.enabled ? 'fa-toggle-on' : 'fa-toggle-off'}"></i>
                                        </div>
                                        <button class="acu-rule-delete" data-rule-id="${escapeHtml(rule.id)}" title="删除此规则"><i class="fa-solid fa-trash"></i></button>
                                    </div>
                                `;
                                  })
                                  .join('')}
                            </div>
                            <div style="display:flex;gap:8px;margin-top:8px;">
                                <button class="acu-add-rule-btn" id="btn-add-regex-rule" style="flex:1;">
                                    <i class="fa-solid fa-plus"></i> 添加转换规则
                                </button>
                                <button class="acu-add-rule-btn" id="btn-import-tavern-regex" style="flex:1;">
                                    <i class="fa-solid fa-file-import"></i> 导入酒馆正则
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 高级设置 -->
                    <div class="acu-settings-group ${isGroupExpanded('advanced') ? '' : 'collapsed'}" data-group="advanced">
                        <div class="acu-settings-group-title">
                            <i class="fa-solid ${chevron('advanced')} acu-group-chevron"></i>
                            <i class="fa-solid fa-sliders-h"></i> 高级设置
                        </div>
                        <div class="acu-settings-group-body">
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-dice-d20"></i> 自定义属性规则</span>
                                </div>
                                <button id="cfg-attr-preset-manage" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-cog"></i> 管理
                                </button>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-dice"></i> 检定设置</span>
                                </div>
                                <button id="cfg-advanced-preset-manage" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-cog"></i> 管理
                                </button>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-wand-magic-sparkles"></i> 自定义交互规则</span>
                                </div>
                                <button id="cfg-action-preset-manage" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-cog"></i> 管理
                                </button>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-filter"></i> 变量过滤黑名单</span>
                                </div>
                                <button id="cfg-blacklist-manage" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-cog"></i> 管理
                                </button>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-bug"></i> Debug控制台</span>
                                </div>
                                <button id="btn-open-debug-console" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-terminal"></i> 打开
                                </button>
                            </div>
                            <div class="acu-setting-row">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-trash-can"></i> 清空本地缓存</span>
                                </div>
                                <button id="cfg-clear-local-cache" class="acu-setting-action-btn" style="width: 90px; padding: 6px 12px; font-size: 12px; margin-bottom: 0;">
                                    <i class="fa-solid fa-eraser"></i> 清空
                                </button>
                            </div>
                            <div class="acu-setting-row acu-setting-row-toggle">
                                <div class="acu-setting-info">
                                    <span class="acu-setting-label"><i class="fa-solid fa-bell-slash"></i> 屏蔽神-数据库弹窗</span>
                                </div>
                                <label class="acu-toggle">
                                    <input type="checkbox" id="cfg-db-toast-mute" ${config.muteDatabaseToasts ? 'checked' : ''}>
                                    <span class="acu-toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                </div><!-- 关闭 .acu-settings-body -->
            </div>
        </div>
    `);
    $('body').append(dialog);

    // === 分组折叠交互（带动画） ===
    dialog.find('.acu-settings-group-title').on('click', function () {
      const $group = $(this).closest('.acu-settings-group');
      const $body = $group.find('.acu-settings-group-body');

      // 防止动画过程中重复点击
      if ($body.hasClass('acu-animating')) return;

      const groupId = $group.data('group');
      const $chevron = $(this).find('.acu-group-chevron');
      let expanded = Store.get('acu_settings_expanded', ['appearance']);

      if ($group.hasClass('collapsed')) {
        // 展开
        $group.removeClass('collapsed');
        $chevron.removeClass('fa-chevron-right').addClass('fa-chevron-down');
        if (!expanded.includes(groupId)) expanded.push(groupId);

        $body.addClass('acu-animating').show();
        const targetHeight = $body.prop('scrollHeight');
        $body.css('height', 0).animate({ height: targetHeight }, 180, function () {
          $(this).css('height', '').removeClass('acu-animating');
        });
      } else {
        // 收起
        $group.addClass('collapsed');
        $chevron.removeClass('fa-chevron-down').addClass('fa-chevron-right');
        expanded = expanded.filter(id => id !== groupId);

        const currentHeight = $body.outerHeight();
        $body
          .addClass('acu-animating')
          .css('height', currentHeight)
          .animate({ height: 0 }, 180, function () {
            $(this).hide().css('height', '').removeClass('acu-animating');
          });
      }

      Store.set('acu_settings_expanded', expanded);
    });

    // === 设置项事件绑定 ===
    // 主题
    dialog.find('#cfg-theme').on('change', function () {
      const newTheme = $(this).val();
      saveConfig({ theme: newTheme });
      dialog
        .find('.acu-edit-dialog')
        .removeClass(THEMES.map(t => `acu-theme-${t.id}`).join(' '))
        .addClass(`acu-theme-${newTheme}`);
    });

    // 字体
    dialog.find('#cfg-font-family').on('change', function () {
      saveConfig({ fontFamily: $(this).val() });
    });

    // 管理属性规则按钮
    dialog.find('#cfg-attr-preset-manage').on('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      dialog.remove();
      isSettingsOpen = false;
      showAttributePresetManager();
    });

    // 管理交互规则按钮
    dialog.find('#cfg-action-preset-manage').on('click', function (e) {
      e.stopPropagation();
      dialog.remove();
      isSettingsOpen = false;
      showActionPresetManager();
    });

    // 管理检定设置按钮
    dialog.find('#cfg-advanced-preset-manage').on('click', function (e) {
      e.stopPropagation();
      dialog.remove();
      isSettingsOpen = false;
      showAdvancedPresetManager();
    });

    dialog.find('#cfg-db-toast-mute').on('change', function () {
      saveConfig({ muteDatabaseToasts: $(this).is(':checked') });
    });

    // 管理变量过滤黑名单按钮
    dialog.find('#cfg-blacklist-manage').on('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      showBlacklistManagerModal();
    });

    // 布局
    dialog.find('#cfg-layout').on('change', function () {
      saveConfig({ layout: $(this).val() });
      renderInterface();
    });
    dialog.find('#cfg-grid-cols').on('change', function () {
      saveConfig({ gridColumns: $(this).val() });
    });

    // 位置
    dialog.find('#cfg-position').on('change', function () {
      saveConfig({ positionMode: $(this).val() });
      renderInterface();
    });
    dialog.find('#cfg-action-pos').on('change', function () {
      saveConfig({ actionsPosition: $(this).val() });
      renderInterface();
    });
    dialog.find('#cfg-col-style').on('change', function () {
      const newStyle = $(this).val();
      saveConfig({ collapseStyle: newStyle });

      // 长条样式时隐藏收起位置选项，其他样式显示
      const $alignRow = dialog.find('#cfg-col-align-row');
      if (newStyle === 'bar') {
        $alignRow.hide();
      } else {
        $alignRow.show();
      }

      renderInterface();
    });
    dialog.find('#cfg-col-align').on('change', function () {
      saveConfig({ collapseAlign: $(this).val() });
      renderInterface();
    });

    // 行动选项
    dialog.find('#cfg-show-opt').on('change', function () {
      const checked = $(this).is(':checked');
      saveConfig({ showOptionPanel: checked });
      if (checked) dialog.find('#row-auto-send').slideDown(200);
      else dialog.find('#row-auto-send').slideUp(200);
      renderInterface();
    });
    dialog.find('#cfg-auto-send').on('change', function () {
      saveConfig({ clickOptionToAutoSend: $(this).is(':checked') });
    });
    dialog.find('#cfg-new').on('change', function () {
      saveConfig({ highlightNew: $(this).is(':checked') });
      renderInterface();
    });

    // === 表格管理：点击切换显示/隐藏 ===
    dialog.find('.acu-table-item-check').on('click', function (e) {
      e.stopPropagation();
      const $item = $(this).closest('.acu-table-manager-item');
      const tableName = $item.data('table-name');
      let hiddenList = getHiddenTables();
      const $icon = $(this).find('i');

      if (hiddenList.includes(tableName)) {
        // 显示
        hiddenList = hiddenList.filter(n => n !== tableName);
        $item.removeClass('hidden-table');
        $icon.removeClass('fa-eye-slash').addClass('fa-eye');
      } else {
        // 隐藏
        hiddenList.push(tableName);
        $item.addClass('hidden-table');
        $icon.removeClass('fa-eye').addClass('fa-eye-slash');
      }

      saveHiddenTables(hiddenList);
      renderInterface();
    });

    // === 表格管理：拖拽排序 ===
    const $list = dialog.find('#table-manager-list');
    createSortableList({
      container: $list,
      itemSelector: '.acu-table-manager-item',
      handleSelector: '.acu-table-item-handle',
      cancelSelector: '.acu-table-item-check',
      getItemId: item => {
        const tableName = $(item).data('table-name');
        if (typeof tableName === 'string') return tableName;
        if (tableName !== undefined && tableName !== null) return String(tableName);
        return null;
      },
      onOrderChange: newOrder => {
        saveTableOrder(newOrder);
      },
    });

    // === Stepper 步进器事件 ===
    dialog.find('.acu-stepper').each(function () {
      const $stepper = $(this);
      const id = $stepper.data('id');
      const min = parseInt($stepper.data('min'));
      const max = parseInt($stepper.data('max'));
      const step = parseInt($stepper.data('step'));
      const $value = $stepper.find('.acu-stepper-value');

      const updateValue = newVal => {
        newVal = Math.max(min, Math.min(max, newVal));
        const unit = id === 'cfg-per-page' ? '' : 'px';
        $value.text(newVal + unit);

        // 实时预览
        if (id === 'cfg-width') {
          $('.acu-wrapper').css('--acu-card-width', newVal + 'px');
          saveConfig({ cardWidth: newVal });
        } else if (id === 'cfg-font-main') {
          $('.acu-wrapper').css('--acu-font-size', newVal + 'px');
          saveConfig({ fontSize: newVal });
        } else if (id === 'cfg-font-opt') {
          $('.acu-wrapper, .acu-embedded-options-container').css('--acu-opt-font-size', newVal + 'px');
          saveConfig({ optionFontSize: newVal });
        } else if (id === 'cfg-per-page') {
          saveConfig({ itemsPerPage: newVal });
        }
      };

      const getCurrentValue = () => {
        const text = $value.text().replace(/[^\d]/g, '');
        return parseInt(text) || min;
      };

      $stepper.find('.acu-stepper-dec').on('click', function () {
        updateValue(getCurrentValue() - step);
      });

      $stepper.find('.acu-stepper-inc').on('click', function () {
        updateValue(getCurrentValue() + step);
      });
    });

    // === 验证规则：切换启用/禁用（使用事件委托支持动态元素）===
    dialog.on('click', '.acu-rule-toggle', function (e) {
      e.stopPropagation();
      const $toggle = $(this);
      const $item = $toggle.closest('.acu-validation-rule-item');
      const ruleId = $item.data('rule-id');
      const $icon = $toggle.find('i');
      const isCurrentlyActive = $toggle.hasClass('active');

      // 切换状态
      ValidationRuleManager.toggleRuleEnabled(ruleId, !isCurrentlyActive);

      // 更新 UI
      if (isCurrentlyActive) {
        $toggle.removeClass('active');
        $icon.removeClass('fa-toggle-on').addClass('fa-toggle-off');
        $item.addClass('disabled');
      } else {
        $toggle.addClass('active');
        $icon.removeClass('fa-toggle-off').addClass('fa-toggle-on');
        $item.removeClass('disabled');
      }
    });

    // === 验证规则：编辑规则 ===
    dialog.on('click', '#validation-rules-list .acu-rule-edit', function (e) {
      e.stopPropagation();
      const ruleId = $(this).data('rule-id');
      const rule = ValidationRuleManager.getRule(ruleId);
      if (!rule) return;

      // 打开编辑弹窗（保留设置弹窗用于更新列表）
      showAddValidationRuleModal(dialog, ruleId);
    });

    // === 验证规则：删除规则（使用事件委托）===
    dialog.on('click', '#validation-rules-list .acu-rule-delete', function (e) {
      e.stopPropagation();
      const ruleId = $(this).data('rule-id');
      const $item = $(this).closest('.acu-validation-rule-item');

      if (confirm('确定要删除这条自定义规则吗？')) {
        if (ValidationRuleManager.removeCustomRule(ruleId)) {
          $item.fadeOut(200, function () {
            $(this).remove();
          });
        }
      }
    });

    // === 验证规则：切换拦截状态（使用事件委托）===
    dialog.on('click', '.acu-rule-intercept', function (e) {
      e.stopPropagation();
      const $btn = $(this);
      const ruleId = $btn.data('rule-id');
      const isCurrentlyActive = $btn.hasClass('active');

      if (ValidationRuleManager.toggleRuleIntercept(ruleId, !isCurrentlyActive)) {
        if (isCurrentlyActive) {
          $btn.removeClass('active').attr('title', '点击启用拦截（违反时回滚）');
        } else {
          $btn.addClass('active').attr('title', '点击关闭拦截');
        }
      }
    });

    // === 预设管理事件 ===
    const refreshPresetUI = () => {
      ValidationRuleManager.clearCache();
      const rules = ValidationRuleManager.getAllRules();
      let html = '';
      rules.forEach(rule => {
        const typeInfo = RULE_TYPE_INFO[rule.ruleType] || { name: rule.ruleType, icon: 'fa-question' };
        const isTableRule = typeInfo.scope === 'table';
        const hasIntercept = rule.intercept;
        html += `
          <div class="acu-validation-rule-item ${rule.enabled ? '' : 'disabled'}" data-rule-id="${escapeHtml(rule.id)}">
            <div class="acu-rule-type-icon" title="${escapeHtml(typeInfo.name)}${isTableRule ? ' (表级)' : ''}">
              <i class="fa-solid ${typeInfo.icon}"></i>
            </div>
            <div class="acu-rule-info">
              <div class="acu-rule-name">${escapeHtml(rule.name)}</div>
              <div class="acu-rule-target">${escapeHtml(rule.targetTable)}${rule.targetColumn ? '.' + escapeHtml(rule.targetColumn) : isTableRule ? ' (整表)' : ''}</div>
            </div>
            <div class="acu-rule-intercept ${hasIntercept ? 'active' : ''}" data-rule-id="${escapeHtml(rule.id)}" title="${hasIntercept ? '点击关闭拦截' : '点击启用拦截（违反时回滚）'}"><i class="fa-solid fa-shield-halved"></i></div>
            <button class="acu-rule-edit" data-rule-id="${escapeHtml(rule.id)}" title="编辑此规则" style="background:none;border:none;color:var(--text-sub);cursor:pointer;padding:4px;opacity:0.6;transition:all 0.2s;flex-shrink:0;"><i class="fa-solid fa-pen"></i></button>
            <div class="acu-rule-toggle ${rule.enabled ? 'active' : ''}" title="点击切换启用/禁用">
              <i class="fa-solid ${rule.enabled ? 'fa-toggle-on' : 'fa-toggle-off'}"></i>
            </div>
            <button class="acu-rule-delete" data-rule-id="${escapeHtml(rule.id)}" title="删除此规则"><i class="fa-solid fa-trash"></i></button>
          </div>`;
      });
      dialog.find('#validation-rules-list').html(html);
    };

    // 切换预设
    dialog.find('#preset-select').on('change', function () {
      if (PresetManager.setActivePreset($(this).val())) {
        refreshPresetUI();
      }
    });

    // 复制预设
    dialog.find('#btn-preset-dup').on('click', function () {
      const preset = PresetManager.getActivePreset();
      if (!preset) return;
      const newPreset = PresetManager.duplicatePreset(preset.id);
      if (newPreset) {
        dialog
          .find('#preset-select')
          .append(`<option value="${escapeHtml(newPreset.id)}">${escapeHtml(newPreset.name)}</option>`);
        dialog.find('#preset-select').val(newPreset.id).trigger('change');
      }
    });

    // 新建预设
    dialog.find('#btn-preset-new').on('click', function () {
      const name = prompt('请输入新预设名称:', '我的预设');
      if (!name?.trim()) return;
      const newPreset = PresetManager.createPreset(name.trim());
      if (newPreset) {
        dialog
          .find('#preset-select')
          .append(`<option value="${escapeHtml(newPreset.id)}">${escapeHtml(newPreset.name)}</option>`);
        dialog.find('#preset-select').val(newPreset.id).trigger('change');
      }
    });

    // 删除预设
    dialog.find('#btn-preset-del').on('click', function () {
      const preset = PresetManager.getActivePreset();
      if (!preset) return;
      if (preset.id === 'default') {
        if (window.toastr) window.toastr.warning('默认预设不能删除');
        return;
      }
      if (!confirm(`确定删除预设"${preset.name}"吗？`)) return;
      if (PresetManager.deletePreset(preset.id)) {
        dialog.find(`#preset-select option[value="${preset.id}"]`).remove();
        dialog.find('#preset-select').val('default').trigger('change');
      }
    });

    // 导出预设
    dialog.find('#btn-preset-export').on('click', function () {
      const preset = PresetManager.getActivePreset();
      if (!preset) return;
      const json = PresetManager.exportPreset(preset.id);
      if (json) {
        // 同属性预设导出方式一致：优先导出为文件，避免聊天窗口等环境的粘贴长度限制
        try {
          const filename = `acu_validation_preset_${preset.name || preset.id}_${Date.now()}.json`;
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (e) {
          // 如果浏览器不支持 Blob 下载，则回退到剪贴板/弹窗复制
          navigator.clipboard
            .writeText(json)
            .then(() => {})
            .catch(() => {
              prompt('复制以下内容:', json);
            });
        }
      }
    });

    // 导入预设（使用文件选择器）
    dialog.find('#btn-preset-import').on('click', function () {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = async e => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
          const json = await file.text();
          if (!json?.trim()) return;

          // 先解析JSON获取预设名称，检查是否有同名预设
          let parsedData;
          try {
            parsedData = JSON.parse(json.trim());
          } catch {
            if (window.toastr) window.toastr.error('JSON格式无效');
            return;
          }

          const importingName = parsedData?.preset?.name || '导入的预设';
          const existingPresets = PresetManager.getAllPresets();
          const existingNames = existingPresets.map(p => p.name);
          const hasConflict = existingNames.includes(importingName);

          // 执行导入的函数
          const doImport = (overwrite: boolean, newName?: string) => {
            // 如果需要重命名，修改JSON中的名称
            let finalJson = json.trim();
            if (newName && parsedData?.preset) {
              parsedData.preset.name = newName;
              // 同时生成新的ID避免ID冲突
              parsedData.preset.id = `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              finalJson = JSON.stringify(parsedData);
            }

            // 如果是覆盖模式且存在同名预设，先删除旧预设
            if (overwrite && hasConflict) {
              const existingPreset = existingPresets.find(p => p.name === importingName);
              if (existingPreset && existingPreset.id !== 'default') {
                PresetManager.deletePreset(existingPreset.id);
                dialog.find(`#preset-select option[value="${existingPreset.id}"]`).remove();
              }
            }

            const result = PresetManager.importPreset(finalJson, false);
            if (result && result.preset) {
              const newPreset = result.preset;
              dialog
                .find('#preset-select')
                .append(`<option value="${escapeHtml(newPreset.id)}">${escapeHtml(newPreset.name)}</option>`);
              dialog.find('#preset-select').val(newPreset.id).trigger('change');

              // 如果版本较旧，提示用户是否合并
              if (result.needsMerge) {
                if (
                  confirm(
                    '检测到预设版本较旧，是否要合并新版本的默认值？\n\n这将保留您的自定义规则，并添加新版本中的新规则。',
                  )
                ) {
                  if (PresetManager.mergePresetWithDefaults(newPreset.id)) {
                    refreshPresetUI();
                  } else {
                    if (window.toastr) window.toastr.error('合并失败');
                  }
                }
              }
            } else {
              if (window.toastr) window.toastr.error('导入失败，请检查格式');
            }
          };

          // 如果有冲突，显示冲突处理弹窗
          if (hasConflict) {
            showPresetConflictDialog({
              presetName: importingName,
              presetType: '数据验证',
              existingNames,
              onOverwrite: () => doImport(true),
              onRename: newName => doImport(false, newName),
              onCancel: () => {},
            });
          } else {
            // 无冲突，直接导入
            doImport(false);
          }
        } catch (err) {
          console.error('[DICE]PresetManager 导入失败:', err);
          if (window.toastr) window.toastr.error('导入失败: ' + (err as Error).message);
        }
      };
      input.click();
    });

    // 恢复默认预设规则
    dialog.find('#btn-preset-reset').on('click', function () {
      if (!confirm('确定要将默认预设恢复为初始状态吗？\n这将删除所有对默认预设的修改。')) return;
      if (PresetManager.resetDefaultPreset()) {
        // 如果当前是默认预设，刷新规则列表
        if (PresetManager.getActivePreset()?.id === 'default') {
          refreshPresetUI();
        }
      } else {
        if (window.toastr) window.toastr.error('恢复失败');
      }
    });

    // === 正则转换规则:切换启用/禁用 ===
    dialog.on('click', '#regex-rules-list .acu-rule-toggle', function () {
      const $item = $(this).closest('.acu-validation-rule-item');
      const ruleId = $item.data('rule-id');
      const currentState = RegexTransformationManager.getAllRules().find(r => r.id === ruleId)?.enabled;
      const newState = !currentState;
      const rule = RegexTransformationManager.getRule(ruleId);

      RegexTransformationManager.toggleRuleEnabled(ruleId, newState);

      if (newState) {
      } else {
        toastr.info('规则已禁用');
      }

      refreshRegexRulesList(); // [修复] 局部刷新规则列表,而不是全量重渲染
    });

    // === 正则转换规则：编辑规则 ===
    dialog.on('click', '#regex-rules-list .acu-rule-edit', function () {
      const $item = $(this).closest('.acu-validation-rule-item');
      const ruleId = $item.data('rule-id');
      const rule = RegexTransformationManager.getRule(ruleId);
      if (!rule) return;

      // 打开编辑弹窗
      showAddRegexRuleModal(ruleId);
    });

    // === 正则转换规则:删除规则 ===
    dialog.on('click', '#regex-rules-list .acu-rule-delete', function () {
      const $item = $(this).closest('.acu-validation-rule-item');
      const ruleId = $item.data('rule-id');
      const rule = RegexTransformationManager.getRule(ruleId);
      if (!rule) return;

      if (confirm(`确定要删除规则"${rule.name}"吗？`)) {
        RegexTransformationManager.removeRule(ruleId);
        refreshRegexRulesList(); // [修复] 局部刷新规则列表,而不是全量重渲染
      }
    });

    // === 正则转换预设:切换预设 ===
    dialog.find('#regex-preset-select').on('change', function () {
      const presetId = $(this).val();
      RegexPresetManager.setActivePreset(String(presetId));

      refreshRegexRulesList(); // [修复] 局部刷新规则列表,而不是全量重渲染
    });

    // === 正则转换预设:复制预设 ===
    dialog.find('#btn-regex-preset-dup').on('click', function () {
      const currentPreset = RegexPresetManager.getActivePreset();
      if (!currentPreset) return;

      const name = prompt('请输入新预设名称:', `${currentPreset.name} (副本)`);
      if (!name) return;

      const newPreset = RegexPresetManager.createPreset(name, currentPreset.id);
      if (newPreset) {
        // [修复] 刷新预设下拉列表
        const $presetSelect = dialog.find('#regex-preset-select');
        $presetSelect.append(`<option value="${escapeHtml(newPreset.id)}">${escapeHtml(newPreset.name)}</option>`);
        $presetSelect.val(newPreset.id);

        refreshRegexRulesList(); // 刷新规则列表
      } else {
        toastr.error('预设名称已存在');
      }
    });

    // === 正则转换预设:新建预设 ===
    dialog.find('#btn-regex-preset-new').on('click', function () {
      const name = prompt('请输入预设名称:');
      if (!name) return;

      const newPreset = RegexPresetManager.createPreset(name, null);
      if (newPreset) {
        RegexPresetManager.setActivePreset(newPreset.id);

        // [修复] 刷新预设下拉列表
        const $presetSelect = dialog.find('#regex-preset-select');
        $presetSelect.append(`<option value="${escapeHtml(newPreset.id)}">${escapeHtml(newPreset.name)}</option>`);
        $presetSelect.val(newPreset.id);

        refreshRegexRulesList(); // 刷新规则列表
      } else {
        toastr.error('预设名称已存在');
      }
    });

    // === 正则转换预设:删除预设 ===
    dialog.find('#btn-regex-preset-del').on('click', function () {
      const currentPreset = RegexPresetManager.getActivePreset();
      if (!currentPreset) return;

      if (confirm(`确定要删除预设"${currentPreset.name}"吗？`)) {
        const success = RegexPresetManager.deletePreset(currentPreset.id);
        if (success) {
          // [修复] 刷新预设下拉列表
          const $presetSelect = dialog.find('#regex-preset-select');
          $presetSelect.find(`option[value="${currentPreset.id}"]`).remove();

          // 切换到默认预设
          const defaultPresetId = RegexPresetManager.getActivePreset()?.id;
          if (defaultPresetId) {
            $presetSelect.val(defaultPresetId);
          }

          refreshRegexRulesList(); // 刷新规则列表
        } else {
          toastr.error('不能删除最后一个预设');
        }
      }
    });

    // === 正则转换预设：导出预设 ===
    dialog.find('#btn-regex-preset-export').on('click', function () {
      const currentPreset = RegexPresetManager.getActivePreset();
      if (!currentPreset) return;

      const json = RegexPresetManager.exportPreset(currentPreset.id);
      if (json) {
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `regex-preset-${currentPreset.name}-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }
    });

    // === 正则转换预设：导入预设 ===
    dialog.find('#btn-regex-preset-import').on('click', function () {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = async e => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
          const text = await file.text();
          if (!text?.trim()) return;

          // 先解析JSON获取预设名称，检查是否有同名预设
          let parsedData;
          try {
            parsedData = JSON.parse(text.trim());
          } catch {
            toastr.error('JSON格式无效');
            return;
          }

          const importingName = parsedData?.name || '导入的预设';
          const existingPresets = RegexPresetManager.getAllPresets();
          const existingNames = existingPresets.map(p => p.name);
          const hasConflict = existingNames.includes(importingName);

          // 执行导入的函数
          const doImport = (overwrite: boolean, newName?: string) => {
            // 如果需要重命名，修改JSON中的名称
            let finalJson = text.trim();
            if (newName) {
              parsedData.name = newName;
              // 同时生成新的ID避免ID冲突
              parsedData.id = `regex_preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              finalJson = JSON.stringify(parsedData);
            }

            // 如果是覆盖模式且存在同名预设，先删除旧预设
            if (overwrite && hasConflict) {
              const existingPreset = existingPresets.find(p => p.name === importingName);
              if (existingPreset) {
                // 检查是否不是最后一个预设
                if (existingPresets.length > 1) {
                  RegexPresetManager.deletePreset(existingPreset.id);
                  dialog.find(`#regex-preset-select option[value="${existingPreset.id}"]`).remove();
                }
              }
            }

            const preset = RegexPresetManager.importPreset(finalJson);
            if (preset) {
              // [修复] 刷新预设下拉列表
              const $presetSelect = dialog.find('#regex-preset-select');
              $presetSelect.append(`<option value="${escapeHtml(preset.id)}">${escapeHtml(preset.name)}</option>`);
              $presetSelect.val(preset.id);

              // [修复] 切换到导入的预设并同步规则到实际存储
              RegexPresetManager.setActivePreset(preset.id);
              Store.set(STORAGE_KEY_REGEX_RULES, preset.rules || []);
              RegexTransformationManager.clearCache();

              refreshRegexRulesList(); // 刷新规则列表
            } else {
              toastr.error('预设格式无效');
            }
          };

          // 如果有冲突，显示冲突处理弹窗
          if (hasConflict) {
            showPresetConflictDialog({
              presetName: importingName,
              presetType: '正则转换',
              existingNames,
              onOverwrite: () => doImport(true),
              onRename: newName => doImport(false, newName),
              onCancel: () => {},
            });
          } else {
            // 无冲突，直接导入
            doImport(false);
          }
        } catch (err) {
          toastr.error('导入失败: ' + (err as Error).message);
        }
      };
      input.click();
    });

    // === 正则转换预设：恢复默认预设 ===
    dialog.find('#btn-regex-preset-reset').on('click', function () {
      if (!confirm('确定要恢复默认预设吗？\n\n此操作将清除当前所有正则规则，并恢复为系统内置的默认规则。')) return;

      // 重置默认预设的规则为内置规则
      const presets = RegexPresetManager.getAllPresets();
      let defaultPreset = presets.find(p => p.id === 'regex_default');

      if (defaultPreset) {
        // 用内置规则覆盖默认预设
        defaultPreset.rules = JSON.parse(JSON.stringify(BUILTIN_REGEX_RULES.map(r => ({ ...r, builtin: true }))));
        defaultPreset.version = PRESET_FORMAT_VERSION;
        defaultPreset.updatedAt = Date.now();
      } else {
        // 默认预设不存在，创建它
        defaultPreset = {
          id: 'regex_default',
          name: '默认预设',
          description: '系统默认的正则转换规则预设',
          version: PRESET_FORMAT_VERSION,
          rules: JSON.parse(JSON.stringify(BUILTIN_REGEX_RULES.map(r => ({ ...r, builtin: true })))),
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };
        presets.unshift(defaultPreset);
      }
      RegexPresetManager._save(presets);

      // 切换到默认预设并同步规则
      Store.set(STORAGE_KEY_REGEX_ACTIVE_PRESET, 'regex_default');

      // 强制用内置规则覆盖规则存储
      Store.set(
        STORAGE_KEY_REGEX_RULES,
        JSON.parse(JSON.stringify(BUILTIN_REGEX_RULES.map(r => ({ ...r, builtin: true })))),
      );
      RegexTransformationManager.clearCache();

      // 刷新UI - 重新渲染下拉框选项
      const $presetSelect = dialog.find('#regex-preset-select');
      $presetSelect.empty();
      RegexPresetManager.getAllPresets().forEach(p => {
        const versionSuffix = p.id === 'regex_default' ? ` v${PRESET_FORMAT_VERSION}` : '';
        $presetSelect.append(`<option value="${escapeHtml(p.id)}">${escapeHtml(p.name)}${versionSuffix}</option>`);
      });
      $presetSelect.val('regex_default');
      refreshRegexRulesList();

      toastr.success(`已恢复默认预设，包含 ${BUILTIN_REGEX_RULES.length} 条内置规则`);
    });

    // === 正则转换规则:添加规则 ===
    dialog.find('#btn-add-regex-rule').on('click', function () {
      showAddRegexRuleModal();
    });

    // === 正则转换规则:导入酒馆正则 ===
    dialog.find('#btn-import-tavern-regex').on('click', function () {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = async e => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
          const text = await file.text();
          if (!text?.trim()) return;

          let parsed;
          try {
            parsed = JSON.parse(text.trim());
          } catch {
            toastr.error('JSON格式无效');
            return;
          }

          // 支持单个对象或数组
          const tavernRegexList: TavernRegex[] = Array.isArray(parsed) ? parsed : [parsed];

          // 验证格式：必须有 scriptName 和 findRegex
          if (!tavernRegexList.every(r => r.scriptName && r.findRegex)) {
            toastr.error('不是有效的酒馆正则格式（需要 scriptName 和 findRegex 字段）');
            return;
          }

          const existingRules = RegexTransformationManager.getAllRules();
          const existingNames = existingRules.map(r => r.name);

          let importedCount = 0;
          let skippedCount = 0;

          // 逐条处理导入
          const processNext = (index: number): void => {
            if (index >= tavernRegexList.length) {
              // 全部处理完成
              refreshRegexRulesList();
              if (skippedCount > 0) {
                toastr.info(`导入完成: ${importedCount} 条成功, ${skippedCount} 条跳过`);
              } else if (importedCount > 0) {
                toastr.success(`成功导入 ${importedCount} 条酒馆正则规则`);
              }
              return;
            }

            const tavernRegex = tavernRegexList[index];
            const convertedRule = convertTavernRegexToRule(tavernRegex);
            const hasConflict = existingNames.includes(convertedRule.name);

            if (hasConflict) {
              // 有冲突，弹窗询问
              showPresetConflictDialog({
                presetName: convertedRule.name,
                presetType: '酒馆正则规则',
                existingNames,
                onOverwrite: () => {
                  // 删除旧规则
                  const oldRule = RegexTransformationManager.getAllRules().find(r => r.name === convertedRule.name);
                  if (oldRule) RegexTransformationManager.removeRule(oldRule.id);
                  RegexTransformationManager.addCustomRule(convertedRule);
                  existingNames.push(convertedRule.name);
                  importedCount++;
                  processNext(index + 1);
                },
                onRename: newName => {
                  convertedRule.name = newName;
                  convertedRule.id = `tavern_import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                  RegexTransformationManager.addCustomRule(convertedRule);
                  existingNames.push(newName);
                  importedCount++;
                  processNext(index + 1);
                },
                onCancel: () => {
                  skippedCount++;
                  processNext(index + 1);
                },
              });
            } else {
              // 无冲突，直接添加
              RegexTransformationManager.addCustomRule(convertedRule);
              existingNames.push(convertedRule.name);
              importedCount++;
              processNext(index + 1);
            }
          };

          // 开始处理
          processNext(0);
        } catch (err) {
          toastr.error('导入失败: ' + (err as Error).message);
        }
      };
      input.click();
    });

    // === 验证规则:添加自定义规则 ===
    dialog.find('#btn-add-validation-rule').on('click', function () {
      showAddValidationRuleModal(dialog);
    });

    // === Debug控制台 ===
    dialog.find('#btn-open-debug-console').on('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      dialog.remove();
      isSettingsOpen = false;
      showDebugConsoleModal();
    });

    // === 清空本地缓存 ===
    dialog.find('#cfg-clear-local-cache').on('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      showManualUpdateDialog({
        title: '清空本地缓存',
        iconClass: 'fa-trash-can',
        description: '您确定要清空本地缓存数据吗？此操作主要用于解决缓存冲突或空间不足问题。',
        safeTitle: '高风险操作',
        safeDescription: '注意：此操作将永久删除本地保存的所有配置（包括主题色、布局、规则设置等）。',
        confirmText: '确认清空',
        loadingText: '正在清理...',
        isDanger: true,
        safeIconClass: 'fa-triangle-exclamation',
        onConfirm: async () => {
          const removedLocalStorageKeys = await clearDiceLocalCacheData();
          if (window.toastr) {
            window.toastr.success(
              `本地缓存已清理（localStorage ${removedLocalStorageKeys} 项，含 IndexedDB/脚本缓存）。建议刷新页面以重新初始化设置。`,
            );
          }
        },
      });
    });

    // === 关闭 ===
    const closeDialog = () => {
      isSettingsOpen = false;
      dialog.remove();
      renderInterface();
    };
    dialog.on('click', '#dlg-close-x, .acu-settings-header .acu-close-btn', closeDialog);

    // 帮助按钮点击事件
    dialog.on('click', '#acu-help-btn', function (e) {
      e.stopPropagation();
      window.open('https://jerryzmtz.github.io/DiceSystemManual//', '_blank');
    });

    // 手动更新按钮点击事件
    dialog.on('click', '#acu-manual-update-btn', function (e) {
      e.stopPropagation();
      showManualUpdateDialog();
    });
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);
  };

  // [优化] 渲染防抖：避免短时间内多次渲染导致重复日志
  let renderInterfaceTimer = null;
  let renderInterfacePending = false;

  const renderInterface = () => {
    // 设置面板打开时跳过重绘，防止事件丢失
    if (isSettingsOpen) {
      if (!renderInterfacePending) {
        console.info('[DICE]设置面板打开中，跳过界面渲染');
        renderInterfacePending = true;
      }
      return;
    }

    // [修复] 在防抖前立即保存滚动状态，确保锁定操作等场景下滚动位置不丢失
    saveCurrentTabState();

    // 防抖：如果已有待执行的渲染，取消它
    if (renderInterfaceTimer) {
      clearTimeout(renderInterfaceTimer);
    }

    // 设置新的防抖定时器（50ms延迟，足够短以保持响应性，足够长以合并多次调用）
    renderInterfaceTimer = setTimeout(() => {
      renderInterfaceTimer = null;
      renderInterfacePending = false;
      _renderInterfaceImpl();
    }, 50);
  };

  // 实际的渲染实现函数
  const _renderInterfaceImpl = () => {
    console.info('[DICE]开始渲染界面...');
    const { $ } = getCore();

    // [修复] Observer 延迟创建保险 (带节流优化)
    if (!observer && $('#chat').length) {
      const $chat = $('#chat');
      let mutationLock = false;
      const handleMutation = () => {
        if (mutationLock) return;
        mutationLock = true;
        requestAnimationFrame(() => {
          const config = getConfig();
          if (config.positionMode === 'embedded') {
            mutationLock = false;
            return;
          }
          const children = $chat.children();
          const lastChild = children.last()[0];
          const wrapper = $('.acu-wrapper')[0];
          if (wrapper && lastChild && lastChild !== wrapper) {
            if ($(lastChild).hasClass('mes') || $(lastChild).hasClass('message-body')) {
              $chat.append(wrapper);
            }
          }

          // [新增] 检测到新消息时，应用投骰结果隐藏逻辑（消除闪烁）
          const diceCfg = getDiceConfig();
          if (diceCfg && diceCfg.hideDiceResultInChat) {
            // 步骤1：立即对新消息应用遮罩样式，避免闪烁
            const children = $chat.children();
            const lastChild = children.last();
            if (lastChild.hasClass('mes') || lastChild.hasClass('message-body')) {
              lastChild.addClass('acu-dice-result-revealing');
            }

            // 步骤2：使用RAF在下一帧快速执行隐藏逻辑
            requestAnimationFrame(() => {
              hideDiceResultsInUserMessages();

              // 步骤3：隐藏完成后移除遮罩，触发揭示动画
              requestAnimationFrame(() => {
                lastChild.removeClass('acu-dice-result-revealing').addClass('acu-dice-result-revealed');
                // 动画结束后清理类名
                setTimeout(() => {
                  lastChild.removeClass('acu-dice-result-revealed');
                }, 200);
              });
            });
          }

          mutationLock = false;
        });
      };
      observer = new MutationObserver(handleMutation);
      observer.observe($chat[0], { childList: true });
    }
    let rawData;
    let isDataFromDatabase = false; // 标记数据是否来自数据库（需要检查自动替换）
    if (hasUnsavedChanges && cachedRawData) {
      rawData = cachedRawData;
    } else {
      rawData = getTableData();
      isDataFromDatabase = true; // 数据来自数据库，需要检查自动替换

      // [自动替换] 应用auto模式的正则转换规则
      // 注意：只在非自动转换过程中执行，防止循环触发
      // 只在从数据库获取新数据时执行自动替换
      if (rawData && !isAutoTransforming && isDataFromDatabase) {
        try {
          const enabledRules = RegexTransformationManager.getEnabledRules();

          if (enabledRules.length > 0) {
            console.info(`[DICE]检测到数据更新，应用 ${enabledRules.length} 条规则...`);

            isAutoTransforming = true; // 设置标志，防止循环触发
            const transformResult = RegexTransformationEngine.applyToTable(rawData, enabledRules);
            if (transformResult.totalApplied > 0) {
              console.info(`[DICE]自动替换完成，共影响 ${transformResult.totalApplied} 处数据`);

              // 如果转换成功，需要保存到数据库
              // 使用 saveDataOnly 避免触发快照更新和界面重渲染（因为后面会继续渲染）
              // 注意：saveDataOnly 可能会触发 UpdateController.handleUpdate()，但由于 isAutoTransforming 标志，不会再次触发转换
              // 不等待保存完成，让它在后台执行，避免阻塞界面渲染
              saveDataOnly(rawData, transformResult.modifiedSheetKeys).catch(err => {
                console.warn('[DICE]自动转换后保存数据失败:', err);
              });
            }
            if (transformResult.errors.length > 0) {
              console.warn(`[DICE]自动转换遇到 ${transformResult.errors.length} 个错误:`, transformResult.errors);
            } else if (transformResult.totalApplied === 0) {
              console.info('[DICE]自动转换执行完成，但没有匹配到需要转换的数据');
            }
            isAutoTransforming = false; // 清除标志
          } else {
            isAutoTransforming = false; // 清除标志
          }
        } catch (transformError) {
          isAutoTransforming = false; // 确保异常时也清除标志
          const errorMsg = transformError instanceof Error ? transformError.message : String(transformError);
          console.error('[DICE]自动转换失败:', transformError);
        }
      }

      if (rawData) {
        cachedRawData =
          typeof structuredClone === 'function' ? structuredClone(rawData) : JSON.parse(JSON.stringify(rawData));

        const existingSnapshot = loadSnapshot();
        const currentCtx = getCurrentContextFingerprint();

        // 检查快照是否有效（存在且包含实际表数据）
        const hasValidSnapshotData =
          existingSnapshot && Object.keys(existingSnapshot).some(k => k.startsWith('sheet_'));

        if (!existingSnapshot || !hasValidSnapshotData) {
          // 情况1：没有快照 或 快照数据为空 → 保存新快照
          saveSnapshot({ ...cachedRawData, _contextId: currentCtx });
        } else if (!existingSnapshot._contextId) {
          // 情况2：旧版快照（无 ID）→ 打上当前上下文标记，但不覆盖数据
          saveSnapshot({ ...existingSnapshot, _contextId: currentCtx });
        } else if (existingSnapshot._contextId !== currentCtx) {
          // 情况3：确认切换了聊天 → 覆盖为新数据
          cachedRawData._contextId = currentCtx;
          saveSnapshot(cachedRawData);
        }
        // 情况4：同一聊天且快照有效 → 不动，保持高亮正常
      }
    }

    const $searchInput = $('.acu-search-input');
    if ($('.acu-wrapper').length && $searchInput.is(':focus')) {
      if (rawData) {
        if (!isSaving) currentDiffMap = generateDiffMap(rawData);
        const tables = processJsonData(rawData);
        const activeTab = getActiveTabState();
        const currentTabName = activeTab && tables[activeTab] ? activeTab : null;

        if (currentTabName && tables[currentTabName]) {
          const newHtml = renderTableContent(tables[currentTabName], currentTabName);
          const $virtualDom = $('<div>').html(newHtml);
          $('.acu-card-grid').replaceWith($virtualDom.find('.acu-card-grid'));
          $('.acu-panel-title').html($virtualDom.find('.acu-panel-title').html());
          // [修复] 修正函数名错误，复用主事件绑定
          bindEvents(tables);
          bindOptionEvents(); // <--- 加上这一句，以此确保万无一失
          return;
        }
      }
    }

    let lastScrollX = 0;
    let lastScrollY = 0;

    const $oldContent = $('.acu-panel-content');
    if ($oldContent.length) {
      lastScrollX = $oldContent.scrollLeft();
      lastScrollY = $oldContent.scrollTop();
    }

    $('.acu-wrapper').remove();
    const tables = processJsonData(rawData || {});

    if (isSaving) {
      currentDiffMap = new Set();
    } else {
      currentDiffMap = generateDiffMap(rawData);
    }

    const savedOrder = getSavedTableOrder();
    let orderedNames = Object.keys(tables);
    if (savedOrder)
      orderedNames = savedOrder.filter(n => tables[n]).concat(orderedNames.filter(n => !savedOrder.includes(n)));

    const hiddenList = getHiddenTables();
    orderedNames = orderedNames.filter(n => !hiddenList.includes(n));

    const activeTab = getActiveTabState();
    let currentTabName = activeTab && tables[activeTab] && !hiddenList.includes(activeTab) ? activeTab : null;

    const config = getConfig();
    const isCollapsed = getCollapsedState();

    const layoutClass = config.layout === 'vertical' ? 'acu-layout-vertical' : '';
    // [补回这行] 定义面板位置样式 (悬浮/嵌入)
    const positionClass = `acu-mode-${config.positionMode || 'fixed'}`;

    // [新增] 自动列数 (智能填满) 逻辑
    let finalGridCols = config.gridColumns;
    if (finalGridCols === 'auto') {
      const n = orderedNames.length;

      if (n <= 4) {
        finalGridCols = n < 2 ? 2 : n;
      } else {
        const empty3 = Math.ceil(n / 3) * 3 - n;
        const empty4 = Math.ceil(n / 4) * 4 - n;
        finalGridCols = empty4 <= empty3 ? 4 : 3;
      }
    }

    // --- [修改] 提取选项数据 + 变化检测 ---
    let optionHtml = '';
    let currentOptionHash = null; // 当前选项的指纹

    if (config.showOptionPanel !== false) {
      const optionTables = [];
      Object.keys(tables).forEach(k => {
        if (k.includes('选项')) optionTables.push(tables[k]);
      });

      // [修改开始] 添加收起面板的开关 - 叙事书页风重设计
      if (optionTables.length > 0) {
        const isOptionsCollapsed = getOptionsCollapsedState();
        const collapseIcon = isOptionsCollapsed ? 'fa-chevron-right' : 'fa-chevron-down';
        const collapseText = isOptionsCollapsed ? '展开' : '收起';
        const collapsedClass = isOptionsCollapsed ? 'collapsed' : '';

        let optionCount = 0;
        let hasBtns = false;
        // [修改结束]
        let optionValues = []; // 用于生成指纹

        // 先统计选项数量
        optionTables.forEach(table => {
          if (table.rows) {
            table.rows.forEach(row => {
              row.forEach((cell, idx) => {
                if (idx > 0 && cell && String(cell).trim()) {
                  optionCount++;
                }
              });
            });
          }
        });

        // 生成标题栏
        let buttonsHtml = `
                    <div class="acu-opt-header" data-action="toggle-options">
                        <span>
                            <i class="fa-solid ${collapseIcon}" style="margin-right:6px;font-size:10px;"></i>
                            行动选项 (${optionCount})
                        </span>
                    </div>`;

        optionTables.forEach(table => {
          if (table.rows) {
            table.rows.forEach(row => {
              row.forEach((cell, idx) => {
                if (idx > 0 && cell && String(cell).trim()) {
                  const cellStr = String(cell).trim();
                  buttonsHtml += `<button class="acu-opt-btn" data-val="${safeEncodeURIComponent(cellStr)}">${escapeHtml(cellStr)}</button>`;
                  optionValues.push(cellStr);
                  hasBtns = true;
                }
              });
            });
          }
        });

        if (hasBtns) {
          optionHtml = `<div class="acu-option-panel acu-theme-${config.theme} ${collapsedClass}">${buttonsHtml}</div>`;
          // 生成选项内容的指纹 (简单拼接)
          // [修复] 将收起状态加入指纹，强制触发重绘
          currentOptionHash =
            optionValues.join('|||') +
            (isOptionsCollapsed ? '_collapsed' : '_expanded') +
            `_theme_${config.theme}` +
            `_optSize_${config.optionFontSize || 12}`;
        }
      }
    }

    // [修改] 判断选项是否变化，并控制可见性
    const optionChanged = currentOptionHash !== lastOptionHash;
    // [修复] 只要有选项数据，就应该显示面板（而不是仅在内容变化时）
    // 这修复了用户发送消息后 optionPanelVisible 被设为 false 且选项内容未变时无法恢复的问题
    if (currentOptionHash !== null) {
      optionPanelVisible = true;
    }
    lastOptionHash = currentOptionHash; // 更新缓存

    // [修复] 悬浮收起模式需要特殊类，防止 wrapper 坍塌导致按钮消失
    let html = `<div class="acu-wrapper ${positionClass} acu-theme-${config.theme} ${layoutClass}" style="--acu-card-width:${config.cardWidth}px; --acu-font-size:${config.fontSize}px; --acu-opt-font-size:${config.optionFontSize || 12}px; --acu-grid-cols:${finalGridCols}">`;

    // [布局核心] 如果是嵌入模式，选项放在 DOM 最前面（因为是 column-reverse，视觉上在最下面）
    // [修改] 增加 optionPanelVisible 判断
    if (config.positionMode === 'embedded' && optionHtml && optionPanelVisible) {
      html += optionHtml;
    }

    if (isCollapsed) {
      const colStyleClass = `acu-col-${config.collapseStyle || 'bar'}`;
      const alignClass = `acu-align-${config.collapseAlign || 'right'}`;

      html += `
                <div class="acu-expand-trigger ${colStyleClass} ${alignClass}" id="acu-btn-expand">
                    <i class="fa-solid fa-table"></i> <span>数据库助手 (${Object.keys(tables).length})</span>
                </div>
            `;
    } else {
      // [修改] 读取保存的高度
      const savedHeight = currentTabName ? getTableHeights()[currentTabName] : null;
      // [修改] 支持仪表盘、变更面板和变量面板渲染
      const isDashboardActive = Store.get(STORAGE_KEY_DASHBOARD_ACTIVE, false);
      const isChangesPanelActive = Store.get('acu_changes_panel_active', false);
      const isMvuActive = getActiveTabState() === MvuModule.MODULE_ID;
      const mvuSavedHeight = isMvuActive ? getTableHeights()[MvuModule.MODULE_ID] : null;
      const finalSavedHeight = mvuSavedHeight || savedHeight;
      const shouldShowPanel = isDashboardActive || isChangesPanelActive || isMvuActive || currentTabName;

      html += `
                <div class="acu-data-display ${shouldShowPanel ? 'visible' : ''} ${finalSavedHeight ? 'acu-manual-mode' : ''}" id="acu-data-area" style="${finalSavedHeight ? 'height:' + finalSavedHeight + 'px;' : ''}">
                    ${
                      isChangesPanelActive
                        ? renderChangesPanel(rawData)
                        : isDashboardActive
                          ? renderDashboard(tables)
                          : isMvuActive
                            ? '<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>'
                            : currentTabName
                              ? renderTableContent(tables[currentTabName], currentTabName)
                              : ''
                    }
                </div>
                `;

      // [修复] 强制写入网格列数，防止浏览器初次渲染时卡成单列
      // PC端(>768px) CSS使用了 display:flex !important，会自动忽略这个 grid 属性，所以很安全
      const gridFixStyle = `grid-template-columns: repeat(${finalGridCols}, 1fr);`;

      html += `
                <div class="acu-nav-container ${config.actionsPosition === 'top' ? 'acu-pos-top' : ''}" id="acu-nav-bar" style="${gridFixStyle}">
                    <div class="acu-order-controls" id="acu-order-hint"><i class="fa-solid fa-arrows-alt"></i> 拖动调整顺序，完成后点击保存退出</div>
            `;

      // === 计算变更数量 + 验证错误数量（供审核按钮显示） ===
      const isChangesActive = Store.get('acu_changes_panel_active', false);
      const isFavoritesActive = Store.get('acu_favorites_panel_active', false);
      const isSimpleModeNav = Store.get(STORAGE_KEY_VALIDATION_MODE, false);
      let changesCount = 0;
      let validationErrorCount = 0;
      if (rawData) {
        const snapshot = loadSnapshot();
        if (snapshot) {
          for (const sheetId in rawData) {
            if (!sheetId.startsWith('sheet_')) continue;
            const newSheet = rawData[sheetId];
            const oldSheet = snapshot[sheetId];
            if (!newSheet?.content) continue;
            const newRows = newSheet.content.slice(1);
            const oldRows = oldSheet?.content?.slice(1) || [];

            // [优化] 使用标题匹配计算变更数量（与detectChanges保持一致）
            const oldRowsByTitle = new Map<string, Array<{ index: number; row: (typeof oldRows)[0] }>>();
            oldRows.forEach((row, rIdx) => {
              const title = String(row[1] ?? '').trim();
              if (!oldRowsByTitle.has(title)) {
                oldRowsByTitle.set(title, []);
              }
              oldRowsByTitle.get(title)!.push({ index: rIdx, row });
            });

            newRows.forEach((row, rowIdx) => {
              const title = String(row[1] ?? '').trim();
              let oldRow: (typeof oldRows)[0] | undefined;

              if (title && oldRowsByTitle.has(title)) {
                const queue = oldRowsByTitle.get(title)!;
                if (queue.length > 0) {
                  const matched = queue.shift()!;
                  oldRow = matched.row;
                }
              } else if (!title) {
                oldRow = oldRows[rowIdx];
              }

              if (!oldRow) {
                changesCount++; // 新增行
              } else {
                // 检查是否有字段变化
                let hasChange = false;
                row.forEach((cell, colIdx) => {
                  if (colIdx === 0) return;
                  if (String(cell ?? '') !== String(oldRow![colIdx] ?? '')) hasChange = true;
                });
                if (hasChange) changesCount++;
              }
            });

            // 计算删除的行数（使用标题计数差值）
            const newTitleCounts = new Map<string, number>();
            const oldTitleCounts = new Map<string, number>();
            newRows.forEach(row => {
              const title = String(row[1] ?? '').trim();
              if (title) newTitleCounts.set(title, (newTitleCounts.get(title) || 0) + 1);
            });
            oldRows.forEach(row => {
              const title = String(row[1] ?? '').trim();
              if (title) oldTitleCounts.set(title, (oldTitleCounts.get(title) || 0) + 1);
            });
            oldTitleCounts.forEach((oldCount, title) => {
              const newCount = newTitleCounts.get(title) || 0;
              if (oldCount > newCount) changesCount += oldCount - newCount;
            });
            // 空标题行的删除
            const emptyOldCount = oldRows.filter(r => !String(r[1] ?? '').trim()).length;
            const emptyNewCount = newRows.filter(r => !String(r[1] ?? '').trim()).length;
            if (emptyOldCount > emptyNewCount) changesCount += emptyOldCount - emptyNewCount;
          }
          for (const sheetId in snapshot) {
            if (sheetId.startsWith('sheet_') && !rawData[sheetId]) changesCount++;
          }
        }
        // 计算验证错误数量
        validationErrorCount = ValidationEngine.getErrorCount(rawData);
      }
      // 数据验证模式只显示验证错误数量，完整审核模式只显示变更数量
      const isValidationMode = isSimpleModeNav;
      const displayCount = isValidationMode ? validationErrorCount : changesCount;
      // 警告图标只在数据验证模式下且有错误时显示
      const showWarningIcon = isValidationMode && validationErrorCount > 0;

      // === 构建导航按钮（支持排序和隐藏） ===
      const navHiddenList = getHiddenTables();
      const navSavedOrder = getSavedTableOrder() || [];

      // 定义所有导航项（特殊按钮 + 表格）
      const SPECIAL_NAV_ITEMS = [
        { key: '__dice__', icon: 'fa-dice-d20', label: '掷骰', id: 'acu-btn-dice-nav', extraClass: 'acu-dice-nav-btn' },
        {
          key: '__changes__',
          icon: 'fa-code-compare',
          label: `审核${displayCount > 0 ? '(' + displayCount + ')' : ''}`,
          id: 'acu-btn-changes',
          extraClass: `acu-changes-btn${showWarningIcon ? ' has-validation-errors' : ''}`,
          isActive: isChangesActive,
          warningIcon: showWarningIcon,
        },
        {
          key: '__mvu__',
          icon: 'fa-code-branch',
          label: '变量',
          id: 'acu-btn-mvu',
          extraClass: 'acu-mvu-btn',
          isActive: getActiveTabState() === MvuModule.MODULE_ID,
        },
        {
          key: '__favorites__',
          icon: 'fa-star',
          label: '收藏夹',
          id: 'acu-btn-favorites',
          extraClass: 'acu-favorites-btn',
          isActive: isFavoritesActive,
        },
      ];

      // 构建完整的导航项列表
      let allNavItems = [];

      // 添加特殊按钮
      SPECIAL_NAV_ITEMS.forEach(item => {
        // 先检查是否被用户隐藏
        if (navHiddenList.includes(item.key)) return;

        // 对于MVU按钮，总是显示（不再检查是否可用）
        if (item.key === '__mvu__') {
          allNavItems.push({ ...item, isSpecial: true });
          return;
        }

        // 其他按钮的checkAvailable检查
        if (item.checkAvailable && !item.checkAvailable()) return;
        allNavItems.push({ ...item, isSpecial: true });
      });

      // 添加表格标签
      orderedNames.forEach(name => {
        allNavItems.push({
          key: name,
          icon: getIconForTableName(name),
          label: name,
          isSpecial: false,
          isActive: !isDashboardActive && !isChangesActive && currentTabName === name,
        });
      });

      // 应用保存的排序
      if (navSavedOrder.length > 0) {
        const orderMap = new Map(navSavedOrder.map((k, i) => [k, i]));
        allNavItems.sort((a, b) => {
          const aIdx = orderMap.has(a.key) ? orderMap.get(a.key) : 9999;
          const bIdx = orderMap.has(b.key) ? orderMap.get(b.key) : 9999;
          return aIdx - bIdx;
        });
      }

      // [固定] 仪表盘按钮（始终第一个，不参与排序/隐藏）
      // 注意：order 从 1 开始，避免移动端 Grid 布局问题
      html += `<button class="acu-nav-btn acu-dashboard-btn ${isDashboardActive ? 'active' : ''}" id="acu-btn-dashboard" style="order: 1;">
                <i class="fa-solid fa-chart-line"></i><span>仪表盘</span>
            </button>`;

      // 渲染所有导航项（order 从 2 开始）
      allNavItems.forEach((item, idx) => {
        const activeClass = item.isActive ? 'active' : '';
        const extraClass = item.extraClass || '';
        const orderVal = idx + 2; // 从 2 开始，仪表盘占用 1

        if (item.isSpecial) {
          // 特殊按钮
          const warningIconHtml = item.warningIcon
            ? '<i class="fa-solid fa-triangle-exclamation acu-nav-warning-icon"></i>'
            : '';
          html += `<button class="acu-nav-btn ${extraClass} ${activeClass}" id="${item.id}" style="order: ${orderVal};">
                        <i class="fa-solid ${item.icon}"></i><span>${escapeHtml(item.label)}</span>${warningIconHtml}
                    </button>`;
        } else {
          // 表格标签
          html += `<button class="acu-nav-btn ${activeClass}" data-table="${escapeHtml(item.key)}" style="order: ${orderVal};">
                        <i class="fa-solid ${item.icon}"></i><span>${escapeHtml(item.label)}</span>
                    </button>`;
        }
      });

      // 渲染固定功能按钮（order 设为最大值，确保在最后）
      html += `<div class="acu-actions-group" id="acu-active-actions" style="order: 9999;">`;
      ACTION_BUTTONS.forEach(btn => {
        html += `<button class="acu-action-btn" id="${btn.id}" title="${btn.title}"><i class="fa-solid ${btn.icon}"></i></button>`;
      });
      html += `</div>`;

      html += `</div>`; // 关闭 acu-nav-container
    }

    html += `</div>`; // 关闭 acu-wrapper

    const $existing = $('.acu-wrapper');
    if ($existing.length) {
      $existing.replaceWith(html);
    } else {
      insertHtmlToPage(html);
    }

    // --- [修改] 悬浮模式下，只有选项变化且可见时才插入 ---
    if (config.positionMode !== 'embedded' && optionHtml && optionPanelVisible) {
      if (optionChanged) {
        // 选项有变化，重新插入到最新 AI 消息
        injectIndependentOptions(optionHtml);
      } else {
        // 选项没变化，检查容器是否还存在且在正确位置
        const $existing = $('.acu-embedded-options-container');
        if ($existing.length === 0) {
          // 容器不存在了（可能被删掉了），重新插入
          injectIndependentOptions(optionHtml);
        } else {
          // [修复] 检查容器是否在最新的 AI 消息上，而不是旧消息
          const $lastAiMes = $('#chat .mes')
            .filter(function () {
              const $this = $(this);
              if ($this.attr('is_user') === 'true' || $this.attr('is_system') === 'true' || $this.hasClass('sys_mes'))
                return false;
              if ($this.find('.name_text').text().trim() === 'System' || $this.attr('data-is-system') === 'true')
                return false;
              if ($this.find('.mes_text').length === 0) return false;
              if ($this.css('display') === 'none') return false;
              return true;
            })
            .last();

          const isOnLatestMessage =
            $lastAiMes.length > 0 && $lastAiMes.find('.acu-embedded-options-container').length > 0;

          if (!isOnLatestMessage) {
            // 容器存在但不在最新消息上，需要重新插入
            injectIndependentOptions(optionHtml);
          } else {
            // [修复] 如果容器存在但不可见（被fadeOut隐藏），强制重新插入
            const containerVisible = $existing.is(':visible');
            const containerDisplay = $existing.css('display');
            const containerHtmlLength = $existing.html()?.length || 0;
            if (!containerVisible || containerDisplay === 'none' || containerHtmlLength === 0) {
              injectIndependentOptions(optionHtml);
            }
          }
        }
      }
    } else if (config.positionMode !== 'embedded') {
      // 没有选项数据时，清理旧的容器
      $('.acu-embedded-options-container').remove();
    } else {
      // [修复] 嵌入式模式：清理悬浮模式遗留的独立选项容器
      $('.acu-embedded-options-container').remove();
    }

    bindEvents(tables);
    bindOptionEvents();
    updateSaveButtonState();
    // [修复] 仪表盘NPC头像异步加载
    loadDashboardNpcAvatars();
    // [修复] 如果审核面板激活，绑定其事件
    if (Store.get('acu_changes_panel_active', false)) {
      bindChangesEvents();
    }
    // [修复] 如果变量面板激活，绑定其事件并尝试获取数据
    if (canWriteMvuPanel()) {
      const $panel = $('#acu-data-area');
      if ($panel.length) {
        // 总是尝试获取数据（带重试，增加重试次数）
        // 简化逻辑：直接显示面板，不等待数据加载
        // 用户可以通过刷新按钮来获取数据
        $panel.html('<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>');
        MvuModule.bindEvents($panel);

        // 可选：在后台尝试获取数据（不阻塞界面显示）
        MvuModule.getDataWithRetry(5, 800)
          .then(mvuData => {
            // 如果获取到数据，刷新面板显示
            if (mvuData && canWriteMvuPanel()) {
              $panel.html('<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>');
              MvuModule.bindEvents($panel);
            }
          })
          .catch(err => {
            console.error('[DICE]MvuModule Error getting data:', err);
            if (canWriteMvuPanel()) {
              // 错误时也刷新面板，显示错误状态
              $panel.html('<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>');
              MvuModule.bindEvents($panel);
            }
          });
      }
    }

    setTimeout(() => {
      const $newContent = $('.acu-panel-content');
      const activeTab = getActiveTabState();
      const savedState = tableScrollStates[activeTab];

      if ($newContent.length) {
        // 1. 恢复面板整体位置
        // 优先使用 savedState (记忆)，其次使用 lastScrollY (防抖)
        if (savedState) {
          $newContent.scrollTop(savedState.top);
          $newContent.scrollLeft(savedState.left);
        } else {
          if (lastScrollY > 0) $newContent.scrollTop(lastScrollY);
          if (lastScrollX > 0) $newContent.scrollLeft(lastScrollX);
        }

        // 2. 恢复卡片内部滚动位置 (针对长文本)
        if (savedState && savedState.inner) {
          Object.keys(savedState.inner).forEach(key => {
            const scrollTop = savedState.inner[key];
            // 找到对应的行
            const $targetTitle = $newContent.find(`.acu-editable-title[data-row="${key}"]`);
            if ($targetTitle.length) {
              const $card = $targetTitle.closest('.acu-data-card');
              // 恢复卡片本身的滚动 (如果样式是 overflow on card)
              $card.scrollTop(scrollTop);
              // 同时也尝试恢复 body 的滚动 (如果样式是 overflow on body)
              $card.find('.acu-card-body').scrollTop(scrollTop);
            }
          });
        }
      }
    }, 0);

    console.info('[DICE]界面渲染完成');
  };

  // [新增] 独立插入选项到最新气泡
  const injectIndependentOptions = htmlContent => {
    const { $ } = getCore();
    $('.acu-embedded-options-container').remove();

    // 复用寻找最新 AI 消息的逻辑
    const getTargetContainer = () => {
      const $allMes = $('#chat .mes');
      const $aiMes = $allMes.filter(function () {
        const $this = $(this);
        if ($this.attr('is_user') === 'true' || $this.attr('is_system') === 'true' || $this.hasClass('sys_mes'))
          return false;
        // 增加 data-is-system 属性判断，兼容性更好
        if ($this.find('.name_text').text().trim() === 'System' || $this.attr('data-is-system') === 'true')
          return false;
        // [修复] 忽略没有文本内容的空消息壳子
        if ($this.find('.mes_text').length === 0) return false;
        if ($this.css('display') === 'none') return false;
        return true;
      });
      if ($aiMes.length === 0) return null;

      const $targetMes = $aiMes.last();
      const $targetText = $targetMes.find('.mes_text');
      const $targetBlock = $targetMes.find('.mes_block');
      if ($targetText.length) return $targetText;
      if ($targetBlock.length) return $targetBlock;
      return $targetMes;
    };

    const $target = getTargetContainer();
    if ($target && $target.length) {
      const optConfig = getConfig();
      const $container = $(
        `<div class="acu-embedded-options-container acu-theme-${optConfig.theme}" style="--acu-opt-font-size:${optConfig.optionFontSize || 12}px;"></div>`,
      );
      $container.html(htmlContent);
      // [修复] 插入到 mes_text 的后面（作为兄弟元素），而不是内部
      // 这样 SillyTavern 重写 mes_text 内容时不会销毁我们的容器
      $target.after($container);
    }
  };

  // [修复版] 绑定选项点击事件 (优化：事件委托 + 增强发送逻辑)
  const bindOptionEvents = () => {
    const { $ } = getCore();
    // 移除旧的直接绑定，改用 Body 委托，提升性能并防止动态元素事件丢失
    $('body')
      .off('click.acu_opt')
      .on('click.acu_opt', '.acu-opt-btn', async function (e) {
        e.preventDefault();
        e.stopPropagation();

        const config = getConfig();
        const val = safeDecodeURIComponent($(this).data('val'));

        // 情况1: 没勾选自动发送 -> 填入输入框
        if (!config.clickOptionToAutoSend) {
          smartInsertToTextarea(val, 'action');
          $('#send_textarea').focus();
          return;
        }

        // 情况2: 自动发送
        // 方案A: TavernHelper (最稳健，支持 refresh: 'affected' 以提升性能)
        if (window.TavernHelper) {
          try {
            // 1. 使用 createChatMessages 直接插入消息
            if (window.TavernHelper.createChatMessages) {
              await window.TavernHelper.createChatMessages(
                [
                  {
                    role: 'user',
                    message: val,
                  },
                ],
                {
                  // 利用 TavernHelper 的特性，只刷新受影响的楼层，避免整个聊天重绘
                  refresh: 'affected',
                },
              );

              // 2. 触发生成
              if (window.TavernHelper.triggerSlash) {
                await window.TavernHelper.triggerSlash('/trigger');
              }
              return;
            }
          } catch (err) {
            console.warn('[DICE]ACU TavernHelper 发送失败，尝试备用方案', err);
          }
        }

        // 方案B: SillyTavern 原生接口 (Slash Command)
        const ST = window.SillyTavern || window.parent?.SillyTavern;
        if (ST && ST.executeSlashCommandsWithOptions) {
          try {
            // 使用 raw=true 避免复杂字符转义问题 (参考 slash_command.txt)
            const safeVal = val.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            const cmd = `/send raw=true "${safeVal}"`;

            const sendResult = await ST.executeSlashCommandsWithOptions(cmd);

            if (!sendResult.isError && !sendResult.isAborted) {
              await ST.executeSlashCommandsWithOptions('/trigger');
              return;
            }
            console.warn('[DICE]ACU ST接口 send 失败:', sendResult);
          } catch (err) {
            console.warn('[DICE]ACU ST接口失败，尝试按钮模拟', err);
          }
        }

        // 方案C: 填入输入框 + 点击按钮 (最后兜底)
        const ta = $('#send_textarea');
        if (ta.length) {
          ta.val(val);
          ta.trigger('input').trigger('change');
          // 短暂延迟确保 React 状态同步
          await new Promise(r => setTimeout(r, 50));
          const sendBtn = $('#send_but').filter(':visible');
          if (sendBtn.length) {
            sendBtn[0].click();
          } else {
            // 尝试触发回车
            const enterEvent = $.Event('keydown', { keyCode: 13, which: 13, bubbles: true });
            ta.trigger(enterEvent);
          }
        }
      });
  };

  const insertHtmlToPage = html => {
    const { $ } = getCore();
    const config = getConfig();

    // --- 模式分支处理 ---

    // 1. 嵌入模式 (Embedded)：保持您原版 v19 的复杂逻辑，跟随气泡
    if (config.positionMode === 'embedded') {
      $('.acu-wrapper').remove(); // 嵌入模式下，为了准确性，先移除旧的

      const getTargetContainer = () => {
        const $allMes = $('#chat .mes');
        const $aiMes = $allMes.filter(function () {
          const $this = $(this);
          if ($this.attr('is_user') === 'true') return false;
          if ($this.attr('is_system') === 'true') return false;
          if ($this.hasClass('sys_mes')) return false;
          const name = $this.find('.name_text').text().trim();
          if (name === 'System') return false;
          if ($this.css('display') === 'none') return false;
          const $textDiv = $this.find('.mes_text');
          if ($textDiv.length === 0) return false;
          const textContent = $textDiv.text().trim();
          const hasImage = $textDiv.find('img').length > 0;
          if (textContent.length === 0 && !hasImage) return false;
          return true;
        });
        // 如果找不到 AI 消息，回退到 chat
        if ($aiMes.length === 0) return $('#chat');

        // 锁定逻辑

        let targetIndex = $aiMes.length - 1;
        const $targetMes = $aiMes.eq(targetIndex);
        const $targetBlock = $targetMes.find('.mes_block');
        return $targetBlock.length ? $targetBlock : $targetMes;
      };

      const $target = getTargetContainer();
      if ($target.length) {
        if ($target.hasClass('mes_block') || $target.hasClass('mes')) {
          if ($target.find('.acu-wrapper').length === 0) {
            $target.append(html);
          } else {
            $target.find('.acu-wrapper').replaceWith(html);
          }
        } else {
          // Fallback
          if ($('#chat').find('.acu-wrapper').length === 0) {
            $target.append(html);
          }
        }
      } else {
        $('body').append(html);
      }
      return;
    }

    // 2. 悬浮底部模式 (Fixed)：【核心修改】完全照搬脚本 B 的稳健逻辑
    // 不再每次都移除，而是“有则替换，无则追加”，防止闪烁
    const $chat = $('#chat');
    const $oldWrapper = $('.acu-wrapper');

    if ($oldWrapper.length) {
      $oldWrapper.replaceWith(html);
    } else {
      if ($chat.length) {
        $chat.append(html);
      } else {
        $('body').append(html);
      }
    }
  };
  // [新增] 渲染变更审核面板
  const renderChangesPanel = rawData => {
    const snapshot = loadSnapshot();
    const config = getConfig();

    // 运行数据验证
    const validationErrors = rawData ? ValidationEngine.validateAllData(rawData) : [];

    if (!snapshot || !rawData) {
      // 即使没有快照，如果有验证错误也显示
      if (validationErrors.length === 0) {
        return `
                <div class="acu-panel-header">
                    <div class="acu-panel-title">
                        <div class="acu-title-main"><i class="fa-solid fa-code-compare"></i> <span class="acu-title-text">更新审核</span></div>
                        <div class="acu-title-sub">对比上次保存的快照</div>
                    </div>
                    <div class="acu-header-actions">
                        <button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
                    </div>
                </div>
                <div class="acu-panel-content" style="display:flex;align-items:center;justify-content:center;">
                    <div class="acu-empty-hint">暂无快照数据</div>
                </div>`;
      }
    }

    // 收集所有变更
    const changes = [];

    for (const sheetId in rawData) {
      if (!sheetId.startsWith('sheet_')) continue;
      const newSheet = rawData[sheetId];
      const oldSheet = snapshot[sheetId];
      if (!newSheet?.name || !newSheet?.content) continue;

      const tableName = newSheet.name;
      const headers = newSheet.content[0] || [];
      const newRows = newSheet.content.slice(1);
      const oldRows = oldSheet?.content?.slice(1) || [];

      // [优化] 使用标题匹配检测修改和新增
      // 构建快照数据的标题映射表（队列模式处理重复标题）
      const oldRowsByTitle = new Map<string, Array<{ index: number; row: (typeof oldRows)[0] }>>();
      oldRows.forEach((row, rIdx) => {
        const title = String(row[1] ?? '').trim();
        if (!oldRowsByTitle.has(title)) {
          oldRowsByTitle.set(title, []);
        }
        oldRowsByTitle.get(title)!.push({ index: rIdx, row });
      });

      newRows.forEach((row, rowIdx) => {
        const title = String(row[1] ?? '').trim();

        // 尝试通过标题匹配找到对应的旧行
        let oldRow: (typeof oldRows)[0] | undefined;
        let oldRowIndex: number | undefined;

        if (title && oldRowsByTitle.has(title)) {
          const queue = oldRowsByTitle.get(title)!;
          if (queue.length > 0) {
            const matched = queue.shift()!; // 队列消耗模式
            oldRow = matched.row;
            oldRowIndex = matched.index;
          }
        } else if (!title) {
          // 空标题回退到索引匹配
          oldRow = oldRows[rowIdx];
          oldRowIndex = rowIdx;
        }

        if (!oldRow) {
          // 整行新增
          changes.push({
            type: 'row_added',
            tableName,
            tableKey: sheetId,
            rowIndex: rowIdx,
            headers,
            row,
            title: row[1] || `行 ${rowIdx + 1}`,
          });
        } else {
          // 检查单元格变化，收集同一行的所有修改
          const rowChanges: Array<{
            colIndex: number;
            header: string;
            oldValue: string;
            newValue: string;
          }> = [];
          row.forEach((cell, colIdx) => {
            if (colIdx === 0) return; // 跳过索引列
            const oldVal = String(oldRow![colIdx] ?? '');
            const newVal = String(cell ?? '');
            if (oldVal !== newVal) {
              rowChanges.push({
                colIndex: colIdx,
                header: headers[colIdx] || `列${colIdx}`,
                oldValue: oldVal,
                newValue: newVal,
              });
            }
          });

          if (rowChanges.length === 1) {
            // 单字段修改
            const c = rowChanges[0];
            changes.push({
              type: 'cell_modified',
              tableName,
              tableKey: sheetId,
              rowIndex: rowIdx,
              colIndex: c.colIndex,
              header: c.header,
              oldValue: c.oldValue,
              newValue: c.newValue,
              rowTitle: row[1] || `行 ${rowIdx + 1}`,
            });
          } else if (rowChanges.length > 1) {
            // 多字段修改，合并为一条
            changes.push({
              type: 'row_modified',
              tableName,
              tableKey: sheetId,
              rowIndex: rowIdx,
              headers,
              row,
              oldRow,
              changedFields: rowChanges,
              rowTitle: row[1] || `行 ${rowIdx + 1}`,
            });
          }
        }
      });

      // [优化] 使用标题匹配检测删除的行
      // 构建当前数据的标题计数
      const newTitleCounts = new Map();
      newRows.forEach((row, rIdx) => {
        const title = String(row[1] ?? '').trim();
        if (title) {
          newTitleCounts.set(title, (newTitleCounts.get(title) || 0) + 1);
        }
      });

      // 构建快照数据的标题计数
      const oldTitleCounts = new Map();
      oldRows.forEach((row, rIdx) => {
        const title = String(row[1] ?? '').trim();
        if (title) {
          oldTitleCounts.set(title, (oldTitleCounts.get(title) || 0) + 1);
        }
      });

      // 找出被删除的行：在快照中存在但在当前数据中不存在（或数量减少）
      const processedTitles = new Set();
      oldRows.forEach((oldRow, rIdx) => {
        const title = String(oldRow[1] ?? '').trim();

        if (!title) {
          // 空标题：用索引判断
          if (rIdx >= newRows.length) {
            changes.push({
              type: 'row_deleted',
              tableName,
              tableKey: sheetId,
              rowIndex: rIdx,
              headers,
              row: oldRow,
              title: `行 ${rIdx + 1}`,
            });
          }
        } else if (!processedTitles.has(title)) {
          processedTitles.add(title);
          const oldCount = oldTitleCounts.get(title) || 0;
          const newCount = newTitleCounts.get(title) || 0;
          const deletedCount = oldCount - newCount;

          if (deletedCount > 0) {
            // 找到该标题在快照中的所有行，取最后deletedCount个作为删除
            const matchingOldRows = oldRows
              .map((r, i) => ({ row: r, index: i }))
              .filter(item => String(item.row[1] ?? '').trim() === title);

            const deletedRows = matchingOldRows.slice(-deletedCount);
            deletedRows.forEach(item => {
              changes.push({
                type: 'row_deleted',
                tableName,
                tableKey: sheetId,
                rowIndex: item.index,
                headers,
                row: item.row,
                title: title,
              });
            });
          }
        }
      });
    }

    // 检测整个表被删除
    for (const sheetId in snapshot) {
      if (!sheetId.startsWith('sheet_')) continue;
      if (!rawData[sheetId]) {
        const oldSheet = snapshot[sheetId];
        changes.push({
          type: 'table_deleted',
          tableName: oldSheet?.name || sheetId,
          tableKey: sheetId,
        });
      }
    }

    // 获取数据验证模式状态
    const isValidationMode = Store.get(STORAGE_KEY_VALIDATION_MODE, false);

    // 根据模式渲染不同的标题和按钮
    const panelTitle = isValidationMode ? '数据验证' : '完整审核';
    const panelIcon = isValidationMode ? 'fa-shield-halved' : 'fa-code-compare';
    const toggleTitle = isValidationMode ? '切换到完整审核模式' : '切换到数据验证模式';

    // 渲染 HTML
    let html = `
            <div class="acu-panel-header">
                <div class="acu-panel-title">
                    <div class="acu-title-main"><i class="fa-solid ${panelIcon}"></i> <span class="acu-title-text">${panelTitle}</span></div>
                </div>
                <div class="acu-header-actions">
                    ${!isValidationMode ? '<button class="acu-changes-batch-btn acu-batch-accept" title="接受全部变更"><i class="fa-solid fa-check-double"></i></button>' : ''}
                    <button class="acu-changes-batch-btn acu-batch-reject" title="${isValidationMode ? '全部回滚' : '拒绝全部变更'}"><i class="fa-solid fa-rotate-left"></i></button>
                    <button class="acu-changes-batch-btn acu-simple-mode-toggle ${isValidationMode ? 'active' : ''}" title="${toggleTitle}">
                        <i class="fa-solid ${isValidationMode ? 'fa-filter-circle-xmark' : 'fa-filter'}"></i>
                    </button>
                    <div class="acu-height-control">
                        <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="审核面板" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                    </div>
                    <button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
                </div>
            </div>`;

    html += `<div class="acu-panel-content acu-changes-content ${config.layout === 'horizontal' ? 'acu-changes-horizontal' : ''}">`;

    // === 数据验证模式：只渲染验证错误，使用变更列表的卡片样式 ===
    if (isValidationMode) {
      if (validationErrors.length === 0) {
        html += `<div class="acu-empty-hint" style="padding:40px;text-align:center;flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;">
                <i class="fa-solid fa-check-circle" style="font-size:32px;color:var(--acu-success-text);margin-bottom:10px;display:block;"></i>
                数据验证通过，无违规项
            </div>`;
      } else {
        // 使用变更列表的卡片样式渲染验证错误
        const groupedErrors = ValidationEngine.groupErrorsByTable(validationErrors);
        const collapsedGroups = Store.get('acu_validation_collapsed_groups', []);

        html += `<div class="acu-changes-list">`;

        for (const tableName in groupedErrors) {
          const tableErrors = groupedErrors[tableName];
          const isCollapsed = collapsedGroups.includes(tableName);

          html += `<div class="acu-changes-group ${isCollapsed ? 'collapsed' : ''}">
                    <div class="acu-changes-group-header acu-validation-group-header" data-table="${escapeHtml(tableName)}" style="cursor:pointer;">
                        <i class="fa-solid fa-chevron-${isCollapsed ? 'right' : 'down'} acu-collapse-icon" style="font-size:10px;width:12px;transition:transform 0.2s;"></i>
                        <i class="fa-solid ${getIconForTableName(tableName)}"></i> ${escapeHtml(tableName)}
                        <span class="acu-changes-count" style="background:var(--acu-error-text);">${tableErrors.length}</span>
                    </div>
                    <div class="acu-changes-group-body" style="${isCollapsed ? 'display:none;' : ''}">`;

          tableErrors.forEach(error => {
            const ruleData = error.rule
              ? escapeHtml(
                  JSON.stringify({
                    ruleId: error.ruleId,
                    ruleType: error.ruleType,
                    tableName: error.tableName,
                    rowIndex: error.rowIndex,
                    columnName: error.columnName || '',
                    currentValue: error.currentValue || '',
                    rowTitle: error.rowTitle || '', // 添加 rowTitle 到 ruleData
                    rule: error.rule,
                  }),
                )
              : '';

            html += `<div class="acu-change-item acu-validation-error-item"
                         data-table="${escapeHtml(error.tableName)}"
                         data-row="${error.rowIndex}"
                         data-column="${escapeHtml(error.columnName || '')}"
                         data-rule-id="${escapeHtml(error.ruleId || '')}"
                         data-rule-type="${escapeHtml(error.ruleType || '')}"
                         data-rule-data="${ruleData}">
                        <span class="acu-change-badge" style="background:var(--acu-hl-manual-bg);color:var(--acu-hl-manual);">!</span>
                        ${error.rowTitle && error.rowIndex >= 0 ? `<div class="acu-validation-row-title" style="font-size:11px;color:var(--acu-text-sub);margin-bottom:2px;">${escapeHtml(error.rowTitle)}</div>` : ''}
                        <span class="acu-change-title">${escapeHtml(error.columnName || '整行')}${error.currentValue ? `: ${escapeHtml(error.currentValue.length > 15 ? error.currentValue.substring(0, 15) + '...' : error.currentValue)}` : ''}</span>
                        <span class="acu-validation-error-msg">${escapeHtml(error.errorMessage.length > 25 ? error.errorMessage.substring(0, 25) + '...' : error.errorMessage)}</span>
                        <div class="acu-change-actions">
                            <button class="acu-change-action-btn acu-action-reject" title="回滚"><i class="fa-solid fa-rotate-left"></i></button>
                            <button class="acu-change-action-btn acu-action-edit" title="编辑"><i class="fa-solid fa-pen"></i></button>
                        </div>
                    </div>`;
          });

          html += `</div></div>`;
        }

        html += `</div>`;
      }
    } else {
      // === 完整审核模式：只渲染变更列表，不包含验证错误 ===
      if (changes.length === 0) {
        html += `<div class="acu-empty-hint" style="padding:40px;text-align:center;flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;">
                <i class="fa-solid fa-check-circle" style="font-size:32px;color:var(--acu-success-text);margin-bottom:10px;display:block;"></i>
                当前数据与快照一致，无变更
            </div>`;
      } else {
        // 按表名分组
        const groupedChanges = {};
        changes.forEach(c => {
          const key = c.tableName;
          if (!groupedChanges[key]) groupedChanges[key] = [];
          groupedChanges[key].push(c);
        });

        html += `<div class="acu-changes-list">`;

        const collapsedGroups = Store.get('acu_changes_collapsed_groups', []);

        for (const tableName in groupedChanges) {
          const tableChanges = groupedChanges[tableName];
          const isCollapsed = collapsedGroups.includes(tableName);
          html += `<div class="acu-changes-group ${isCollapsed ? 'collapsed' : ''}">
                    <div class="acu-changes-group-header" data-table="${escapeHtml(tableName)}" style="cursor:pointer;">
                        <i class="fa-solid fa-chevron-${isCollapsed ? 'right' : 'down'} acu-collapse-icon" style="font-size:10px;width:12px;transition:transform 0.2s;"></i>
                        <i class="fa-solid ${getIconForTableName(tableName)}"></i> ${escapeHtml(tableName)}
                        <span class="acu-changes-count">${tableChanges.length}</span>
                    </div>
                    <div class="acu-changes-group-body" style="${isCollapsed ? 'display:none;' : ''}">`;

          tableChanges.forEach(change => {
            if (change.type === 'row_added') {
              html += `<div class="acu-change-item acu-change-added"
                            data-change-type="row_added"
                            data-table-key="${change.tableKey}"
                            data-row-index="${change.rowIndex}">
                            <span class="acu-change-badge acu-badge-added">新</span>
                            <span class="acu-change-title">${escapeHtml(change.title)}</span>
                            <div class="acu-change-actions">
                                <button class="acu-change-action-btn acu-action-accept" title="接受"><i class="fa-solid fa-check"></i></button>
                                <button class="acu-change-action-btn acu-action-reject" title="拒绝"><i class="fa-solid fa-rotate-left"></i></button>
                                <button class="acu-change-action-btn acu-action-edit" title="编辑"><i class="fa-solid fa-pen"></i></button>
                            </div>
                        </div>`;
            } else if (change.type === 'row_deleted') {
              html += `<div class="acu-change-item acu-change-deleted"
                            data-change-type="row_deleted"
                            data-table-key="${change.tableKey}"
                            data-row-index="${change.rowIndex}">
                            <span class="acu-change-badge acu-badge-deleted">删</span>
                            <span class="acu-change-title" style="text-decoration:line-through;opacity:0.6;">${escapeHtml(change.title)}</span>
                            <div class="acu-change-actions">
                                <button class="acu-change-action-btn acu-action-accept" title="接受删除"><i class="fa-solid fa-check"></i></button>
                                <button class="acu-change-action-btn acu-action-restore" title="恢复此行"><i class="fa-solid fa-undo"></i></button>
                            </div>
                        </div>`;
            } else if (change.type === 'cell_modified') {
              const oldShort = change.oldValue.length > 15 ? change.oldValue.substring(0, 15) + '...' : change.oldValue;
              const newShort = change.newValue.length > 15 ? change.newValue.substring(0, 15) + '...' : change.newValue;

              const isOptionTable = change.tableName && change.tableName.includes('选项');
              let fieldDisplay;
              if (isOptionTable) {
                fieldDisplay = `${escapeHtml(change.tableName)}.${escapeHtml(change.header)}`;
              } else {
                fieldDisplay = `${escapeHtml(change.rowTitle)}.${escapeHtml(change.header)}`;
              }

              html += `<div class="acu-change-item acu-change-modified"
                            data-change-type="cell_modified"
                            data-table-key="${change.tableKey}"
                            data-row-index="${change.rowIndex}"
                            data-col-index="${change.colIndex}"
  data-old-value="${safeEncodeURIComponent(change.oldValue)}">
                            <span class="acu-change-badge acu-badge-modified">更</span>
                            <span class="acu-change-field">${fieldDisplay}</span>
                            <span class="acu-change-diff">
                                <span class="acu-diff-old">${escapeHtml(oldShort || '(空)')}</span>
                                <span class="acu-diff-arrow">→</span>
                                <span class="acu-diff-new">${escapeHtml(newShort || '(空)')}</span>
                            </span>
                            <div class="acu-change-actions">
                                <button class="acu-change-action-btn acu-action-accept" title="接受"><i class="fa-solid fa-check"></i></button>
                                <button class="acu-change-action-btn acu-action-reject" title="拒绝"><i class="fa-solid fa-rotate-left"></i></button>
                                <button class="acu-change-action-btn acu-action-edit" title="编辑"><i class="fa-solid fa-pen"></i></button>
                            </div>
                        </div>`;
            } else if (change.type === 'row_modified') {
              // 多字段修改，显示修改数量
              const fieldCount = change.changedFields.length;
              const fieldNames = change.changedFields
                .slice(0, 2)
                .map(f => f.header)
                .join('、');
              const moreText = fieldCount > 2 ? ` 等${fieldCount}项` : '';

              html += `<div class="acu-change-item acu-change-modified"
                            data-change-type="row_modified"
                            data-table-key="${change.tableKey}"
                            data-row-index="${change.rowIndex}">
                            <span class="acu-change-badge acu-badge-modified">更</span>
                            <span class="acu-change-title">${escapeHtml(change.rowTitle)}</span>
                            <span class="acu-change-field-count">${escapeHtml(fieldNames)}${moreText}</span>
                            <div class="acu-change-actions">
                                <button class="acu-change-action-btn acu-action-accept" title="接受"><i class="fa-solid fa-check"></i></button>
                                <button class="acu-change-action-btn acu-action-reject" title="拒绝"><i class="fa-solid fa-rotate-left"></i></button>
                                <button class="acu-change-action-btn acu-action-edit" title="编辑"><i class="fa-solid fa-pen"></i></button>
                            </div>
                        </div>`;
            } else if (change.type === 'table_deleted') {
              html += `<div class="acu-change-item acu-change-deleted"
                            data-change-type="table_deleted"
                            data-table-key="${change.tableKey}">
                            <span class="acu-change-badge acu-badge-deleted">删</span>
                            <span class="acu-change-title" style="text-decoration:line-through;opacity:0.6;">整表已删除</span>
                            <div class="acu-change-actions">
                                <button class="acu-change-action-btn acu-action-accept" title="接受"><i class="fa-solid fa-check"></i></button>
                                <button class="acu-change-action-btn acu-action-restore" title="恢复整表"><i class="fa-solid fa-undo"></i></button>
                            </div>
                        </div>`;
            }
          });

          html += `</div></div>`;
        }

        html += `</div>`;
      }
    }

    html += `</div>`;
    return html;
  };
  // [新增] 绑定变更面板事件
  const bindChangesEvents = () => {
    const { $ } = getCore();

    // 关闭按钮
    $('.acu-changes-content')
      .closest('.acu-data-display')
      .find('.acu-close-btn')
      .off('click')
      .on('click', function () {
        Store.set('acu_changes_panel_active', false);
        $('#acu-data-area').removeClass('visible');
        $('.acu-nav-btn').removeClass('active');
      });

    // === 触摸滑动检测阈值（用于区分滑动和点击）===
    const TOUCH_MOVE_THRESHOLD = 10; // 移动超过10px视为滑动

    // === 验证错误：回滚按钮（恢复快照值）===
    $('.acu-validation-error-item .acu-action-reject')
      .off('click')
      .on('click', async function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-validation-error-item');
        const tableName = $item.data('table');
        const rowIndex = parseInt($item.data('row'), 10);
        const columnName = $item.data('column');

        const snapshot = loadSnapshot();
        if (!snapshot) {
          if (window.toastr) window.toastr.warning('无快照数据可恢复');
          return;
        }

        try {
          const rawData = cachedRawData || getTableData();
          for (const sheetId in rawData) {
            if (rawData[sheetId]?.name === tableName && snapshot[sheetId]) {
              const headers = rawData[sheetId].content?.[0] || [];
              const colIdx = headers.indexOf(columnName);
              if (colIdx >= 0 && snapshot[sheetId].content?.[rowIndex + 1]) {
                const snapshotValue = snapshot[sheetId].content[rowIndex + 1][colIdx];
                rawData[sheetId].content[rowIndex + 1][colIdx] = snapshotValue;
                await saveDataToDatabase(rawData, false, false);
                renderInterface();
                return;
              }
              break;
            }
          }
          if (window.toastr) window.toastr.warning('无法找到对应的快照数据');
        } catch (err) {
          console.error('[DICE]ACU 恢复快照值失败:', err);
          if (window.toastr) window.toastr.error('恢复失败');
        }
      });

    // === 验证错误：编辑按钮（智能修改）===
    $('.acu-validation-error-item .acu-action-edit')
      .off('click')
      .on('click', function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-validation-error-item');
        const ruleData = $item.data('rule-data');
        if (!ruleData) {
          if (window.toastr) window.toastr.warning('无法获取规则信息');
          return;
        }
        try {
          const parsed = typeof ruleData === 'string' ? JSON.parse(ruleData) : ruleData;
          const error = {
            ruleId: parsed.ruleId,
            ruleType: parsed.ruleType,
            rule: parsed.rule,
            tableName: $item.data('table') || parsed.tableName || '',
            rowIndex: parseInt($item.data('row'), 10) || parsed.rowIndex || 0,
            columnName: $item.data('column') || parsed.columnName || '',
            currentValue: parsed.currentValue || '',
            rowTitle: parsed.rowTitle || '', // 添加 rowTitle 到错误对象
            ruleName: parsed.ruleName || parsed.rule?.name || '',
            errorMessage: parsed.errorMessage || parsed.rule?.errorMessage || '',
          };
          showSmartFixModal(error);
        } catch (err) {
          console.error('[DICE]ACU 解析规则数据失败:', err);
          if (window.toastr) window.toastr.error('解析规则数据失败');
        }
      });

    // === 验证错误项：点击定位（但按钮区域除外，且区分滑动和点击）===
    let validationItemTouchStartPos: { x: number; y: number } | null = null;

    $('.acu-validation-error-item')
      .off('click touchstart touchend touchmove')
      .on('touchstart', function (e) {
        const touch = (e.originalEvent as TouchEvent).touches[0];
        validationItemTouchStartPos = { x: touch.clientX, y: touch.clientY };
      })
      .on('touchmove', function (e) {
        if (!validationItemTouchStartPos) return;
        const touch = (e.originalEvent as TouchEvent).touches[0];
        const deltaX = Math.abs(touch.clientX - validationItemTouchStartPos.x);
        const deltaY = Math.abs(touch.clientY - validationItemTouchStartPos.y);
        // 如果移动超过阈值，清除起始位置，表示这是滑动
        if (deltaX > TOUCH_MOVE_THRESHOLD || deltaY > TOUCH_MOVE_THRESHOLD) {
          validationItemTouchStartPos = null;
        }
      })
      .on('touchend', function (e) {
        // 如果触摸位置已被清除（滑动），不触发点击
        if (!validationItemTouchStartPos) return;
        validationItemTouchStartPos = null;

        // 如果点击的是按钮区域，不触发定位
        if ($(e.target).closest('.acu-change-actions, .acu-change-action-btn').length) {
          return;
        }

        // [新增] 检查是否为数据验证模式下的验证错误项
        const isValidationMode = Store.get(STORAGE_KEY_VALIDATION_MODE, false);
        if (isValidationMode) {
          // 数据验证模式下的验证项不跳转
          return;
        }

        const tableName = $(this).data('table');
        const rowIndex = $(this).data('row');

        // 关闭审核面板并跳转到对应表格
        Store.set('acu_changes_panel_active', false);
        saveActiveTabState(tableName);
        renderInterface();

        // 延迟滚动到对应行
        setTimeout(() => {
          const $targetCard = $(`.acu-data-card[data-row-index="${rowIndex}"]`);
          if ($targetCard.length) {
            $targetCard[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
            $targetCard.addClass('acu-highlight-flash');
            setTimeout(() => $targetCard.removeClass('acu-highlight-flash'), 2000);
          }
        }, 300);
      })
      .on('click', function (e) {
        // 桌面端仍使用 click 事件
        // 如果点击的是按钮区域，不触发定位
        if ($(e.target).closest('.acu-change-actions, .acu-change-action-btn').length) {
          return;
        }

        // 检测是否是触摸设备，如果是则 touchend 已处理
        if ('ontouchstart' in window) return;

        // [新增] 检查是否为数据验证模式下的验证错误项
        const isValidationMode = Store.get(STORAGE_KEY_VALIDATION_MODE, false);
        if (isValidationMode) {
          // 数据验证模式下的验证项不跳转
          return;
        }

        const tableName = $(this).data('table');
        const rowIndex = $(this).data('row');

        // 关闭审核面板并跳转到对应表格
        Store.set('acu_changes_panel_active', false);
        saveActiveTabState(tableName);
        renderInterface();

        // 延迟滚动到对应行
        setTimeout(() => {
          const $targetCard = $(`.acu-data-card[data-row-index="${rowIndex}"]`);
          if ($targetCard.length) {
            $targetCard[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
            $targetCard.addClass('acu-highlight-flash');
            setTimeout(() => $targetCard.removeClass('acu-highlight-flash'), 2000);
          }
        }, 300);
      });

    // 折叠/展开分组（根据模式使用不同的存储键）
    $('.acu-changes-group-header')
      .off('click')
      .on('click', function (e) {
        if ($(e.target).closest('.acu-change-item').length) return;

        const tableName = $(this).data('table');
        const $group = $(this).closest('.acu-changes-group');
        const $body = $group.find('.acu-changes-group-body');
        const $icon = $(this).find('.acu-collapse-icon');

        // 根据是否是数据验证模式使用不同的存储键
        const isValidationMode = $(this).hasClass('acu-validation-group-header');
        const storageKey = isValidationMode ? 'acu_validation_collapsed_groups' : 'acu_changes_collapsed_groups';
        let collapsedGroups = Store.get(storageKey, []);

        if ($group.hasClass('collapsed')) {
          $group.removeClass('collapsed');
          $body.slideDown(200);
          $icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');
          collapsedGroups = collapsedGroups.filter(n => n !== tableName);
        } else {
          $group.addClass('collapsed');
          $body.slideUp(200);
          $icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');
          if (!collapsedGroups.includes(tableName)) {
            collapsedGroups.push(tableName);
          }
        }

        Store.set(storageKey, collapsedGroups);
      });

    // === 单项操作：接受（完整面板变更条目）===
    $('.acu-change-item .acu-action-accept')
      .off('click')
      .on('click', async function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-change-item');
        const changeType = $item.data('change-type');
        const tableKey = $item.data('table-key');
        const rowIndex = $item.data('row-index');
        const colIndex = $item.data('col-index');

        const snapshot = loadSnapshot();
        const rawData = cachedRawData || getTableData();
        if (!snapshot || !rawData) return;

        if (changeType === 'cell_modified') {
          // 接受单元格修改：将新值写入快照
          if (snapshot[tableKey]?.content?.[rowIndex + 1] && rawData[tableKey]?.content?.[rowIndex + 1]) {
            snapshot[tableKey].content[rowIndex + 1][colIndex] = rawData[tableKey].content[rowIndex + 1][colIndex];
          }
        } else if (changeType === 'row_modified') {
          // 接受整行修改：将整行新值写入快照
          if (snapshot[tableKey]?.content && rawData[tableKey]?.content?.[rowIndex + 1]) {
            snapshot[tableKey].content[rowIndex + 1] = [...rawData[tableKey].content[rowIndex + 1]];
          }
        } else if (changeType === 'row_added') {
          // 接受新增行：将新行写入快照
          if (rawData[tableKey]?.content?.[rowIndex + 1]) {
            if (!snapshot[tableKey]) {
              snapshot[tableKey] = JSON.parse(JSON.stringify(rawData[tableKey]));
            } else {
              snapshot[tableKey].content[rowIndex + 1] = [...rawData[tableKey].content[rowIndex + 1]];
            }
          }
        } else if (changeType === 'row_deleted') {
          // 接受删除：从快照中也删除该行
          if (snapshot[tableKey]?.content?.[rowIndex + 1]) {
            snapshot[tableKey].content.splice(rowIndex + 1, 1);
          }
        } else if (changeType === 'table_deleted') {
          // 接受整表删除：从快照中删除该表
          delete snapshot[tableKey];
        }

        saveSnapshot(snapshot);

        // 移除该条目并刷新
        $item.fadeOut(200, function () {
          $(this).remove();
          refreshChangesPanel();
        });
      });

    // === 单项操作：拒绝（完整面板变更条目）===
    $('.acu-change-item .acu-action-reject')
      .off('click')
      .on('click', async function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-change-item');
        const changeType = $item.data('change-type');
        const tableKey = $item.data('table-key');
        const rowIndex = $item.data('row-index');
        const colIndex = $item.data('col-index');
        const oldValue = safeDecodeURIComponent($item.data('old-value') || '');

        const snapshot = loadSnapshot();
        let rawData = cachedRawData || getTableData();
        if (!snapshot || !rawData) return;

        if (changeType === 'cell_modified') {
          // 拒绝单元格修改：恢复为快照中的旧值
          if (rawData[tableKey]?.content?.[rowIndex + 1]) {
            rawData[tableKey].content[rowIndex + 1][colIndex] = oldValue;
          }
        } else if (changeType === 'row_modified') {
          // 拒绝整行修改：从快照恢复整行
          if (snapshot[tableKey]?.content?.[rowIndex + 1] && rawData[tableKey]?.content) {
            rawData[tableKey].content[rowIndex + 1] = [...snapshot[tableKey].content[rowIndex + 1]];
          }
        } else if (changeType === 'row_added') {
          // 拒绝新增行：从数据中删除该行
          if (rawData[tableKey]?.content?.[rowIndex + 1]) {
            rawData[tableKey].content.splice(rowIndex + 1, 1);
          }
        }

        // [修复] 使用轻量级保存，只保存数据，不更新快照
        await saveDataOnly(rawData, [tableKey]);

        // 移除该条目并刷新
        $item.fadeOut(200, function () {
          $(this).remove();
          refreshChangesPanel();
        });
      });

    // === 单项操作：恢复（用于已删除的行/表）===
    $('.acu-action-restore')
      .off('click')
      .on('click', async function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-change-item');
        const changeType = $item.data('change-type');
        const tableKey = $item.data('table-key');
        const rowIndex = $item.data('row-index');

        const snapshot = loadSnapshot();
        let rawData = cachedRawData || getTableData();
        if (!snapshot || !rawData) return;

        if (changeType === 'row_deleted') {
          // 恢复删除的行：从快照中取回该行
          if (snapshot[tableKey]?.content?.[rowIndex + 1]) {
            const restoredRow = [...snapshot[tableKey].content[rowIndex + 1]];
            if (!rawData[tableKey]) {
              rawData[tableKey] = JSON.parse(JSON.stringify(snapshot[tableKey]));
              rawData[tableKey].content = [snapshot[tableKey].content[0]];
            }
            // 插入到正确位置
            rawData[tableKey].content.splice(rowIndex + 1, 0, restoredRow);
          }
        } else if (changeType === 'table_deleted') {
          // 恢复整个表：从快照中取回
          if (snapshot[tableKey]) {
            rawData[tableKey] = JSON.parse(JSON.stringify(snapshot[tableKey]));
          }
        }

        // [修复] 使用轻量级保存，只保存数据，不更新快照
        await saveDataOnly(rawData, [tableKey]);

        // 移除该条目并刷新
        $item.fadeOut(200, function () {
          $(this).remove();
          refreshChangesPanel();
        });
      });

    // === 单项操作：编辑（完整面板变更条目，排除验证错误项）===
    $('.acu-change-item:not(.acu-validation-error-item) .acu-action-edit')
      .off('click')
      .on('click', function (e) {
        e.stopPropagation();
        const $item = $(this).closest('.acu-change-item');
        const tableKey = $item.data('table-key');
        const rowIndex = $item.data('row-index');
        const changeType = $item.data('change-type');

        if (!tableKey || rowIndex === undefined) return;

        const rawData = cachedRawData || getTableData();
        if (!rawData || !rawData[tableKey]) return;

        const sheet = rawData[tableKey];
        const headers = sheet.content ? sheet.content[0] : [];
        const row = sheet.content ? sheet.content[rowIndex + 1] : null;

        if (!row) {
          if (window.toastr) window.toastr.warning('该行可能已被删除');
          return;
        }

        // 根据变更类型选择编辑方式
        if (changeType === 'row_modified') {
          // 多字段修改，打开整体编辑
          showRowCompareEditModal(row, headers, sheet.name || '编辑', rowIndex, tableKey);
        } else if (changeType === 'cell_modified') {
          const colIndex = $item.data('col-index');
          const headerName = headers[colIndex] || `列${colIndex}`;
          const cellValue = row[colIndex] || '';
          showChangeSingleFieldModal(cellValue, headerName, sheet.name, rowIndex, colIndex, tableKey);
        } else {
          showChangeEditModal(row, headers, sheet.name || '编辑', rowIndex, tableKey);
        }
      });

    // === 批量操作：接受全部 ===
    $('.acu-batch-accept')
      .off('click')
      .on('click', async function () {
        const rawData = cachedRawData || getTableData();
        if (!rawData) return;

        // 将当前数据完整保存为新快照
        saveSnapshot(JSON.parse(JSON.stringify(rawData)));
        currentDiffMap = new Set();

        // 刷新面板
        refreshChangesPanel();
      });

    // === 批量操作：拒绝全部 ===
    $('.acu-batch-reject')
      .off('click')
      .on('click', async function () {
        const snapshot = loadSnapshot();
        if (!snapshot) {
          if (window.toastr) window.toastr.warning('无快照数据');
          return;
        }

        // 将快照数据恢复为当前数据
        const restoredData = JSON.parse(JSON.stringify(snapshot));
        cachedRawData = restoredData;
        await saveDataToDatabase(restoredData, false, false);
      });

    // === 简洁模式切换 ===
    $('.acu-simple-mode-toggle')
      .off('click')
      .on('click', function () {
        const currentMode = Store.get(STORAGE_KEY_VALIDATION_MODE, false);
        const newMode = !currentMode;
        Store.set(STORAGE_KEY_VALIDATION_MODE, newMode);

        // 刷新面板
        const rawData = cachedRawData || getTableData();
        $('#acu-data-area').html(renderChangesPanel(rawData));
        bindChangesEvents();

        // 更新导航栏计数
        updateChangesCount(rawData);
      });

    // === 高度拖动调节 ===
    $('.acu-changes-content')
      .closest('.acu-data-display')
      .find('.acu-height-drag-handle')
      .off('pointerdown')
      .on('pointerdown', function (e) {
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const handle = this;
        handle.setPointerCapture(e.pointerId);
        $(handle).addClass('active');
        const $panel = $('#acu-data-area');
        const startHeight = $panel.height();
        const startY = e.clientY;
        const tableName = $(handle).data('table');

        handle.onpointermove = function (moveE) {
          const dy = moveE.clientY - startY;
          let newHeight = startHeight - dy; // 向上拖动增加高度
          if (newHeight < MIN_PANEL_HEIGHT) newHeight = MIN_PANEL_HEIGHT;
          if (newHeight > MAX_PANEL_HEIGHT) newHeight = MAX_PANEL_HEIGHT;
          $panel.css('height', newHeight + 'px');
        };
        handle.onpointerup = function (upE) {
          $(handle).removeClass('active');
          handle.releasePointerCapture(upE.pointerId);
          handle.onpointermove = null;
          handle.onpointerup = null;
          // 保存高度
          const finalHeight = $panel.height();
          const heights = getTableHeights();
          heights[tableName] = finalHeight;
          saveTableHeights(heights);
        };
      })
      .off('dblclick')
      .on('dblclick', function (e) {
        e.preventDefault();
        e.stopPropagation();
        const tableName = $(this).data('table');
        const $panel = $('#acu-data-area');
        $panel.css('height', ''); // 清除高度样式
        // 清除保存的高度
        const heights = getTableHeights();
        delete heights[tableName];
        saveTableHeights(heights);
      });

    // === 横向模式：智能区分横向和竖向滑动 ===
    const $horizontalScroller = $('.acu-changes-content.acu-changes-horizontal');
    if ($horizontalScroller.length) {
      $horizontalScroller[0].addEventListener(
        'touchstart',
        function (e) {
          this._touchStartX = e.touches[0].clientX;
          this._touchStartY = e.touches[0].clientY;
          this._scrollDirection = null; // 重置滚动方向
        },
        { passive: true },
      );

      $horizontalScroller[0].addEventListener(
        'touchmove',
        function (e) {
          if (!this._touchStartX) return;

          const deltaX = Math.abs(e.touches[0].clientX - this._touchStartX);
          const deltaY = Math.abs(e.touches[0].clientY - this._touchStartY);

          // 第一次移动时确定主滚动方向
          if (!this._scrollDirection && (deltaX > 5 || deltaY > 5)) {
            this._scrollDirection = deltaX > deltaY ? 'horizontal' : 'vertical';
          }

          // 只在明确是横向滚动时才阻止事件传播
          // 竖向滚动时不做任何干预，让其自然触发页面滚动
          if (this._scrollDirection === 'horizontal' && deltaX > 10) {
            e.stopPropagation();
          }
        },
        { passive: false },
      );

      $horizontalScroller[0].addEventListener(
        'touchend',
        function () {
          this._touchStartX = null;
          this._touchStartY = null;
          this._scrollDirection = null;
        },
        { passive: true },
      );
    }
  };

  // [新增] 刷新变更面板（辅助函数）
  const refreshChangesPanel = () => {
    const { $ } = getCore();
    const rawData = cachedRawData || getTableData();
    currentDiffMap = generateDiffMap(rawData);

    const $panel = $('#acu-data-area');
    if ($panel.length && Store.get('acu_changes_panel_active', false)) {
      $panel.html(renderChangesPanel(rawData));
      bindChangesEvents();

      // 更新导航栏计数
      updateChangesCount(rawData);
    }
  };

  // [新增] 更新审核按钮计数（包含变更数 + 验证错误数）
  const updateChangesCount = rawData => {
    const { $ } = getCore();
    const snapshot = loadSnapshot();
    let changesCount = 0;

    if (snapshot && rawData) {
      for (const sheetId in rawData) {
        if (!sheetId.startsWith('sheet_')) continue;
        const newSheet = rawData[sheetId];
        const oldSheet = snapshot[sheetId];
        if (!newSheet?.content) continue;
        const newRows = newSheet.content.slice(1);
        const oldRows = oldSheet?.content?.slice(1) || [];

        // [优化] 使用标题匹配计算变更数量（与detectChanges保持一致）
        const oldRowsByTitle = new Map<string, Array<{ index: number; row: (typeof oldRows)[0] }>>();
        oldRows.forEach((row, rIdx) => {
          const title = String(row[1] ?? '').trim();
          if (!oldRowsByTitle.has(title)) {
            oldRowsByTitle.set(title, []);
          }
          oldRowsByTitle.get(title)!.push({ index: rIdx, row });
        });

        newRows.forEach((row, rowIdx) => {
          const title = String(row[1] ?? '').trim();
          let oldRow: (typeof oldRows)[0] | undefined;

          if (title && oldRowsByTitle.has(title)) {
            const queue = oldRowsByTitle.get(title)!;
            if (queue.length > 0) {
              const matched = queue.shift()!;
              oldRow = matched.row;
            }
          } else if (!title) {
            oldRow = oldRows[rowIdx];
          }

          if (!oldRow) {
            changesCount++; // 新增行
          } else {
            // 检查是否有字段变化
            let hasChange = false;
            row.forEach((cell, colIdx) => {
              if (colIdx === 0) return;
              if (String(cell ?? '') !== String(oldRow![colIdx] ?? '')) hasChange = true;
            });
            if (hasChange) changesCount++;
          }
        });

        // 计算删除的行数（使用标题计数差值）
        const newTitleCounts = new Map<string, number>();
        const oldTitleCounts = new Map<string, number>();
        newRows.forEach(row => {
          const title = String(row[1] ?? '').trim();
          if (title) newTitleCounts.set(title, (newTitleCounts.get(title) || 0) + 1);
        });
        oldRows.forEach(row => {
          const title = String(row[1] ?? '').trim();
          if (title) oldTitleCounts.set(title, (oldTitleCounts.get(title) || 0) + 1);
        });
        oldTitleCounts.forEach((oldCount, title) => {
          const newCount = newTitleCounts.get(title) || 0;
          if (oldCount > newCount) changesCount += oldCount - newCount;
        });
        // 空标题行的删除
        const emptyOldCount = oldRows.filter(r => !String(r[1] ?? '').trim()).length;
        const emptyNewCount = newRows.filter(r => !String(r[1] ?? '').trim()).length;
        if (emptyOldCount > emptyNewCount) changesCount += emptyOldCount - emptyNewCount;
      }
      for (const sheetId in snapshot) {
        if (sheetId.startsWith('sheet_') && !rawData[sheetId]) changesCount++;
      }
    }

    // 获取验证错误数量
    const validationErrorCount = rawData ? ValidationEngine.getErrorCount(rawData) : 0;

    // 根据模式决定显示的数量：数据验证模式只计错误数，完整审核模式只计变更数
    const isValidationMode = Store.get(STORAGE_KEY_VALIDATION_MODE, false);
    const displayCount = isValidationMode ? validationErrorCount : changesCount;
    // 警告图标只在数据验证模式下且有错误时显示
    const showWarningIcon = isValidationMode && validationErrorCount > 0;

    const $btn = $('#acu-btn-changes');
    const $span = $btn.find('span');
    $span.html(displayCount > 0 ? `审核(${displayCount})` : '审核');

    // 更新警告图标
    if (showWarningIcon) {
      if (!$btn.find('.acu-nav-warning-icon').length) {
        $span.append(' <i class="fa-solid fa-triangle-exclamation acu-nav-warning-icon"></i>');
      }
      $btn.addClass('has-validation-errors');
    } else {
      $btn.find('.acu-nav-warning-icon').remove();
      $btn.removeClass('has-validation-errors');
    }
  };
  // [新增] 变更面板专用编辑弹窗（保存后只更新单行快照）
  const showChangeEditModal = (row, headers, tableName, rowIndex, tableKey) => {
    const { $ } = getCore();
    const config = getConfig();

    const inputsHtml = row
      .map((cell, idx) => {
        if (idx === 0) return '';
        const headerName = headers[idx] || `列 ${idx}`;
        const val = cell || '';
        return `
                <div class="acu-card-edit-field">
                    <label class="acu-card-edit-label">${escapeHtml(headerName)}</label>
                    <textarea class="acu-card-edit-input acu-card-edit-textarea" data-col="${idx}" spellcheck="false" rows="1">${escapeHtml(val)}</textarea>
                </div>`;
      })
      .join('');

    const dialog = $(`
            <div class="acu-edit-overlay">
                <div class="acu-edit-dialog acu-theme-${config.theme}">
                    <div class="acu-edit-title">编辑变更 (#${rowIndex + 1} - ${escapeHtml(tableName)})</div>
                    <div class="acu-settings-content acu-settings-content-scroll">
                        ${inputsHtml}
                    </div>
                    <div class="acu-dialog-btns">
                        <button class="acu-dialog-btn" id="dlg-change-cancel"><i class="fa-solid fa-times"></i> 取消</button>
                        <button class="acu-dialog-btn acu-btn-confirm" id="dlg-change-save"><i class="fa-solid fa-check"></i> 保存并确认</button>
                    </div>
                </div>
            </div>
        `);
    $('body').append(dialog);

    // [修复] 自动高度调节逻辑
    const adjustHeight = el => {
      // 关键修复：使用 auto 而不是 0px，防止布局塌陷并正确获取 scrollHeight
      el.style.height = 'auto';
      const contentHeight = el.scrollHeight + 2;
      const maxHeight = 500;
      el.style.height = Math.min(contentHeight, maxHeight) + 'px';
      el.style.overflowY = contentHeight > maxHeight ? 'auto' : 'hidden';
    };

    // 1. 初始化时：使用 requestAnimationFrame 确保在 DOM 渲染后执行
    requestAnimationFrame(() => {
      dialog.find('textarea').each(function () {
        adjustHeight(this);
      });
    });

    // 2. 输入时：实时调整
    dialog.find('textarea').on('input', function () {
      adjustHeight(this);
    });
    dialog.find('textarea').on('input', function () {
      adjustHeight(this);
    });

    const closeDialog = () => {
      isSettingsOpen = false;
      dialog.remove();
    };
    dialog.find('#dlg-change-cancel').click(closeDialog);
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);

    dialog.find('#dlg-change-save').click(async () => {
      let rawData = cachedRawData || getTableData();
      if (rawData && rawData[tableKey]) {
        const currentRow = rawData[tableKey]?.content?.[rowIndex + 1];
        if (!currentRow) {
          closeDialog();
          return;
        }

        let hasChanges = false;
        dialog.find('textarea').each(function () {
          const colIdx = parseInt($(this).data('col'));
          const newVal = $(this).val();
          if (String(currentRow[colIdx]) !== String(newVal)) {
            hasChanges = true;
            currentRow[colIdx] = newVal;
          }
        });

        if (hasChanges) {
          // 1. 保存到数据库（不更新快照）
          try {
            await saveDataOnly(rawData, [tableKey]);
          } catch (e) {
            console.error('[DICE]ACU 保存失败:', e);
            let errorMessage = e.message || '保存出错，请检查数据格式和大小';
            // 检查是否是 "Settings could not be saved" 相关的错误
            const errorMsg = String(e);
            if (
              errorMsg.includes('Settings could not be saved') ||
              errorMsg.includes('server connection') ||
              errorMsg.includes('data loss')
            ) {
              errorMessage = '保存失败：服务器连接问题或数据过大，请检查网络连接或减少数据量';
            }
            if (window.toastr) {
              window.toastr.error(errorMessage, '保存失败', { timeOut: 7000 });
            } else {
              alert(`保存失败: ${errorMessage}`);
            }
            // 保存失败时不关闭对话框，让用户重试
            return;
          }

          // 2. 只更新快照中这一行（关键！）
          const snapshot = loadSnapshot();
          if (snapshot && snapshot[tableKey] && snapshot[tableKey].content) {
            snapshot[tableKey].content[rowIndex + 1] = [...currentRow];
            saveSnapshot(snapshot);
          }

          // 3. 重新计算 diffMap 并刷新变更面板
          currentDiffMap = generateDiffMap(rawData);

          // 4. 刷新变更面板
          const $panel = $('#acu-data-area');
          $panel.html(renderChangesPanel(rawData));
          bindChangesEvents();
        }
      }
      closeDialog();
    });
  };
  // [新增] 变更面板专用单字段编辑弹窗
  const showChangeSingleFieldModal = (value, headerName, tableName, rowIndex, colIndex, tableKey) => {
    const { $ } = getCore();
    const config = getConfig();

    // 获取快照中的旧值
    const snapshot = loadSnapshot();
    const oldValue = snapshot?.[tableKey]?.content?.[rowIndex + 1]?.[colIndex] ?? '';
    const hasOldValue = oldValue !== '' && String(oldValue) !== String(value);

    const dialog = $(`
            <div class="acu-edit-overlay">
                <div class="acu-edit-dialog acu-theme-${config.theme}" style="max-width:450px;">
                    <div class="acu-edit-title">编辑: ${escapeHtml(tableName)} - ${escapeHtml(headerName)}</div>
                    <div class="acu-settings-content" style="flex:1; overflow-y:auto; padding:15px;">
                        ${
                          hasOldValue
                            ? `
                        <div class="acu-diff-section acu-diff-old-section">
                            <div class="acu-diff-label">
                                <i class="fa-solid fa-clock-rotate-left"></i> 原始值（快照）
                            </div>
                            <div class="acu-diff-readonly">${escapeHtml(oldValue)}</div>
                        </div>
                        <div class="acu-diff-arrow-down">
                            <i class="fa-solid fa-arrow-down"></i>
                        </div>
                        `
                            : ''
                        }
                        <div class="acu-diff-section acu-diff-new-section">
                            <div class="acu-diff-label">
                                <i class="fa-solid fa-pen"></i> ${hasOldValue ? '当前值（可编辑）' : '内容'}
                            </div>
                            <textarea class="acu-change-single-input acu-edit-textarea" spellcheck="false"
                                style="width:100%;min-height:60px;max-height:300px;padding:12px;resize:none;">${escapeHtml(value)}</textarea>
                        </div>
                    </div>
                    <div class="acu-dialog-btns">
                        <button class="acu-dialog-btn" id="dlg-single-cancel"><i class="fa-solid fa-times"></i> 取消</button>
                        ${hasOldValue ? `<button class="acu-dialog-btn acu-btn-revert" id="dlg-single-revert"><i class="fa-solid fa-rotate-left"></i> 恢复原值</button>` : ''}
                        <button class="acu-dialog-btn acu-btn-confirm" id="dlg-single-save"><i class="fa-solid fa-check"></i> 保存</button>
                    </div>
                </div>
            </div>
        `);
    $('body').append(dialog);

    // 自动高度
    const $textarea = dialog.find('.acu-change-single-input');
    const adjustHeight = () => {
      $textarea[0].style.height = 'auto';
      const h = Math.max(60, Math.min($textarea[0].scrollHeight + 2, 300));
      $textarea[0].style.height = h + 'px';
    };
    setTimeout(adjustHeight, 0);
    $textarea.on('input', adjustHeight);
    $textarea.focus();

    const closeDialog = () => dialog.remove();
    dialog.find('#dlg-single-cancel').click(closeDialog);
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);

    // [新增] 恢复原值按钮
    dialog.find('#dlg-single-revert').click(function () {
      $textarea.val(oldValue).trigger('input');
    });

    dialog.find('#dlg-single-save').click(async () => {
      const newVal = $textarea.val();
      let rawData = cachedRawData || getTableData();

      if (rawData && rawData[tableKey] && rawData[tableKey].content) {
        const currentRow = rawData[tableKey].content[rowIndex + 1];
        if (currentRow && String(currentRow[colIndex]) !== String(newVal)) {
          currentRow[colIndex] = newVal;

          // 保存到数据库
          await saveDataOnly(rawData, [tableKey]);

          // 只更新快照中这一个单元格
          const snapshot = loadSnapshot();
          if (
            snapshot &&
            snapshot[tableKey] &&
            snapshot[tableKey].content &&
            snapshot[tableKey].content[rowIndex + 1]
          ) {
            snapshot[tableKey].content[rowIndex + 1][colIndex] = newVal;
            saveSnapshot(snapshot);
          }

          // 刷新
          currentDiffMap = generateDiffMap(rawData);
          refreshChangesPanel();
        }
      }
      closeDialog();
    });
  };

  // [新增] 多字段变更整体对比编辑弹窗
  const showRowCompareEditModal = (row, headers, tableName, rowIndex, tableKey) => {
    const { $ } = getCore();
    const config = getConfig();

    // 获取快照中的旧行
    const snapshot = loadSnapshot();
    const oldRow = snapshot?.[tableKey]?.content?.[rowIndex + 1] || [];

    // 构建字段对比列表
    let fieldsHtml = '';
    for (let idx = 1; idx < headers.length; idx++) {
      const headerName = headers[idx] || `列 ${idx}`;
      const oldVal = oldRow[idx] ?? '';
      const newVal = row[idx] ?? '';
      const isChanged = String(oldVal) !== String(newVal);

      fieldsHtml += `
                <div class="acu-row-edit-field ${isChanged ? 'acu-field-changed' : ''}">
                    <div class="acu-row-edit-label">${escapeHtml(headerName)} ${isChanged ? '<span class="acu-changed-badge">已改</span>' : ''}</div>
                    ${isChanged ? `<div class="acu-row-edit-old">${escapeHtml(oldVal) || '<span class="acu-empty-val">(空)</span>'}</div>` : ''}
                    <textarea class="acu-row-edit-input acu-edit-textarea" data-col="${idx}" spellcheck="false" rows="1">${escapeHtml(newVal)}</textarea>
                </div>
            `;
    }

    const dialog = $(`
            <div class="acu-edit-overlay">
                <div class="acu-edit-dialog acu-theme-${config.theme}" style="max-width:550px;">
                    <div class="acu-edit-title">整体编辑: ${escapeHtml(tableName)} - ${escapeHtml(row[1] || '行 ' + (rowIndex + 1))}</div>
                    <div class="acu-settings-content" style="flex:1; overflow-y:auto; padding:15px; max-height:60vh;">
                        ${fieldsHtml}
                    </div>
                    <div class="acu-dialog-btns">
                        <button class="acu-dialog-btn" id="dlg-row-cancel"><i class="fa-solid fa-times"></i> 取消</button>
                        <button class="acu-dialog-btn" id="dlg-row-revert"><i class="fa-solid fa-rotate-left"></i> 全部恢复</button>
                        <button class="acu-dialog-btn acu-btn-confirm" id="dlg-row-save"><i class="fa-solid fa-check"></i> 保存</button>
                    </div>
                </div>
            </div>
        `);
    $('body').append(dialog);

    // 自动高度
    const adjustHeight = el => {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight + 2, 200) + 'px';
    };
    dialog.find('textarea').each(function () {
      adjustHeight(this);
    });
    dialog.find('textarea').on('input', function () {
      adjustHeight(this);
    });

    const closeDialog = () => dialog.remove();
    dialog.find('#dlg-row-cancel').click(closeDialog);
    setupOverlayClose(dialog, 'acu-edit-overlay', closeDialog);

    // 全部恢复
    dialog.find('#dlg-row-revert').click(function () {
      dialog.find('textarea').each(function () {
        const colIdx = parseInt($(this).data('col'));
        $(this)
          .val(oldRow[colIdx] ?? '')
          .trigger('input');
      });
    });

    // 保存
    dialog.find('#dlg-row-save').click(async () => {
      let rawData = cachedRawData || getTableData();
      if (!rawData?.[tableKey]?.content?.[rowIndex + 1]) {
        closeDialog();
        return;
      }

      const currentRow = rawData[tableKey].content[rowIndex + 1];
      let hasChanges = false;

      dialog.find('textarea').each(function () {
        const colIdx = parseInt($(this).data('col'));
        const newVal = $(this).val();
        if (String(currentRow[colIdx]) !== String(newVal)) {
          hasChanges = true;
          currentRow[colIdx] = newVal;
        }
      });

      if (hasChanges) {
        await saveDataOnly(rawData, [tableKey]);

        // 更新快照中这一行
        const snapshot = loadSnapshot();
        if (snapshot?.[tableKey]?.content) {
          snapshot[tableKey].content[rowIndex + 1] = [...currentRow];
          saveSnapshot(snapshot);
        }

        currentDiffMap = generateDiffMap(rawData);
        refreshChangesPanel();
      }
      closeDialog();
    });
  };
  const renderDashboard = allTables => {
    console.info('[DICE]开始抓取仪表盘数据...');
    // 重建角色名别名注册表
    NameAliasRegistry.rebuild(allTables);
    const config = getConfig();

    // [重构] 使用统一配置中心查找表格
    const globalResult = DashboardDataParser.findTable(allTables, 'global');
    const playerResult = DashboardDataParser.findTable(allTables, 'player');
    const locationResult = DashboardDataParser.findTable(allTables, 'location');
    const npcResult = DashboardDataParser.findTable(allTables, 'npc');
    const questResult = DashboardDataParser.findTable(allTables, 'quest');
    const bagResult = DashboardDataParser.findTable(allTables, 'bag');
    const equipResult = DashboardDataParser.findTable(allTables, 'equip');

    // [重构] 主角数据 - 使用新解析器
    let player = { name: '主角', status: '正常', position: '', attrs: '', money: '0' };
    const playerParsed = DashboardDataParser.parseRows(playerResult, 'player');

    if (playerParsed.length > 0) {
      const p = playerParsed[0];
      player.name = p.name || '主角';
      player.status = p.status || '正常';
      player.position = p.position || '';
      player.money = p.money || '';
      player.resources = '';

      // [特殊处理] 属性列可能有多个，需要合并
      if (playerResult?.data?.headers && playerResult?.data?.rows?.[0]) {
        const headers = playerResult.data.headers;
        const row = playerResult.data.rows[0];
        let allAttrsStr = '';
        headers.forEach((h, idx) => {
          if (h && h.includes('属性')) {
            const val = row[idx];
            if (val) allAttrsStr += (allAttrsStr ? '; ' : '') + val;
          }
        });
        player.attrs = allAttrsStr;

        // 解析资源数据
        headers.forEach((h, idx) => {
          if (h && (h.includes('资源') || h.includes('金钱'))) {
            const val = row[idx];
            if (val) player.resources = val;
          }
        });
      }
    }

    // [兼容] 保留旧变量供后续HTML渲染使用
    const playerRows = playerResult?.data?.rows || [];
    const playerHeaders = playerResult?.data?.headers || [];

    // [重构] 从全局数据表获取当前地点信息 - 使用新解析器
    let globalDetailLocation = ''; // 详细地点（用于高亮匹配）
    let globalLocation = ''; // 次要地区（备选）

    if (globalResult?.data?.rows?.length > 0) {
      const headers = globalResult.data.headers || [];
      const row = globalResult.data.rows[0];

      // 优先获取详细地点
      const detailIdx = DashboardDataParser.findColumnIndex(headers, 'detailLocation', globalResult.config);
      if (detailIdx >= 0 && row[detailIdx]) {
        globalDetailLocation = row[detailIdx];
      }

      // 备选：次要地区
      const locIdx = DashboardDataParser.findColumnIndex(headers, 'currentLocation', globalResult.config);
      globalLocation = locIdx >= 0 && row[locIdx] ? row[locIdx] : row[2] || '';
    }

    // currentPlaceName 优先使用详细地点，其次次要地区，最后从主角位置提取
    let currentPlaceName =
      globalDetailLocation ||
      globalLocation ||
      (player.position.includes('-') ? player.position.split('-')[0].trim() : player.position);

    // [重构] NPC数据 - 使用新解析器
    const npcTableName = npcResult?.name || '重要角色表';
    const npcTableKey = npcResult?.key || '';

    const npcParsed = DashboardDataParser.parseRows(npcResult, 'npc');

    // 分离在场和离场的NPC
    let inSceneNPCs = [];
    let offSceneNPCs = [];
    npcParsed.forEach(npc => {
      const inSceneVal = String(npc.inScene || '').toLowerCase();
      const normalizedNpcName = String(npc.name || '未知').trim() || '未知';
      const npcData = {
        name: normalizedNpcName,
        status: npc.status || '',
        position: npc.position || '',
        index: npc._rowIndex,
      };
      if (inSceneVal === 'true' || inSceneVal === '在场') {
        inSceneNPCs.push(npcData);
      } else {
        offSceneNPCs.push(npcData);
      }
    });
    // 合并：在场的排前面
    let allNPCs = [...inSceneNPCs, ...offSceneNPCs];

    // [重构] 任务数据 - 使用新解析器（显示所有任务，按状态/类型/优先级/进度排序）
    const questTableName = questResult?.name || '备忘事项';
    const questParsed = DashboardDataParser.parseRows(questResult, 'quest');

    // 任务排序辅助函数
    const questStatusOrder = (status: string) => {
      const s = String(status || '').toLowerCase();
      // 进行中排前面，已完成/已失败/已放弃排后面
      if (s.includes('进行中') || s.includes('进行')) return 0;
      return 1; // 已完成、已失败、已放弃等终态
    };
    const questTypeOrder = (type: string) => {
      const t = String(type || '').toLowerCase();
      if (t.includes('主线')) return 0;
      if (t.includes('支线')) return 1;
      if (t.includes('日常')) return 2;
      return 3;
    };
    const questPriorityOrder = (priority: string) => {
      const p = String(priority || '').toLowerCase();
      if (p.includes('紧急')) return 0;
      if (p.includes('重要')) return 1;
      if (p.includes('普通')) return 2;
      return 3;
    };
    const parseProgress = (progress: string) => {
      const match = String(progress || '').match(/(\d+)\s*%/);
      return match ? parseInt(match[1], 10) : 0;
    };

    let activeTasks = questParsed
      .map(q => ({
        name: q.name || '任务',
        type: q.type || '',
        status: q.status || '',
        priority: q.priority || '',
        progress: q.progress || '',
        _rowIndex: q._rowIndex,
      }))
      .sort((a, b) => {
        // 1. 状态：进行中 > 已完成
        const aStatusOrder = questStatusOrder(a.status);
        const bStatusOrder = questStatusOrder(b.status);
        const statusDiff = aStatusOrder - bStatusOrder;
        if (statusDiff !== 0) return statusDiff;

        // 已完成任务：按行号倒序（行号低的靠后）
        if (aStatusOrder === 1) {
          return (b._rowIndex ?? 0) - (a._rowIndex ?? 0);
        }

        // 进行中任务的排序规则：
        // 2. 类型：主线 > 支线 > 日常
        const typeDiff = questTypeOrder(a.type) - questTypeOrder(b.type);
        if (typeDiff !== 0) return typeDiff;
        // 3. 优先级：紧急 > 重要 > 普通
        const priorityDiff = questPriorityOrder(a.priority) - questPriorityOrder(b.priority);
        if (priorityDiff !== 0) return priorityDiff;
        // 4. 进度：低 → 高
        return parseProgress(a.progress) - parseProgress(b.progress);
      });
    // [重构] 背包物品数据 - 使用新解析器
    const bagTableName = bagResult?.name || '背包物品表';

    const bagParsed = DashboardDataParser.parseRows(bagResult, 'bag');
    let bagItems = bagParsed.map(item => ({
      name: item.name || '未知物品',
      count: item.count || '1',
      type: item.type || '',
    }));

    // [重构] 装备数据 - 使用新解析器 + 过滤器
    const equipTableName = equipResult?.name || '装备表';

    const equipParsed = DashboardDataParser.parseRows(equipResult, 'equip');
    const equippedParsed = DashboardDataParser.applyFilter(equipParsed, 'equipped', 'equip');

    let equippedItems = equippedParsed.map(e => ({
      name: e.name || '未知装备',
      type: e.type || '',
      part: e.part || '',
    }));
    // [重构] 地点数据 - 使用新解析器
    const locationTableName = locationResult?.name || '世界地图点';
    const locationTableKey = locationResult?.key || '';

    const locationParsed = DashboardDataParser.parseRows(locationResult, 'location');

    // 构建HTML
    let html = `
        <div class="acu-panel-header">
            <div class="acu-panel-title">
                <div class="acu-title-main"><i class="fa-solid fa-chart-line"></i> <span class="acu-title-text">仪表盘</span></div>
                <div class="acu-title-sub">综合状态总览</div>
            </div>
            <div class="acu-header-actions">
                <div class="acu-height-control">
                    <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="仪表盘" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                </div>
                <button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
            </div>
        </div>
        <div class="acu-panel-content acu-dashboard-content">
            <div class="acu-dash-body ${config.layout === 'horizontal' ? 'acu-dash-horizontal' : ''}">
            <!-- 左列：主角状态 + 基础属性 + 特有属性 -->
                <div class="acu-dash-player">
                    <h3 class="acu-dash-clickable acu-dash-preview-trigger"
                        data-table-key="${playerResult?.key || ''}"
                        data-row-index="0"
                        data-preview-type="player"
                        style="cursor:pointer;display:flex;justify-content:space-between;align-items:center;">
                        <span><i class="fa-solid fa-user-circle"></i> ${escapeHtml(replaceUserPlaceholders(getDisplayName(player.name)))}</span>
                        <span style="font-size:11px;font-weight:normal;color:var(--acu-text-main);background:var(--acu-badge-bg);padding:2px 8px;border-radius:10px;max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(player.status)}">${escapeHtml(player.status.length > 6 ? player.status.substring(0, 6) + '..' : player.status)}</span>
                    </h3>
                    ${(() => {
                      // 解析资源数据
                      const resourcesStr = player.resources || player.money || '';
                      const parsedResources = parseAttributeString(resourcesStr);

                      // 分别收集基础属性和特有属性
                      let baseAttrs = [];
                      let specialAttrs = [];
                      if (playerRows.length > 0 && playerHeaders.length > 0) {
                        const row = playerRows[0];
                        playerHeaders.forEach((h, idx) => {
                          if (h && h.includes('基础属性')) {
                            const parsed = parseAttributeString(row[idx] || '');
                            parsed.forEach(attr => {
                              if (!baseAttrs.some(a => a.name === attr.name)) {
                                baseAttrs.push(attr);
                              }
                            });
                          } else if (h && h.includes('特有属性')) {
                            const parsed = parseAttributeString(row[idx] || '');
                            parsed.forEach(attr => {
                              if (!specialAttrs.some(a => a.name === attr.name)) {
                                specialAttrs.push(attr);
                              }
                            });
                          }
                        });
                      }

                      let html = '';

                      // 资源区块
                      if (parsedResources.length > 0) {
                        html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 6px;max-height:44px;overflow-y:auto;margin-bottom:4px;padding-bottom:4px;border-bottom:1px dashed var(--acu-border);">
                                ${parsedResources
                                  .map(
                                    res => `
                                    <div style="display:flex;justify-content:space-between;align-items:center;padding:2px 3px;">
                                        <span style="color:var(--acu-text-sub);font-size:10px;white-space:nowrap;" title="${escapeHtml(res.name)}">${escapeHtml(res.name.substring(0, 3))}</span>
                                        <div style="display:flex;align-items:center;gap:2px;flex-shrink:0;">
                                            <span style="color:var(--acu-accent);font-size:11px;font-weight:bold;">${res.value}</span>
                                            <i class="fa-solid fa-dice-d20 acu-dash-dice-btn" data-target="${res.value}" data-name="${escapeHtml(res.name)}" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.4;font-size:10px;" title="以${res.name}(${res.value})进行检定"></i>
                                        </div>
                                    </div>
                                `,
                                  )
                                  .join('')}
                            </div>`;
                      }

                      // 属性区块标题（合并基础属性和特有属性），点击打开主角卡片
                      html += `<h4 class="acu-dash-clickable acu-dash-preview-trigger"
                          data-table-key="${playerResult?.key || ''}"
                          data-row-index="0"
                          data-preview-type="player"
                          style="font-size:12px;color:var(--acu-accent);margin:4px 0 2px 0;display:flex;align-items:center;gap:4px;cursor:pointer;"><i class="fa-solid fa-chart-bar" style="font-size:10px;"></i> 属性 (${baseAttrs.length + specialAttrs.length})</h4>`;

                      // 合并所有属性：3列，最多4行（移动端行高更大，按约24px计算，4行≈96px），超出滚动
                      const allAttrs = [...baseAttrs, ...specialAttrs];
                      if (allAttrs.length > 0) {
                        html += `<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:2px 4px;max-height:104px;overflow-y:auto;overflow-x:hidden;padding-bottom:2px;">
                                ${allAttrs
                                  .map(
                                    attr => `
                                    <div style="display:flex;justify-content:space-between;align-items:center;padding:2px 3px;border-bottom:1px dashed var(--acu-border);min-width:0;">
                                        <span style="color:var(--acu-text-sub);font-size:10px;white-space:nowrap;" title="${escapeHtml(attr.name)}">${escapeHtml(attr.name.substring(0, 2))}</span>
                                        <div style="display:flex;align-items:center;gap:2px;flex-shrink:0;">
                                            <span style="color:var(--acu-text-main);font-size:11px;font-weight:bold;">${attr.value}</span>
                                            <i class="fa-solid fa-dice-d20 acu-dash-dice-btn" data-target="${attr.value}" data-name="${escapeHtml(attr.name)}" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.4;font-size:10px;" title="以${attr.name}(${attr.value})进行检定"></i>
                                        </div>
                                    </div>
                                `,
                                  )
                                  .join('')}
                            </div>`;
                      } else {
                        html += `<div class="acu-empty-hint">暂无属性</div>`;
                      }

                      return html;
                    })()}
                </div>

                <!-- 中列：地点 + NPC -->
                <div class="acu-dash-locations">
                    <h3 class="acu-dash-table-link" data-table="${escapeHtml(locationTableName)}" style="display:flex;justify-content:space-between;align-items:center;">
                        <span><i class="fa-solid fa-map"></i> 地点 (${locationParsed.length})</span>
                        <i class="fa-solid fa-map acu-dash-map-btn" title="地图可视化" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.6;font-size:12px;padding:4px;"></i>
                    </h3>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 6px;align-content:start;max-height:110px;overflow-y:auto;overflow-x:hidden;margin-bottom:10px;">
                    ${
                      locationParsed.length > 0
                        ? locationParsed
                            .map((loc, idx) => {
                              const areaName = loc.name || '未知';
                              const isCurrent =
                                currentPlaceName &&
                                (areaName.includes(currentPlaceName) || currentPlaceName.includes(areaName));
                              const emoji = getElementEmoji(areaName, null);
                              let iconHtml = '';
                              if (emoji) {
                                if (emoji.startsWith('fa:')) {
                                  iconHtml = `<i class="fa-solid fa-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else if (emoji.startsWith('ti:')) {
                                  iconHtml = `<i class="ti ti-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else {
                                  iconHtml = `<span style="font-size:10px;">${emoji}</span>`;
                                }
                              } else {
                                iconHtml = isCurrent
                                  ? '<i class="fa-solid fa-location-dot"></i>'
                                  : '<i class="fa-solid fa-map-pin" style="font-size:9px;opacity:0.4;"></i>';
                              }
                              return `<div class="acu-location-item acu-dash-clickable acu-dash-preview-trigger ${isCurrent ? 'acu-current-location' : ''}"
                            data-table-key="${escapeHtml(locationTableKey)}"
                            data-row-index="${loc._rowIndex}"
                            data-preview-type="location">
                            <span style="display:flex;align-items:center;gap:4px;">
                                ${iconHtml}
                                <span title="${escapeHtml(areaName)}">${escapeHtml(areaName)}</span>
                            </span>
                            ${!isCurrent ? `<i class="fa-solid fa-walking acu-dash-goto-btn" data-location="${escapeHtml(areaName)}" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.4;font-size:10px;flex-shrink:0;" title="前往${areaName}"></i>` : '<i class="fa-solid fa-street-view" style="flex-shrink:0;" title="您在这里"></i>'}
                        </div>`;
                            })
                            .join('')
                        : '<div class="acu-empty-hint">暂无地点数据</div>'
                    }
                    </div>

                    <h3 class="acu-dash-table-link" data-table="${escapeHtml(npcTableName)}" style="margin-top:10px;display:flex;justify-content:space-between;align-items:center;">
                        <span><i class="fa-solid fa-users"></i> 角色 (${allNPCs.length})</span>
                        <span style="display:flex;gap:8px;">
                            <i class="fa-solid fa-project-diagram acu-dash-relation-graph-btn" title="人物关系图" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.6;font-size:12px;padding:4px;"></i>
                            <i class="fa-solid fa-user-circle acu-dash-avatar-manager-btn" title="头像管理" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.6;font-size:12px;padding:4px;"></i>
                        </span>
                    </h3>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 6px;align-content:start;max-height:150px;overflow-y:auto;overflow-x:hidden;">
                    ${
                      allNPCs.length > 0
                        ? allNPCs
                            .map((npc, npcIdx) => {
                              const npcName = String(npc.name || '').trim() || '未知';
                              const npcDisplayName = replaceUserPlaceholders(getDisplayName(npcName)).trim() || '未知';
                              const npcDisplayShort =
                                npcDisplayName.length > 4 ? npcDisplayName.substring(0, 4) + '..' : npcDisplayName;
                              const npcFallbackChar = npcDisplayName.charAt(0) || '？';
                              const isInScene = inSceneNPCs.some(n => n.name === npcName);
                              const isLastNpc = npcIdx === allNPCs.length - 1;
                              const npcAvatar = AvatarManager.get(npcName);
                              const avatarOffsetX = AvatarManager.getOffsetX(npcName);
                              const avatarOffsetY = AvatarManager.getOffsetY(npcName);
                              const avatarScale = AvatarManager.getScale(npcName);
                              const avatarStyle = npcAvatar
                                ? `background-image:url('${npcAvatar}');background-size:${avatarScale}%;background-position:${avatarOffsetX}% ${avatarOffsetY}%;`
                                : '';
                              const offSceneFilter = isInScene
                                ? ''
                                : 'filter:grayscale(80%) brightness(0.7);opacity:0.5;';
                              return `<div class="acu-dash-clickable acu-dash-preview-trigger"
                            data-table-key="${escapeHtml(npcTableKey)}"
                            data-row-index="${npc.index}"
                            data-preview-type="npc"
                            style="padding:6px 4px;${!isLastNpc ? 'border-bottom:1px dashed var(--acu-border);' : ''}">
                            <div style="display:flex;justify-content:space-between;align-items:center;">
                                <span class="acu-task-name" style="font-size:12px;display:flex;align-items:center;gap:6px;">
                                    <span class="acu-dash-npc-avatar" data-npc-name="${escapeHtml(npcName)}" style="width:22px;height:22px;border-radius:50%;flex-shrink:0;display:flex;align-items:center;justify-content:center;background:var(--acu-badge-bg, rgba(0,255,255,0.12));border:1.5px solid ${isInScene ? 'var(--acu-accent)' : 'var(--acu-border)'};${avatarStyle}${offSceneFilter}" title="${isInScene ? '在场' : '不在场'}">
                                        ${!npcAvatar ? `<span class="acu-dash-npc-avatar-fallback" style="font-size:10px;font-weight:bold;color:var(--acu-accent);">${escapeHtml(npcFallbackChar)}</span>` : ''}
                                    </span>
                                    <span title="${escapeHtml(npcDisplayName)}" style="${isInScene ? '' : 'opacity:0.6;'}">${escapeHtml(npcDisplayShort)}</span>
                                </span>
                                <div style="display:flex;align-items:center;">
                                    <i class="fa-solid fa-people-arrows acu-dash-contest-btn" data-npc="${escapeHtml(npcName)}" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.4;font-size:8px;" title="与${escapeHtml(npcDisplayName)}进行对抗检定"></i>
                                </div>
                            </div>
                        </div>`;
                            })
                            .join('')
                        : '<div class="acu-empty-hint">暂无重要人物</div>'
                    }
                    </div>
                </div>

                <!-- 右列：背包 + 技能 + 任务 -->
                <div class="acu-dash-intel">
                    <h3 class="acu-dash-table-link" data-table="${escapeHtml(bagTableName)}"><i class="fa-solid fa-bag-shopping"></i> 物品 (${bagParsed.length})</h3>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 6px;max-height:90px;overflow-y:auto;margin-bottom:10px;">
                    ${
                      bagItems.length > 0
                        ? bagItems
                            .map((item, idx) => {
                              const isLastBag = idx === bagItems.length - 1;
                              const emoji = getElementEmoji(item.name, null);
                              let iconHtml = '';
                              if (emoji) {
                                if (emoji.startsWith('fa:')) {
                                  iconHtml = `<i class="fa-solid fa-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else if (emoji.startsWith('ti:')) {
                                  iconHtml = `<i class="ti ti-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else {
                                  iconHtml = `<span style="font-size:10px;">${emoji}</span>`;
                                }
                              } else {
                                iconHtml = '<i class="fa-solid fa-cube" style="font-size:9px;opacity:0.4;"></i>';
                              }
                              return `<div class="acu-dash-clickable acu-dash-preview-trigger"
                            data-table-key="${bagResult?.key || ''}"
                            data-row-index="${idx}"
                            data-preview-type="bag"
                            style="display:flex;justify-content:space-between;align-items:center;padding:5px 4px;font-size:11px;cursor:pointer;${!isLastBag ? 'border-bottom:1px dashed var(--acu-border);' : ''}">
                            <span style="color:var(--acu-text-main);flex:1;white-space:nowrap;display:flex;align-items:center;gap:4px;" title="${escapeHtml(item.name)}">
                                ${iconHtml}
                                ${escapeHtml(item.name.length > 4 ? item.name.substring(0, 4) + '..' : item.name)}
                            </span>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <i class="fa-solid fa-hand-pointer acu-dash-use-item-btn" data-item="${escapeHtml(item.name)}" style="cursor:pointer;color:var(--acu-text-sub);opacity:0.4;font-size:8px;" title="使用${item.name}"></i>
                            </div>
                        </div>`;
                            })
                            .join('')
                        : '<div class="acu-empty-hint">暂无物品</div>'
                    }
                    </div>

                    <h3 class="acu-dash-table-link" data-table="${escapeHtml(equipTableName)}" style="margin-top:10px;"><i class="fa-solid fa-shield-halved"></i> 装备 (${equippedItems.length})</h3>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;max-height:80px;overflow-y:auto;margin-bottom:10px;">
                    ${
                      equippedItems.length > 0
                        ? equippedItems
                            .map((item, idx) => {
                              const isLast = idx === equippedItems.length - 1;
                              const emoji = getElementEmoji(item.name, null);
                              let iconHtml = '';
                              if (emoji) {
                                if (emoji.startsWith('fa:')) {
                                  iconHtml = `<i class="fa-solid fa-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else if (emoji.startsWith('ti:')) {
                                  iconHtml = `<i class="ti ti-${emoji.slice(3)}" style="font-size:10px;opacity:0.7;"></i>`;
                                } else {
                                  iconHtml = `<span style="font-size:10px;">${emoji}</span>`;
                                }
                              } else {
                                iconHtml = '<i class="fa-solid fa-shirt" style="font-size:9px;opacity:0.4;"></i>';
                              }
                              return `<div class="acu-dash-clickable acu-dash-preview-trigger"
                            data-table-key="${equipResult?.key || ''}"
                            data-row-index="${equipParsed.findIndex(r => r.name === item.name)}"
                            data-preview-type="equipment"
                            style="display:flex;align-items:center;gap:4px;padding:4px;font-size:11px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;${!isLast ? 'border-bottom:1px dashed var(--acu-border);' : ''}">
                            ${iconHtml}
                            <span style="color:var(--acu-text-main);overflow:hidden;text-overflow:ellipsis;" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</span>
                        </div>`;
                            })
                            .join('')
                        : '<div class="acu-empty-hint">暂无装备</div>'
                    }
                    </div>

                    <h3 class="acu-dash-table-link" data-table="${escapeHtml(questTableName)}" style="margin-top:10px;"><i class="fa-solid fa-clipboard-list"></i> 任务 (${activeTasks.length})</h3>
                    <div style="max-height:50px;overflow-y:auto;">
                    ${
                      activeTasks.length > 0
                        ? activeTasks
                            .map((t, idx) => {
                              const isMain = String(t.type || '').includes('主线');
                              // 解析进度百分比
                              let progressPercent = null;
                              const progressMatch = String(t.progress || '').match(/(\d+)\s*%/);
                              if (progressMatch) {
                                progressPercent = Math.min(100, Math.max(0, parseInt(progressMatch[1], 10)));
                              }
                              const progressBar =
                                progressPercent !== null
                                  ? `<div style="width:40px;height:4px;background:var(--acu-border);border-radius:2px;overflow:hidden;"><div style="width:${progressPercent}%;height:100%;background:var(--acu-accent);"></div></div>`
                                  : '';
                              return `<div class="acu-task-item acu-dash-clickable acu-dash-preview-trigger"
                            data-table-key="${questResult?.key || ''}"
                            data-row-index="${t._rowIndex !== undefined ? t._rowIndex : questParsed.findIndex(q => q.name === t.name)}"
                            data-preview-type="quest"
                            style="padding:4px 8px;margin-bottom:3px;cursor:pointer;">
                            <div style="display:flex;justify-content:space-between;align-items:center;">
                                <div class="acu-task-name" style="font-size:11px;${isMain ? 'font-weight:600;' : ''}">${escapeHtml(t.name)}</div>
                                ${progressBar}
                            </div>
                        </div>`;
                            })
                            .join('')
                        : '<div class="acu-empty-hint">暂无任务</div>'
                    }
                    </div>
                </div>
            </div>
    `;

    // 统计已加载的模块数量
    const loadedModules = [
      globalResult ? '全局数据' : null,
      playerResult ? '主角信息' : null,
      locationResult ? '地点' : null,
      npcResult ? 'NPC' : null,
      questResult ? '任务' : null,
      bagResult ? '背包' : null,
      equipResult ? '装备' : null,
    ].filter(Boolean);

    console.info(`[DICE]仪表盘数据抓取完成，共${loadedModules.length}个模块: ${loadedModules.join(', ')}`);
    return html;
  };

  // [修复] 仪表盘NPC头像异步加载（支持IndexedDB本地头像）
  const loadDashboardNpcAvatars = () => {
    const $avatars = $('.acu-dash-npc-avatar[data-npc-name]');
    if ($avatars.length === 0) return;

    const normalizeName = (value: string): string => {
      const base = String(value || '')
        .normalize('NFKC')
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .trim();
      if (!base) return '';
      const display = replaceUserPlaceholders(getDisplayName(base)).trim() || base;
      return display
        .normalize('NFKC')
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .replace(/\s+/g, '')
        .toLowerCase();
    };

    void (async () => {
      const allAvatarData = AvatarManager.getAll();
      const candidatePool: string[] = [];
      const pushUnique = (name: string) => {
        const cleaned = String(name || '').trim();
        if (!cleaned) return;
        if (!candidatePool.includes(cleaned)) candidatePool.push(cleaned);
      };

      Object.keys(allAvatarData).forEach(pushUnique);
      Object.values(allAvatarData).forEach(data => {
        const aliasCandidates = Array.isArray((data as { aliases?: unknown[] }).aliases)
          ? ((data as { aliases?: unknown[] }).aliases as unknown[])
          : [];
        aliasCandidates.forEach(alias => pushUnique(String(alias || '')));
      });

      let localNames: string[] = [];
      try {
        localNames = (await LocalAvatarDB.getAllNames()) as string[];
      } catch {
        localNames = [];
      }
      localNames.forEach(name => pushUnique(String(name || '')));

      const normalizedNameMap = new Map<string, string[]>();
      const addNormalized = (name: string) => {
        const key = normalizeName(name);
        if (!key) return;
        if (!normalizedNameMap.has(key)) normalizedNameMap.set(key, []);
        const list = normalizedNameMap.get(key)!;
        if (!list.includes(name)) list.push(name);
      };
      candidatePool.forEach(addNormalized);

      const getManualAliases = (name: string): string[] => {
        const data = AvatarManager.getAll()[name] as { aliases?: unknown[] } | undefined;
        if (!data || !Array.isArray(data.aliases)) return [];
        return data.aliases.map(alias => String(alias || '').trim()).filter(Boolean);
      };

      $avatars.each(function () {
        const $el = $(this);
        const rawName = String($el.attr('data-npc-name') || '').trim();
        if (!rawName) return;

        void (async () => {
          try {
            const displayName = getDisplayName(rawName);
            const resolvedName = NameAliasRegistry.resolve(rawName);
            const avatarPrimaryName = AvatarManager.getPrimaryName(rawName);

            const directCandidates = Array.from(
              new Set(
                [
                  rawName,
                  displayName,
                  resolvedName,
                  avatarPrimaryName,
                  replaceUserPlaceholders(rawName),
                  replaceUserPlaceholders(displayName),
                  replaceUserPlaceholders(resolvedName),
                  ...NameAliasRegistry.getAliases(resolvedName),
                  ...NameAliasRegistry.getAliases(avatarPrimaryName),
                  ...getManualAliases(resolvedName),
                  ...getManualAliases(avatarPrimaryName),
                ]
                  .map(v => String(v || '').trim())
                  .filter(Boolean),
              ),
            );

            const allCandidates = [...directCandidates];
            directCandidates.forEach(name => {
              const key = normalizeName(name);
              if (!key) return;
              const mapped = normalizedNameMap.get(key) || [];
              mapped.forEach(m => {
                if (!allCandidates.includes(m)) allCandidates.push(m);
              });
            });

            let matchedName: string | null = null;
            let matchedUrl: string | null = null;
            let matchedLocal = false;

            // 1) 先尝试本地头像（最稳定）
            for (const name of allCandidates) {
              const localUrl = await LocalAvatarDB.get(name);
              if (localUrl) {
                matchedName = name;
                matchedUrl = localUrl;
                matchedLocal = true;
                break;
              }
            }

            // 2) 再尝试URL头像缓存
            if (!matchedUrl) {
              for (const name of allCandidates) {
                const url = AvatarManager.get(name);
                if (url) {
                  matchedName = name;
                  matchedUrl = url;
                  break;
                }
              }
            }

            // 3) 最后完整兜底（主角占位符/别名）
            if (!matchedUrl) {
              for (const name of allCandidates) {
                const url = await AvatarManager.getAsync(name);
                if (url) {
                  matchedName = name;
                  matchedUrl = url;
                  break;
                }
              }
            }

            // 找不到头像：保留首字fallback
            if (!matchedUrl || !matchedName) {
              $el.css({
                'background-image': 'none',
                'background-color': 'var(--acu-badge-bg, rgba(0,255,255,0.12))',
              });
              $el.find('.acu-dash-npc-avatar-fallback').show();
              return;
            }

            const applyAvatar = () => {
              const offsetX = AvatarManager.getOffsetX(matchedName!);
              const offsetY = AvatarManager.getOffsetY(matchedName!);
              const scale = AvatarManager.getScale(matchedName!);
              $el.css({
                'background-image': `url('${matchedUrl}')`,
                'background-size': `${scale}%`,
                'background-position': `${offsetX}% ${offsetY}%`,
                'background-repeat': 'no-repeat',
                'background-color': 'var(--acu-badge-bg, rgba(0,255,255,0.12))',
              });
              $el.find('.acu-dash-npc-avatar-fallback').hide();
            };

            // 本地头像/Blob链接直接应用，避免预加载阶段被误判
            if (matchedLocal || matchedUrl.startsWith('blob:')) {
              applyAvatar();
              return;
            }

            // URL头像先预加载，坏链路保持fallback
            const img = new Image();
            img.onload = applyAvatar;
            img.onerror = () => {
              $el.css({
                'background-image': 'none',
                'background-color': 'var(--acu-badge-bg, rgba(0,255,255,0.12))',
              });
              $el.find('.acu-dash-npc-avatar-fallback').show();
            };
            img.src = matchedUrl;
          } catch {
            $el.css({
              'background-image': 'none',
              'background-color': 'var(--acu-badge-bg, rgba(0,255,255,0.12))',
            });
            $el.find('.acu-dash-npc-avatar-fallback').show();
          }
        })();
      });
    })();
  };

  // ========== [新增] 收藏夹面板渲染函数 ==========
  const renderFavoritesPanel = async (): Promise<string> => {
    const allFavorites = await FavoritesManager.getAll();
    const allTags = await FavoritesManager.getAllTags();

    // 按标签分组
    const groupedByTag: Record<string, FavoriteItem[]> = {};
    const untagged: FavoriteItem[] = [];

    for (const fav of allFavorites) {
      if (fav.tags && fav.tags.length > 0) {
        for (const tag of fav.tags) {
          if (!groupedByTag[tag]) groupedByTag[tag] = [];
          groupedByTag[tag].push(fav);
        }
      } else {
        untagged.push(fav);
      }
    }

    // 生成卡片HTML (复用普通表格卡片样式 acu-data-card)
    const renderFavoriteCard = (fav: FavoriteItem) => {
      // 显示所有行，不做截断，超过高度内部滚动
      const rowsHtml = fav.header
        .map((h, i) => {
          // 清理列标题：移除括号/方括号及其内容（与表格卡片保持一致）
          const cleanHeader = h.replace(/[\(（\[【][^)）\]】]*[\)）\]】]/g, '').trim();
          return `
        <div class="acu-card-row">
          <div class="acu-card-label">${escapeHtml(cleanHeader)}</div>
          <div class="acu-card-value">${escapeHtml(String(fav.rowData[i] || ''))}</div>
        </div>
      `;
        })
        .join('');
      const tagsHtml = fav.tags.map(tag => `<span class="acu-fav-tag">${escapeHtml(tag)}</span>`).join('');
      const sourceLabel = fav.sourceInfo ? escapeHtml(fav.sourceInfo.tableName) : '';

      // 复用 acu-data-card 结构，来源标签移到底部与tags一起显示
      return `
        <div class="acu-data-card acu-fav-card" data-id="${escapeHtml(fav.id)}">
          <div class="acu-card-header">
            <span class="acu-editable-title">${escapeHtml(String(fav.rowData[0] || '未命名'))}</span>
          </div>
          <div class="acu-card-body view-list">${rowsHtml}</div>
          <div class="acu-fav-card-tags">
            ${sourceLabel ? `<span class="acu-fav-card-source">${sourceLabel}</span>` : ''}
            ${tagsHtml}
          </div>
        </div>
      `;
    };

    // 获取配置以复用布局选项
    const config = getConfig();

    // 生成分组内容
    let contentHtml = '';

    // 按标签分组，每组使用 acu-card-grid 实现横向滚动
    for (const tag of Object.keys(groupedByTag).sort()) {
      contentHtml += `
        <div class="acu-fav-group">
          <div class="acu-fav-group-title"><i class="fa-solid fa-tag"></i> ${escapeHtml(tag)}</div>
          <div class="acu-card-grid">${groupedByTag[tag].map(renderFavoriteCard).join('')}</div>
        </div>
      `;
    }

    // 未分类
    if (untagged.length > 0) {
      contentHtml += `
        <div class="acu-fav-group">
          <div class="acu-fav-group-title"><i class="fa-solid fa-inbox"></i> 未分类</div>
          <div class="acu-card-grid">${untagged.map(renderFavoriteCard).join('')}</div>
        </div>
      `;
    }

    if (allFavorites.length === 0) {
      contentHtml += `
        <div class="acu-fav-empty">
          <i class="fa-solid fa-star"></i>
          <p>暂无收藏</p>
          <p>右键点击表格行 → 选择"收藏此行"</p>
        </div>
      `;
    }

    return `
      <div class="acu-fav-wrapper acu-theme-${config.theme}" style="--acu-card-width:${config.cardWidth}px; --acu-font-size:${config.fontSize}px;">
      <div class="acu-panel-header">
        <div class="acu-panel-title">
          <div class="acu-title-main"><i class="fa-solid fa-star"></i> <span class="acu-title-text">收藏夹</span></div>
          <div class="acu-title-sub">(共${allFavorites.length}项)</div>
        </div>
        <div class="acu-header-actions">
          <button class="acu-view-btn" id="acu-fav-import" title="导入"><i class="fa-solid fa-file-import"></i></button>
          <button class="acu-view-btn" id="acu-fav-export" title="导出"><i class="fa-solid fa-file-export"></i></button>
          <div class="acu-search-wrapper"><i class="fa-solid fa-search acu-search-icon"></i><input type="text" class="acu-search-input" id="acu-fav-search" placeholder="搜索..." /></div>
          <div class="acu-height-control"><i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="收藏夹"></i></div>
          <button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
        </div>
      </div>
      <div class="acu-fav-panel-content">
        <div class="acu-fav-tag-filter-collapsible collapsed">
          <div class="acu-fav-tag-filter-header">
            <span>标签过滤</span>
            <i class="fa-solid fa-chevron-down acu-fav-tag-toggle-icon"></i>
          </div>
          <div class="acu-fav-tag-filter-body">
            ${untagged.length > 0 ? '<button class="acu-fav-tag-btn active" data-tag="__untagged__">未分类</button>' : ''}
            ${allTags.map(tag => `<button class="acu-fav-tag-btn active" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</button>`).join('')}
          </div>
        </div>
        ${contentHtml}
      </div>
      </div>
    `;
  };

  // ========== [新增] 收藏夹面板事件绑定 ==========
  const bindFavoritesEvents = ($panel: JQuery) => {
    const { $ } = getCore();
    const rawData = cachedRawData || getTableData();
    const currentTables = rawData || {};

    // 只解绑收藏夹相关的事件，防止影响其他功能的事件绑定（如标签页切换）
    $panel.off('.favEvents');

    // === [修复] 收藏夹面板：阻止水平滑动冒泡，防止触发 ST 的 swipe regenerate ===
    (function () {
      const panelEl = $panel[0];
      if (!panelEl) return;

      // 清理旧的事件监听器（通过标记）
      if ((panelEl as any)._favSwipeFixApplied) return;
      (panelEl as any)._favSwipeFixApplied = true;

      let touchStartX = 0;
      let touchStartY = 0;
      let isHorizontalSwipe = false;

      const onTouchStart = (e: TouchEvent) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          isHorizontalSwipe = false;
        }
      };

      const onTouchMove = (e: TouchEvent) => {
        if (e.touches.length !== 1) return;

        const touch = e.touches[0];
        const deltaX = Math.abs(touch.clientX - touchStartX);
        const deltaY = Math.abs(touch.clientY - touchStartY);

        // 判断是否为水平滑动：deltaY很小时降低阈值，否则使用标准判断
        const isHorizontal = deltaY < 5 ? deltaX > 5 && deltaX > deltaY * 2 : deltaX > deltaY * 1.5 && deltaX > 10;

        if (isHorizontal) {
          isHorizontalSwipe = true;
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      const onTouchEnd = (e: TouchEvent) => {
        if (isHorizontalSwipe) {
          e.stopImmediatePropagation();
          e.stopPropagation();
          isHorizontalSwipe = false;
        }
        touchStartX = 0;
        touchStartY = 0;
      };

      // 在捕获阶段监听，优先于 ST 的事件处理
      panelEl.addEventListener('touchstart', onTouchStart, true);
      panelEl.addEventListener('touchmove', onTouchMove, true);
      panelEl.addEventListener('touchend', onTouchEnd, true);

      // 清理函数（页面卸载时）
      $(window).on('pagehide.favSwipeFix', () => {
        panelEl.removeEventListener('touchstart', onTouchStart, true);
        panelEl.removeEventListener('touchmove', onTouchMove, true);
        panelEl.removeEventListener('touchend', onTouchEnd, true);
      });
    })();

    // 关闭按钮
    $panel.on('click.favEvents', '.acu-close-btn', function (e) {
      e.stopPropagation();
      Store.set('acu_favorites_panel_active', false);
      // [修复] 实际隐藏面板
      $panel.html('');
      $('#acu-btn-favorites').removeClass('active');
    });

    // [修复] 高度拖拽 - 收藏夹面板
    $panel.on('pointerdown.favEvents', '.acu-height-drag-handle', function (e) {
      if (e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const handle = this;
      handle.setPointerCapture(e.pointerId);
      $(handle).addClass('active');
      const $dataArea = $('#acu-data-area');
      const startHeight = $dataArea.height() || 400;
      const startY = e.clientY;
      const tableName = $(handle).data('table');

      handle.onpointermove = function (moveE: PointerEvent) {
        const dy = moveE.clientY - startY;
        let newHeight = startHeight - dy;
        if (newHeight < MIN_PANEL_HEIGHT) newHeight = MIN_PANEL_HEIGHT;
        if (newHeight > MAX_PANEL_HEIGHT) newHeight = MAX_PANEL_HEIGHT;
        $dataArea.css('height', newHeight + 'px');
      };
      handle.onpointerup = function (upE: PointerEvent) {
        $(handle).removeClass('active');
        handle.releasePointerCapture(upE.pointerId);
        handle.onpointermove = null;
        handle.onpointerup = null;
        if (tableName) {
          const heights = getTableHeights();
          heights[tableName] = parseInt($dataArea.css('height'));
          saveTableHeights(heights);
          $dataArea.addClass('acu-manual-mode');
        }
      };
    });

    // [修复] 双击重置高度 - 收藏夹面板
    $panel.on('dblclick.favEvents', '.acu-height-drag-handle', function (e) {
      e.preventDefault();
      e.stopPropagation();
      const tableName = $(this).data('table');
      if (tableName) {
        const heights = getTableHeights();
        delete heights[tableName];
        saveTableHeights(heights);
        $('#acu-data-area').css('height', '').removeClass('acu-manual-mode');
      }
    });

    // 标签过滤折叠/展开
    $panel.on('click.favEvents', '.acu-fav-tag-filter-header', function () {
      const $collapsible = $(this).closest('.acu-fav-tag-filter-collapsible');
      $collapsible.toggleClass('collapsed');
    });

    // 标签按钮toggle
    $panel.on('click.favEvents', '.acu-fav-tag-btn', function () {
      const $btn = $(this);
      const tag = $btn.data('tag') as string;
      const isActive = $btn.hasClass('active');

      // 切换按钮状态
      $btn.toggleClass('active');

      // 过滤对应分组
      if (tag === '__untagged__') {
        // 未分类分组：找标题包含"未分类"的分组
        $panel.find('.acu-fav-group').each(function () {
          const groupTitle = $(this).find('.acu-fav-group-title').text();
          if (groupTitle.includes('未分类')) {
            $(this).toggle(!isActive);
          }
        });
      } else {
        // 普通标签分组：找标题匹配的分组
        $panel.find('.acu-fav-group').each(function () {
          const groupTitle = $(this).find('.acu-fav-group-title').text();
          if (groupTitle.includes(tag) && !groupTitle.includes('未分类')) {
            $(this).toggle(!isActive);
          }
        });
      }
    });

    // 搜索
    $panel.find('#acu-fav-search').on(
      'input.favEvents',
      _.debounce(function () {
        const searchTerm = ($(this).val() as string).toLowerCase().trim();
        $panel.find('.acu-fav-card').each(function () {
          const cardText = $(this).text().toLowerCase();
          $(this).toggle(cardText.includes(searchTerm));
        });
      }, 300),
    );

    // 显示收藏卡片菜单
    const showFavCardMenu = (e: JQuery.ClickEvent, cardId: string) => {
      $('.acu-cell-menu, .acu-menu-backdrop').remove();

      const backdrop = $('<div class="acu-menu-backdrop"></div>');
      $('body').append(backdrop);

      const config = getConfig();
      const menu = $(`
        <div class="acu-cell-menu acu-theme-${config.theme}" data-fav-id="${escapeHtml(cardId)}">
          <div class="acu-cell-menu-item" data-action="edit"><i class="fa-solid fa-pen"></i> 编辑</div>
          <div class="acu-cell-menu-item" data-action="copy"><i class="fa-solid fa-copy"></i> 复制</div>
          <div class="acu-cell-menu-item" data-action="send"><i class="fa-solid fa-paper-plane"></i> 发送到表格</div>
          <div class="acu-cell-menu-item" data-action="delete"><i class="fa-solid fa-trash"></i> 删除</div>
          <div class="acu-cell-menu-item" data-action="close"><i class="fa-solid fa-times"></i> 关闭菜单</div>
        </div>
      `);
      $('body').append(menu);

      // 定位菜单
      const winWidth = $(window).width() || 800;
      const winHeight = $(window).height() || 600;
      const mWidth = menu.outerWidth() || 150;
      const mHeight = menu.outerHeight() || 150;
      let posX = e.clientX || winWidth / 2;
      let posY = e.clientY || winHeight / 2;
      if (posX + mWidth > winWidth) posX = winWidth - mWidth - 10;
      if (posY + mHeight > winHeight) posY = winHeight - mHeight - 10;
      menu.css({ left: posX, top: posY });

      // 点击backdrop关闭
      backdrop.on('click', () => {
        $('.acu-cell-menu, .acu-menu-backdrop').remove();
      });

      // 菜单项点击事件
      menu.on('click', '.acu-cell-menu-item', async function () {
        const action = $(this).data('action');
        const id = menu.data('fav-id');
        $('.acu-cell-menu, .acu-menu-backdrop').remove();

        if (action === 'close') return;

        const fav = await FavoritesManager.getById(id);
        if (!fav) return;

        if (action === 'edit') {
          showFavoriteEditModal(fav, async updated => {
            await FavoritesManager.updateFavorite(id, updated);
            $panel.html(await renderFavoritesPanel());
            bindFavoritesEvents($panel);
          });
        } else if (action === 'copy') {
          const copied = await FavoritesManager.duplicateFavorite(id);
          if (copied) {
            $panel.html(await renderFavoritesPanel());
            bindFavoritesEvents($panel);
          }
        } else if (action === 'send') {
          const compatible = FavoritesManager.findCompatibleTables(fav, currentTables);
          if (compatible.length === 0) {
            toastr.warning('当前聊天没有兼容的表格');
            return;
          }
          showSendToTableModal(fav, compatible, currentTables, async () => {
            $panel.html(await renderFavoritesPanel());
            bindFavoritesEvents($panel);
          });
        } else if (action === 'delete') {
          await FavoritesManager.deleteFavorite(id);
          $panel.html(await renderFavoritesPanel());
          bindFavoritesEvents($panel);
        }
      });
    };

    // 单击卡片显示菜单
    $panel.on('click.favEvents', '.acu-fav-card', function (e) {
      e.stopPropagation();
      const $card = $(this);
      const cardId = $card.data('id');

      // Toggle行为：同一卡片再次点击则关闭菜单
      const existingMenu = $('.acu-cell-menu');
      if (existingMenu.length && existingMenu.data('fav-id') === cardId) {
        $('.acu-cell-menu, .acu-menu-backdrop').remove();
        return;
      }

      showFavCardMenu(e, cardId);
    });

    // 导入
    $panel.on('click.favEvents', '#acu-fav-import', async function () {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async e => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) {
          const text = await file.text();
          const result = await FavoritesManager.importFavorites(text);
          // [修复] importFavorites 返回 { added, updated } 对象，不是数字
          if (result && (result.added > 0 || result.updated > 0)) {
            if (window.toastr) window.toastr.success(`导入成功: 新增${result.added}条, 更新${result.updated}条`);
            $panel.html(await renderFavoritesPanel());
            bindFavoritesEvents($panel);
          } else {
            if (window.toastr) window.toastr.warning('导入失败或无有效数据');
          }
        }
      };
      input.click();
    });

    // 导出
    $panel.on('click.favEvents', '#acu-fav-export', async function () {
      const json = await FavoritesManager.exportFavorites();
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `favorites_${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
      if (window.toastr) window.toastr.success('导出成功');
    });

    console.log('[DICE] bindFavoritesEvents initialized');
  };

  const renderTableContent = (tableData, tableName) => {
    if (!tableData || !tableData.rows.length)
      return `
            <div class="acu-panel-header"><div class="acu-panel-title"><i class="fa-solid ${getIconForTableName(tableName)}"></i> ${tableName}</div><button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button></div>
            <div class="acu-panel-content"><div style="text-align:center;color:var(--acu-text-sub);padding:20px;">暂无数据</div></div>`;

    const config = getConfig();
    const headers = (tableData.headers || []).slice(1);

    // [新增] 获取神-数据库锁定状态API
    const dbLockApi = getDbLockAPI();
    const sheetKey = dbLockApi ? getSheetKeyByTableName(tableName) : null;
    const lockState = dbLockApi && sheetKey ? dbLockApi.getTableLockState(sheetKey) : null;

    // 获取当前表格的视图模式 (默认 list)
    const currentStyle = (getTableStyles() || {})[tableName] || 'list';
    const isGridMode = currentStyle === 'grid';

    let titleColIndex = 1;
    if (tableData.headers.length === 1) {
      titleColIndex = 0;
    } else if (tableName.includes('总结') || tableName.includes('大纲')) {
      const idx = tableData.headers.findIndex(
        h => h && (h.includes('索引') || h.includes('编号') || h.includes('代码')),
      );
      if (idx > 0) titleColIndex = idx;
    }

    // --- 搜索和排序逻辑 ---
    let processedRows = tableData.rows.map((row, index) => {
      const rowKey = getRowKey(tableName, row, tableData.headers);
      const isBookmarked = rowKey && BookmarkManager.isBookmarked(tableName, rowKey);
      return { data: row, originalIndex: index, rowKey, isBookmarked };
    });
    const searchTerm = (tableSearchStates[tableName] || '').toLowerCase().trim();

    // 检查是否需要倒序显示
    const isReversed = isTableReversed(tableName);

    if (searchTerm) {
      processedRows = processedRows.filter(item =>
        item.data.some(cell => String(cell).toLowerCase().includes(searchTerm)),
      );
      processedRows.sort((a, b) => {
        // 优先按bookmark状态排序：bookmark的在前
        if (a.isBookmarked && !b.isBookmarked) return -1;
        if (!a.isBookmarked && b.isBookmarked) return 1;
        // 在bookmark组内和非bookmark组内，保持原有的搜索匹配度排序
        const titleA = String(a.data[titleColIndex] || '').toLowerCase();
        const titleB = String(b.data[titleColIndex] || '').toLowerCase();
        const aHitTitle = titleA.includes(searchTerm);
        const bHitTitle = titleB.includes(searchTerm);
        if (titleA === searchTerm && titleB !== searchTerm) return -1;
        if (titleA !== searchTerm && titleB === searchTerm) return 1;
        if (aHitTitle && !bHitTitle) return -1;
        if (!aHitTitle && bHitTitle) return 1;
        return a.originalIndex - b.originalIndex;
      });
    } else {
      // 默认按原始顺序排列，如果启用倒序则反转
      // 但bookmark的始终在前
      processedRows.sort((a, b) => {
        // 优先按bookmark状态排序：bookmark的在前
        if (a.isBookmarked && !b.isBookmarked) return -1;
        if (!a.isBookmarked && b.isBookmarked) return 1;
        // 在bookmark组内和非bookmark组内，保持原有的排序逻辑
        if (isReversed) {
          return b.originalIndex - a.originalIndex;
        } else {
          return a.originalIndex - b.originalIndex;
        }
      });
    }

    const itemsPerPage = config.itemsPerPage || 50;
    const totalItems = processedRows.length;
    const totalPages = Math.ceil(totalItems / itemsPerPage) || 1;
    let currentPage = tablePageStates[tableName] || 1;
    if (currentPage > totalPages) currentPage = totalPages;
    if (currentPage < 1) currentPage = 1;
    tablePageStates[tableName] = currentPage;

    const startIdx = (currentPage - 1) * itemsPerPage;
    const endIdx = startIdx + itemsPerPage;
    const rowsToRender = processedRows.slice(startIdx, endIdx);
    // [修改] 表头增加了 视图切换按钮 和 高度拖拽手柄
    // 生成倒序按钮（仅特定表格显示）
    const showReverseBtn = shouldShowReverseButton(tableName);
    const reverseBtnHtml = showReverseBtn
      ? `
            <button class="acu-view-btn acu-reverse-btn" data-table="${escapeHtml(tableName)}" title="${isReversed ? '当前：倒序（新→旧），点击切换为正序' : '当前：正序（旧→新），点击切换为倒序'}">
                <i class="fa-solid ${isReversed ? 'fa-sort-amount-up' : 'fa-sort-amount-down'}"></i>
            </button>
        `
      : '';

    let html = `
            <div class="acu-panel-header">
                <div class="acu-panel-title">
    <div class="acu-title-main"><i class="fa-solid ${getIconForTableName(tableName)}"></i> <span class="acu-title-text">${escapeHtml(tableName)}</span></div>
    <div class="acu-title-sub">(${startIdx + 1}-${Math.min(endIdx, totalItems)} / 共${totalItems}项)${isReversed ? ' <span style="color:var(--acu-accent);">↓倒序</span>' : ''}</div>
</div>
                <div class="acu-header-actions">
                    ${isCharacterTable(tableName) ? `<button class="acu-view-btn" id="acu-btn-relation-graph" data-table="${escapeHtml(tableName)}" title="查看人物关系图"><i class="fa-solid fa-project-diagram"></i></button>` : ''}
                    ${tableName.includes('地图') ? `<button class="acu-view-btn acu-table-map-btn" title="地图可视化"><i class="fa-solid fa-map"></i></button>` : ''}
                    ${reverseBtnHtml}
                    <button class="acu-view-btn" id="acu-btn-switch-style" data-table="${escapeHtml(tableName)}" title="🔄 点击切换视图模式 (当前: ${isGridMode ? '双列网格' : '单列列表'})">
                        <i class="fa-solid ${isGridMode ? 'fa-th-large' : 'fa-list'}"></i>
                    </button>
                    <div class="acu-height-control">
                        <i class="fa-solid fa-arrows-up-down acu-height-drag-handle" data-table="${escapeHtml(tableName)}" title="↕️ 拖动调整面板高度 | 双击恢复默认"></i>
                    </div>

                    <div class="acu-search-wrapper"><i class="fa-solid fa-search acu-search-icon"></i><input type="text" class="acu-search-input" placeholder="搜索全部..." value="${(tableSearchStates[tableName] || '').replace(/"/g, '&quot;')}" /></div>
                    <button class="acu-close-btn" title="关闭"><i class="fa-solid fa-times"></i></button>
                </div>
            </div>
            <div class="acu-panel-content"><div class="acu-card-grid">`;

    html += rowsToRender
      .map(item => {
        const realRowIdx = item.originalIndex;
        const row = item.data;
        const cardTitle = row[titleColIndex] || '未命名';
        // 角色相关表格：将逗号分隔名称转为主key显示
        const cardTitleDisplay = isCharacterTable(tableName) ? getDisplayName(String(cardTitle)) : String(cardTitle);
        const showDefaultIndex = titleColIndex === 1;
        const titleCellId = `${tableData.key}-${realRowIdx}-${titleColIndex}`;
        const isTitleModified = window.acuModifiedSet && window.acuModifiedSet.has(titleCellId);
        const isRowNew = currentDiffMap.has(`${tableName}-row-${realRowIdx}`);
        let rowClass = '';
        if (config.highlightNew) {
          if (isTitleModified) rowClass = 'acu-highlight-manual';
          else if (isRowNew) rowClass = 'acu-highlight-diff';
        }

        // [迁移] 计算整行锁定状态（移到外层以便卡片标题使用）
        const cardLockRowKey = getRowKey(tableName, row, tableData.headers);
        const cardRowIndex =
          sheetKey && cardLockRowKey ? findRowIndexByPrimaryKey(sheetKey, tableName, cardLockRowKey) : null;
        const isCardRowLocked = lockState && cardRowIndex !== null ? lockState.rows.includes(cardRowIndex) : false;

        // [新增] 计算标题列是否单独锁定（用于在标题后显示小锁图标）
        // titleColIndex 是包含行号列的索引，神-数据库的 colIndex 不包含行号列，需要 -1
        const isTitleCellLocked =
          lockState && cardRowIndex !== null ? lockState.cells.includes(`${cardRowIndex}:${titleColIndex - 1}`) : false;

        // 计算有效列数，用于网格视图末行占满处理
        const validColIndices = row.map((_, i) => i).filter(i => i > 0 && i !== titleColIndex);
        const isOddValidCount = validColIndices.length % 2 === 1;

        const cardBody = row
          .map((cell, cIdx) => {
            if (cIdx <= 0 || cIdx === titleColIndex) return '';
            // [新增] 隐藏"交互选项"列（因为已经以按钮形式显示）
            const currentHeader = headers[cIdx - 1] || '';
            if (currentHeader.includes('交互')) return '';
            const isLastValidCol = cIdx === validColIndices[validColIndices.length - 1];
            const spanFullRow = isLastValidCol && isOddValidCount;
            // 清理列标题：移除括号/方括号及其内容
            const rawHeaderName = headers[cIdx - 1] || '属性' + cIdx;

            // [迁移] 计算单元格锁定状态（复用外层的cardRowIndex）
            // [修复] cIdx 是包含行号列的索引，神-数据库的 colIndex 不包含行号列，需要 -1
            const isThisCellLocked =
              lockState && cardRowIndex !== null ? lockState.cells.includes(`${cardRowIndex}:${cIdx - 1}`) : false;
            // [改进] 整行锁定时，所有单元格都显示锁定图标
            const isThisFieldLocked = isCardRowLocked || isThisCellLocked;

            const headerName = rawHeaderName.replace(/[\(（\[【][^)）\]】]*[\)）\]】]/g, '').trim();
            const safeStr = str =>
              String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            const rawStrOriginal = String(cell).trim();
            const rawStr = replaceUserPlaceholders(rawStrOriginal);
            const invalidPlaceholders = ['-', '--', '—', 'null', 'none', '无', '空', 'n/a', 'undefined', '/', 'nil'];
            if (invalidPlaceholders.includes(rawStr.toLowerCase())) {
              return ''; // 直接跳过这一行，不渲染
            }

            let contentHtml = '';
            let hideLabel = false; // 是否隐藏列标题
            const splitRegex = /[;；]/;

            // [新增] 字段类型判断函数
            const isIdentityField = headerName => {
              if (!headerName) return false;
              const lowerHeader = String(headerName).toLowerCase();
              return lowerHeader.includes('身份');
            };

            const isAttributeField = headerName => {
              if (!headerName) return false;
              const lowerHeader = String(headerName).toLowerCase();
              return (
                lowerHeader.includes('基础属性') || lowerHeader.includes('特有属性') || lowerHeader.includes('属性')
              );
            };

            // 检测是否是属性格式 (如 "演技:92" 或 "演技:92, 洞察:88")
            // [修复] 如果是身份字段，跳过属性解析，直接作为普通文本处理
            const parsedAttrs = isIdentityField(rawHeaderName) ? [] : parseAttributeString(rawStr);
            // [修复] 身份字段优先处理：即使包含括号或分号，也作为普通文本完整显示（左对齐）
            if (isIdentityField(rawHeaderName)) {
              const badgeStyle = getBadgeStyle(rawStr);
              const displayCell = safeStr(rawStr) === '' && String(cell) !== '0' ? '&nbsp;' : safeStr(rawStr);
              contentHtml = badgeStyle
                ? '<span class="acu-badge ' + badgeStyle + '">' + displayCell + '</span>'
                : displayCell;
            } else if (isRelationshipCell(rawStr, headerName)) {
              // [新增] 人际关系智能拆分
              const relations = parseRelationshipString(rawStr);
              // [修复] 过滤掉关系标签为无效值的记录
              const validRelations = relations.filter(rel => {
                if (!rel.relation) return true; // 没有关系标签的保留
                return !invalidPlaceholders.includes(rel.relation.toLowerCase());
              });

              if (validRelations.length > 1) {
                hideLabel = true;
                let relHtml = '';
                for (let i = 0; i < validRelations.length; i++) {
                  const rel = validRelations[i];
                  const borderStyle =
                    i < validRelations.length - 1 ? 'border-bottom:1px dashed rgba(128,128,128,0.2);' : '';
                  relHtml += '<div style="display:flex;align-items:center;gap:8px;padding:3px 0;' + borderStyle + '">';
                  relHtml +=
                    '<span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="' +
                    isThisFieldLocked +
                    '">' +
                    safeStr(rel.name) +
                    '</span>';
                  if (rel.relation) {
                    relHtml +=
                      '<span style="color:var(--acu-text-main);font-size:0.85em;background:var(--acu-badge-bg);padding:1px 6px;border-radius:8px;">' +
                      safeStr(rel.relation) +
                      '</span>';
                  }
                  relHtml += '</div>';
                }
                contentHtml = '<div class="acu-relation-container">' + relHtml + '</div>';
              } else if (validRelations.length === 1) {
                hideLabel = true;
                const rel = validRelations[0];
                contentHtml = '<div style="display:flex;align-items:center;gap:8px;padding:3px 0;">';
                contentHtml +=
                  '<span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="' +
                  isThisFieldLocked +
                  '">' +
                  safeStr(rel.name) +
                  '</span>';
                if (rel.relation) {
                  contentHtml +=
                    '<span style="color:var(--acu-text-main);font-size:0.85em;background:var(--acu-badge-bg);padding:1px 6px;border-radius:8px;">' +
                    safeStr(rel.relation) +
                    '</span>';
                }
                contentHtml += '</div>';
              }
            } else if (parsedAttrs.length > 1) {
              // 多属性：2列网格显示，每个配骰子图标
              hideLabel = true;
              let attrsHtml = '';
              for (let i = 0; i < parsedAttrs.length; i++) {
                const attr = parsedAttrs[i];
                const showDice = !BlacklistManager.isBlacklisted(attr.name);
                attrsHtml +=
                  '<div style="display:flex;justify-content:space-between;align-items:center;padding:2px 0;">';
                attrsHtml +=
                  '<span style="color:var(--acu-text-sub);font-size:0.9em;white-space:nowrap;" data-locked="' +
                  isThisFieldLocked +
                  '" title="' +
                  safeStr(attr.name) +
                  '">' +
                  safeStr(attr.name.length > 3 ? attr.name.substring(0, 5) : attr.name) +
                  '</span>';
                attrsHtml += '<div style="display:flex;align-items:center;gap:4px;">';
                attrsHtml +=
                  '<span style="color:var(--acu-text-main);font-weight:bold;font-size:0.95em;">' +
                  attr.value +
                  '</span>';
                if (showDice) {
                  attrsHtml +=
                    '<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="' +
                    safeStr(attr.name) +
                    '" data-attr-value="' +
                    attr.value +
                    '" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:10px;" title="检定"></i>';
                }
                attrsHtml += '</div></div>';
              }
              contentHtml = '<div class="acu-multi-attr-container">' + attrsHtml + '</div>';
            } else if (parsedAttrs.length === 1) {
              // 单属性格式 (如 "演技:92") - 也隐藏列标题
              hideLabel = true;
              const attr = parsedAttrs[0];
              const showDice = !BlacklistManager.isBlacklisted(attr.name);
              contentHtml = '<div style="display:flex;justify-content:space-between;align-items:center;">';
              contentHtml +=
                '<span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="' +
                isThisFieldLocked +
                '">' +
                safeStr(attr.name) +
                '</span>';
              contentHtml += '<div style="display:flex;align-items:center;gap:6px;">';
              contentHtml += '<span style="color:var(--acu-text-main);font-weight:bold;">' + attr.value + '</span>';
              if (showDice) {
                contentHtml +=
                  '<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="' +
                  safeStr(attr.name) +
                  '" data-attr-value="' +
                  attr.value +
                  '" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:11px;" title="检定"></i>';
              }
              contentHtml += '</div></div>';
            } else if (rawStr.length > 0 && splitRegex.test(rawStr) && !rawStr.includes('http')) {
              // [修复] 无效值黑名单，这些词不应被渲染为标签
              const invalidTagValues = ['-', '--', '—', 'null', 'none', '无', '空', 'n/a', 'undefined', '/', 'nil'];
              const parts = rawStr
                .split(splitRegex)
                .map(s => s.trim())
                .filter(s => s && !invalidTagValues.includes(s.toLowerCase()));
              const allShort = parts.length > 1 && parts.every(p => p.length <= 6);
              if (allShort) {
                const tagsHtml = parts
                  .map(part => {
                    const subStyle = getBadgeStyle(part) || 'acu-badge-neutral';
                    return '<span class="acu-badge ' + subStyle + '">' + safeStr(part) + '</span>';
                  })
                  .join('');
                contentHtml = '<div class="acu-tag-container">' + tagsHtml + '</div>';
              } else if (parts.length > 0) {
                // 过滤后如果还有有效内容，则正常显示
                contentHtml = safeStr(parts.join('; '));
              } else {
                // 过滤后没有任何有效内容，渲染为空
                contentHtml = '';
              }
            } else if (isNumericCell(rawStr) && !rawStr.includes(':') && !rawStr.includes('：')) {
              // 纯数值加骰子，但保留列标题（右对齐，用于显示骰子图标）
              const numVal = extractNumericValue(rawStr);
              const showDice = !BlacklistManager.isBlacklisted(headerName);
              contentHtml = '<div style="display:flex;justify-content:space-between;align-items:center;">';
              contentHtml += '<span>' + safeStr(rawStr) + '</span>';
              if (showDice) {
                contentHtml +=
                  '<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="' +
                  safeStr(headerName) +
                  '" data-attr-value="' +
                  numVal +
                  '" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:11px;" title="检定"></i>';
              }
              contentHtml += '</div>';
            } else {
              const badgeStyle = getBadgeStyle(rawStr);
              const displayCell = safeStr(rawStr) === '' && String(cell) !== '0' ? '&nbsp;' : safeStr(rawStr);
              contentHtml = badgeStyle
                ? '<span class="acu-badge ' + badgeStyle + '">' + displayCell + '</span>'
                : displayCell;
            }

            const isDiffChanged = currentDiffMap.has(tableName + '-' + realRowIdx + '-' + cIdx);
            const cellId = tableData.key + '-' + realRowIdx + '-' + cIdx;
            const isUserModified = window.acuModifiedSet && window.acuModifiedSet.has(cellId);
            let cellHighlight = '';
            if (config.highlightNew) {
              if (isUserModified) cellHighlight = 'acu-highlight-manual';
              else if (isDiffChanged) cellHighlight = 'acu-highlight-diff';
            }

            // 隐藏标题时添加特殊 class
            // 检查锁定状态并添加图标 (已移除重复计算)

            const rowClass =
              'acu-card-row acu-cell' +
              (spanFullRow ? ' acu-grid-span-full' : '') +
              (hideLabel ? ' acu-hide-label' : '');

            return (
              '<div class="' +
              rowClass +
              '" data-key="' +
              escapeHtml(tableData.key) +
              '" data-tname="' +
              escapeHtml(tableName) +
              '" data-row="' +
              realRowIdx +
              '" data-col="' +
              cIdx +
              '" data-val="' +
              safeEncodeURIComponent(cell ?? '') +
              '"><div class="acu-card-label"><span data-locked="' +
              isThisFieldLocked +
              '">' +
              headerName +
              '</span></div><div class="acu-card-value ' +
              cellHighlight +
              '">' +
              contentHtml +
              '</div></div>'
            );
          })
          .join('');

        // [修改] 给 acu-card-body 增加了 view-grid 或 view-list 类
        // [修复] 传入完整的 tableData.headers 而非 slice 后的 headers，避免 getInteractOptionsForRow 内部索引错位
        const tableActions = getInteractOptionsForRow(tableName, tableData.headers, row);
        let actionsHtml = '';

        if (tableActions.length > 0) {
          const cardTitle = row[titleColIndex] || '未知';
          const actionBtns = tableActions
            .map(
              (act, actIdx) =>
                `<button class="acu-action-item ${act.type === 'check' ? 'check-type' : ''}" data-action-idx="${actIdx}" data-row="${realRowIdx}"><i class="fa-solid ${act.icon || 'fa-play'}"></i> ${escapeHtml(act.label)}</button>`,
            )
            .join('');
          actionsHtml = `<div class="acu-card-actions">${actionBtns}</div>`;
        }

        // [修改] 标题小锁图标：整行锁定或标题列单独锁定时都显示
        const isTitleLocked = isCardRowLocked || isTitleCellLocked;

        // [移除] 不再需要单独的整行锁定样式类，因为每个单元格都会显示锁图标
        // const cardLockedClass = isCardRowLocked ? ' acu-card-locked' : '';

        // 检查是否被bookmark
        const cardBookmarkRowKey = getRowKey(tableName, row, tableData.headers);
        const isBookmarked = cardBookmarkRowKey && BookmarkManager.isBookmarked(tableName, cardBookmarkRowKey);
        const bookmarkIcon = cardBookmarkRowKey
          ? `<i class="${isBookmarked ? 'fa-solid' : 'fa-regular'} fa-bookmark acu-bookmark-icon ${isBookmarked ? 'bookmarked' : ''}" data-table="${escapeHtml(tableName)}" data-row-key="${escapeHtml(cardBookmarkRowKey)}" title="${isBookmarked ? '取消书签' : '添加书签'}"></i>`
          : '';

        // [移除] 不再需要右上角的整行锁定图标，因为每个单元格都会显示锁图标
        // const rowLockBadge = isCardRowLocked ? '...' : '';

        return `<div class="acu-data-card"><div class="acu-card-header"><span class="acu-card-index">${showDefaultIndex ? '#' + (realRowIdx + 1) : ''}</span><span class="acu-cell acu-editable-title ${rowClass}" data-key="${escapeHtml(tableData.key)}" data-tname="${escapeHtml(tableName)}" data-row="${realRowIdx}" data-col="${titleColIndex}" data-val="${safeEncodeURIComponent(cardTitle ?? '')}" data-locked="${isTitleLocked}" title="点击编辑标题">${escapeHtml(cardTitleDisplay)}</span>${bookmarkIcon}</div><div class="acu-card-body ${isGridMode ? 'view-grid' : 'view-list'}">${cardBody}</div>${actionsHtml}</div>`;
      })
      .join('');
    html += `</div></div>`;

    if (totalPages > 1) {
      html += `<div class="acu-panel-footer"><button class="acu-page-btn ${currentPage === 1 ? 'disabled' : ''}" data-page="${currentPage - 1}" ${currentPage === 1 ? 'disabled' : ''}><i class="fa-solid fa-chevron-left"></i></button>`;
      const range = [];
      if (totalPages <= 7) {
        for (let i = 1; i <= totalPages; i++) range.push(i);
      } else {
        if (currentPage <= 4) range.push(1, 2, 3, 4, 5, '...', totalPages);
        else if (currentPage >= totalPages - 3)
          range.push(1, '...', totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages);
        else range.push(1, '...', currentPage - 1, currentPage, currentPage + 1, '...', totalPages);
      }
      range.forEach(p => {
        if (p === '...') html += `<span class="acu-page-info">...</span>`;
        else html += `<button class="acu-page-btn ${p === currentPage ? 'active' : ''}" data-page="${p}">${p}</button>`;
      });
      html += `<button class="acu-page-btn ${currentPage === totalPages ? 'disabled' : ''}" data-page="${currentPage + 1}" ${currentPage === totalPages ? 'disabled' : ''}><i class="fa-solid fa-chevron-right"></i></button></div>`;
    }
    return html;
  };

  // [新增] 通用状态保存函数 (面板滚动 + 卡片内部滚动)
  const saveCurrentTabState = () => {
    const { $ } = getCore();
    const activeTab = getActiveTabState();
    const $content = $('.acu-panel-content');

    if (activeTab && $content.length) {
      const innerScrolls = {};
      // 遍历所有卡片，记录内部滚动条位置
      $content.find('.acu-data-card, .acu-card-body, .acu-edit-textarea').each(function () {
        if (this.scrollTop > 0) {
          // 尝试找到这张卡片的唯一标识 (Row Index)
          const $card = $(this).closest('.acu-data-card');
          const rIdx = $card.find('.acu-editable-title').data('row');
          // 如果是编辑框，还要加特殊标记
          const isEdit = $(this).hasClass('acu-edit-textarea');

          if (rIdx !== undefined) {
            const key = isEdit ? `edit-${rIdx}` : rIdx;
            innerScrolls[key] = this.scrollTop;
          }
        }
      });

      // 存入全局状态对象
      tableScrollStates[activeTab] = {
        left: $content.scrollLeft(),
        top: $content.scrollTop(),
        inner: innerScrolls,
        timestamp: Date.now(), // 加个时间戳方便调试
      };
    }
  };

  const closePanel = () => {
    const { $ } = getCore();
    saveCurrentTabState(); // <--- 调用通用保存

    $('#acu-data-area').removeClass('visible');
    $('.acu-nav-btn').removeClass('active');
    saveActiveTabState(null);
    // [修复] 关闭表格面板时，不要移除气泡里的行动选项
    // $('.acu-embedded-options-container').remove();
  };

  /**
   * 面板切换工具函数 - 快速更新面板内容（无过渡延迟）
   * 由于CSS已改为 opacity + visibility 过渡，即使快速更新也不会闪烁
   * @param {Function} updateContentFn - 更新面板内容的函数，接收 $panel 参数
   */
  const switchPanel = updateContentFn => {
    const { $ } = getCore();
    const $panel = $('#acu-data-area');
    const isVisible = $panel.hasClass('visible');

    if (!isVisible) {
      // 面板不可见，直接更新并显示
      updateContentFn($panel);
      $panel.addClass('visible');
    } else {
      // 面板可见，直接更新内容（CSS transition 会自动处理平滑过渡）
      updateContentFn($panel);
    }
  };

  const bindEvents = tables => {
    const { $ } = getCore();
    const $wrapper = $('.acu-wrapper');
    // [新增] 仪表盘-人物关系图按钮
    $wrapper.on('click', '.acu-dash-relation-graph-btn', function (e) {
      e.stopPropagation();
      const allTables = processJsonData(cachedRawData || getTableData());
      const npcResult = DashboardDataParser.findTable(allTables, 'npc');
      if (npcResult && npcResult.data) {
        showRelationshipGraph(npcResult.data);
      } else {
        if (window.toastr) window.toastr.warning('未找到人物数据');
      }
    });

    // [新增] 仪表盘-地图可视化按钮
    $wrapper.on('click', '.acu-dash-map-btn', function (e) {
      e.stopPropagation();
      showMapVisualization();
    });

    // [新增] 仪表盘-头像管理按钮
    $wrapper.on('click', '.acu-dash-avatar-manager-btn', function (e) {
      e.stopPropagation();

      try {
        // 获取表格数据
        let allTables;
        try {
          const rawData = cachedRawData || getTableData();
          allTables = processJsonData(rawData);
        } catch (dataError) {
          console.error('获取表格数据失败:', dataError);
          throw new Error('无法读取表格数据');
        }

        if (!allTables || allTables.length === 0) {
          if (window.toastr) window.toastr.warning('仪表盘数据为空，请先添加表格数据');
          return;
        }

        // 查找角色数据
        const npcResult = DashboardDataParser.findTable(allTables, 'npc');
        const playerResult = DashboardDataParser.findTable(allTables, 'player');

        const nodeArr = [];

        // 添加主角（更严格的数据校验）
        if (playerResult?.data?.rows?.[0]) {
          const playerName = playerResult.data.rows[0][1];
          if (playerName && typeof playerName === 'string' && playerName.trim()) {
            nodeArr.push({ name: playerName.trim(), isPlayer: true });
          }
        }

        // 添加NPC（更严格的数据校验）
        if (npcResult?.data?.rows && Array.isArray(npcResult.data.rows)) {
          npcResult.data.rows.forEach((row, idx) => {
            if (Array.isArray(row) && row[1]) {
              const npcName = row[1];
              if (typeof npcName === 'string' && npcName.trim()) {
                nodeArr.push({ name: npcName.trim(), isPlayer: false, rowIndex: idx });
              }
            }
          });
        }

        // 检查是否有可管理的角色
        if (nodeArr.length === 0) {
          if (window.toastr) {
            window.toastr.warning('未找到角色数据，请先在仪表盘中添加主角或NPC');
          }
          return;
        }

        // 调用头像管理器（捕获其内部可能的错误）
        try {
          showAvatarManager(nodeArr, () => renderInterface());
        } catch (managerError) {
          console.error('showAvatarManager 执行失败:', managerError);
          throw new Error('头像管理器初始化失败');
        }
      } catch (error) {
        // 记录详细错误到控制台（用于开发者调试）
        console.error('头像管理按钮错误:', error);

        // 向用户显示友好的错误提示
        const errorMsg = error instanceof Error ? error.message : '未知错误';
        if (window.toastr) {
          window.toastr.error(`打开头像管理失败: ${errorMsg}`);
        }
      }
    });
    // 仪表盘模块标题点击跳转
    $wrapper.off('click.acu_dash_table_link').on('click.acu_dash_table_link', '.acu-dash-table-link', function (e) {
      e.stopPropagation();
      e.preventDefault();
      const tableName = $(this).data('table');
      if (tableName) {
        // 关闭仪表盘，切换到对应表格
        Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, false);
        Store.set('acu_changes_panel_active', false); // 同时关闭审核面板
        // [防闪烁] 先更新导航按钮状态，再延迟渲染
        $('.acu-nav-btn').removeClass('active');
        $(`.acu-nav-btn[data-table="${tableName}"]`).addClass('active');
        saveActiveTabState(tableName);
        setTimeout(() => renderInterface(), 0);
      }
    });

    // [修复] 阻止横向滑动冒泡到 SillyTavern，防止触发"滑动重新生成"
    $('.acu-panel-content')
      .off('touchstart.acu_swipe touchmove.acu_swipe')
      .on('touchstart.acu_swipe', function (e) {
        this._touchStartX = e.originalEvent.touches[0].clientX;
        this._touchStartY = e.originalEvent.touches[0].clientY;
      })
      .on('touchmove.acu_swipe', function (e) {
        if (!this._touchStartX) return;
        const deltaX = Math.abs(e.originalEvent.touches[0].clientX - this._touchStartX);
        const deltaY = Math.abs(e.originalEvent.touches[0].clientY - this._touchStartY);
        // 如果是横向滑动（角度小于45度），阻止冒泡
        if (deltaX > deltaY && deltaX > 10) {
          e.stopPropagation();
        }
      });

    $('body')
      .off('click.acu_nav_toggle')
      .on('click.acu_nav_toggle', '.acu-nav-toggle-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        if (isEditingOrder) return;
        const currentState = getCollapsedState();
        saveCollapsedState(!currentState);
        renderInterface();
      });

    // [新增] 选项面板折叠事件绑定
    $('body')
      .off('click.acu_opt_toggle')
      .on('click.acu_opt_toggle', '.acu-opt-header[data-action="toggle-options"]', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const currentState = getOptionsCollapsedState();
        saveOptionsCollapsedState(!currentState);
        renderInterface();
      });

    const $panel = $('.acu-panel-content');
    if ($panel.length) {
      // [优化] 滚动防抖，避免频繁写入硬盘导致卡顿
      let scrollTimer = null;
      $panel.off('scroll.acu_save').on('scroll.acu_save', function () {
        const $this = $(this);
        if (scrollTimer) clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          const activeTab = getActiveTabState();
          if (activeTab) {
            if (!tableScrollStates[activeTab]) tableScrollStates[activeTab] = { top: 0, left: 0, inner: {} };
            tableScrollStates[activeTab].top = $this.scrollTop();
            tableScrollStates[activeTab].left = $this.scrollLeft();
            // 不再每次滚动都写入，只更新内存，页面卸载时统一保存
          }
        }, 200);
      });
    }

    $('body')
      .off('click.acu_delegate')
      .on('click.acu_delegate', '.acu-wrapper', function (e) {
        if (isEditingOrder) return;
        const $target = $(e.target);

        // [修复] 设置按钮特殊处理 - 无论在哪个位置都优先响应
        const $settingsBtn = $target.closest('#acu-btn-settings');
        if ($settingsBtn.length) {
          e.stopPropagation();
          e.preventDefault();
          showSettingsModal();
          return;
        }

        const $navBtn = $target.closest('.acu-nav-btn');
        if ($navBtn.length) {
          // [新增] 仪表盘按钮特殊处理
          if ($navBtn.attr('id') === 'acu-btn-dashboard') {
            e.preventDefault();
            e.stopImmediatePropagation();
            const isDashboardActive = Store.get(STORAGE_KEY_DASHBOARD_ACTIVE, false);
            const isPanelVisible = $('#acu-data-area').hasClass('visible');

            if (isDashboardActive && isPanelVisible) {
              // 仪表盘已打开，关闭面板（直接淡出）
              Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, false);
              $('#acu-data-area').removeClass('visible');
              $('.acu-nav-btn').removeClass('active');
            } else {
              // 打开仪表盘（使用平滑过渡）
              Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, true);
              saveActiveTabState(null);
              $('.acu-nav-btn').removeClass('active');
              $navBtn.addClass('active');

              // 使用 switchPanel 实现平滑过渡
              switchPanel($panel => {
                const rawData = cachedRawData || getTableData();
                const tables = processJsonData(rawData || {});
                $panel.html(renderDashboard(tables));
                bindEvents(tables);
                loadDashboardNpcAvatars();
              });
            }
            return false;
          }
          // [新增] 变更审核按钮特殊处理
          if ($navBtn.attr('id') === 'acu-btn-changes') {
            e.preventDefault();
            e.stopImmediatePropagation();
            const isChangesActive = Store.get('acu_changes_panel_active', false);
            const isPanelVisible = $('#acu-data-area').hasClass('visible');

            if (isChangesActive && isPanelVisible) {
              // 变更面板已打开，关闭面板（直接淡出）
              Store.set('acu_changes_panel_active', false);
              $('#acu-data-area').removeClass('visible');
              $('.acu-nav-btn').removeClass('active');
            } else {
              // 打开变更面板（使用平滑过渡）
              clearAllPanelStates(); // [修复] 统一清理所有面板状态
              Store.set('acu_changes_panel_active', true);
              saveActiveTabState(null);
              $('.acu-nav-btn').removeClass('active');
              $navBtn.addClass('active');

              // 使用 switchPanel 实现平滑过渡
              switchPanel($panel => {
                const rawData = cachedRawData || getTableData();
                $panel.html(renderChangesPanel(rawData));
                bindChangesEvents();
              });
            }
            return false;
          }
          // [新增] 收藏夹按钮特殊处理 - 使用面板模式
          if ($navBtn.attr('id') === 'acu-btn-favorites') {
            e.preventDefault();
            e.stopImmediatePropagation();
            const isFavoritesActive = Store.get('acu_favorites_panel_active', false);
            const isPanelVisible = $('#acu-data-area').hasClass('visible');

            if (isFavoritesActive && isPanelVisible) {
              // 收藏夹面板已打开，关闭面板
              Store.set('acu_favorites_panel_active', false);
              $('#acu-data-area').removeClass('visible');
              $('.acu-nav-btn').removeClass('active');
            } else {
              // 打开收藏夹面板
              clearAllPanelStates(); // [修复] 统一清理所有面板状态
              Store.set('acu_favorites_panel_active', true);
              $('.acu-nav-btn').removeClass('active');
              $navBtn.addClass('active');

              // 使用 switchPanel 实现平滑过渡
              switchPanel(async $panel => {
                $panel.html(await renderFavoritesPanel());
                bindFavoritesEvents($panel);
              });
            }
            return false;
          }
          // [新增] MVU变量按钮特殊处理
          if ($navBtn.attr('id') === 'acu-btn-mvu') {
            e.preventDefault();
            e.stopImmediatePropagation();
            const isMvuActive = getActiveTabState() === MvuModule.MODULE_ID;
            const isPanelVisible = $('#acu-data-area').hasClass('visible');

            if (isMvuActive && isPanelVisible) {
              // 变量面板已打开，关闭面板（直接淡出）
              saveActiveTabState(null);
              $('#acu-data-area').removeClass('visible');
              $('.acu-nav-btn').removeClass('active');
            } else {
              // 打开变量面板（使用平滑过渡）
              clearAllPanelStates(); // [修复] 统一清理所有面板状态
              saveActiveTabState(MvuModule.MODULE_ID);
              $('.acu-nav-btn').removeClass('active');
              $navBtn.addClass('active');

              // 使用 switchPanel 实现平滑过渡
              switchPanel($panel => {
                try {
                  const panelHtml = MvuModule.renderPanel();
                  // 确保面板有正确的高度设置
                  const mvuSavedHeight = getTableHeights()[MvuModule.MODULE_ID];
                  if (mvuSavedHeight) {
                    $panel.css('height', mvuSavedHeight + 'px').addClass('acu-manual-mode');
                  } else {
                    $panel.css('height', '').removeClass('acu-manual-mode');
                  }
                  $panel.html('<div class="acu-mvu-panel">' + panelHtml + '</div>');
                  MvuModule.bindEvents($panel);
                } catch (error) {
                  console.error('[MVU] Error rendering panel:', error);
                }

                // 可选：在后台尝试获取数据（不阻塞界面显示）
                MvuModule.getDataWithRetry(5, 800)
                  .then(mvuData => {
                    // 如果获取到数据，刷新面板显示
                    if (mvuData && canWriteMvuPanel()) {
                      $panel.html('<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>');
                      MvuModule.bindEvents($panel);
                    }
                  })
                  .catch(err => {
                    console.error('[DICE]MvuModule Error getting data:', err);
                    if (canWriteMvuPanel()) {
                      // 错误时也刷新面板，显示错误状态
                      $panel.html('<div class="acu-mvu-panel">' + MvuModule.renderPanel() + '</div>');
                      MvuModule.bindEvents($panel);
                    }
                  });
              });
            }
            return false;
          }
          e.stopPropagation();
          const tableName = $navBtn.data('table');
          const currentActiveTab = getActiveTabState();
          if (currentActiveTab === tableName && $('#acu-data-area').hasClass('visible')) {
            closePanel();
            return;
          }
          // [修复] 点击普通表格时，清理所有面板状态
          clearAllPanelStates();
          $('.acu-nav-btn').removeClass('active');
          $navBtn.addClass('active');
          if ($('.acu-panel-content').length && currentActiveTab) {
            saveCurrentTabState();
          }
          saveActiveTabState(tableName);
          setTimeout(() => renderInterface(), 0);
          return;
        }
        const $cell = $target.closest('.acu-cell');
        if ($cell.length) {
          e.stopPropagation();
          showCellMenu(e, $cell[0]);
          return;
        }
        const $pageBtn = $target.closest('.acu-page-btn');
        if ($pageBtn.length) {
          e.stopPropagation();
          if ($pageBtn.hasClass('disabled') || $pageBtn.hasClass('active')) return;
          const newPage = parseInt($pageBtn.data('page'));
          const activeTab = getActiveTabState();
          if (activeTab) {
            tablePageStates[activeTab] = newPage;
            renderInterface();
            requestAnimationFrame(() => {
              $('.acu-panel-content').scrollTop(0);
            });
          }
          return;
        }
        return;
      });

    $('#acu-btn-expand')
      .off('click')
      .on('click', e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        saveCollapsedState(false);
        renderInterface();
      });
    // [回归] 收起按钮逻辑
    $('#acu-btn-collapse')
      .off('click')
      .on('click', e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        saveCollapsedState(true);
        renderInterface();
      });

    // 打开可视化表格编辑器按钮
    $('#acu-btn-open-visualizer')
      .off('click')
      .on('click', e => {
        e.stopPropagation();
        if (isEditingOrder) return;

        // 调用神-数据库的可视化编辑器接口
        const topWin = window.parent || window;
        if (topWin.AutoCardUpdaterAPI && typeof topWin.AutoCardUpdaterAPI.openVisualizer === 'function') {
          topWin.AutoCardUpdaterAPI.openVisualizer();
        } else {
          // 兜底：尝试直接调用全局函数
          if (typeof (topWin as any).openNewVisualizer_ACU === 'function') {
            (topWin as any).openNewVisualizer_ACU();
          } else {
            if (window.toastr) {
              window.toastr.warning('可视化编辑器接口不可用，请确保神-数据库脚本已加载');
            }
          }
        }
      });

    // [修改] 将收起按钮改为手动更新按钮
    $('#acu-btn-force-update')
      .off('click')
      .on('click', async e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        const api = getCore().getDB();
        if (api && typeof api.manualUpdate === 'function') {
          try {
            await api.manualUpdate();
          } catch (err) {
            console.error('[DICE]ACU 手动更新失败:', err);
            const errorMessage = err.message || '更新过程中出现错误';
            if (window.toastr) {
              window.toastr.error(`更新失败: ${errorMessage}`, '错误', { timeOut: 5000 });
            } else {
              alert(`更新失败: ${errorMessage}`);
            }
          }
        } else {
          if (window.toastr) {
            window.toastr.warning('⚠ 后端脚本未提供 manualUpdate 接口，请确保同时也更新了最新的后端脚本', '', {
              timeOut: 5000,
            });
          }
        }
      });
    $('body')
      .off('click.acu_settings')
      .on('click.acu_settings', '#acu-btn-settings', function (e) {
        e.stopPropagation();
        e.preventDefault();
        if (isEditingOrder) return;
        showSettingsModal();
      });
    // [新增] 导航栏掷骰按钮
    $('#acu-btn-dice-nav')
      .off('click')
      .on('click', e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        showDicePanel({
          targetValue: null,
          targetName: '', // 留空让 placeholder 显示
          // 不传 diceType，让函数内部使用保存的值
        });
      });

    // 打开神-数据库
    $('#acu-btn-open-editor')
      .off('click')
      .on('click', e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        const api = getCore().getDB();
        if (api && typeof api.openSettings === 'function') {
          api.openSettings(); // 修改为打开总控制台/设置界面
        } else if (window.toastr) {
          window.toastr.warning('后端脚本(神·数据库)未就绪或版本过低');
        }
      });

    // 重新填表按钮
    $('#acu-btn-refill')
      .off('click')
      .on('click', async e => {
        e.stopPropagation();
        if (isEditingOrder) return;
        const api = getCore().getDB();
        if (api && typeof api.manualUpdate === 'function') {
          try {
            console.log('[DICE]ACU 手动填表触发');
            await api.manualUpdate();
          } catch (err) {
            console.error('[DICE]ACU 手动填表失败:', err);
            const errorMessage = err.message || '填表过程中出现错误';
            if (window.toastr) {
              window.toastr.error(`填表失败: ${errorMessage}`, '错误', { timeOut: 5000 });
            } else {
              alert(`填表失败: ${errorMessage}`);
            }
          }
        } else {
          console.warn('[DICE]ACU manualUpdate API 不可用');
          if (window.toastr) {
            window.toastr.warning('后端脚本未提供 manualUpdate 接口', '', { timeOut: 3000 });
          }
        }
      });
    $('#acu-btn-save-global')
      .off('click')
      .on('click', async function (e) {
        e.stopPropagation();
        if (isEditingOrder) return;
        let dataToSave = null;
        if (hasUnsavedChanges && cachedRawData) {
          dataToSave = cachedRawData;
        } else {
          dataToSave = getTableData();
        }

        if (dataToSave) {
          // 1. 【核心修改】把中间的 false 改为 true，禁止保存后重绘界面
          await saveDataToDatabase(dataToSave, true, true);

          // 2. 【手动善后】因为不重绘了，我们需要手动把界面上的“未保存”红字变回普通颜色
          // 移除所有手动修改的高亮类
          $('.acu-highlight-manual').removeClass('acu-highlight-manual');

          // 3. 清理内部的脏数据标记
          if (window.acuModifiedSet) window.acuModifiedSet.clear();
          hasUnsavedChanges = false;

          // 4. 手动重置保存按钮的状态（去掉呼吸灯，变回灰色）
          const $btn = $(this);
          const $icon = $btn.find('i');
          $icon.removeClass('acu-icon-breathe fa-spinner fa-spin').addClass('fa-save');
          $btn.attr('title', '保存所有修改').css('color', '');
          $btn.prop('disabled', false);

          // 5. 提示用户
        } else {
          if (window.toastr) window.toastr.error('无法获取有效数据，保存失败');
        }
      });

    const $searchInput = $('.acu-search-input');
    if ($searchInput.length) {
      let searchTimeout;
      let isComposing = false;
      $searchInput
        .off('compositionstart compositionend input')
        .on('compositionstart', () => {
          isComposing = true;
        })
        .on('compositionend', function () {
          isComposing = false;
          const val = $(this).val();
          const activeTab = getActiveTabState();
          if (activeTab) {
            tableSearchStates[activeTab] = val;
            tablePageStates[activeTab] = 1;
            renderInterface();
            setTimeout(() => {
              $('.acu-search-input').focus();
            }, 0);
          }
        })
        .on('input', function () {
          if (isComposing) return;
          const val = $(this).val();
          const selectionStart = this.selectionStart;
          const selectionEnd = this.selectionEnd;
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            const activeTab = getActiveTabState();
            if (activeTab) {
              tableSearchStates[activeTab] = val;
              tablePageStates[activeTab] = 1;
              const isFocus = document.activeElement && document.activeElement.classList.contains('acu-search-input');
              renderInterface();
              if (isFocus) {
                const $newInput = $('.acu-search-input');
                $newInput.focus();
                if ($newInput.length && $newInput[0].setSelectionRange) {
                  try {
                    $newInput[0].setSelectionRange(selectionStart, selectionEnd);
                  } catch (e) {}
                }
              }
            }
          }, 300);
        });
    }
    // 人物关系图按钮
    $('#acu-btn-relation-graph')
      .off('click')
      .on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        const tableName = $(this).data('table');
        const rawData = cachedRawData || getTableData();
        if (rawData) {
          // NPC表（重要人物表/重要角色表）直接使用该表数据
          if (isNpcTableName(tableName)) {
            for (const key in rawData) {
              const sheet = rawData[key];
              if (sheet?.name === tableName) {
                const tableData = {
                  headers: sheet.content?.[0] || [],
                  rows: sheet.content?.slice(1) || [],
                  key: key,
                };
                showRelationshipGraph(tableData);
                return;
              }
            }
          } else {
            // 非NPC表（如主角信息），通过DashboardDataParser查找NPC表
            const allTables = processJsonData(rawData);
            const npcResult = DashboardDataParser.findTable(allTables, 'npc');
            if (npcResult && npcResult.data) {
              showRelationshipGraph(npcResult.data);
              return;
            }
          }
        }
        if (window.toastr) window.toastr.warning('无法获取表格数据');
      });
    // 表格面板地图可视化按钮
    $('.acu-table-map-btn')
      .off('click')
      .on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        showMapVisualization();
      });
    // --- [新增] 移植功能的事件绑定 ---

    // 1. 视图切换
    $('#acu-btn-switch-style')
      .off('click')
      .on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        const tableName = $(this).data('table');
        const styles = getTableStyles();
        const current = styles[tableName] || 'list';
        styles[tableName] = current === 'grid' ? 'list' : 'grid'; // 切换
        saveTableStyles(styles);
        renderInterface(); // 重绘
      });

    // 2. 高度拖拽
    $('.acu-height-drag-handle')
      .off('pointerdown')
      .on('pointerdown', function (e) {
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const handle = this;
        handle.setPointerCapture(e.pointerId);
        $(handle).addClass('active');
        const $panel = $('#acu-data-area');
        const startHeight = $panel.height();
        const startY = e.clientY;
        const tableName = $(handle).data('table');

        handle.onpointermove = function (moveE) {
          const dy = moveE.clientY - startY;
          let newHeight = startHeight - dy; // 向上拖动增加高度
          if (newHeight < MIN_PANEL_HEIGHT) newHeight = MIN_PANEL_HEIGHT;
          if (newHeight > MAX_PANEL_HEIGHT) newHeight = MAX_PANEL_HEIGHT;
          $panel.css('height', newHeight + 'px');
        };
        handle.onpointerup = function (upE) {
          $(handle).removeClass('active');
          handle.releasePointerCapture(upE.pointerId);
          handle.onpointermove = null;
          handle.onpointerup = null;
          if (tableName) {
            const heights = getTableHeights();
            heights[tableName] = parseInt($panel.css('height'));
            saveTableHeights(heights);
            $panel.addClass('acu-manual-mode');
          }
        };
      });

    // 3. 双击重置高度 - 支持整个头部区域触发
    $('.acu-height-drag-handle')
      .off('dblclick')
      .on('dblclick', function (e) {
        e.preventDefault();
        e.stopPropagation();
        const tableName = $(this).data('table');
        if (tableName) {
          const heights = getTableHeights();
          delete heights[tableName];
          saveTableHeights(heights);
          $('#acu-data-area').css('height', '').removeClass('acu-manual-mode');
        }
      });

    // [新增] 倒序按钮点击事件
    $wrapper.on('click', '.acu-reverse-btn', function (e) {
      e.stopPropagation();
      const tName = $(this).data('table');
      if (!tName) return;

      toggleTableReverse(tName);

      // 重新渲染当前表格
      renderInterface();
    });
    // [新增] 双击头部任意位置也可重置高度
    $('.acu-panel-header')
      .off('dblclick.acu')
      .on('dblclick.acu', function (e) {
        if ($(e.target).closest('.acu-search-input, .acu-close-btn, .acu-view-btn').length) return;
        e.preventDefault();
        e.stopPropagation();
        const tableName = getActiveTabState();
        if (tableName) {
          const heights = getTableHeights();
          delete heights[tableName];
          saveTableHeights(heights);
          $('#acu-data-area').css('height', '').removeClass('acu-manual-mode');
        }
      });

    $wrapper
      .find('.acu-close-btn')
      .off('click')
      .on('click', function (e) {
        e.stopPropagation();
        const $input = $('.acu-search-input');

        // 如果搜索框有内容，清空搜索框
        if ($input.length && $input.val()) {
          $input.val('').trigger('input').focus();
          return;
        }

        // 检查是否是仪表盘状态
        const isDashboardActive = Store.get(STORAGE_KEY_DASHBOARD_ACTIVE, false);
        if (isDashboardActive) {
          // 仪表盘状态：关闭仪表盘，重新渲染到默认状态
          Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, false);
          saveActiveTabState(null);
          renderInterface();
          return;
        }

        // 检查是否是变量面板状态
        const isMvuActive = getActiveTabState() === MvuModule.MODULE_ID;
        if (isMvuActive) {
          // 变量面板状态：关闭变量面板，重新渲染到默认状态
          saveActiveTabState(null);
          renderInterface();
          return;
        }

        // 普通表格状态：正常关闭面板
        closePanel();
      });
    // [新增] bookmark图标点击事件
    $('body')
      .off('click.acu_bookmark')
      .on('click.acu_bookmark', '.acu-bookmark-icon', function (e) {
        e.stopPropagation();
        e.preventDefault();

        const $icon = $(this);
        const tableName = $icon.data('table');
        const rowKey = $icon.data('row-key');

        if (!tableName || !rowKey) return;

        // 切换bookmark状态
        BookmarkManager.toggleBookmark(tableName, rowKey);

        // 重新渲染表格以更新显示
        if (typeof renderInterface === 'function') {
          renderInterface();
        }
      });

    // [新增] 动作按钮点击事件
    $('body')
      .off('click.acu_action')
      .on('click.acu_action', '.acu-action-item', function (e) {
        e.stopPropagation();
        e.preventDefault();

        const $btn = $(this);
        const rowIdx = parseInt($btn.data('row'), 10);
        const actionIdx = parseInt($btn.data('action-idx'), 10);

        // 获取当前表格信息
        const $card = $btn.closest('.acu-data-card');
        const $title = $card.find('.acu-editable-title');
        const tableKey = $title.data('key');
        const tableName = $title.data('tname') || '';

        // 获取行数据
        const rawData = cachedRawData || getTableData();
        if (!rawData || !rawData[tableKey]) return;

        const headers = rawData[tableKey].content[0] || [];
        const rowData = rawData[tableKey].content[rowIdx + 1] || [];

        // [统一] 使用公共函数获取交互选项（默认动作 + AI生成的自定义动作）
        const actions = getInteractOptionsForRow(tableName, headers, rowData);

        const action = actions[actionIdx];

        // [特殊处理] 技能检定类型：使用技能并打开掷骰面板
        if (action && action.type === 'skill_check') {
          const skillName = rowData[1] || '技能';

          // 查找属性值或熟练度
          let checkValue = null;
          const attrValIdx = headers.findIndex(h => h && h.includes('属性值'));
          const profIdx = headers.findIndex(h => h && (h.includes('熟练') || h.includes('等级')));

          // 优先取属性值
          if (attrValIdx > 0 && rowData[attrValIdx]) {
            const val = extractNumericValue(rowData[attrValIdx]);
            if (val > 0) checkValue = val;
          }
          // 回退到熟练度
          if (checkValue === null && profIdx > 0 && rowData[profIdx]) {
            const val = extractNumericValue(rowData[profIdx]);
            if (val > 0) checkValue = val;
          }

          // 填入使用技能的文本
          const promptText = processTemplate(action.template, rowData, headers);
          smartInsertToTextarea(promptText, 'action');

          // 如果有有效数值，打开掷骰面板
          if (checkValue !== null && checkValue > 0) {
            showDicePanel({
              attrValue: checkValue,
              targetValue: null,
              targetName: skillName,
              initiatorName: '<user>',
            });
          } else {
            $('#send_textarea').focus();
          }
          return;
        }

        if (action && action.template) {
          // 获取该行的数据
          const rawData = cachedRawData || getTableData();
          if (rawData && rawData[tableKey]) {
            const headers = rawData[tableKey].content[0] || [];
            const rowData = rawData[tableKey].content[rowIdx + 1] || [];
            const npcName = rowData[1] || '对方';

            // 如果是"交谈"动作，弹出输入框
            if (action.label === '交谈') {
              const config = getConfig();
              $('.acu-msg-overlay').remove();

              const overlay = $(`
                        <div class="acu-msg-overlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:31200;display:flex;justify-content:center;align-items:center;">
                            <div style="background:var(--acu-bg-panel);border:1px solid var(--acu-border);border-radius:12px;padding:16px;width:90%;max-width:320px;box-shadow:0 10px 40px rgba(0,0,0,0.4);">
                                <div style="font-size:14px;font-weight:bold;color:var(--acu-accent);margin-bottom:12px;display:flex;align-items:center;gap:6px;">
                                    <i class="fa-solid fa-comment"></i> 发送消息给 ${escapeHtml(npcName)}
                                </div>
                                <input type="text" id="acu-msg-input" placeholder="输入消息内容..." style="width:100%;padding:10px 12px;background:var(--acu-input-bg) !important;border:1px solid var(--acu-border);border-radius:6px;color:var(--acu-text-main) !important;font-size:14px;box-sizing:border-box;" autofocus>
                                <div style="display:flex;gap:8px;margin-top:12px;">
                                    <button id="acu-msg-cancel" style="flex:1;padding:8px;background:var(--acu-input-bg);border:1px solid var(--acu-text-sub);border-radius:6px;color:var(--acu-text-main);cursor:pointer;">取消</button>
                                    <button id="acu-msg-send" style="flex:1;padding:8px;background:var(--acu-btn-active-bg);border:none;border-radius:6px;color:var(--acu-btn-active-text);cursor:pointer;font-weight:bold;">发送</button>
                                </div>
                            </div>
                        </div>
                    `);

              $('body').append(overlay);
              // [关键修复] 用 JS 强制设置 overlay 样式
              const overlayEl = overlay[0];
              overlayEl.style.setProperty('position', 'fixed', 'important');
              overlayEl.style.setProperty('top', '0', 'important');
              overlayEl.style.setProperty('left', '0', 'important');
              overlayEl.style.setProperty('right', '0', 'important');
              overlayEl.style.setProperty('bottom', '0', 'important');
              overlayEl.style.setProperty('width', '100vw', 'important');
              overlayEl.style.setProperty('height', '100vh', 'important');
              overlayEl.style.setProperty('display', 'flex', 'important');
              overlayEl.style.setProperty('justify-content', 'center', 'important');
              overlayEl.style.setProperty('align-items', 'center', 'important');
              overlayEl.style.setProperty('z-index', '31100', 'important');
              setTimeout(() => overlay.find('#acu-msg-input').focus(), 50);

              const sendMessage = () => {
                const msg = overlay.find('#acu-msg-input').val().trim();
                if (msg) {
                  const promptText = `<user>对${npcName}说："${msg}"`;
                  smartInsertToTextarea(promptText, 'action');
                  $('#send_textarea').focus();
                }
                overlay.remove();
              };

              overlay.find('#acu-msg-send').click(sendMessage);
              overlay.find('#acu-msg-input').on('keydown', function (ev) {
                if (ev.key === 'Enter') {
                  ev.preventDefault();
                  sendMessage();
                }
              });
              overlay.find('#acu-msg-cancel').click(() => overlay.remove());
              setupOverlayClose(overlay, 'acu-msg-overlay', () => overlay.remove());
              return;
            }

            // 其他动作：使用 processTemplate 处理模板
            const promptText = processTemplate(action.template, rowData, headers);
            smartInsertToTextarea(promptText, 'action');
            $('#send_textarea').focus();
          }
        }
      });

    // [新增] 全局骰子按钮（面板右上角）
    $('body')
      .off('click.acu_global_dice')
      .on('click.acu_global_dice', '#acu-btn-dice', function (e) {
        e.stopPropagation();
        showDicePanel({
          targetValue: 50,
          targetName: '自定义检定',
          diceType: '1d100',
        });
      });
    // ========== [新增代码开始] ==========
    // 仪表盘地点列表的展开/收起交互
    $('body')
      .off('click.acu_location_toggle')
      .on('click.acu_location_toggle', '.acu-location-header', function (e) {
        e.stopPropagation();
        const $group = $(this).closest('.acu-location-group');
        $group.toggleClass('expanded');
      });

    // [新增] 仪表盘跳转功能：点击"查看全部"或地点项，跳转到对应表格
    $('body')
      .off('click.acu_dash_jump')
      .on('click.acu_dash_jump', '.acu-dash-jump-link, .acu-dash-loc-item', function (e) {
        e.stopPropagation();
        const tableName = $(this).data('table');
        const searchTerm = $(this).data('search') || '';

        if (tableName) {
          // 1. 关闭仪表盘
          Store.set(STORAGE_KEY_DASHBOARD_ACTIVE, false);

          // 2. 切换到目标表格
          saveActiveTabState(tableName);

          // 3. 如果有搜索词，设置搜索状态
          if (searchTerm) {
            tableSearchStates[tableName] = searchTerm;
            tablePageStates[tableName] = 1;
          }

          // 4. 重新渲染
          renderInterface();

          // 5. 聚焦搜索框（如果有搜索词）
          if (searchTerm) {
            setTimeout(() => {
              const $input = $('.acu-search-input');
              if ($input.length) $input.focus();
            }, 100);
          }
        }
      });
    // ========== [新增代码结束] ==========
    // [新增] 表格卡片内联骰子图标点击事件
    $('body')
      .off('click.acu_inline_dice')
      .on('click.acu_inline_dice', '.acu-inline-dice-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();

        // 使用 .attr() 直接读取，避免 jQuery 驼峰转换问题
        const attrName = $(this).attr('data-attr-name') || '属性';
        const attrValue = parseInt($(this).attr('data-attr-value'), 10) || 50;

        // 获取卡片标题作为实体名称（NPC名字等）
        const $card = $(this).closest('.acu-data-card');
        const cardTitle = $card.find('.acu-editable-title').text().trim();

        // 判断是否是主角相关表格（如果是主角表，仍用<user>）
        const tableName = $card.find('.acu-editable-title').data('tname') || '';
        const isPlayerTable = tableName.includes('主角');
        const initiatorName = isPlayerTable ? '<user>' : cardTitle;

        showDicePanel({
          attrValue: attrValue,
          targetValue: null, // 让showDicePanel根据模式自动计算
          targetName: attrName,
          initiatorName: initiatorName,
          // 不传 diceType，使用保存的值
        });
      });
    // [新增] 仪表盘骰子检定按钮
    $('body')
      .off('click.acu_dash_dice')
      .on('click.acu_dash_dice', '.acu-dash-dice-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const targetValue = parseInt($(this).data('target'), 10) || 50;
        const targetName = $(this).data('name') || '属性';
        const npcName = $(this).data('npc') || '';

        // 如果是NPC的属性，直接打开对抗检定
        if (npcName) {
          // 修复：尝试获取主角的同名属性值
          const playerAttrValue = getAttributeValue('<user>', targetName) || 50;
          showContestPanel({
            initiatorName: '<user>',
            initiatorValue: playerAttrValue,
            opponentName: npcName,
            opponentValue: targetValue,
          });
        } else {
          showDicePanel({
            attrValue: targetValue,
            targetValue: null,
            targetName: targetName,
            initiatorName: '<user>',
          });
        }
      });
    // [新增] 已知地区"前往"按钮
    $('body')
      .off('click.acu_dash_goto')
      .on('click.acu_dash_goto', '.acu-dash-goto-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const locationName = $(this).data('location') || '未知地点';
        const promptText = `<user>前往${locationName}。`;
        smartInsertToTextarea(promptText, 'action');
        $('#send_textarea').focus();
      });
    // [新增] 背包物品"使用"按钮
    $('body')
      .off('click.acu_dash_use_item')
      .on('click.acu_dash_use_item', '.acu-dash-use-item-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const itemName = $(this).data('item') || '物品';
        const promptText = `<user>使用${itemName}。`;
        smartInsertToTextarea(promptText, 'action');
        $('#send_textarea').focus();
      });
    // [新增] 技能列表"使用"按钮 - 使用技能并进行检定
    $('body')
      .off('click.acu_dash_use_skill')
      .on('click.acu_dash_use_skill', '.acu-dash-use-skill-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const skillName = $(this).data('skill') || '技能';

        // 查找该技能的属性值或熟练度
        const rawData = cachedRawData || getTableData();
        let checkValue = null;

        if (rawData) {
          // 查找技能表
          for (const key in rawData) {
            const sheet = rawData[key];
            if (!sheet || !sheet.name || !sheet.content) continue;
            if (sheet.name.includes('技能') || sheet.name.includes('能力')) {
              const headers = sheet.content[0] || [];
              // 动态查找列索引
              const nameIdx = headers.findIndex(h => h && (h.includes('名称') || h.includes('技能名'))) || 1;
              const attrValIdx = headers.findIndex(h => h && h.includes('属性值'));
              const profIdx = headers.findIndex(h => h && (h.includes('熟练') || h.includes('等级')));

              for (let i = 1; i < sheet.content.length; i++) {
                const row = sheet.content[i];
                if (row && row[nameIdx === -1 ? 1 : nameIdx] === skillName) {
                  // 优先取属性值
                  if (attrValIdx > 0 && row[attrValIdx]) {
                    const val = extractNumericValue(row[attrValIdx]);
                    if (val > 0) {
                      checkValue = val;
                      break;
                    }
                  }
                  // 回退到熟练度
                  if (profIdx > 0 && row[profIdx]) {
                    const val = extractNumericValue(row[profIdx]);
                    if (val > 0) {
                      checkValue = val;
                      break;
                    }
                  }
                  break;
                }
              }
              if (checkValue !== null) break;
            }
          }
        }

        // 先填入使用技能的文本
        const promptText = `<user>使用${skillName}。`;
        smartInsertToTextarea(promptText, 'action');

        // 如果有有效数值，打开掷骰面板进行检定
        if (checkValue !== null && checkValue > 0) {
          showDicePanel({
            attrValue: checkValue,
            targetValue: null,
            targetName: skillName,
            initiatorName: '<user>',
          });
        } else {
          // 没有有效数值，只聚焦输入框
          $('#send_textarea').focus();
        }
      });
    // [新增] 进行中任务"追踪"按钮
    $('body')
      .off('click.acu_dash_track_task')
      .on('click.acu_dash_track_task', '.acu-dash-track-task-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const taskName = $(this).data('task') || '任务';
        const promptText = `<user>将${taskName}设为当前追踪目标。`;
        smartInsertToTextarea(promptText, 'action');
        $('#send_textarea').focus();
      });
    // [新增] 重要人物"发消息"按钮
    $('body')
      .off('click.acu_dash_msg')
      .on('click.acu_dash_msg', '.acu-dash-msg-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const npcName = $(this).data('npc') || '对方';
        const config = getConfig();

        // 移除已有的弹窗
        $('.acu-msg-overlay').remove();

        const overlay = $(`
            <div class="acu-msg-overlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:31200;display:flex;justify-content:center;align-items:center;">
                <div class="acu-msg-dialog" style="background:var(--acu-bg-panel);border:1px solid var(--acu-border);border-radius:12px;padding:16px;width:90%;max-width:320px;box-shadow:0 10px 40px rgba(0,0,0,0.4);">
                    <div style="font-size:14px;font-weight:bold;color:var(--acu-accent);margin-bottom:12px;display:flex;align-items:center;gap:6px;">
                        <i class="fa-solid fa-comment"></i> 发送消息给 ${escapeHtml(npcName)}
                    </div>
                    <input type="text" id="acu-msg-input" placeholder="输入消息内容..." style="width:100%;padding:10px 12px;background:var(--acu-input-bg) !important;border:1px solid var(--acu-border);border-radius:6px;color:var(--acu-text-main) !important;font-size:14px;box-sizing:border-box;" autofocus>
                    <div style="display:flex;gap:8px;margin-top:12px;">
                        <button id="acu-msg-cancel" style="flex:1;padding:8px;background:var(--acu-input-bg);border:1px solid var(--acu-text-sub);border-radius:6px;color:var(--acu-text-main);cursor:pointer;">取消</button>
                        <button id="acu-msg-send" style="flex:1;padding:8px;background:var(--acu-btn-active-bg);border:none;border-radius:6px;color:var(--acu-btn-active-text);cursor:pointer;font-weight:bold;">发送</button>
                    </div>
                </div>
            </div>
        `);

        $('body').append(overlay);
        const overlayEl = overlay[0];
        overlayEl.style.setProperty('position', 'fixed', 'important');
        overlayEl.style.setProperty('top', '0', 'important');
        overlayEl.style.setProperty('left', '0', 'important');
        overlayEl.style.setProperty('right', '0', 'important');
        overlayEl.style.setProperty('bottom', '0', 'important');
        overlayEl.style.setProperty('width', '100vw', 'important');
        overlayEl.style.setProperty('height', '100vh', 'important');
        overlayEl.style.setProperty('display', 'flex', 'important');
        overlayEl.style.setProperty('justify-content', 'center', 'important');
        overlayEl.style.setProperty('align-items', 'center', 'important');
        overlayEl.style.setProperty('z-index', '31100', 'important');
        setTimeout(() => overlay.find('#acu-msg-input').focus(), 50);

        const sendMessage = () => {
          const msg = overlay.find('#acu-msg-input').val().trim();
          if (msg) {
            const promptText = `<user>对${npcName}说："${msg}"`;
            smartInsertToTextarea(promptText, 'action');
            $('#send_textarea').focus();
          }
          overlay.remove();
        };

        // 点击发送
        overlay.find('#acu-msg-send').click(sendMessage);

        // 回车发送
        overlay.find('#acu-msg-input').on('keydown', function (ev) {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            sendMessage();
          }
        });

        // 点击取消或背景关闭
        overlay.find('#acu-msg-cancel').click(() => overlay.remove());
        setupOverlayClose(overlay, 'acu-msg-overlay', () => overlay.remove());
      });
    // [新增] NPC对抗检定按钮
    $('body')
      .off('click.acu_dash_contest')
      .on('click.acu_dash_contest', '.acu-dash-contest-btn', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const npcName = $(this).data('npc') || '';

        const rawData = cachedRawData || getTableData();

        var playerAttrValue = 50;
        var npcAttrValue = 50;
        var foundPlayer = false;
        var foundNPC = false;

        if (rawData) {
          for (var key in rawData) {
            var sheet = rawData[key];
            if (!sheet || !sheet.name || !sheet.content) continue;

            // 主角信息表
            if (sheet.name?.includes('主角')) {
              if (sheet.content[1]) {
                var attrStr = sheet.content[1][7] || '';
                var parts = attrStr.split(/[,，;；\s]+/);
                for (var i = 0; i < parts.length; i++) {
                  var match = parts[i].match(/^([\u4e00-\u9fa5a-zA-Z]+)[:\s：]\s*(\d+)/);
                  if (match) {
                    playerAttrValue = parseInt(match[2], 10);
                    foundPlayer = true;
                    break;
                  }
                }
              }
            }

            // 重要人物表
            if (isNpcTableName(sheet.name) && npcName) {
              for (var j = 1; j < sheet.content.length; j++) {
                var row = sheet.content[j];
                if (row && row[1] === npcName) {
                  var npcAttrStr = row[9] || '';
                  var npcParts = npcAttrStr.split(/[,，;；\s]+/);
                  for (var k = 0; k < npcParts.length; k++) {
                    var npcMatch = npcParts[k].match(/^([\u4e00-\u9fa5a-zA-Z]+)[:\s：]\s*(\d+)/);
                    if (npcMatch) {
                      npcAttrValue = parseInt(npcMatch[2], 10);
                      foundNPC = true;
                      break;
                    }
                  }
                  break;
                }
              }
            }
          }
        }

        showContestPanel({
          initiatorName: '<user>',
          initiatorValue: playerAttrValue,
          opponentName: npcName,
          opponentValue: npcAttrValue,
          diceType: '1d100',
        });
      });

    // [新增] 弹窗内单元格点击菜单支持（全局委托）
    // 使用 $('body') 而非 $(document)，确保在 iframe 环境下正确工作
    $('body')
      .off('click.acu_preview_cell_menu')
      .on('click.acu_preview_cell_menu', '.acu-preview-overlay .acu-cell', function (e) {
        console.log('[DICE] preview cell click triggered', this, $(this).data());
        // 排除关闭按钮
        if ($(e.target).closest('.acu-preview-close').length) return;

        const $this = $(this);
        const existingMenu = $('.acu-cell-menu');

        // [修复] Toggle 行为：同一单元格再次点击则关闭菜单
        if (existingMenu.length) {
          const menuCellId = existingMenu.data('cell-id');
          const thisCellId = `${$this.data('key')}-${$this.data('row')}-${$this.data('col')}`;
          if (menuCellId === thisCellId) {
            $('.acu-cell-menu, .acu-menu-backdrop').remove();
            return;
          }
        }

        e.stopPropagation();
        e.preventDefault();
        showCellMenu(e, this);

        // 记录当前菜单对应的单元格ID，用于 toggle 判断
        const cellId = `${$this.data('key')}-${$this.data('row')}-${$this.data('col')}`;
        $('.acu-cell-menu').data('cell-id', cellId);
      });

    // [重构] 仪表盘预览功能：复用表格卡片渲染，完整功能
    $('body')
      .off('click.acu_dash_preview')
      .on('click.acu_dash_preview', '.acu-dash-preview-trigger', function (e) {
        e.stopPropagation();

        const tableKey = $(this).data('table-key');
        const rowIndex = parseInt($(this).data('row-index'), 10);

        if (!tableKey || isNaN(rowIndex)) return;

        const rawData = cachedRawData || getTableData();
        if (!rawData || !rawData[tableKey]) return;

        const table = rawData[tableKey];
        const tableName = table.name || '详情';
        const headers = table.content[0] || [];
        const rowData = table.content[rowIndex + 1];

        if (!rowData) return;

        const config = getConfig();
        const title = rowData[1] || '未命名';
        const titleDisplay = isCharacterTable(tableName) ? getDisplayName(String(title)) : String(title);

        // 复用 renderTableContent 中的卡片渲染逻辑
        const titleColIndex = 1;
        const realRowIdx = rowIndex;

        // [新增] 获取神-数据库锁定状态API
        const dbLockApi = getDbLockAPI();
        const sheetKey = dbLockApi ? getSheetKeyByTableName(tableName) : null;
        const lockState = dbLockApi && sheetKey ? dbLockApi.getTableLockState(sheetKey) : null;

        // [新增] 计算行锁定状态（在循环外部计算一次）
        const lockRowKey = getRowKey(tableName, rowData, headers);
        const dbRowIndex = sheetKey && lockRowKey ? findRowIndexByPrimaryKey(sheetKey, tableName, lockRowKey) : null;
        const isCardRowLocked =
          lockState && dbRowIndex !== null ? (lockState.rows?.includes(dbRowIndex) ?? false) : false;

        // [新增] 计算标题列锁定状态
        const isTitleLocked =
          isCardRowLocked ||
          (lockState && dbRowIndex !== null
            ? (lockState.cells?.includes(`${dbRowIndex}:${titleColIndex - 1}`) ?? false)
            : false);

        // 构建卡片内容（复用主表格的渲染逻辑）
        let cardBody = '';
        rowData.forEach((cell, cIdx) => {
          if (cIdx <= 0 || cIdx === titleColIndex) return;
          const currentHeader = headers[cIdx] || '';
          if (currentHeader.includes('交互')) return; // 隐藏交互选项列

          // 清理列标题：移除括号/方括号及其内容（与表格卡片保持一致）
          const headerName = (headers[cIdx] || '属性' + cIdx).replace(/[\(（\[【][^)）\]】]*[\)）\]】]/g, '').trim();
          const rawStr = String(cell || '').trim();
          if (!rawStr) return;

          // [修复] 计算锁定状态：整行锁定或单元格锁定
          // [修复] cIdx 是包含行号列的索引，神-数据库的 colIndex 不包含行号列，需要 -1
          const isThisCellLocked =
            lockState && dbRowIndex !== null
              ? (lockState.cells?.includes(`${dbRowIndex}:${cIdx - 1}`) ?? false)
              : false;
          const isThisFieldLocked = isCardRowLocked || isThisCellLocked;

          let contentHtml = '';
          let hideLabel = false;

          const parsedAttrs = parseAttributeString(rawStr);
          // [新增] 人际关系智能拆分
          if (isRelationshipCell(rawStr, headerName)) {
            const relations = parseRelationshipString(rawStr);
            if (relations.length > 1) {
              hideLabel = true;
              let relHtml = '';
              relations.forEach((rel, i) => {
                const borderStyle = i < relations.length - 1 ? 'border-bottom:1px dashed rgba(128,128,128,0.2);' : '';
                relHtml += `<div style="display:flex;justify-content:flex-start;align-items:center;gap:8px;padding:3px 0;${borderStyle}">
                              <span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="${isThisFieldLocked}">${escapeHtml(rel.name)}</span>
                              ${rel.relation ? `<span style="color:var(--acu-text-main);font-size:0.85em;background:var(--acu-badge-bg);padding:1px 6px;border-radius:8px;">${escapeHtml(rel.relation)}</span>` : ''}
                          </div>`;
              });
              contentHtml = `<div class="acu-relation-container">${relHtml}</div>`;
            } else if (relations.length === 1 && relations[0].relation) {
              hideLabel = true; // [修复] 单个人际关系也需要隐藏标签
              const rel = relations[0];
              contentHtml = `<div style="display:flex;justify-content:flex-start;align-items:center;gap:8px;">
                          <span style="color:var(--acu-text-sub);" data-locked="${isThisFieldLocked}">${escapeHtml(rel.name)}</span>
                          <span style="color:var(--acu-text-main);font-size:0.85em;background:var(--acu-badge-bg);padding:1px 6px;border-radius:8px;">${escapeHtml(rel.relation)}</span>
                      </div>`;
            }
          } else if (parsedAttrs.length > 1) {
            hideLabel = true;
            let attrsHtml = '';
            parsedAttrs.forEach((attr, i) => {
              const showDice = !BlacklistManager.isBlacklisted(attr.name);
              const borderStyle = i < parsedAttrs.length - 1 ? 'border-bottom:1px dashed rgba(128,128,128,0.2);' : '';
              attrsHtml += `<div style="display:flex;justify-content:space-between;align-items:center;padding:3px 0;${borderStyle}">
                          <span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="${isThisFieldLocked}">${escapeHtml(attr.name)}</span>
                          <div style="display:flex;align-items:center;gap:6px;">
                              <span style="color:var(--acu-text-main);font-weight:bold;">${attr.value}</span>
                              ${showDice ? `<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="${escapeHtml(attr.name)}" data-attr-value="${attr.value}" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:11px;" title="检定"></i>` : ''}
                          </div></div>`;
            });
            contentHtml = `<div class="acu-multi-attr-container">${attrsHtml}</div>`;
          } else if (parsedAttrs.length === 1) {
            hideLabel = true;
            const attr = parsedAttrs[0];
            const showDice = !BlacklistManager.isBlacklisted(attr.name);
            contentHtml = `<div style="display:flex;justify-content:space-between;align-items:center;">
                      <span style="color:var(--acu-text-sub);font-size:0.95em;" data-locked="${isThisFieldLocked}">${escapeHtml(attr.name)}</span>
                      <div style="display:flex;align-items:center;gap:6px;">
                          <span style="color:var(--acu-text-main);font-weight:bold;">${attr.value}</span>
                          ${showDice ? `<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="${escapeHtml(attr.name)}" data-attr-value="${attr.value}" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:11px;" title="检定"></i>` : ''}
                      </div></div>`;
          } else if (isNumericCell(rawStr) && !rawStr.includes(':') && !rawStr.includes('：')) {
            const numVal = extractNumericValue(rawStr);
            const showDice = !BlacklistManager.isBlacklisted(headerName);
            contentHtml = `<div style="display:flex;justify-content:space-between;align-items:center;">
                      <span>${escapeHtml(rawStr)}</span>
                      ${showDice ? `<i class="fa-solid fa-dice-d20 acu-inline-dice-btn" data-attr-name="${escapeHtml(headerName)}" data-attr-value="${numVal}" style="cursor:pointer;color:var(--acu-accent);opacity:0.5;font-size:11px;margin-left:6px;" title="检定"></i>` : ''}
                  </div>`;
          } else {
            const badgeStyle = getBadgeStyle(rawStr);
            contentHtml = badgeStyle
              ? `<span class="acu-badge ${badgeStyle}">${escapeHtml(rawStr)}</span>`
              : escapeHtml(rawStr);
          }

          const rowClass = 'acu-card-row acu-cell' + (hideLabel ? ' acu-hide-label' : '');
          cardBody += `<div class="${rowClass}" data-key="${escapeHtml(tableKey)}" data-tname="${escapeHtml(tableName)}" data-row="${realRowIdx}" data-col="${cIdx}" data-val="${safeEncodeURIComponent(cell ?? '')}">
                <div class="acu-card-label"><span data-locked="${isThisFieldLocked}">${escapeHtml(headerName)}</span></div>
                <div class="acu-card-value">${contentHtml}</div>
            </div>`;
        });

        // [统一] 使用公共函数获取交互选项（默认动作 + AI生成的自定义动作）
        // [修复] 原逻辑直接覆盖默认选项，现改为追加合并
        const tableActions = getInteractOptionsForRow(tableName, headers, rowData);
        let actionsHtml = '';
        if (tableActions.length > 0) {
          const actionBtns = tableActions
            .map(
              (act, actIdx) =>
                `<button class="acu-action-item ${act.type === 'check' ? 'check-type' : ''}" data-action-idx="${actIdx}" data-row="${realRowIdx}"><i class="fa-solid ${act.icon || 'fa-play'}"></i> ${escapeHtml(act.label)}</button>`,
            )
            .join('');
          actionsHtml = `<div class="acu-card-actions">${actionBtns}</div>`;
        }

        // 构建完整卡片
        const cardHtml = `
            <div class="acu-preview-overlay acu-theme-${config.theme}" style="--acu-card-width:${config.cardWidth}px;--acu-font-size:${config.fontSize}px;">
                <div class="acu-data-card" style="width:90vw;max-width:420px;max-height:85vh;overflow-y:auto;">
                    <div class="acu-card-header">
                        <span class="acu-card-index">#${realRowIdx + 1}</span>
                    <span class="acu-cell acu-editable-title" data-key="${escapeHtml(tableKey)}" data-tname="${escapeHtml(tableName)}" data-row="${realRowIdx}" data-col="${titleColIndex}" data-val="${safeEncodeURIComponent(title)}" data-locked="${isTitleLocked}">${escapeHtml(titleDisplay)}</span>
                        <button class="acu-preview-close" style="margin-left:auto;background:none;border:none;color:var(--acu-text-sub);cursor:pointer;font-size:16px;padding:4px;"><i class="fa-solid fa-times"></i></button>
                    </div>
                    <div class="acu-card-body view-list">${cardBody}</div>
                    ${actionsHtml}
                </div>
            </div>
        `;

        $('.acu-preview-overlay').remove();
        $('body').append(cardHtml);

        // 强制样式修复
        const overlayEl = $('.acu-preview-overlay')[0];
        if (overlayEl) {
          overlayEl.style.setProperty('position', 'fixed', 'important');
          overlayEl.style.setProperty('top', '0', 'important');
          overlayEl.style.setProperty('left', '0', 'important');
          overlayEl.style.setProperty('right', '0', 'important');
          overlayEl.style.setProperty('bottom', '0', 'important');
          overlayEl.style.setProperty('width', '100vw', 'important');
          overlayEl.style.setProperty('height', '100vh', 'important');
          overlayEl.style.setProperty('display', 'flex', 'important');
          overlayEl.style.setProperty('justify-content', 'center', 'important');
          overlayEl.style.setProperty('align-items', 'center', 'important');
        }

        // 关闭事件
        const $previewOverlay = $('.acu-preview-overlay');
        setupOverlayClose($previewOverlay, 'acu-preview-overlay', () => $previewOverlay.remove());
        $previewOverlay.on('click', function (ev) {
          if ($(ev.target).closest('.acu-preview-close').length) {
            $(this).remove();
          }
        });
      });

    // === [修复] 移动端审核面板：阻止水平滑动冒泡，防止触发 ST 的 swipe regenerate ===
    (function () {
      const $doc = $(document);
      let touchStartX = 0;
      let touchStartY = 0;

      // 使用事件委托，监听整个 data-area
      $doc.on('touchstart.acuSwipeFix', '#acu-data-area', function (e) {
        if (e.originalEvent.touches.length === 1) {
          touchStartX = e.originalEvent.touches[0].clientX;
          touchStartY = e.originalEvent.touches[0].clientY;
        }
      });

      $doc.on('touchmove.acuSwipeFix', '#acu-data-area', function (e) {
        if (e.originalEvent.touches.length !== 1) return;

        const touch = e.originalEvent.touches[0];
        const deltaX = Math.abs(touch.clientX - touchStartX);
        const deltaY = Math.abs(touch.clientY - touchStartY);

        // 如果是水平滑动为主（X位移 > Y位移 * 1.5），阻止冒泡
        if (deltaX > deltaY * 1.5 && deltaX > 10) {
          e.stopPropagation();
          console.log('[DICE]ACU 阻止水平滑动冒泡，防止 ST swipe');
        }
      });
    })();
  };

  let selectedSwapSource = null;
  const toggleOrderEditMode = () => {
    const { $ } = getCore();
    isEditingOrder = !isEditingOrder;

    const $container = $('#acu-nav-bar');
    const $hint = $('#acu-order-hint');
    const $pool = $('#acu-action-pool');

    // 检查必要元素是否存在
    if (!$container.length) {
      console.error('[DICE]ACU 找不到导航栏容器');
      isEditingOrder = false;
      return;
    }

    selectedSwapSource = null;
    $('.acu-swap-selected').removeClass('acu-swap-selected');

    if (isEditingOrder) {
      // 进入编辑模式
      $container.addClass('editing-order');
      if ($pool.length) $pool.addClass('visible');

      if ($hint.length) {
        $hint
          .html(
            `
                    <div style="display:flex; justify-content:space-between; align-items:center; width:100%; flex-wrap:wrap; gap:8px;">
                        <div style="display:flex; align-items:center; gap:10px; flex:1; min-width:200px;">
                            <span><i class="fa-solid fa-layer-group"></i> 布局编辑</span>
                            <span style="font-size:11px; opacity:0.9; font-weight:normal;">拖动或点击交换位置</span>
                        </div>
                        <button id="acu-btn-finish-sort" class="acu-btn-finish-sort">>
                            <i class="fa-solid fa-check"></i> 完成保存
                        </button>
                    </div>
                `,
          )
          .addClass('visible')
          .css('display', 'flex');

        $('#acu-btn-finish-sort').hover(
          function () {
            $(this).addClass('hover');
          },
          function () {
            $(this).removeClass('hover');
          },
        );

        $('#acu-btn-finish-sort')
          .off('click')
          .on('click', function (e) {
            e.stopPropagation();
            e.preventDefault();
            toggleOrderEditMode();
          });
      }

      // 关闭数据面板
      $('#acu-data-area').removeClass('visible');

      // 设置可拖拽属性（排除特殊按钮）
      $container.find('.acu-nav-btn').not('#acu-btn-dashboard, #acu-btn-dice-nav').attr('draggable', 'true');
      $container.find('.acu-action-btn').attr('draggable', 'true');

      // 初始化拖拽
      initSortable();
    } else {
      // 退出编辑模式
      $container.removeClass('editing-order');
      if ($hint.length) $hint.removeClass('visible').hide();
      if ($pool.length) $pool.removeClass('visible');

      // 移除拖拽属性和事件
      $container.find('.acu-nav-btn, .acu-action-btn').attr('draggable', 'false');
      $('.acu-nav-btn, .acu-action-btn').off('.sort');
      $('#acu-action-pool, #acu-active-actions').off('.sort');

      // 保存表格标签顺序
      const newTableOrder = [];
      $container.find('.acu-nav-btn[data-table]').each(function () {
        const tableName = $(this).data('table');
        if (tableName) {
          newTableOrder.push(tableName);
        }
      });
      if (newTableOrder.length > 0) {
        saveTableOrder(newTableOrder);
      }

      // 保存功能按钮顺序
      const newActionOrder = [];
      $('#acu-active-actions .acu-action-btn').each(function () {
        const btnId = $(this).attr('id');
        if (btnId) {
          newActionOrder.push(btnId);
        }
      });

      // 保护设置按钮
      if (!newActionOrder.includes('acu-btn-settings')) {
        newActionOrder.push('acu-btn-settings');
      }

      Store.set(STORAGE_KEY_ACTION_ORDER, newActionOrder);

      // 重绘界面
      renderInterface();
    }
  };

  const initSortable = () => {
    const { $ } = getCore();
    let $dragSrcEl = null;

    // 清理旧事件
    $('.acu-nav-btn, .acu-action-btn, #acu-action-pool, #acu-active-actions').off('.sort');

    // --- 1. 按钮本身的拖拽逻辑 (交换顺序) ---
    const $items = $('.acu-nav-btn, .acu-action-btn');

    $items.on('dragstart.sort', function (e) {
      $dragSrcEl = $(this);
      $(this).css('opacity', '0.4');
      e.originalEvent.dataTransfer.effectAllowed = 'move';
    });

    $items.on('dragend.sort', function (e) {
      $(this).css('opacity', '1');
      $('.acu-drag-over').removeClass('acu-drag-over');
      $('.acu-actions-group, .acu-unused-pool').removeClass('dragging-over');
    });

    $items.on('dragover.sort', function (e) {
      e.preventDefault();
      return false;
    });
    $items.on('dragenter.sort', function () {
      if ($dragSrcEl && this !== $dragSrcEl[0]) $(this).addClass('acu-drag-over');
    });
    $items.on('dragleave.sort', function () {
      $(this).removeClass('acu-drag-over');
    });

    $items.on('drop.sort', function (e) {
      e.stopPropagation();
      $(this).removeClass('acu-drag-over');
      if (!$dragSrcEl || $dragSrcEl[0] === this) return false;

      const isSrcAction = $dragSrcEl.hasClass('acu-action-btn');
      const isTgtAction = $(this).hasClass('acu-action-btn');
      if (isSrcAction !== isTgtAction) return false;

      if (isSrcAction) {
        const targetPoolId = $(this).parent().attr('id');
        const srcPoolId = $dragSrcEl.parent().attr('id');

        if (srcPoolId === 'acu-action-pool' && targetPoolId === 'acu-active-actions') {
          if ($('#acu-active-actions').children().length >= MAX_ACTION_BUTTONS) {
            if (window.toastr) window.toastr.warning('活动栏最多6个，请先拖走一个');
            return false;
          }
        }

        if (srcPoolId !== targetPoolId) {
          $(this).before($dragSrcEl);
          return false;
        }
      }

      const $temp = $('<span>').hide();
      $dragSrcEl.before($temp);
      $(this).before($dragSrcEl);
      $temp.replaceWith($(this));
      return false;
    });

    // --- 2. 容器的拖拽逻辑 (上架/下架) ---
    const $containers = $('#acu-action-pool, #acu-active-actions');

    $containers.on('dragover.sort', function (e) {
      e.preventDefault();
      if ($dragSrcEl && $dragSrcEl.hasClass('acu-action-btn')) {
        $(this).addClass('dragging-over');
      }
    });

    $containers.on('dragleave.sort', function (e) {
      $(this).removeClass('dragging-over');
    });

    $containers.on('drop.sort', function (e) {
      e.stopPropagation();
      $(this).removeClass('dragging-over');

      if ($dragSrcEl && $dragSrcEl.hasClass('acu-action-btn')) {
        const currentParentId = $dragSrcEl.parent().attr('id');
        const targetId = $(this).attr('id');
        const btnId = $dragSrcEl.attr('id');

        if (currentParentId !== targetId) {
          if (targetId === 'acu-action-pool') {
            if (btnId === 'acu-btn-settings') {
              if (window.toastr) window.toastr.warning('设置按钮是核心组件，无法移除');
              return false;
            }
            $(this).append($dragSrcEl);
          } else if (targetId === 'acu-active-actions') {
            if ($(this).children().length >= 6) {
              if (window.toastr) window.toastr.warning('活动栏已满6个，无法继续添加');
              return false;
            }
            $(this).append($dragSrcEl);
          }
        }
      }
      return false;
    });

    // --- 【新增】3. 容器点击事件 - 支持点动移动功能按钮 ---
    $containers.on('click.sort', function (e) {
      e.stopPropagation();

      // 如果点击的是按钮本身，不处理
      if ($(e.target).closest('.acu-action-btn, .acu-nav-btn').length > 0) return;

      // 如果没有选中任何按钮，不处理
      if (!selectedSwapSource) return;

      const $src = $(selectedSwapSource);

      // 只有功能按钮才能跨池移动
      if (!$src.hasClass('acu-action-btn')) {
        if (window.toastr) window.toastr.warning('表格标签不能移入功能池');
        $src.removeClass('acu-swap-selected');
        selectedSwapSource = null;
        return;
      }

      const srcPoolId = $src.parent().attr('id');
      const targetId = $(this).attr('id');
      const btnId = $src.attr('id');

      // 同一个容器内点击，取消选中
      if (srcPoolId === targetId) {
        $src.removeClass('acu-swap-selected');
        selectedSwapSource = null;
        return;
      }

      // 活动栏 → 备选池
      if (targetId === 'acu-action-pool') {
        if (btnId === 'acu-btn-settings') {
          if (window.toastr) window.toastr.warning('设置按钮是核心组件，无法移除');
          $src.removeClass('acu-swap-selected');
          selectedSwapSource = null;
          return;
        }
        $(this).append($src);
        $src.removeClass('acu-swap-selected');
        selectedSwapSource = null;
      }
      // 备选池 → 活动栏
      else if (targetId === 'acu-active-actions') {
        if ($('#acu-active-actions').children().length >= MAX_ACTION_BUTTONS) {
          if (window.toastr) window.toastr.warning('活动栏已满6个，请先移走一个');
          return;
        }
        $(this).append($src);
        $src.removeClass('acu-swap-selected');
        selectedSwapSource = null;
      }
    });

    // --- 4. 点击互换模式 (Click-to-Swap) - 按钮之间 ---
    $items.on('click.sort', function (e) {
      e.preventDefault();
      e.stopPropagation();

      if (selectedSwapSource && selectedSwapSource === this) {
        $(this).removeClass('acu-swap-selected');
        selectedSwapSource = null;
        return;
      }

      if (!selectedSwapSource) {
        selectedSwapSource = this;
        $(this).addClass('acu-swap-selected');
        return;
      }

      const $src = $(selectedSwapSource);
      const $tgt = $(this);

      const isSrcAction = $src.hasClass('acu-action-btn');
      const isTgtAction = $tgt.hasClass('acu-action-btn');
      if (isSrcAction !== isTgtAction) {
        if (window.toastr) window.toastr.warning('无法在表格标签和功能按钮之间交换');
        $src.removeClass('acu-swap-selected');
        selectedSwapSource = this;
        $(this).addClass('acu-swap-selected');
        return;
      }

      const srcPoolId = $src.parent().attr('id');
      const tgtPoolId = $tgt.parent().attr('id');

      if (isSrcAction && srcPoolId === 'acu-action-pool' && tgtPoolId === 'acu-active-actions') {
        if ($('#acu-active-actions').children().length >= MAX_ACTION_BUTTONS) {
          if (window.toastr) window.toastr.warning('活动栏最多6个，请先移走一个');
          return;
        }
      }

      if (srcPoolId !== tgtPoolId) {
        $tgt.before($src);
      } else {
        const $temp = $('<span>').hide();
        $src.before($temp);
        $tgt.before($src);
        $temp.replaceWith($tgt);
      }

      $src.removeClass('acu-swap-selected');
      selectedSwapSource = null;
    });
  };

  const showCellMenu = (e, cell) => {
    const { $ } = getCore();
    $('.acu-cell-menu, .acu-menu-backdrop').remove();
    const backdrop = $('<div class="acu-menu-backdrop"></div>');
    $('body').append(backdrop);

    const $cell = $(cell); // 保存单元格引用用于直接操作 data-locked
    const rowIdx = parseInt($cell.data('row'), 10);
    const colIdx = parseInt($cell.data('col'), 10);
    if (isNaN(rowIdx) || isNaN(colIdx)) {
      console.warn('[DICE]ACU 无效的行/列索引');
      backdrop.remove();
      return;
    }
    const tableKey = $cell.data('key');
    // v19.x 可能没有 tname，尝试获取
    const tableName = $cell.data('tname') || $cell.closest('.acu-data-card').find('.acu-editable-title').text();
    const content = safeDecodeURIComponent($cell.data('val'));
    const config = getConfig();

    // 保存卡片引用用于整行操作
    const $card = $cell.closest('.acu-data-card');

    // 唯一标识 ID
    const cellId = `${tableKey}-${rowIdx}-${colIdx}`;
    if (!window.acuModifiedSet) window.acuModifiedSet = new Set();

    // 状态检查
    const isModified = window.acuModifiedSet.has(cellId);

    // 计算锁定状态
    const headers = cachedRawData?.[tableKey]?.content?.[0] || [];
    const rowData = cachedRawData?.[tableKey]?.content?.[rowIdx + 1] || [];
    const lockRowKey = getRowKey(tableName, rowData, headers);
    const currentHeader = headers[colIdx] || '';

    let isFieldLocked = false;
    let hasAnyLockInRow = false;
    let rowIndex = -1;
    let sheetKey = '';

    const api = getDbLockAPI();
    if (api && lockRowKey) {
      sheetKey = getSheetKeyByTableName(tableName);
      if (sheetKey) {
        rowIndex = findRowIndexByPrimaryKey(sheetKey, tableName, lockRowKey);
        if (rowIndex !== null && rowIndex !== -1) {
          const lockState = api.getTableLockState(sheetKey);
          if (lockState) {
            // 检查行锁定
            hasAnyLockInRow = lockState.rows?.includes(rowIndex) ?? false;
            // 检查单元格锁定
            // [修复] colIdx 是包含行号列的索引，神-数据库的 colIndex 不包含行号列，需要 -1
            const cellKey = `${rowIndex}:${colIdx - 1}`;
            isFieldLocked = lockState.cells?.includes(cellKey) ?? false;
          }
        } else {
          console.warn('[DICE] 找不到表格的 rowIndex');
          isFieldLocked = false;
          hasAnyLockInRow = false;
        }
      } else {
        console.warn('[DICE] 找不到表格的 sheetKey');
        isFieldLocked = false;
        hasAnyLockInRow = false;
      }
    } else {
      if (!api) console.warn('[DICE] 神-数据库 API 不可用');
      isFieldLocked = false;
      hasAnyLockInRow = false;
    }

    // 构建锁定菜单项
    let lockMenuHtml = '';
    if (lockRowKey) {
      lockMenuHtml = '<div style="border-top:1px dashed var(--acu-border); margin:4px 0;"></div>';

      // 单元格锁定选项：当前单元格被锁定时显示"解锁"，否则显示"锁定"
      if (isFieldLocked) {
        lockMenuHtml +=
          '<div class="acu-cell-menu-item" id="act-unlock-field"><i class="fa-solid fa-unlock"></i> 解锁此单元格</div>';
      } else {
        lockMenuHtml +=
          '<div class="acu-cell-menu-item" id="act-lock-field"><i class="fa-solid fa-lock"></i> 锁定此单元格</div>';
      }

      // 整行锁定选项：行中有任意锁定时显示"解锁整行"，否则显示"锁定整行"
      if (hasAnyLockInRow) {
        lockMenuHtml +=
          '<div class="acu-cell-menu-item" id="act-unlock-row"><i class="fa-solid fa-unlock"></i> 解锁整行</div>';
      } else {
        lockMenuHtml +=
          '<div class="acu-cell-menu-item" id="act-lock-row"><i class="fa-solid fa-lock"></i> 锁定整行</div>';
      }
    }

    const menu = $(`
            <div class="acu-cell-menu acu-theme-${config.theme}">
                <div class="acu-cell-menu-item" id="act-edit"><i class="fa-solid fa-pen"></i> 编辑内容</div>
                <div class="acu-cell-menu-item" id="act-edit-card"><i class="fa-solid fa-edit"></i> 整体编辑</div>
                <div class="acu-cell-menu-item" id="act-insert"><i class="fa-solid fa-plus"></i> 在下方插入新行</div>
                <div class="acu-cell-menu-item" id="act-copy"><i class="fa-solid fa-copy"></i> 复制内容</div>
                <div class="acu-cell-menu-item" id="act-favorite"><i class="fa-solid fa-star"></i> 收藏此行</div>
                ${lockMenuHtml}
                ${isModified ? '<div class="acu-cell-menu-item" id="act-undo"><i class="fa-solid fa-undo"></i> 撤销本次修改</div>' : ''}
                <div class="acu-cell-menu-item" id="act-delete"><i class="fa-solid fa-trash"></i> 删除整行</div>
                <div class="acu-cell-menu-item" id="act-close"><i class="fa-solid fa-times"></i> 关闭菜单</div>
            </div>
        `);
    $('body').append(menu);

    // 稳健的坐标计算
    const winWidth = $(window).width();
    const winHeight = $(window).height();
    const mWidth = menu.outerWidth() || 150;
    const mHeight = menu.outerHeight() || 150;
    let clientX = e.clientX;
    let clientY = e.clientY;
    if (!clientX && e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length) {
      clientX = e.originalEvent.touches[0].clientX;
      clientY = e.originalEvent.touches[0].clientY;
    } else if (!clientX && e.changedTouches && e.changedTouches.length) {
      clientX = e.changedTouches[0].clientX;
      clientY = e.changedTouches[0].clientY;
    }

    // 兜底坐标
    if (clientX === undefined) clientX = winWidth / 2;
    if (clientY === undefined) clientY = winHeight / 2;

    let left = clientX + 5;
    let top = clientY + 5;
    if (left + mWidth > winWidth) left = clientX - mWidth - 5;
    if (top + mHeight > winHeight) top = clientY - mHeight - 5;

    // 防止负坐标
    if (left < 5) left = 5;
    if (top < 5) top = 5;

    menu.css({ top: top + 'px', left: left + 'px' });

    const closeAll = () => {
      menu.remove();
      backdrop.remove();
    };
    backdrop.on('click', closeAll);
    menu.find('#act-close').click(closeAll);
    // 锁定字段
    // [修复] colIdx 是包含行号列的索引，神-数据库的 colIndex 不包含行号列，需要 -1
    const dbColIndex = colIdx - 1;
    menu.find('#act-lock-field').click(e => {
      e.stopPropagation();
      if (lockRowKey && currentHeader) {
        if (api && sheetKey && rowIndex !== null && rowIndex !== -1 && dbColIndex >= 0) {
          api.lockTableCell(sheetKey, rowIndex, dbColIndex, true);
          // [优化] 直接修改 data-locked 属性，无需重新渲染
          // [修复] 同时更新 $cell 自身和内部所有带 data-locked 的元素
          if ($cell.is('[data-locked]')) {
            $cell.attr('data-locked', 'true');
          }
          $cell.find('[data-locked]').attr('data-locked', 'true');
        } else {
          console.warn('[DICE] 神-数据库API不可用或索引转换失败，无法锁定单元格');
        }
      }
      closeAll();
    });

    // 解锁字段
    menu.find('#act-unlock-field').click(e => {
      e.stopPropagation();
      if (lockRowKey && currentHeader) {
        if (api && sheetKey && rowIndex !== null && rowIndex !== -1 && dbColIndex >= 0) {
          api.lockTableCell(sheetKey, rowIndex, dbColIndex, false);
          // [优化] 直接修改 data-locked 属性，无需重新渲染
          // [修复] 同时更新 $cell 自身和内部所有带 data-locked 的元素
          if ($cell.is('[data-locked]')) {
            $cell.attr('data-locked', 'false');
          }
          $cell.find('[data-locked]').attr('data-locked', 'false');
        } else {
          console.warn('[DICE] 神-数据库API不可用或索引转换失败，无法解锁单元格');
        }
      }
      closeAll();
    });

    // 锁定整行
    menu.find('#act-lock-row').click(e => {
      e.stopPropagation();
      if (lockRowKey) {
        if (api && sheetKey && rowIndex !== null && rowIndex !== -1) {
          api.lockTableRow(sheetKey, rowIndex, true);
          // [优化] 直接修改卡片内所有可锁定元素的 data-locked 属性
          $card.find('[data-locked]').attr('data-locked', 'true');
        } else {
          console.warn('[DICE] 神-数据库API不可用或索引转换失败，无法锁定整行');
        }
      }
      closeAll();
    });

    // 解锁整行
    menu.find('#act-unlock-row').click(e => {
      e.stopPropagation();
      if (lockRowKey) {
        if (api && sheetKey && rowIndex !== null && rowIndex !== -1) {
          // [改进] 解锁整行时，同时清除该行的所有单元格锁定
          const currentLockState = api.getTableLockState(sheetKey);
          if (currentLockState && currentLockState.cells) {
            // 找出该行的所有单元格锁定并逐一解锁
            const rowPrefix = `${rowIndex}:`;
            currentLockState.cells.forEach((cellKey: string) => {
              if (cellKey.startsWith(rowPrefix)) {
                const cellColIndex = parseInt(cellKey.split(':')[1], 10);
                if (!isNaN(cellColIndex)) {
                  api.lockTableCell(sheetKey, rowIndex, cellColIndex, false);
                }
              }
            });
          }
          // 解锁整行
          api.lockTableRow(sheetKey, rowIndex, false);
          // [优化] 直接修改卡片内所有可锁定元素的 data-locked 属性
          $card.find('[data-locked]').attr('data-locked', 'false');
        } else {
          console.warn('[DICE] 神-数据库API不可用或索引转换失败，无法解锁整行');
        }
      }
      closeAll();
    });

    // 复制功能 (v7.9 融合增强版：优先酒馆接口，兼容性最佳)
    menu.find('#act-copy').click(async e => {
      e.stopPropagation();

      // 【第一优先级】尝试使用酒馆 v7.7 的原生接口 (移动端/PWA 完美兼容)
      // 来源: slash_command.txt /clipboard-set
      if (window.TavernHelper && window.TavernHelper.triggerSlash) {
        try {
          // 转义特殊字符防止命令崩溃
          const safeContent = content
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\{/g, '\\{')
            .replace(/\}/g, '\\}');
          await window.TavernHelper.triggerSlash(`/clipboard-set "${safeContent}"`);
          closeAll();
          return; // 如果成功，直接结束，不走后面的浏览器逻辑
        } catch (err) {
          console.warn('[DICE]ACU 酒馆接口复制失败，尝试浏览器原生方法', err);
        }
      }

      // 【第二优先级】浏览器原生逻辑 (v7.8 的兜底方案)
      const doCopy = text => {
        // 方案A: 现代 API (仅在 HTTPS 或 localhost 下有效)
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard
            .writeText(text)
            .then(() => {})
            .catch(() => {
              fallbackCopy(text);
            });
        } else {
          // 方案B: 传统 execCommand (兼容 HTTP)
          fallbackCopy(text);
        }
      };

      const fallbackCopy = text => {
        try {
          const textArea = document.createElement('textarea');
          textArea.value = text;

          // 移动端防抖动处理
          textArea.style.position = 'fixed';
          textArea.style.left = '-9999px';
          textArea.style.top = '0';
          textArea.setAttribute('readonly', '');

          document.body.appendChild(textArea);

          textArea.select();
          textArea.setSelectionRange(0, 99999); // 针对 iOS Safari

          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);

          if (successful) {
          } else {
            throw new Error('execCommand failed');
          }
        } catch (err) {
          console.error('[DICE]ACU 复制失败:', err);
          prompt('复制失败，请长按下方文本手动复制:', text);
        }
      };

      doCopy(content);
      closeAll();
    });

    // 收藏此行功能
    menu.find('#act-favorite').click(async () => {
      try {
        // 获取当前行的完整数据
        const tableData = cachedRawData?.[tableKey];
        if (!tableData || !tableData.content) {
          toastr.error('无法获取表格数据');
          closeAll();
          return;
        }

        // 获取表头（去掉首列null）
        const fullHeader = tableData.content[0] || [];
        const header: string[] = fullHeader.slice(1).map((h: any) => String(h || ''));

        // 获取行数据（去掉首列null）
        const fullRowData = tableData.content[rowIdx + 1] || [];
        const rowDataValues: (string | number)[] = fullRowData.slice(1);

        if (header.length === 0 || rowDataValues.length === 0) {
          toastr.error('行数据为空');
          closeAll();
          return;
        }

        // 弹出标签输入框
        const tagInput = await showTagInputModal();
        if (tagInput === null) {
          // 用户取消
          closeAll();
          return;
        }
        const tags: string[] = tagInput
          ? tagInput
              .split(',')
              .map(t => t.trim())
              .filter(t => t.length > 0)
          : [];

        // 添加到收藏夹
        const result = await FavoritesManager.addFavorite(tableKey, tableName, header, rowDataValues, tags);

        if (result) {
          toastr.success('收藏成功');
        } else {
          toastr.error('收藏失败');
        }
      } catch (e) {
        console.error('[DICE]收藏失败:', e);
        toastr.error('收藏失败: ' + (e instanceof Error ? e.message : String(e)));
      }
      closeAll();
    });

    // 撤销功能
    menu.find('#act-undo').click(() => {
      const snapshot = loadSnapshot();
      let originalValue = null;
      if (snapshot && snapshot[tableKey]?.content[rowIdx + 1]) {
        originalValue = snapshot[tableKey].content[rowIdx + 1][colIdx];
      }

      if (originalValue !== null) {
        if (!cachedRawData) cachedRawData = getTableData();
        if (cachedRawData && cachedRawData[tableKey]?.content[rowIdx + 1]) {
          cachedRawData[tableKey].content[rowIdx + 1][colIdx] = originalValue;
        }

        const $cell = $(cell);
        $cell.attr('data-val', safeEncodeURIComponent(originalValue));
        $cell.data('val', safeEncodeURIComponent(originalValue));

        // [核心修复1] 正确查找显示目标，防止覆盖 Label
        let $displayTarget = $cell;
        if ($cell.find('.acu-card-value').length > 0) {
          $displayTarget = $cell.find('.acu-card-value');
        } else if ($cell.hasClass('acu-grid-item')) {
          $displayTarget = $cell.find('.acu-grid-value');
        } else if ($cell.hasClass('acu-full-item')) {
          $displayTarget = $cell.find('.acu-full-value');
        }

        const badgeStyle = getBadgeStyle(originalValue);
        if (badgeStyle && !$cell.hasClass('acu-editable-title')) {
          $displayTarget.html(`<span class="acu-badge ${badgeStyle}">${originalValue}</span>`);
        } else {
          $displayTarget.text(originalValue);
        }

        // [修复] 修正类名，确保撤销后高亮立即消失
        $displayTarget.removeClass('acu-highlight-manual acu-highlight-diff');
        if ($cell.hasClass('acu-editable-title')) $cell.removeClass('acu-highlight-manual acu-highlight-diff');

        window.acuModifiedSet.delete(cellId);

        if (window.acuModifiedSet.size === 0) {
          hasUnsavedChanges = false;
          updateSaveButtonState();
        }
      } else {
        if (window.toastr) window.toastr.warning('无法找到原始数据，撤销失败');
      }
      closeAll();
    });

    // [优化] 删除逻辑 (统一即时删除)
    menu.find('#act-delete').click(async () => {
      // [修复] 在任何DOM操作之前保存滚动位置
      const $panelContent = $('.acu-panel-content');
      const savedScrollTop = $panelContent.length ? $panelContent.scrollTop() : 0;
      const savedScrollLeft = $panelContent.length ? $panelContent.scrollLeft() : 0;

      // 关闭右键菜单
      closeAll();

      // [Bug 1 修复] 只关闭preview card，保留地图overlay
      const $mapOverlay = $('.acu-map-overlay');
      const isFromMap = $mapOverlay.length > 0;

      // 只移除preview card overlay
      $('.acu-preview-overlay').remove();

      // --- 视觉优化：前端直接移除 DOM ---
      if (isFromMap) {
        // 地图中的元素chip有 data-table-key 和 data-row-index 属性
        $mapOverlay.find(`.acu-map-element-chip[data-table-key="${tableKey}"][data-row-index="${rowIdx}"]`).remove();
        $mapOverlay.find(`.acu-map-thumbnail[data-table-key="${tableKey}"][data-row-index="${rowIdx}"]`).remove();
      }

      // 主面板中的卡片动画移除
      const $card = $(cell).closest('.acu-data-card');
      if ($card.length && !isFromMap) {
        $card.css('transition', 'all 0.2s ease').css('opacity', '0').css('transform', 'scale(0.9)');
        setTimeout(() => $card.slideUp(200, () => $card.remove()), 200);
      }

      // --- 数据操作 ---
      if (!cachedRawData) cachedRawData = getTableData() || loadSnapshot();
      if (cachedRawData && cachedRawData[tableKey]?.content) {
        cachedRawData[tableKey].content.splice(rowIdx + 1, 1);

        try {
          // 保存到数据库
          await saveDataOnly(cachedRawData, [tableKey]);

          // [Bug 3 修复] 立即同步更新diffMap，避免闪烁
          currentDiffMap = generateDiffMap(cachedRawData);

          // 刷新界面
          renderInterface();

          // [修复] 如果地图overlay存在，刷新地图数据（重建viewModel）
          if (isFromMap) {
            const refreshMapData = $mapOverlay.data('refreshMapData');
            if (typeof refreshMapData === 'function') {
              await refreshMapData();
            }
          }

          // [修复] 恢复滚动位置（在renderInterface防抖完成后）
          setTimeout(() => {
            const $newContent = $('.acu-panel-content');
            if ($newContent.length && (savedScrollTop > 0 || savedScrollLeft > 0)) {
              $newContent.scrollTop(savedScrollTop);
              $newContent.scrollLeft(savedScrollLeft);
            }
          }, 60);
        } catch (e) {
          console.error('[DICE]ACU 删除保存失败:', e);
          toastr.error('删除保存失败: ' + (e instanceof Error ? e.message : String(e)));
          renderInterface();

          // [修复] 即使失败也恢复滚动位置
          setTimeout(() => {
            const $newContent = $('.acu-panel-content');
            if ($newContent.length && (savedScrollTop > 0 || savedScrollLeft > 0)) {
              $newContent.scrollTop(savedScrollTop);
              $newContent.scrollLeft(savedScrollLeft);
            }
          }, 60);
        }
      }
    });

    // [新增] 插入新行功能 (修复版：增加立即重绘指令)
    menu.find('#act-insert').click(async () => {
      closeAll();
      // 1. 获取最新数据 (优先用缓存，没有则重新获取)
      if (!cachedRawData) cachedRawData = getTableData();
      if (!cachedRawData) cachedRawData = loadSnapshot();

      if (cachedRawData && cachedRawData[tableKey]?.content) {
        const sheet = cachedRawData[tableKey];
        // 2. 构造空行 (长度等于表头)
        const colCount = sheet.content[0] ? sheet.content[0].length : 2;
        const newRow = new Array(colCount).fill('');
        // 智能填充序号 (简单的自增逻辑)
        if (colCount > 0) newRow[0] = String(sheet.content.length);

        // 3. 插入数据 (rowIdx是当前行下标，+2 表示插入到当前行对应的 content 索引之后)
        sheet.content.splice(rowIdx + 2, 0, newRow);

        // 4. 保存
        // 先保存数据
        await saveDataToDatabase(cachedRawData, false, true);

        // 【核心修复】保存后立即重绘界面，否则新行不会显示！
        renderInterface();

        // 额外优化：如果是竖向模式，尝试滚动一下以确保新行可见
        setTimeout(() => {
          const $panel = $('.acu-panel-content');
          // 只有当不在底部时才微调，防止乱跳
          if ($panel.length && $panel[0].scrollHeight > $panel.height()) {
            $panel.scrollTop($panel.scrollTop() + 10);
          }
        }, 100);
      }
    });

    // [新增] 整体编辑事件
    menu.find('#act-edit-card').click(() => {
      closeAll();
      const rawData = cachedRawData || getTableData();
      if (rawData && rawData[tableKey]) {
        const headers = rawData[tableKey].content[0];
        const row = rawData[tableKey].content[rowIdx + 1];
        if (row) {
          showCardEditModal(row, headers, tableName, rowIdx, tableKey);
        }
      }
    });

    menu.find('#act-edit').click(() => {
      closeAll();
      showEditDialog(content, async newVal => {
        // 1. 写入内存数据
        if (!cachedRawData) cachedRawData = getTableData() || loadSnapshot();

        if (cachedRawData && cachedRawData[tableKey]?.content[rowIdx + 1]) {
          cachedRawData[tableKey].content[rowIdx + 1][colIdx] = newVal;
        } else {
          alert('数据结构异常，无法写入缓存，请刷新页面');
          return;
        }

        // 2. 准备 UI 元素
        const $cell = $(cell);
        $cell.attr('data-val', safeEncodeURIComponent(newVal)).data('val', safeEncodeURIComponent(newVal));

        let $displayTarget = $cell;
        if ($cell.find('.acu-card-value').length) $displayTarget = $cell.find('.acu-card-value');
        else if ($cell.hasClass('acu-grid-item')) $displayTarget = $cell.find('.acu-grid-value');
        else if ($cell.hasClass('acu-editable-title')) $displayTarget = $cell;

        // 3. 更新 UI 文字/样式 (通用)
        const badgeStyle = getBadgeStyle(newVal);
        if (badgeStyle && !$cell.hasClass('acu-editable-title')) {
          $displayTarget.html(`<span class="acu-badge ${badgeStyle}">${escapeHtml(newVal)}</span>`);
        } else {
          $displayTarget.text(newVal);
        }

        // 4. 统一使用即时保存 + 单行快照更新（保留其他行的AI变更高亮）
        // 移除高亮 (因为马上就保存了)
        $displayTarget.removeClass('acu-highlight-manual acu-highlight-diff');
        if ($cell.hasClass('acu-editable-title')) $cell.removeClass('acu-highlight-manual acu-highlight-diff');

        // 使用 saveRowInstantly 执行即时保存 + 单行快照更新
        try {
          const currentRow = cachedRawData[tableKey].content[rowIdx + 1];
          await saveRowInstantly(tableKey, rowIdx, [...currentRow]);
        } catch (e) {
          console.error('[DICE]ACU 单元格保存失败:', e);
          toastr.error('保存失败: ' + (e instanceof Error ? e.message : String(e)));
        }
      });
    });
  };

  const showEditDialog = (content, onSave) => {
    const { $ } = getCore();
    const config = getConfig();

    const dialog = $(`
            <div class="acu-edit-overlay">
                <!-- 2. [修改] 在这里加上 acu-theme-${config.theme} -->
                <div class="acu-edit-dialog acu-theme-${config.theme}">
                    <div class="acu-edit-title">编辑单元格内容</div>
                    <textarea class="acu-edit-textarea" spellcheck="false">${escapeHtml(content)}</textarea>
                    <div class="acu-dialog-btns">
                        <button class="acu-dialog-btn" id="dlg-cancel"><i class="fa-solid fa-times"></i> 取消</button>
                        <button class="acu-dialog-btn acu-btn-confirm" id="dlg-save"><i class="fa-solid fa-check"></i> 保存</button>
                    </div>
                </div>
            </div>
        `);
    $('body').append(dialog);

    const adjustHeight = el => {
      el.style.height = 'auto';
      el.style.height = el.scrollHeight + 2 + 'px';
    };
    dialog.find('textarea').on('input', function () {
      adjustHeight(this);
    });

    dialog.find('#dlg-cancel').click(() => dialog.remove());
    // 点击遮罩层也可以关闭
    setupOverlayClose(dialog, 'acu-edit-overlay', () => dialog.remove());

    dialog.find('#dlg-save').click(() => {
      onSave(dialog.find('textarea').val());
      dialog.remove();
    });
  };

  // ==========================================
  // [优化后] 新的初始化入口 (Observer 只创建一次)
  // ==========================================
  // 检测可视化表格脚本冲突
  const detectVisualizerConflict = () => {
    const { $ } = getCore();
    if (!$) return false;

    // 检测方法1: 检查是否存在可视化表格创建的 DOM 元素（最可靠）
    // 可视化表格会创建 .acu-wrapper，但骰子系统也会创建，所以需要进一步判断
    const $wrapper = $('.acu-wrapper');
    if ($wrapper.length > 0) {
      // 检查 wrapper 内部是否有可视化表格特有的元素
      // 可视化表格 v12.60 使用 'acu_visualizer_ui_v20_pagination' 作为 SCRIPT_ID
      // 检查是否有可视化表格特有的类名或结构
      const hasVisualizerNav = $wrapper.find('.acu-nav-container').length > 0;
      const hasVisualizerDataDisplay = $wrapper.find('.acu-data-display').length > 0;

      // 如果 wrapper 存在但没有骰子系统的特征元素，可能是可视化表格
      // 或者检查 wrapper 的 data 属性或 id
      const wrapperId = $wrapper.attr('id') || '';
      const wrapperClass = $wrapper.attr('class') || '';

      // 如果检测到可视化表格特有的结构，判定为冲突
      if (hasVisualizerNav && hasVisualizerDataDisplay) {
        // 进一步检查：是否有骰子系统的特征（如骰子按钮等）
        const hasDiceFeatures = $wrapper.find('[id*="dice"], [class*="dice"]').length > 0;
        if (!hasDiceFeatures) {
          return true; // 只有可视化表格的特征，没有骰子系统特征
        }
      }
    }

    // 检测方法2: 检查脚本内容中是否有可视化表格的标识
    try {
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const content = script.textContent || script.innerHTML || '';
        // 检查可视化表格 v12.60 的特定标识
        if (content.includes('acu_visualizer_ui_v20_pagination') && content.includes('acu_ui_config_v18')) {
          return true;
        }
      }
    } catch (e) {
      // 脚本检查失败，忽略
    }

    // 检测方法3: 检查 localStorage（作为辅助判断）
    // 只有当 localStorage 中有可视化表格配置，且没有骰子系统配置时，才判定为冲突
    try {
      const visualizerConfig = localStorage.getItem('acu_ui_config_v18');
      const diceConfig = localStorage.getItem('acu_ui_config_v19');

      // 如果只有可视化表格的配置，且 DOM 中没有骰子系统的元素，判定为冲突
      if (visualizerConfig && !diceConfig) {
        // 再次检查 DOM，确保没有骰子系统的元素
        const hasDiceInDOM = $('[id*="dice"], [class*="dice"]').length > 0;
        if (!hasDiceInDOM) {
          return true;
        }
      }
    } catch (e) {
      // localStorage 访问失败，忽略
    }

    return false;
  };

  // 显示冲突错误对话框
  const showConflictDialog = () => {
    const { $ } = getCore();
    if (!$) return;

    // 移除可能存在的旧对话框
    $('.dice-conflict-dialog-overlay').remove();

    const dialogHtml = `
      <div class="dice-conflict-dialog-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(4px);
        z-index: 31200;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
      ">
        <div class="dice-conflict-dialog" style="
          background: #fff;
          border-radius: 16px;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
          max-width: 500px;
          width: 100%;
          padding: 30px;
          box-sizing: border-box;
          animation: diceDialogPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        ">
          <div style="
            text-align: center;
            margin-bottom: 20px;
          ">
            <div style="
              font-size: 48px;
              color: #e74c3c;
              margin-bottom: 15px;
            ">⚠️</div>
            <h2 style="
              font-size: 24px;
              font-weight: bold;
              color: #333;
              margin: 0 0 10px 0;
            ">脚本冲突检测</h2>
            <p style="
              font-size: 16px;
              color: #666;
              line-height: 1.6;
              margin: 0;
            ">检测到"可视化表格"脚本正在运行</p>
          </div>
          <div style="
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
          ">
            <p style="
              font-size: 14px;
              color: #856404;
              line-height: 1.6;
              margin: 0;
            ">
              <strong>提示：</strong>骰子系统与可视化表格脚本功能冲突，不能同时启用。<br>
              请在酒馆助手的脚本管理中，<strong>关闭其中一个脚本后刷新酒馆页面</strong>。
            </p>
          </div>
          <div style="
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
          ">
            <button id="dice-conflict-close" style="
              background: #6c757d;
              color: #fff;
              border: none;
              border-radius: 8px;
              padding: 12px 24px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              transition: all 0.2s;
              min-width: 120px;
            ">我知道了</button>
          </div>
        </div>
      </div>
      <style>
        @keyframes diceDialogPop {
          from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
          }
          to {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }
        .dice-conflict-dialog button:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .dice-conflict-dialog button:active {
          transform: translateY(0);
        }
        @media (max-width: 768px) {
          .dice-conflict-dialog {
            padding: 20px !important;
            margin: 10px !important;
            max-width: calc(100% - 20px) !important;
          }
          .dice-conflict-dialog h2 {
            font-size: 20px !important;
          }
          .dice-conflict-dialog p {
            font-size: 14px !important;
          }
        }
      </style>
    `;

    $('body').append(dialogHtml);

    // 绑定关闭事件
    $('#dice-conflict-close').on('click', function () {
      $('.dice-conflict-dialog-overlay').fadeOut(200, function () {
        $(this).remove();
      });
    });

    // 点击背景关闭
    const $conflictOverlay = $('.dice-conflict-dialog-overlay');
    setupOverlayClose($conflictOverlay, 'dice-conflict-dialog-overlay', () => {
      $conflictOverlay.fadeOut(200, function () {
        $(this).remove();
      });
    });

    // 使用 toastr 作为补充提示（如果可用）
    if (window.toastr) {
      window.toastr.error('脚本冲突：骰子系统与可视化表格不能同时启用', '冲突检测', {
        timeOut: 0,
        extendedTimeOut: 0,
        closeButton: true,
        preventDuplicates: true,
      });
    }
  };

  const init = () => {
    if (isInitialized) return;

    // 清理旧的LockManager锁定数据 (已迁移到神-数据库API)
    (() => {
      const prefix = 'acu_locked_fields_v2_';
      const keysToRemove: string[] = [];

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(prefix)) {
          keysToRemove.push(key);
        }
      }

      keysToRemove.forEach(key => localStorage.removeItem(key));

      if (keysToRemove.length > 0) {
        console.info(`[DICE] 已清理 ${keysToRemove.length} 个旧锁定数据键`);
      }
    })();

    console.log('[DICE]开始初始化骰子系统...');

    // 恢复 ConsoleCaptureManager 状态（从 localStorage）
    try {
      ConsoleCaptureManager.restore();
      console.info('[DICE]ConsoleCaptureManager 状态已恢复');
    } catch (e) {
      console.error('[DICE]恢复 ConsoleCaptureManager 状态失败:', e);
    }

    // 检查并恢复错误状态（在初始化时）
    try {
      ErrorHandler.checkAndRestore();
      console.info('[DICE]错误状态检查完成');
    } catch (e) {
      console.error('[DICE]初始化时检查错误状态失败:', e);
    }

    // 冲突检测：在初始化前检查是否有可视化表格脚本
    if (detectVisualizerConflict()) {
      showConflictDialog();
      console.error('[DICE]骰子系统 检测到可视化表格脚本冲突，已阻止初始化');
      return; // 阻止初始化
    }

    console.info('[DICE]注入 MVU 样式和自定义样式...');
    MvuModule.injectStyles();

    // 清理旧的 Observer（防止重复监听）
    if (observer) {
      observer.disconnect();
      observer = null;
      console.info('[DICE]清理旧的 MutationObserver');
    }
    addStyles();
    const initCfg = getConfig();
    const initFontVal = FONTS.find(f => f.id === initCfg.fontFamily)?.val || FONTS[0].val;
    injectDatabaseStyles(initCfg.theme, initFontVal);
    setDatabaseToastMute(initCfg.muteDatabaseToasts === true);
    // 2. 保留原有的 SillyTavern 事件监听（使用具名函数防止重复注册）
    if (window.SillyTavern && window.SillyTavern.eventSource) {
      console.info('[DICE]注册 SillyTavern 事件监听器...');
      const events = window.SillyTavern.eventTypes;
      const source = window.SillyTavern.eventSource;
      const triggers = [events.CHAT_CHANGED, events.MESSAGE_SWIPED, events.MESSAGE_DELETED, events.MESSAGE_UPDATED];

      // 确保只创建一次处理函数
      if (!_boundRenderHandler) {
        _boundRenderHandler = () => {
          if (!isEditingOrder) {
            console.info('[DICE]消息更新事件触发，延迟渲染界面');
            setTimeout(renderInterface, 500);
          } else {
            console.info('[DICE]正在编辑顺序，跳过界面渲染');
          }
        };
      }

      // 确保只创建一次聊天切换处理函数（移到模块级防止重复注册）
      if (!window._acuBoundChatChangeHandler) {
        window._acuBoundChatChangeHandler = () => {
          console.info('[DICE]聊天切换事件触发，清理缓存并重新渲染');
          cachedRawData = null;
          tablePageStates = {};
          tableSearchStates = {};
          tableScrollStates = {};
          hasUnsavedChanges = false;
          currentDiffMap.clear();
          if (window.acuModifiedSet) window.acuModifiedSet.clear();
          // 清除变量面板缓存，避免不同聊天间模式/数据串线
          try {
            if (typeof MvuModule?.clearCache === 'function') {
              MvuModule.clearCache();
            }
          } catch (e) {
            console.warn('[DICE]清除变量面板缓存失败:', e);
          }
          setTimeout(renderInterface, 500);
        };
      }
      const _boundChatChangeHandler = window._acuBoundChatChangeHandler;

      triggers.forEach(evt => {
        if (evt) {
          source.removeListener(evt, _boundRenderHandler);
          source.removeListener(evt, _boundChatChangeHandler); // 防止重复注册
          if (evt === events.CHAT_CHANGED) {
            source.on(evt, _boundChatChangeHandler);
          } else {
            source.on(evt, _boundRenderHandler);
          }
        }
      });
      console.info(`[DICE]已注册 ${triggers.length} 个事件监听器`);
    } else {
      console.warn('[DICE]SillyTavern 事件源不可用，跳过事件监听器注册');
    }

    // 3. 轮询等待数据库 API 就绪
    const loop = () => {
      const api = getCore().getDB();
      if (api?.exportTableAsJson) {
        isInitialized = true;
        console.log('[DICE]骰子系统初始化成功');
        console.info('[DICE]数据库 API 已就绪');

        // --- [Fix] 移动到这里：确保 API 就绪且 #chat 存在后再启动监听 (带节流优化) ---
        const $chat = $('#chat');
        if ($chat.length && !observer) {
          console.info('[DICE]启动聊天区域 MutationObserver');
          let mutationLock = false;
          const handleMutation = () => {
            if (mutationLock) return;
            mutationLock = true;
            requestAnimationFrame(() => {
              const config = getConfig();
              if (config.positionMode === 'embedded') {
                mutationLock = false;
                return;
              }

              const children = $chat.children();
              const lastChild = children.last()[0];
              const wrapper = $('.acu-wrapper')[0];

              if (wrapper && lastChild && lastChild !== wrapper) {
                if ($(lastChild).hasClass('mes') || $(lastChild).hasClass('message-body')) {
                  $chat.append(wrapper);
                }
              }

              // [新增] 检测到新消息时，应用投骰结果隐藏逻辑（消除闪烁）
              const diceCfg = getDiceConfig();
              if (diceCfg && diceCfg.hideDiceResultInChat) {
                // 步骤1：立即对新消息应用遮罩样式，避免闪烁
                const children = $chat.children();
                const lastChild = children.last();
                if (lastChild.hasClass('mes') || lastChild.hasClass('message-body')) {
                  lastChild.addClass('acu-dice-result-revealing');
                }

                // 步骤2：使用RAF在下一帧快速执行隐藏逻辑
                requestAnimationFrame(() => {
                  hideDiceResultsInUserMessages();

                  // 步骤3：隐藏完成后移除遮罩，触发揭示动画
                  requestAnimationFrame(() => {
                    lastChild.removeClass('acu-dice-result-revealing').addClass('acu-dice-result-revealed');
                    // 动画结束后清理类名
                    setTimeout(() => {
                      lastChild.removeClass('acu-dice-result-revealed');
                    }, 200);
                  });
                });
              }

              mutationLock = false;
            });
          };
          observer = new MutationObserver(handleMutation);
          observer.observe($chat[0], { childList: true });
        } else if (!$chat.length) {
          console.warn('[DICE]聊天区域 (#chat) 未找到，跳过 MutationObserver 设置');
        }
        // --------------------------------------------------

        console.info('[DICE]执行首次界面渲染...');
        renderInterface(); // 首次渲染
        // [新增] 初始化时处理已存在的消息中的投骰结果
        setTimeout(() => {
          hideDiceResultsInUserMessages();
        }, 500);
        // 注册回调
        if (api.registerTableUpdateCallback) {
          api.registerTableUpdateCallback(UpdateController.handleUpdate);
          console.info('[DICE]已注册表格更新回调');

          // 恢复快照功能
          if (api.registerTableFillStartCallback) {
            api.registerTableFillStartCallback(() => {
              const current = api.exportTableAsJson();
              if (current) saveSnapshot(current);
            });
            console.info('[DICE]已注册表格填充开始回调');
          }
        } else {
          console.warn('[DICE]数据库 API 不支持回调注册');
        }
      } else {
        // 限制重试次数，防止无限循环 (约 60秒后放弃)
        if (!isInitialized) {
          window._acuInitRetries = (window._acuInitRetries || 0) + 1;
          if (window._acuInitRetries < 60) {
            if (window._acuInitRetries % 10 === 0) {
              console.info(`[DICE]等待数据库 API 就绪... (${window._acuInitRetries}/60)`);
            }
            setTimeout(loop, 1000);
          } else {
            console.error('[DICE]未检测到数据库后端 API，停止轮询。请确保已安装神·数据库脚本。');
          }
        }
      }
    };
    loop();

    // [新增] 监听用户发送消息 - 隐藏选项面板（选项已过时）
    const setupOptionHideListener = () => {
      const { $ } = getCore();
      const hideOptionPanel = () => {
        optionPanelVisible = false;
        $('.acu-option-panel, .acu-embedded-options-container').fadeOut(200, function () {
          $(this).remove();
        });
      };

      const pendingCrazyAppend = new Map<number, { result: string; createdAt: number }>();
      const CRAZY_APPEND_TTL_MS = 12000;
      let lastCrazyPreSendAt = 0;
      // [疯狂模式] MESSAGE_SENT 同步注入的骰点结果，供 GENERATION_AFTER_COMMANDS 合并到 params.prompt
      let pendingCrazySyncResult: string | null = null;

      const normalizeMessageId = (messageId: number | string) => {
        const id = typeof messageId === 'string' ? Number(messageId) : messageId;
        return Number.isFinite(id) ? id : null;
      };

      const hasDiceResultInText = (text: string) => {
        if (!text) return false;
        // 统一使用 <meta:检定结果> 标签格式检测
        const metaRegex = /<meta:检定结果>[\s\S]*?<\/meta:检定结果>/g;
        return metaRegex.test(text);
      };

      const insertDiceIntoUserInputBlock = (text: string, diceResult: string) => {
        if (!text || !diceResult) return '';
        const blockRegex = /(<本轮用户输入>)([\s\S]*?)(<\/本轮用户输入>)/;
        const blockMatch = text.match(blockRegex);
        if (!blockMatch) return '';
        const inner = blockMatch[2];
        if (inner.includes(diceResult)) return '';
        const prefix = inner.startsWith('\n') ? '\n' : '';
        const suffix = inner.endsWith('\n') ? '\n' : '';
        const trimmedInner = inner.trim();
        const newInner = trimmedInner ? `${trimmedInner} ${diceResult}` : diceResult;
        const textWithoutDice = text.includes(diceResult) ? text.replace(diceResult, '').trim() : text;
        return textWithoutDice.replace(blockRegex, `${blockMatch[1]}${prefix}${newInner}${suffix}${blockMatch[3]}`);
      };

      const applyCrazyModeToPrompt = (type: string, params: unknown, dryRun: boolean) => {
        if (dryRun) return;
        const safeParams = params && typeof params === 'object' ? (params as Record<string, unknown>) : {};
        const quietPrompt = typeof safeParams.quiet_prompt === 'string' ? safeParams.quiet_prompt : '';
        const automaticTrigger = safeParams.automatic_trigger === true;
        const alreadyApplied = safeParams._acu_crazy_applied === true;
        if (alreadyApplied || automaticTrigger) return;
        if (type === 'quiet' || quietPrompt.trim().length > 0) return;

        const originalPrompt = typeof safeParams.prompt === 'string' ? safeParams.prompt : '';
        if (!originalPrompt || !originalPrompt.trim()) return;

        // [合并器] 如果 MESSAGE_SENT 已同步注入骰点，确保 params.prompt 也包含
        // 这是关键步骤：神-数据库可能已读取 lastMessage.mes（含骰点）并重写 params.prompt
        // 此时需确保骰点不会丢失
        if (pendingCrazySyncResult) {
          const storedResult = pendingCrazySyncResult;
          pendingCrazySyncResult = null;
          if (!hasDiceResultInText(originalPrompt)) {
            let finalPrompt = '';
            if (originalPrompt.includes('<本轮用户输入>')) {
              const inserted = insertDiceIntoUserInputBlock(originalPrompt, storedResult);
              finalPrompt =
                inserted && inserted !== originalPrompt ? inserted : `${originalPrompt.trim()} ${storedResult}`.trim();
            } else {
              finalPrompt = `${originalPrompt.trim()} ${storedResult}`.trim();
            }
            safeParams.prompt = finalPrompt;
            safeParams._acu_crazy_applied = true;
            console.info('[DICE]疯狂模式: 已合并骰点到 params.prompt');
          }
          return;
        }

        // 已经有骰点结果，跳过
        if (hasDiceResultInText(originalPrompt)) return;

        // 300ms 防抖（仅用于 triggerCrazyModeBeforeSend 的场景，如发送按钮点击）
        const now = Date.now();
        if (now - lastCrazyPreSendAt < 300) return;

        // 兆底：如果前面的路径都没触发，尝试独立触发
        if (!shouldTriggerCrazyMode()) return;

        const crazyRollResult = generateCrazyRoll();
        if (!crazyRollResult) return;

        let finalPrompt = '';
        if (originalPrompt.includes('<本轮用户输入>')) {
          const inserted = insertDiceIntoUserInputBlock(originalPrompt, crazyRollResult);
          finalPrompt =
            inserted && inserted !== originalPrompt ? inserted : `${originalPrompt.trim()} ${crazyRollResult}`.trim();
        } else {
          finalPrompt = `${originalPrompt.trim()} ${crazyRollResult}`.trim();
        }

        safeParams.prompt = finalPrompt;
        safeParams._acu_crazy_applied = true;
        lastCrazyPreSendAt = now;
      };

      const triggerCrazyModeBeforeSend = () => {
        const now = Date.now();
        if (now - lastCrazyPreSendAt < 300) return;

        const { $ } = getCore();
        const $ta = $('#send_textarea');
        const content = ($ta.val() || '').toString().trim();
        if (!content) return;
        if (hasDiceResultInText(content)) return;
        if (!shouldTriggerCrazyMode()) return;

        const crazyRollResult = generateCrazyRoll();
        if (!crazyRollResult) return;

        smartInsertToTextarea(crazyRollResult, 'dice');
        const updatedValue = ($ta.val() || '').toString();
        if (updatedValue) {
          const textarea = $ta[0] as HTMLTextAreaElement;
          textarea.value = updatedValue;
          textarea.dispatchEvent(new Event('input', { bubbles: true }));
          textarea.dispatchEvent(new Event('change', { bubbles: true }));
        }
        lastCrazyPreSendAt = now;
      };

      // [疯狂模式] 在 MESSAGE_SENT 中同步注入骰点到用户消息
      // 确保在 GENERATION_AFTER_COMMANDS 之前完成，使神-数据库读 lastMessage.mes 时能看到骰点
      const syncInjectCrazyToMessage = (messageId: number | string) => {
        const id = normalizeMessageId(messageId);
        if (id === null) return;

        const stChat = ST?.chat || window.parent?.SillyTavern?.chat;
        if (!stChat) return;

        const msg = stChat[id];
        if (!msg || !msg.is_user) return;

        const text = String(msg.mes || '').trim();
        if (!text) return;
        if (hasDiceResultInText(text)) return;
        if (!shouldTriggerCrazyMode()) return;

        const crazyRollResult = generateCrazyRoll();
        if (!crazyRollResult) return;

        // 同步写入聊天记录
        if (text.includes('<本轮用户输入>')) {
          const inserted = insertDiceIntoUserInputBlock(text, crazyRollResult);
          msg.mes = inserted && inserted !== text ? inserted : `${text} ${crazyRollResult}`.trim();
        } else {
          msg.mes = `${text} ${crazyRollResult}`.trim();
        }

        // 存储结果供 GENERATION_AFTER_COMMANDS 合并到 params.prompt
        pendingCrazySyncResult = crazyRollResult;
        lastCrazyPreSendAt = Date.now();
        console.info('[DICE]疯狂模式: 已同步注入到用户消息', id);
      };
      const queueCrazyAppend = (messageId: number | string) => {
        const id = normalizeMessageId(messageId);
        if (id === null) return;
        if (!shouldTriggerCrazyMode()) return;

        const crazyRollResult = generateCrazyRoll();
        if (!crazyRollResult) return;

        pendingCrazyAppend.set(id, { result: crazyRollResult, createdAt: Date.now() });
        void applyCrazyAppend(id);
      };

      const applyCrazyAppend = async (messageId: number | string) => {
        const id = normalizeMessageId(messageId);
        if (id === null) return;

        const pending = pendingCrazyAppend.get(id);
        if (!pending) return;

        if (Date.now() - pending.createdAt > CRAZY_APPEND_TTL_MS) {
          pendingCrazyAppend.delete(id);
          return;
        }

        pendingCrazyAppend.delete(id);
        let newMessage = '';

        try {
          await enqueueMessageMutation(id, async () => {
            const stChat = ST?.chat || window.parent?.SillyTavern?.chat;
            const stMsg = stChat && typeof id === 'number' ? stChat[id] : null;
            const msg = getChatMessages(id)[0];
            if (!msg || msg.role !== 'user') {
              if (!stMsg || !stMsg.is_user) {
                return;
              }
            }

            const originalText = String(stMsg?.mes ?? msg?.message ?? '');
            if (hasDiceResultInText(originalText)) {
              return;
            }

            const extraObj: Record<string, unknown> =
              msg?.extra && typeof msg.extra === 'object' ? (msg.extra as Record<string, unknown>) : {};
            if (extraObj.acuCrazyModeApplied === true) {
              return;
            }

            if (originalText.includes('<本轮用户输入>')) {
              const inserted = insertDiceIntoUserInputBlock(originalText, pending.result);
              newMessage =
                inserted && inserted !== originalText ? inserted : `${originalText} ${pending.result}`.trim();
            } else {
              newMessage = originalText ? `${originalText} ${pending.result}` : pending.result;
            }

            if (stMsg && stMsg.is_user) {
              stMsg.mes = newMessage;
            }

            await setChatMessages(
              [{ message_id: id, message: newMessage, extra: { ...extraObj, acuCrazyModeApplied: true } }],
              { refresh: 'affected' },
            );
          });
        } catch (e) {
          console.warn('[DICE]疯狂模式: 附加骰子结果失败', e);
        }

        const { $ } = getCore();
        const $ta = $('#send_textarea');
        if ($ta.length && newMessage) {
          const currentVal = ($ta.val() || '').toString();
          if (currentVal === newMessage) {
            $ta.val('').trigger('input').trigger('change');
          }
        }
      };

      // [修复] 在发送按钮点击时恢复真实结果
      const setupSendButtonListener = () => {
        // [新增] 拦截输入框的 value 属性，确保读取时自动替换占位符
        interceptTextareaValue();

        // [修复] 使用捕获阶段拦截，确保在发送逻辑之前执行
        const sendButton = document.getElementById('send_but');
        if (sendButton) {
          const onSendCapture = () => {
            // 在捕获阶段提前注入疯狂模式
            triggerCrazyModeBeforeSend();
            // 在捕获阶段立即恢复真实结果
            restoreDiceResultBeforeSend();
          };
          sendButton.addEventListener('click', onSendCapture, true);
          sendButton.addEventListener('pointerup', onSendCapture, true);
          sendButton.addEventListener('touchend', onSendCapture, true);
        }

        // 监听发送按钮点击（jQuery方式作为备用）
        $(document)
          .off('click.acu_restore_dice', '#send_but')
          .on('click.acu_restore_dice', '#send_but', function (e) {
            // 在事件冒泡前注入疯狂模式
            triggerCrazyModeBeforeSend();
            // 在事件冒泡前恢复真实结果
            restoreDiceResultBeforeSend();
          });

        // [新增] 监听输入框的创建/替换，重新拦截新的输入框
        const observer = new MutationObserver(() => {
          const $ta = $('#send_textarea');
          if ($ta.length && !$ta[0]._acuValueIntercepted) {
            interceptTextareaValue();
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });
      };

      const installCrazyGenerateHook = () => {
        const rootWindow = window as Window & {
          __acuCrazyGenerateHookInstalled?: boolean;
          __acuCrazyGenerateOriginal?: (...args: unknown[]) => unknown;
        };
        if (rootWindow.__acuCrazyGenerateHookInstalled) return;
        if (!rootWindow.TavernHelper || typeof rootWindow.TavernHelper.generate !== 'function') return;

        rootWindow.__acuCrazyGenerateOriginal = rootWindow.TavernHelper.generate;
        rootWindow.TavernHelper.generate = async function (...args: unknown[]) {
          const options =
            args.length > 0 && args[0] && typeof args[0] === 'object' ? (args[0] as Record<string, unknown>) : null;

          if (options) {
            const quietPrompt = typeof options.quiet_prompt === 'string' ? options.quiet_prompt : '';
            const automaticTrigger = options.automatic_trigger === true;
            const alreadyApplied = options._acu_crazy_applied === true;
            if (!alreadyApplied && !automaticTrigger && quietPrompt.trim().length === 0) {
              let originalPrompt = '';
              const injects = options.injects;
              if (Array.isArray(injects) && injects.length > 0) {
                const first = injects[0];
                if (first && typeof first === 'object') {
                  const content = (first as Record<string, unknown>).content;
                  if (typeof content === 'string') originalPrompt = content;
                }
              }
              if (!originalPrompt && typeof options.prompt === 'string') {
                originalPrompt = options.prompt;
              }
              if (!originalPrompt && typeof options.user_input === 'string') {
                originalPrompt = options.user_input;
              }

              if (originalPrompt && !hasDiceResultInText(originalPrompt) && shouldTriggerCrazyMode()) {
                const crazyRollResult = generateCrazyRoll();
                if (crazyRollResult) {
                  const mergedPrompt = `${originalPrompt.trim()} ${crazyRollResult}`.trim();
                  if (Array.isArray(injects) && injects.length > 0) {
                    const first = injects[0];
                    if (first && typeof first === 'object') {
                      (first as Record<string, unknown>).content = mergedPrompt;
                    }
                  } else if (typeof options.prompt === 'string') {
                    options.prompt = mergedPrompt;
                  } else {
                    options.user_input = mergedPrompt;
                  }
                  options._acu_crazy_applied = true;
                  lastCrazyPreSendAt = Date.now();
                  console.info('[DICE]疯狂模式: 已注入到生成请求');
                }
              }
            }
          }

          return (rootWindow.__acuCrazyGenerateOriginal as (...args: unknown[]) => unknown).apply(this, args);
        };
        rootWindow.__acuCrazyGenerateHookInstalled = true;
      };

      // [优化] 统一事件注册逻辑 (优先 ST 原生 -> 降级到全局)
      const ST = window.SillyTavern || window.parent?.SillyTavern;
      // 获取事件名，兼容不同版本
      const evtName =
        ST?.eventTypes?.MESSAGE_SENT || (window.tavern_events ? window.tavern_events.MESSAGE_SENT : 'message_sent');

      // 1. 优先使用 ST.eventSource (官方标准)
      if (ST?.eventSource) {
        ST.eventSource.on(evtName, hideOptionPanel);
        // [新增] 同时监听消息发送事件，应用投骰结果隐藏
        ST.eventSource.on(evtName, async messageId => {
          // 同步注入疯狂模式到用户消息（确保在 GENERATION_AFTER_COMMANDS 之前完成）
          syncInjectCrazyToMessage(messageId);

          // [新增] 执行待处理的检定后果
          await processPendingEffectRuns(messageId);

          // 延迟执行，确保消息已渲染到DOM
          const diceCfg = getDiceConfig();
          if (diceCfg && diceCfg.hideDiceResultInChat) {
            setTimeout(() => {
              hideDiceResultsInUserMessages();
            }, 300);
          }
        });

        // [新增] 在 GENERATION_AFTER_COMMANDS 中注入（影响剧情推进接收内容）
        const afterCommandsEvtName =
          ST?.eventTypes?.GENERATION_AFTER_COMMANDS ||
          (window.tavern_events ? window.tavern_events.GENERATION_AFTER_COMMANDS : 'GENERATION_AFTER_COMMANDS');
        if (afterCommandsEvtName) {
          ST.eventSource.on(afterCommandsEvtName, (type, params, dryRun) => {
            applyCrazyModeToPrompt(type, params, dryRun);
          });
        }

        installCrazyGenerateHook();
        setupSendButtonListener();
        return;
      }

      // 2. 降级尝试全局 eventOn (TavernHelper 或旧版环境)
      if (typeof window.eventOn === 'function') {
        window.eventOn(evtName, hideOptionPanel);
        // [新增] 同时监听消息发送事件，应用投骰结果隐藏
        window.eventOn(evtName, async messageId => {
          // 同步注入疯狂模式到用户消息（确保在 GENERATION_AFTER_COMMANDS 之前完成）
          syncInjectCrazyToMessage(messageId);

          // [新增] 执行待处理的检定后果
          await processPendingEffectRuns(messageId);

          // 延迟执行，确保消息已渲染到DOM
          const diceCfg = getDiceConfig();
          if (diceCfg && diceCfg.hideDiceResultInChat) {
            setTimeout(() => {
              hideDiceResultsInUserMessages();
            }, 300);
          }
        });

        // [新增] 在 GENERATION_AFTER_COMMANDS 中注入（影响剧情推进接收内容）
        const afterCommandsEvtName = window.tavern_events
          ? window.tavern_events.GENERATION_AFTER_COMMANDS
          : 'GENERATION_AFTER_COMMANDS';
        window.eventOn(afterCommandsEvtName, (type, params, dryRun) => {
          applyCrazyModeToPrompt(type, params, dryRun);
        });

        installCrazyGenerateHook();
        setupSendButtonListener();
        return;
      }
    };

    // 延迟执行，确保酒馆助手已加载
    setTimeout(setupOptionHideListener, 2000);

    // [新增] 立即尝试拦截输入框（如果已经存在）
    setTimeout(() => {
      interceptTextareaValue();
    }, 500);

    // [新增] 监听ERA变量更新，自动刷新变量面板
    const eventOn = window.eventOn || window.parent?.eventOn;
    if (typeof eventOn === 'function') {
      eventOn('era:writeDone', detail => {
        // 清除 ERA 缓存
        if (typeof MvuModule === 'object' && typeof MvuModule.clearCache === 'function') {
          MvuModule.clearCache();
        }

        // 如果当前检测到的是ERA数据，自动刷新面板
        const mode = MvuModule.detectMode();
        if (mode === 'era' && getActiveTabState() === MvuModule.MODULE_ID) {
          console.log('[DICE]ERA变量已更新，自动刷新面板');
          renderInterface();
        }
      });
    } else {
      console.warn('[DICE]无法监听 ERA 事件，eventOn 不可用');
    }

    // [新增] 页面卸载时清理资源
    $(window)
      .off('beforeunload.acu pagehide.acu')
      .on('beforeunload.acu pagehide.acu', () => {
        try {
          // 取消所有挂起的异步请求
          abortAllPendingRequests();
          const timer = (window as Record<string, unknown>).__acuEffectRunCleanerTimer;
          if (typeof timer === 'number') {
            window.clearInterval(timer);
            delete (window as Record<string, unknown>).__acuEffectRunCleanerTimer;
          }
          localStorage.setItem(STORAGE_KEY_SCROLL, JSON.stringify(tableScrollStates));
          if (observer) {
            observer.disconnect();
            observer = null;
          }
        } catch (e) {
          console.warn('[DICE]页面卸载清理出错:', e);
        }
      });
  };

  // ========================================
  // 测试函数：验证配对表修复逻辑
  // ========================================
  // 在浏览器控制台运行：window.testPairedTableFix()
  window.testPairedTableFix = function () {
    // 构造测试数据：包含空白行、共同编码、各自独有编码、跳号
    const prefix = 'AM';
    const startFrom = 1;
    const columnName = '编码索引';

    // 总结表（表1）：AM0001, AM0002, 空白(错误行), AM0030, 空白(错误行)
    // 有效编码：AM0001, AM0002, AM0030
    const table1Sheet = {
      name: '总结表',
      content: [
        ['编码索引', '时间跨度', '纪要'],
        ['AM0001', '时间1', '纪要1'],
        ['AM0002', '时间2', '纪要2'],
        [null, '时间3-错误行', '纪要3-错误行'], // 空白编码（错误行，应保持不动）
        ['AM0030', '时间4', '纪要4'],
        [null, '时间5-错误行', '纪要5-错误行'], // 空白编码（错误行，应保持不动）
      ],
    };

    // 总结大纲表（表2）：空白(错误行), AM0002, AM0030, AM0040, AM0050
    // 有效编码：AM0002, AM0030, AM0040, AM0050
    const table2Sheet = {
      name: '总体大纲',
      content: [
        ['编码索引', '时间跨度', '大纲'],
        [null, '时间A-错误行', '大纲A-错误行'], // 空白编码（错误行，应保持不动）
        ['AM0002', '时间B', '大纲B'],
        ['AM0030', '时间C', '大纲C'],
        ['AM0040', '时间D', '大纲D'],
        ['AM0050', '时间E', '大纲E'],
      ],
    };

    // 提取编码
    const extract1 = extractCodesFromTable(table1Sheet, columnName, prefix);
    const extract2 = extractCodesFromTable(table2Sheet, columnName, prefix);

    // 构建映射
    const mapping = buildCodeMapping(extract1.allCodes, extract2.allCodes, prefix, startFrom);

    // 执行修复
    const rawData = {};
    const result = alignAndFixPairedTables(
      table1Sheet,
      'sheet1',
      table2Sheet,
      'sheet2',
      columnName,
      mapping,
      prefix,
      startFrom,
      rawData,
    );

    // 验证结果
    const getValidCodes = sheet =>
      sheet.content
        .slice(1)
        .map(r => r[0])
        .filter(c => c && String(c).match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\d+$`)));

    const codes1 = getValidCodes(table1Sheet);
    const codes2 = getValidCodes(table2Sheet);

    // 检查空白行是否保持原数据
    const emptyRows1 = table1Sheet.content
      .slice(1)
      .filter(r => !r[0] || !String(r[0]).match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\d+$`)));
    const emptyRows2 = table2Sheet.content
      .slice(1)
      .filter(r => !r[0] || !String(r[0]).match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\d+$`)));

    // 验证编码是否严格递增
    const validateSequence = (codes, prefix, startFrom) => {
      const numbers = codes
        .map(c => {
          if (!c) return null;
          const match = c.match(new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\d+)$`));
          return match ? parseInt(match[1], 10) : null;
        })
        .filter(n => n !== null);

      for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] !== startFrom + i) {
          return false;
        }
      }
      return true;
    };

    const isValid1 = validateSequence(codes1, prefix, startFrom);
    const isValid2 = validateSequence(codes2, prefix, startFrom);

    // 验证两个表的有效编码集合是否一致
    const set1 = new Set(codes1);
    const set2 = new Set(codes2);
    const setsEqual = set1.size === set2.size && [...set1].every(c => set2.has(c));

    // 验证空白行数据是否保留
    const emptyRowsPreserved1 = emptyRows1.some(r => r[1] && r[1].includes('错误行'));
    const emptyRowsPreserved2 = emptyRows2.some(r => r[1] && r[1].includes('错误行'));

    return {
      table1Sheet,
      table2Sheet,
      result,
      codes1,
      codes2,
      emptyRows1,
      emptyRows2,
      isValid1,
      isValid2,
      setsEqual,
      emptyRowsPreserved1,
      emptyRowsPreserved2,
      // 综合验证：有效编码严格递增 + 两表有效编码一致 + 空白行数据保留
      isValid: isValid1 && isValid2 && setsEqual && emptyRowsPreserved1 && emptyRowsPreserved2,
    };
  };

  // 暴露诊断工具到全局（方便控制台调用）
  window.diagnoseDiceVariables = async function () {
    if (typeof MvuModule !== 'undefined' && typeof MvuModule.diagnoseVariableFramework === 'function') {
      return await MvuModule.diagnoseVariableFramework();
    } else {
      console.error('[DICE]MvuModule 未初始化或诊断工具不可用');
      return null;
    }
  };

  const { $ } = getCore();
  if ($) $(document).ready(init);
  else window.addEventListener('load', init);
})();
